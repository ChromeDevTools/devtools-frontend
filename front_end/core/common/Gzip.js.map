{
  "version": 3,
  "sources": ["../../../../../../front_end/core/common/Gzip.ts"],
  "sourcesContent": ["// Copyright 2025 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/**\n * Quickly determine if gzipped, by seeing if the first 3 bytes of the file header match the gzip signature\n */\nexport function isGzip(ab: ArrayBuffer): boolean {\n  const buf = new Uint8Array(ab);\n  if (!buf || buf.length < 3) {\n    return false;\n  }\n  // https://www.rfc-editor.org/rfc/rfc1952#page-6\n  return buf[0] === 0x1F && buf[1] === 0x8B && buf[2] === 0x08;\n}\n\n/** Decode a gzipped _or_ plain text ArrayBuffer to a decoded string */\nexport async function arrayBufferToString(ab: ArrayBuffer): Promise<string> {\n  if (isGzip(ab)) {\n    return await decompress(ab);\n  }\n  const str = new TextDecoder('utf-8').decode(ab);\n  return str;\n}\n\nexport async function fileToString(file: File): Promise<string> {\n  let stream = file.stream();\n  if (file.type.endsWith('gzip')) {\n    stream = decompressStream(stream);\n  }\n  const arrayBuffer = await new Response(stream).arrayBuffer();\n  const str = new TextDecoder('utf-8').decode(arrayBuffer);\n  return str;\n}\n\n/**\n * Decompress a gzipped ArrayBuffer to a string.\n * Consider using `arrayBufferToString` instead, which can handle both gzipped and plain text buffers.\n */\nexport async function decompress(gzippedBuffer: ArrayBuffer): Promise<string> {\n  const buffer = await gzipCodec(gzippedBuffer, new DecompressionStream('gzip'));\n  const str = new TextDecoder('utf-8').decode(buffer);\n  return str;\n}\nexport async function compress(str: string): Promise<ArrayBuffer> {\n  const encoded = new TextEncoder().encode(str);\n  const buffer = await gzipCodec(encoded, new CompressionStream('gzip'));\n  return buffer;\n}\n\n/** Private coder/decoder **/\nasync function gzipCodec(\n    buffer: Uint8Array<ArrayBufferLike>|ArrayBuffer,\n    codecStream: CompressionStream|DecompressionStream): Promise<ArrayBuffer> {\n  const readable = new ReadableStream({\n    start(controller) {\n      controller.enqueue(buffer);\n      controller.close();\n    }\n  });\n  const codecReadable = readable.pipeThrough(codecStream);\n  // A response is a convenient way to get an ArrayBuffer from a ReadableStream.\n  return await new Response(codecReadable).arrayBuffer();\n}\n\nexport function decompressStream(stream: ReadableStream): ReadableStream {\n  // https://github.com/wicg/compression/blob/main/explainer.md#deflate-compress-an-arraybuffer\n  const ds = new DecompressionStream('gzip');\n  return stream.pipeThrough(ds);\n}\nexport function compressStream(stream: ReadableStream): ReadableStream {\n  const cs = new CompressionStream('gzip');\n  return stream.pipeThrough(cs);\n}\n"],
  "mappings": ";AAOO,gBAAS,OAAO,IAA0B;AAC/C,QAAM,MAAM,IAAI,WAAW,EAAE;AAC7B,MAAI,CAAC,OAAO,IAAI,SAAS,GAAG;AAC1B,WAAO;AAAA,EACT;AAEA,SAAO,IAAI,CAAC,MAAM,MAAQ,IAAI,CAAC,MAAM,OAAQ,IAAI,CAAC,MAAM;AAC1D;AAGA,sBAAsB,oBAAoB,IAAkC;AAC1E,MAAI,OAAO,EAAE,GAAG;AACd,WAAO,MAAM,WAAW,EAAE;AAAA,EAC5B;AACA,QAAM,MAAM,IAAI,YAAY,OAAO,EAAE,OAAO,EAAE;AAC9C,SAAO;AACT;AAEA,sBAAsB,aAAa,MAA6B;AAC9D,MAAI,SAAS,KAAK,OAAO;AACzB,MAAI,KAAK,KAAK,SAAS,MAAM,GAAG;AAC9B,aAAS,iBAAiB,MAAM;AAAA,EAClC;AACA,QAAM,cAAc,MAAM,IAAI,SAAS,MAAM,EAAE,YAAY;AAC3D,QAAM,MAAM,IAAI,YAAY,OAAO,EAAE,OAAO,WAAW;AACvD,SAAO;AACT;AAMA,sBAAsB,WAAW,eAA6C;AAC5E,QAAM,SAAS,MAAM,UAAU,eAAe,IAAI,oBAAoB,MAAM,CAAC;AAC7E,QAAM,MAAM,IAAI,YAAY,OAAO,EAAE,OAAO,MAAM;AAClD,SAAO;AACT;AACA,sBAAsB,SAAS,KAAmC;AAChE,QAAM,UAAU,IAAI,YAAY,EAAE,OAAO,GAAG;AAC5C,QAAM,SAAS,MAAM,UAAU,SAAS,IAAI,kBAAkB,MAAM,CAAC;AACrE,SAAO;AACT;AAGA,eAAe,UACX,QACA,aAA0E;AAC5E,QAAM,WAAW,IAAI,eAAe;AAAA,IAClC,MAAM,YAAY;AAChB,iBAAW,QAAQ,MAAM;AACzB,iBAAW,MAAM;AAAA,IACnB;AAAA,EACF,CAAC;AACD,QAAM,gBAAgB,SAAS,YAAY,WAAW;AAEtD,SAAO,MAAM,IAAI,SAAS,aAAa,EAAE,YAAY;AACvD;AAEO,gBAAS,iBAAiB,QAAwC;AAEvE,QAAM,KAAK,IAAI,oBAAoB,MAAM;AACzC,SAAO,OAAO,YAAY,EAAE;AAC9B;AACO,gBAAS,eAAe,QAAwC;AACrE,QAAM,KAAK,IAAI,kBAAkB,MAAM;AACvC,SAAO,OAAO,YAAY,EAAE;AAC9B;",
  "names": []
}
