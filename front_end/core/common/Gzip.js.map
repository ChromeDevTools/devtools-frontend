{"version":3,"file":"Gzip.js","sourceRoot":"","sources":["../../../../../../front_end/core/common/Gzip.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2025 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/**\n * Quickly determine if gzipped, by seeing if the first 3 bytes of the file header match the gzip signature\n */\nexport function isGzip(ab: ArrayBufferLike): boolean {\n  const buf = new Uint8Array(ab);\n  if (!buf || buf.length < 3) {\n    return false;\n  }\n  // https://www.rfc-editor.org/rfc/rfc1952#page-6\n  return buf[0] === 0x1F && buf[1] === 0x8B && buf[2] === 0x08;\n}\n\n/** Decode a gzipped _or_ plain text ArrayBuffer to a decoded string */\nexport async function arrayBufferToString(ab: ArrayBufferLike): Promise<string> {\n  if (isGzip(ab)) {\n    return await decompress(ab);\n  }\n  const str = new TextDecoder('utf-8').decode(ab);\n  return str;\n}\n\nexport async function fileToString(file: File): Promise<string> {\n  let stream = file.stream();\n  if (file.type.endsWith('gzip')) {\n    stream = decompressStream(stream);\n  }\n  const arrayBuffer = await new Response(stream).arrayBuffer();\n  const str = new TextDecoder('utf-8').decode(arrayBuffer);\n  return str;\n}\n\n/**\n * Decompress a gzipped ArrayBuffer to a string.\n * Consider using `arrayBufferToString` instead, which can handle both gzipped and plain text buffers.\n */\nexport async function decompress(gzippedBuffer: ArrayBufferLike): Promise<string> {\n  const buffer = await gzipCodec(gzippedBuffer, new DecompressionStream('gzip'));\n  const str = new TextDecoder('utf-8').decode(buffer);\n  return str;\n}\nexport async function compress(str: string): Promise<ArrayBuffer> {\n  const encoded = new TextEncoder().encode(str);\n  const buffer = await gzipCodec(encoded, new CompressionStream('gzip'));\n  return buffer;\n}\n\n/** Private coder/decoder **/\nasync function gzipCodec(\n    buffer: Uint8Array<ArrayBufferLike>|ArrayBufferLike,\n    codecStream: CompressionStream|DecompressionStream): Promise<ArrayBuffer> {\n  const readable = new ReadableStream({\n    start(controller) {\n      controller.enqueue(buffer instanceof ArrayBuffer ? new Uint8Array(buffer) : buffer);\n      controller.close();\n    }\n  });\n  const codecReadable = readable.pipeThrough(codecStream);\n  // A response is a convenient way to get an ArrayBuffer from a ReadableStream.\n  return await new Response(codecReadable).arrayBuffer();\n}\n\nexport function decompressStream(stream: ReadableStream): ReadableStream {\n  // https://github.com/wicg/compression/blob/main/explainer.md#deflate-compress-an-arraybuffer\n  const ds = new DecompressionStream('gzip');\n  return stream.pipeThrough(ds);\n}\n\nexport function compressStream(stream: ReadableStream): ReadableStream {\n  const cs = new CompressionStream('gzip');\n  return stream.pipeThrough(cs);\n}\n\nexport function createMonitoredStream(stream: ReadableStream, onProgress: (bytesRead: number) => void): ReadableStream {\n  let bytesRead = 0;\n\n  const progressTransformer = new TransformStream({\n    transform(chunk, controller) {\n      bytesRead += chunk.byteLength;\n      onProgress(bytesRead);\n      controller.enqueue(chunk);\n    }\n  });\n\n  return stream.pipeThrough(progressTransformer);\n}\n"]}