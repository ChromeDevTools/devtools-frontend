{"version":3,"file":"Mutex.js","sourceRoot":"","sources":["../../../../../../front_end/core/common/Mutex.ts"],"names":[],"mappings":"AAAA,sCAAsC;AACtC,yEAAyE;AACzE,6BAA6B;AAI7B;;;;;GAKG;AACH,MAAM,OAAO,KAAK;IAChB,OAAO,GAAG,KAAK,CAAC;IAChB,UAAU,GAAsB,EAAE,CAAC;IAEnC,gBAAgB;IAChB,OAAO;QACL,MAAM,KAAK,GAAG,EAAC,QAAQ,EAAE,KAAK,EAAC,CAAC;QAChC,IAAI,IAAI,CAAC,OAAO,EAAE,CAAC;YACjB,OAAO,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE;gBAC3B,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC;YACvE,CAAC,CAAC,CAAC;QACL,CAAC;QACD,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;QACpB,OAAO,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;IAC1D,CAAC;IAED,QAAQ,CAAC,KAA0B;QACjC,IAAI,KAAK,CAAC,QAAQ,EAAE,CAAC;YACnB,MAAM,IAAI,KAAK,CAAC,gCAAgC,CAAC,CAAC;QACpD,CAAC;QACD,KAAK,CAAC,QAAQ,GAAG,IAAI,CAAC;QAEtB,MAAM,OAAO,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,CAAC;QACxC,IAAI,CAAC,OAAO,EAAE,CAAC;YACb,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;YACrB,OAAO;QACT,CAAC;QACD,OAAO,EAAE,CAAC;IACZ,CAAC;IAED,KAAK,CAAC,GAAG,CAAI,MAAwB;QACnC,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,OAAO,EAAE,CAAC;QACrC,IAAI,CAAC;YACH,wEAAwE;YACxE,kEAAkE;YAClE,gDAAgD;YAChD,MAAM,MAAM,GAAG,MAAM,MAAM,EAAE,CAAC;YAC9B,OAAO,MAAM,CAAC;QAChB,CAAC;gBAAS,CAAC;YACT,OAAO,EAAE,CAAC;QACZ,CAAC;IACH,CAAC;CACF","sourcesContent":["// Copyright 2022 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\ntype ReleaseFunction = () => void;\n\n/**\n * Use Mutex class to coordinate local concurrent operations.\n * Once `acquire` promise resolves, you hold the lock and must\n * call `release` function returned by `acquire` to release the\n * lock. Failing to `release` the lock may lead to deadlocks.\n */\nexport class Mutex {\n  #locked = false;\n  #acquirers: Array<() => void> = [];\n\n  // This is FIFO.\n  acquire(): Promise<ReleaseFunction> {\n    const state = {resolved: false};\n    if (this.#locked) {\n      return new Promise(resolve => {\n        this.#acquirers.push(() => resolve(this.#release.bind(this, state)));\n      });\n    }\n    this.#locked = true;\n    return Promise.resolve(this.#release.bind(this, state));\n  }\n\n  #release(state: {resolved: boolean}): void {\n    if (state.resolved) {\n      throw new Error('Cannot release more than once.');\n    }\n    state.resolved = true;\n\n    const resolve = this.#acquirers.shift();\n    if (!resolve) {\n      this.#locked = false;\n      return;\n    }\n    resolve();\n  }\n\n  async run<T>(action: () => Promise<T>): Promise<T> {\n    const release = await this.acquire();\n    try {\n      // Note we need to await here because we want the await to release AFTER\n      // that await happens. Returning action() will trigger the release\n      // immediately which is counter to what we want.\n      const result = await action();\n      return result;\n    } finally {\n      release();\n    }\n  }\n}\n"]}