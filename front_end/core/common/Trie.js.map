{"version":3,"file":"Trie.js","sourceRoot":"","sources":["../../../../../../front_end/core/common/Trie.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2016 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n// Extracts the element type of an array like, eg:\n// ElementType<number[]> -> number\n// ElementTYpe<string> -> string\ntype ElementType<T extends ArrayLike<unknown>> = T extends ArrayLike<infer E>? E : never;\n\n/**\n * Abstracts some generic operations that have different implementations depending\n * on whether we operate on strings or array of things.\n **/\ninterface TrieableTrait<T extends ArrayLike<ElementType<T>>> {\n  empty(): T;\n  append(base: T, appendage: ElementType<T>): T;\n  slice(base: T, start: number, end: number): T;\n}\n\nexport class Trie<T extends ArrayLike<ElementType<T>>> {\n  #size!: number;\n  #root: number;\n  #edges!: Array<Map<ElementType<T>, number>>;\n  #isWord!: boolean[];\n  #wordsInSubtree!: number[];\n  #freeNodes!: number[];\n  #traitImpl: TrieableTrait<T>;\n\n  constructor(traitImpl: TrieableTrait<T>) {\n    this.#root = 0;\n    this.#traitImpl = traitImpl;\n    this.clear();\n  }\n\n  static newStringTrie(): Trie<string> {\n    return new Trie<string>({\n      empty: () => '',\n      append: (base, appendage) => base + appendage,\n      slice: (base, start, end) => base.slice(start, end),\n    });\n  }\n\n  static newArrayTrie<T extends Array<ElementType<T>>>(): Trie<Array<ElementType<T>>> {\n    return new Trie<Array<ElementType<T>>>({\n      empty: () => [],\n      append: (base, appendage) => base.concat([appendage]),\n      slice: (base, start, end) => base.slice(start, end),\n    });\n  }\n\n  add(word: T): void {\n    let node: number = this.#root;\n    ++this.#wordsInSubtree[this.#root];\n    for (let i = 0; i < word.length; ++i) {\n      const edge = word[i];\n      let next = this.#edges[node].get(edge);\n      if (!next) {\n        if (this.#freeNodes.length) {\n          next = (this.#freeNodes.pop() as number);\n        } else {\n          next = this.#size++;\n          this.#isWord.push(false);\n          this.#wordsInSubtree.push(0);\n          this.#edges.push(new Map());\n        }\n        this.#edges[node].set(edge, next);\n      }\n      ++this.#wordsInSubtree[next];\n      node = next;\n    }\n    this.#isWord[node] = true;\n  }\n\n  remove(word: T): boolean {\n    if (!this.has(word)) {\n      return false;\n    }\n    let node: number = this.#root;\n    --this.#wordsInSubtree[this.#root];\n    for (let i = 0; i < word.length; ++i) {\n      const edge = word[i];\n      const next = this.#edges[node].get(edge) as number;\n      if (!--this.#wordsInSubtree[next]) {\n        this.#edges[node].delete(edge);\n        this.#freeNodes.push(next);\n      }\n      node = next;\n    }\n    this.#isWord[node] = false;\n    return true;\n  }\n\n  has(word: T): boolean {\n    let node: number|undefined = this.#root;\n    for (let i = 0; i < word.length; ++i) {\n      node = this.#edges[node].get(word[i]);\n      if (!node) {\n        return false;\n      }\n    }\n    return this.#isWord[node];\n  }\n\n  words(prefix?: T): T[] {\n    prefix = prefix ?? this.#traitImpl.empty();\n    let node: number|undefined = this.#root;\n    for (let i = 0; i < prefix.length; ++i) {\n      node = this.#edges[node].get(prefix[i]);\n      if (!node) {\n        return [];\n      }\n    }\n    const results: T[] = [];\n    this.dfs(node, prefix, results);\n    return results;\n  }\n\n  private dfs(node: number, prefix: T, results: T[]): void {\n    if (this.#isWord[node]) {\n      results.push(prefix);\n    }\n    const edges = this.#edges[node];\n    for (const [edge, node] of edges) {\n      const newPrefix = this.#traitImpl.append(prefix, edge);\n      this.dfs(node, newPrefix, results);\n    }\n  }\n\n  longestPrefix(word: T, fullWordOnly: boolean): T {\n    let node: number|undefined = this.#root;\n    let wordIndex = 0;\n    for (let i = 0; i < word.length; ++i) {\n      node = this.#edges[node].get(word[i]);\n      if (!node) {\n        break;\n      }\n      if (!fullWordOnly || this.#isWord[node]) {\n        wordIndex = i + 1;\n      }\n    }\n    return this.#traitImpl.slice(word, 0, wordIndex);\n  }\n\n  clear(): void {\n    this.#size = 1;\n    this.#root = 0;\n    this.#edges = [new Map()];\n    this.#isWord = [false];\n    this.#wordsInSubtree = [0];\n    this.#freeNodes = [];\n  }\n}\n"]}