{
  "version": 3,
  "sources": ["../../../../../../front_end/core/common/Trie.ts"],
  "sourcesContent": ["// Copyright 2016 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n// Extracts the element type of an array like, eg:\n// ElementType<number[]> -> number\n// ElementTYpe<string> -> string\ntype ElementType<T extends ArrayLike<unknown>> = T extends ArrayLike<infer E>? E : never;\n\n/**\n * Abstracts some generic operations that have different implementations depending\n * on whether we operate on strings or array of things.\n **/\ninterface TrieableTrait<T extends ArrayLike<ElementType<T>>> {\n  empty(): T;\n  append(base: T, appendage: ElementType<T>): T;\n  slice(base: T, start: number, end: number): T;\n}\n\nexport class Trie<T extends ArrayLike<ElementType<T>>> {\n  #size!: number;\n  #root: number;\n  #edges!: Array<Map<ElementType<T>, number>>;\n  #isWord!: boolean[];\n  #wordsInSubtree!: number[];\n  #freeNodes!: number[];\n  #traitImpl: TrieableTrait<T>;\n\n  constructor(traitImpl: TrieableTrait<T>) {\n    this.#root = 0;\n    this.#traitImpl = traitImpl;\n    this.clear();\n  }\n\n  static newStringTrie(): Trie<string> {\n    return new Trie<string>({\n      empty: () => '',\n      append: (base, appendage) => base + appendage,\n      slice: (base, start, end) => base.slice(start, end),\n    });\n  }\n\n  static newArrayTrie<T extends Array<ElementType<T>>>(): Trie<Array<ElementType<T>>> {\n    return new Trie<Array<ElementType<T>>>({\n      empty: () => [],\n      append: (base, appendage) => base.concat([appendage]),\n      slice: (base, start, end) => base.slice(start, end),\n    });\n  }\n\n  add(word: T): void {\n    let node: number = this.#root;\n    ++this.#wordsInSubtree[this.#root];\n    for (let i = 0; i < word.length; ++i) {\n      const edge = word[i];\n      let next = this.#edges[node].get(edge);\n      if (!next) {\n        if (this.#freeNodes.length) {\n          next = (this.#freeNodes.pop() as number);\n        } else {\n          next = this.#size++;\n          this.#isWord.push(false);\n          this.#wordsInSubtree.push(0);\n          this.#edges.push(new Map());\n        }\n        this.#edges[node].set(edge, next);\n      }\n      ++this.#wordsInSubtree[next];\n      node = next;\n    }\n    this.#isWord[node] = true;\n  }\n\n  remove(word: T): boolean {\n    if (!this.has(word)) {\n      return false;\n    }\n    let node: number = this.#root;\n    --this.#wordsInSubtree[this.#root];\n    for (let i = 0; i < word.length; ++i) {\n      const edge = word[i];\n      const next = this.#edges[node].get(edge) as number;\n      if (!--this.#wordsInSubtree[next]) {\n        this.#edges[node].delete(edge);\n        this.#freeNodes.push(next);\n      }\n      node = next;\n    }\n    this.#isWord[node] = false;\n    return true;\n  }\n\n  has(word: T): boolean {\n    let node: number|undefined = this.#root;\n    for (let i = 0; i < word.length; ++i) {\n      node = this.#edges[node].get(word[i]);\n      if (!node) {\n        return false;\n      }\n    }\n    return this.#isWord[node];\n  }\n\n  words(prefix?: T): T[] {\n    prefix = prefix ?? this.#traitImpl.empty();\n    let node: number|undefined = this.#root;\n    for (let i = 0; i < prefix.length; ++i) {\n      node = this.#edges[node].get(prefix[i]);\n      if (!node) {\n        return [];\n      }\n    }\n    const results: T[] = [];\n    this.dfs(node, prefix, results);\n    return results;\n  }\n\n  private dfs(node: number, prefix: T, results: T[]): void {\n    if (this.#isWord[node]) {\n      results.push(prefix);\n    }\n    const edges = this.#edges[node];\n    for (const [edge, node] of edges) {\n      const newPrefix = this.#traitImpl.append(prefix, edge);\n      this.dfs(node, newPrefix, results);\n    }\n  }\n\n  longestPrefix(word: T, fullWordOnly: boolean): T {\n    let node: number|undefined = this.#root;\n    let wordIndex = 0;\n    for (let i = 0; i < word.length; ++i) {\n      node = this.#edges[node].get(word[i]);\n      if (!node) {\n        break;\n      }\n      if (!fullWordOnly || this.#isWord[node]) {\n        wordIndex = i + 1;\n      }\n    }\n    return this.#traitImpl.slice(word, 0, wordIndex);\n  }\n\n  clear(): void {\n    this.#size = 1;\n    this.#root = 0;\n    this.#edges = [new Map()];\n    this.#isWord = [false];\n    this.#wordsInSubtree = [0];\n    this.#freeNodes = [];\n  }\n}\n"],
  "mappings": "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",
  "names": ["node"]
}
