{
  "version": 3,
  "sources": ["../../../../../../front_end/core/host/GdpClient.ts"],
  "sourcesContent": ["// Copyright 2025 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Root from '../root/root.js';\n\nimport * as DispatchHttpRequestClient from './DispatchHttpRequestClient.js';\nimport type {DispatchHttpRequestRequest} from './InspectorFrontendHostAPI.js';\n\nexport enum SubscriptionStatus {\n  ENABLED = 'SUBSCRIPTION_STATE_ENABLED',\n  PENDING = 'SUBSCRIPTION_STATE_PENDING',\n  CANCELED = 'SUBSCRIPTION_STATE_CANCELED',\n  REFUNDED = 'SUBSCRIPTION_STATE_REFUNDED',\n  AWAITING_FIX = 'SUBSCRIPTION_STATE_AWAITING_FIX',\n  ON_HOLD = 'SUBSCRIPTION_STATE_ACCOUNT_ON_HOLD',\n}\n\nexport enum SubscriptionTier {\n  PREMIUM_ANNUAL = 'SUBSCRIPTION_TIER_PREMIUM_ANNUAL',\n  PREMIUM_MONTHLY = 'SUBSCRIPTION_TIER_PREMIUM_MONTHLY',\n  PRO_ANNUAL = 'SUBSCRIPTION_TIER_PRO_ANNUAL',\n  PRO_MONTHLY = 'SUBSCRIPTION_TIER_PRO_MONTHLY',\n}\n\nexport enum EligibilityStatus {\n  ELIGIBLE = 'ELIGIBLE',\n  NOT_ELIGIBLE = 'NOT_ELIGIBLE',\n}\n\nexport enum EmailPreference {\n  ENABLED = 'ENABLED',\n  DISABLED = 'DISABLED',\n}\n\ninterface CheckElibigilityResponse {\n  createProfile: EligibilityStatus;\n}\n\ninterface BatchGetAwardsResponse {\n  awards?: Award[];\n}\n\nexport interface Award {\n  name: string;\n  badge: {\n    title: string,\n    description: string,\n    imageUri: string,\n    deletableByUser: boolean,\n  };\n  title: string;\n  description: string;\n  imageUri: string;\n  createTime: string;\n  awardingUri: string;\n}\n\nexport interface Profile {\n  // Resource name of the profile.\n  // Format: profiles/{obfuscated_profile_id}\n  name: string;\n  activeSubscription?: {\n    subscriptionStatus: SubscriptionStatus,\n    // To ensure forward compatibility, we accept any string, allowing the server to\n    // introduce new subscription tiers without breaking older clients.\n    subscriptionTier: SubscriptionTier|string,\n  };\n}\n\nexport interface GetProfileResponse {\n  profile: Profile|null;\n  isEligible: boolean;\n}\n\n/**\n * The `batchGet` awards endpoint returns badge names with an\n * obfuscated user ID (e.g., `profiles/12345/awards/badge-name`).\n * This function normalizes them to use `me` instead of the ID\n * (e.g., `profiles/me/awards/badge-path`) to match the format\n * used for client-side requests.\n **/\nfunction normalizeBadgeName(name: string): string {\n  return name.replace(/profiles\\/[^/]+\\/awards\\//, 'profiles/me/awards/');\n}\n\nexport const GOOGLE_DEVELOPER_PROGRAM_PROFILE_LINK = 'https://developers.google.com/profile/u/me';\n\nasync function makeHttpRequest<R>(request: DispatchHttpRequestRequest): Promise<R> {\n  if (!isGdpProfilesAvailable()) {\n    throw new DispatchHttpRequestClient.DispatchHttpRequestError(\n        DispatchHttpRequestClient.ErrorType.HTTP_RESPONSE_UNAVAILABLE);\n  }\n\n  const response = await DispatchHttpRequestClient.makeHttpRequest(request) as R;\n  return response;\n}\n\nconst SERVICE_NAME = 'gdpService';\nlet gdpClientInstance: GdpClient|null = null;\nexport class GdpClient {\n  #cachedProfilePromise?: Promise<Profile>;\n  #cachedEligibilityPromise?: Promise<CheckElibigilityResponse>;\n\n  private constructor() {\n  }\n\n  static instance({forceNew}: {\n    forceNew: boolean,\n  } = {forceNew: false}): GdpClient {\n    if (!gdpClientInstance || forceNew) {\n      gdpClientInstance = new GdpClient();\n    }\n    return gdpClientInstance;\n  }\n\n  /**\n   * Fetches the user's GDP profile and eligibility status.\n   *\n   * It first attempts to fetch the profile. If the profile is not found\n   * (a `NOT_FOUND` error), this is handled gracefully by treating the profile\n   * as `null` and then proceeding to check for eligibility.\n   *\n   * @returns A promise that resolves with an object containing the `profile`\n   * and `isEligible` status, or `null` if an unexpected error occurs.\n   */\n  async getProfile(): Promise<GetProfileResponse|null> {\n    try {\n      const profile = await this.#getProfile();\n      return {\n        profile,\n        isEligible: true,\n      };\n    } catch (err: unknown) {\n      if (err instanceof DispatchHttpRequestClient.DispatchHttpRequestError &&\n          err.type === DispatchHttpRequestClient.ErrorType.HTTP_RESPONSE_UNAVAILABLE) {\n        return null;\n      }\n    }\n\n    try {\n      const checkEligibilityResponse = await this.#checkEligibility();\n      return {\n        profile: null,\n        isEligible: checkEligibilityResponse.createProfile === EligibilityStatus.ELIGIBLE,\n      };\n    } catch {\n      return null;\n    }\n  }\n\n  async #getProfile(): Promise<Profile> {\n    if (this.#cachedProfilePromise) {\n      return await this.#cachedProfilePromise;\n    }\n\n    this.#cachedProfilePromise = makeHttpRequest<Profile>({\n                                   service: SERVICE_NAME,\n                                   path: '/v1beta1/profile:get',\n                                   method: 'GET',\n                                 }).then(profile => {\n      this.#cachedEligibilityPromise = Promise.resolve({createProfile: EligibilityStatus.ELIGIBLE});\n      return profile;\n    });\n\n    return await this.#cachedProfilePromise;\n  }\n\n  async #checkEligibility(): Promise<CheckElibigilityResponse> {\n    if (this.#cachedEligibilityPromise) {\n      return await this.#cachedEligibilityPromise;\n    }\n\n    this.#cachedEligibilityPromise =\n        makeHttpRequest({service: SERVICE_NAME, path: '/v1beta1/eligibility:check', method: 'GET'});\n\n    return await this.#cachedEligibilityPromise;\n  }\n\n  /**\n   * @returns null if the request fails, the awarded badge names otherwise.\n   */\n  async getAwardedBadgeNames({names}: {names: string[]}): Promise<Set<string>|null> {\n    try {\n      const response = await makeHttpRequest<BatchGetAwardsResponse>({\n        service: SERVICE_NAME,\n        path: '/v1beta1/profiles/me/awards:batchGet',\n        method: 'GET',\n        queryParams: {\n          allowMissing: 'true',\n          names,\n        }\n      });\n\n      return new Set(response.awards?.map(award => normalizeBadgeName(award.name)) ?? []);\n    } catch {\n      return null;\n    }\n  }\n\n  async createProfile({user, emailPreference}: {user: string, emailPreference: EmailPreference}):\n      Promise<Profile|null> {\n    try {\n      const response = await makeHttpRequest<Profile>({\n        service: SERVICE_NAME,\n        path: '/v1beta1/profiles',\n        method: 'POST',\n        body: JSON.stringify({\n          user,\n          newsletter_email: emailPreference,\n        }),\n      });\n      this.#clearCache();\n      return response;\n    } catch {\n      return null;\n    }\n  }\n\n  #clearCache(): void {\n    this.#cachedProfilePromise = undefined;\n    this.#cachedEligibilityPromise = undefined;\n  }\n\n  async createAward({name}: {name: string}): Promise<Award|null> {\n    try {\n      const response = await makeHttpRequest<Award>({\n        service: SERVICE_NAME,\n        path: '/v1beta1/profiles/me/awards',\n        method: 'POST',\n        body: JSON.stringify({\n          awardingUri: 'devtools://devtools',\n          name,\n        })\n      });\n      return response;\n    } catch {\n      return null;\n    }\n  }\n}\n\nexport function isGdpProfilesAvailable(): boolean {\n  const isBaseFeatureEnabled = Boolean(Root.Runtime.hostConfig.devToolsGdpProfiles?.enabled);\n  const isBrandedBuild = Boolean(Root.Runtime.hostConfig.devToolsGdpProfilesAvailability?.enabled);\n  const isOffTheRecordProfile = Root.Runtime.hostConfig.isOffTheRecord;\n  const isDisabledByEnterprisePolicy =\n      getGdpProfilesEnterprisePolicy() === Root.Runtime.GdpProfilesEnterprisePolicyValue.DISABLED;\n  return isBaseFeatureEnabled && isBrandedBuild && !isOffTheRecordProfile && !isDisabledByEnterprisePolicy;\n}\n\nexport function getGdpProfilesEnterprisePolicy(): Root.Runtime.GdpProfilesEnterprisePolicyValue {\n  return (\n      Root.Runtime.hostConfig.devToolsGdpProfilesAvailability?.enterprisePolicyValue ??\n      Root.Runtime.GdpProfilesEnterprisePolicyValue.DISABLED);\n}\n\nexport function isBadgesEnabled(): boolean {\n  const isBadgesEnabledByEnterprisePolicy =\n      getGdpProfilesEnterprisePolicy() === Root.Runtime.GdpProfilesEnterprisePolicyValue.ENABLED;\n  const isBadgesEnabledByFeatureFlag = Boolean(Root.Runtime.hostConfig.devToolsGdpProfiles?.badgesEnabled);\n  return isBadgesEnabledByEnterprisePolicy && isBadgesEnabledByFeatureFlag;\n}\n\nexport function isStarterBadgeEnabled(): boolean {\n  return Boolean(Root.Runtime.hostConfig.devToolsGdpProfiles?.starterBadgeEnabled);\n}\n"],
  "mappings": "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",
  "names": ["SubscriptionStatus", "SubscriptionTier", "EligibilityStatus", "EmailPreference"]
}
