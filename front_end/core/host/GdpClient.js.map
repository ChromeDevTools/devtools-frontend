{
  "version": 3,
  "sources": ["../../../../../../front_end/core/host/GdpClient.ts"],
  "sourcesContent": ["// Copyright 2025 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Root from '../root/root.js';\n\nimport {InspectorFrontendHostInstance} from './InspectorFrontendHost.js';\nimport type {DispatchHttpRequestRequest, DispatchHttpRequestResult} from './InspectorFrontendHostAPI.js';\n\nexport enum SubscriptionStatus {\n  ENABLED = 'SUBSCRIPTION_STATE_ENABLED',\n  PENDING = 'SUBSCRIPTION_STATE_PENDING',\n  CANCELED = 'SUBSCRIPTION_STATE_CANCELED',\n  REFUNDED = 'SUBSCRIPTION_STATE_REFUNDED',\n  AWAITING_FIX = 'SUBSCRIPTION_STATE_AWAITING_FIX',\n  ON_HOLD = 'SUBSCRIPTION_STATE_ACCOUNT_ON_HOLD',\n}\n\nexport enum SubscriptionTier {\n  PREMIUM_ANNUAL = 'SUBSCRIPTION_TIER_PREMIUM_ANNUAL',\n  PREMIUM_MONTHLY = 'SUBSCRIPTION_TIER_PREMIUM_MONTHLY',\n  PRO_ANNUAL = 'SUBSCRIPTION_TIER_PRO_ANNUAL',\n  PRO_MONTHLY = 'SUBSCRIPTION_TIER_PRO_MONTHLY',\n}\n\nexport enum EligibilityStatus {\n  ELIGIBLE = 'ELIGIBLE',\n  NOT_ELIGIBLE = 'NOT_ELIGIBLE',\n}\n\nexport enum EmailPreference {\n  ENABLED = 'ENABLED',\n  DISABLED = 'DISABLED',\n}\n\ninterface CheckElibigilityResponse {\n  createProfile: EligibilityStatus;\n}\n\ninterface BatchGetAwardsResponse {\n  awards?: Award[];\n}\n\nexport interface Award {\n  name: string;\n  badge: {\n    title: string,\n    description: string,\n    imageUri: string,\n    deletableByUser: boolean,\n  };\n  title: string;\n  description: string;\n  imageUri: string;\n  createTime: string;\n  awardingUri: string;\n}\n\nexport interface Profile {\n  // Resource name of the profile.\n  // Format: profiles/{obfuscated_profile_id}\n  name: string;\n  activeSubscription?: {\n    subscriptionStatus: SubscriptionStatus,\n    // To ensure forward compatibility, we accept any string, allowing the server to\n    // introduce new subscription tiers without breaking older clients.\n    subscriptionTier: SubscriptionTier|string,\n  };\n}\n\nexport interface GetProfileResponse {\n  profile: Profile|null;\n  isEligible: boolean;\n}\n\nexport enum GdpErrorType {\n  HTTP_RESPONSE_UNAVAILABLE = 'HTTP_RESPONSE_UNAVAILABLE',\n  NOT_FOUND = 'NOT_FOUND',\n}\n\nclass GdpError extends Error {\n  constructor(readonly type: GdpErrorType, options?: ErrorOptions) {\n    super(undefined, options);\n  }\n}\n\n/**\n * The `batchGet` awards endpoint returns badge names with an\n * obfuscated user ID (e.g., `profiles/12345/awards/badge-name`).\n * This function normalizes them to use `me` instead of the ID\n * (e.g., `profiles/me/awards/badge-path`) to match the format\n * used for client-side requests.\n **/\nfunction normalizeBadgeName(name: string): string {\n  return name.replace(/profiles\\/[^/]+\\/awards\\//, 'profiles/me/awards/');\n}\n\nexport const GOOGLE_DEVELOPER_PROGRAM_PROFILE_LINK = 'https://developers.google.com/profile/u/me';\n\nasync function makeHttpRequest<R>(request: DispatchHttpRequestRequest): Promise<R> {\n  if (!isGdpProfilesAvailable()) {\n    throw new GdpError(GdpErrorType.HTTP_RESPONSE_UNAVAILABLE);\n  }\n\n  const response = await new Promise<DispatchHttpRequestResult>(resolve => {\n    InspectorFrontendHostInstance.dispatchHttpRequest(request, resolve);\n  });\n\n  debugLog({request, response});\n  if (response.statusCode === 404) {\n    throw new GdpError(GdpErrorType.NOT_FOUND);\n  }\n\n  if ('response' in response && response.statusCode === 200) {\n    try {\n      return JSON.parse(response.response) as R;\n    } catch (err) {\n      throw new GdpError(GdpErrorType.HTTP_RESPONSE_UNAVAILABLE, {cause: err});\n    }\n  }\n\n  throw new GdpError(GdpErrorType.HTTP_RESPONSE_UNAVAILABLE);\n}\n\nconst SERVICE_NAME = 'gdpService';\nlet gdpClientInstance: GdpClient|null = null;\nexport class GdpClient {\n  #cachedProfilePromise?: Promise<Profile>;\n  #cachedEligibilityPromise?: Promise<CheckElibigilityResponse>;\n\n  private constructor() {\n  }\n\n  static instance({forceNew}: {\n    forceNew: boolean,\n  } = {forceNew: false}): GdpClient {\n    if (!gdpClientInstance || forceNew) {\n      gdpClientInstance = new GdpClient();\n    }\n    return gdpClientInstance;\n  }\n\n  /**\n   * Fetches the user's GDP profile and eligibility status.\n   *\n   * It first attempts to fetch the profile. If the profile is not found\n   * (a `NOT_FOUND` error), this is handled gracefully by treating the profile\n   * as `null` and then proceeding to check for eligibility.\n   *\n   * @returns A promise that resolves with an object containing the `profile`\n   * and `isEligible` status, or `null` if an unexpected error occurs.\n   */\n  async getProfile(): Promise<GetProfileResponse|null> {\n    try {\n      const profile = await this.#getProfile();\n      return {\n        profile,\n        isEligible: true,\n      };\n    } catch (err: unknown) {\n      if (err instanceof GdpError && err.type === GdpErrorType.HTTP_RESPONSE_UNAVAILABLE) {\n        return null;\n      }\n    }\n\n    try {\n      const checkEligibilityResponse = await this.#checkEligibility();\n      return {\n        profile: null,\n        isEligible: checkEligibilityResponse.createProfile === EligibilityStatus.ELIGIBLE,\n      };\n    } catch {\n      return null;\n    }\n  }\n\n  async #getProfile(): Promise<Profile> {\n    if (this.#cachedProfilePromise) {\n      return await this.#cachedProfilePromise;\n    }\n\n    this.#cachedProfilePromise = makeHttpRequest<Profile>({\n                                   service: SERVICE_NAME,\n                                   path: '/v1beta1/profile:get',\n                                   method: 'GET',\n                                 }).then(profile => {\n      this.#cachedEligibilityPromise = Promise.resolve({createProfile: EligibilityStatus.ELIGIBLE});\n      return profile;\n    });\n\n    return await this.#cachedProfilePromise;\n  }\n\n  async #checkEligibility(): Promise<CheckElibigilityResponse> {\n    if (this.#cachedEligibilityPromise) {\n      return await this.#cachedEligibilityPromise;\n    }\n\n    this.#cachedEligibilityPromise =\n        makeHttpRequest({service: SERVICE_NAME, path: '/v1beta1/eligibility:check', method: 'GET'});\n\n    return await this.#cachedEligibilityPromise;\n  }\n\n  /**\n   * @returns null if the request fails, the awarded badge names otherwise.\n   */\n  async getAwardedBadgeNames({names}: {names: string[]}): Promise<Set<string>|null> {\n    try {\n      const response = await makeHttpRequest<BatchGetAwardsResponse>({\n        service: SERVICE_NAME,\n        path: '/v1beta1/profiles/me/awards:batchGet',\n        method: 'GET',\n        queryParams: {\n          allowMissing: 'true',\n          names,\n        }\n      });\n\n      return new Set(response.awards?.map(award => normalizeBadgeName(award.name)) ?? []);\n    } catch {\n      return null;\n    }\n  }\n\n  async createProfile({user, emailPreference}: {user: string, emailPreference: EmailPreference}):\n      Promise<Profile|null> {\n    try {\n      const response = await makeHttpRequest<Profile>({\n        service: SERVICE_NAME,\n        path: '/v1beta1/profiles',\n        method: 'POST',\n        body: JSON.stringify({\n          user,\n          newsletter_email: emailPreference,\n        }),\n      });\n      this.#clearCache();\n      return response;\n    } catch {\n      return null;\n    }\n  }\n\n  #clearCache(): void {\n    this.#cachedProfilePromise = undefined;\n    this.#cachedEligibilityPromise = undefined;\n  }\n\n  async createAward({name}: {name: string}): Promise<Award|null> {\n    try {\n      const response = await makeHttpRequest<Award>({\n        service: SERVICE_NAME,\n        path: '/v1beta1/profiles/me/awards',\n        method: 'POST',\n        body: JSON.stringify({\n          awardingUri: 'devtools://devtools',\n          name,\n        })\n      });\n      return response;\n    } catch {\n      return null;\n    }\n  }\n}\n\nfunction isDebugMode(): boolean {\n  return Boolean(localStorage.getItem('debugGdpIntegrationEnabled'));\n}\n\nfunction debugLog(...log: unknown[]): void {\n  if (!isDebugMode()) {\n    return;\n  }\n\n  // eslint-disable-next-line no-console\n  console.log('debugLog', ...log);\n}\n\nfunction setDebugGdpIntegrationEnabled(enabled: boolean): void {\n  if (enabled) {\n    localStorage.setItem('debugGdpIntegrationEnabled', 'true');\n  } else {\n    localStorage.removeItem('debugGdpIntegrationEnabled');\n  }\n}\n\nexport function isGdpProfilesAvailable(): boolean {\n  const isBaseFeatureEnabled = Boolean(Root.Runtime.hostConfig.devToolsGdpProfiles?.enabled);\n  const isBrandedBuild = Boolean(Root.Runtime.hostConfig.devToolsGdpProfilesAvailability?.enabled);\n  const isOffTheRecordProfile = Root.Runtime.hostConfig.isOffTheRecord;\n  const isDisabledByEnterprisePolicy =\n      getGdpProfilesEnterprisePolicy() === Root.Runtime.GdpProfilesEnterprisePolicyValue.DISABLED;\n  return isBaseFeatureEnabled && isBrandedBuild && !isOffTheRecordProfile && !isDisabledByEnterprisePolicy;\n}\n\nexport function getGdpProfilesEnterprisePolicy(): Root.Runtime.GdpProfilesEnterprisePolicyValue {\n  return (\n      Root.Runtime.hostConfig.devToolsGdpProfilesAvailability?.enterprisePolicyValue ??\n      Root.Runtime.GdpProfilesEnterprisePolicyValue.DISABLED);\n}\n\nexport function isBadgesEnabled(): boolean {\n  const isBadgesEnabledByEnterprisePolicy =\n      getGdpProfilesEnterprisePolicy() === Root.Runtime.GdpProfilesEnterprisePolicyValue.ENABLED;\n  const isBadgesEnabledByFeatureFlag = Boolean(Root.Runtime.hostConfig.devToolsGdpProfiles?.badgesEnabled);\n  return isBadgesEnabledByEnterprisePolicy && isBadgesEnabledByFeatureFlag;\n}\n\nexport function isStarterBadgeEnabled(): boolean {\n  return Boolean(Root.Runtime.hostConfig.devToolsGdpProfiles?.starterBadgeEnabled);\n}\n\n// @ts-expect-error\nglobalThis.setDebugGdpIntegrationEnabled = setDebugGdpIntegrationEnabled;\n"],
  "mappings": "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",
  "names": ["SubscriptionStatus", "SubscriptionTier", "EligibilityStatus", "EmailPreference", "GdpErrorType"]
}
