{"version":3,"file":"NumberFormatter.js","sourceRoot":"","sources":["../../../../../../front_end/core/i18n/NumberFormatter.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport {DevToolsLocale} from './DevToolsLocale.js';\n\nexport interface NumberFormatter {\n  format(value: number, separator?: string): string;\n  formatToParts(value: number): Intl.NumberFormatPart[];\n}\n\n/**\n * Creates an instance of NumberFormatter.\n *\n * Safe to call in top-level of a module, since the creation of Intl.NumberFormat is deferred\n * until first usage.\n */\nexport function defineFormatter(options: Intl.NumberFormatOptions): NumberFormatter {\n  let intlNumberFormat: Intl.NumberFormat;\n\n  return {\n    format(value, separator) {\n      if (!intlNumberFormat) {\n        intlNumberFormat = new Intl.NumberFormat(DevToolsLocale.instance().locale, options);\n      }\n      return formatAndEnsureSpace(intlNumberFormat, value, separator);\n    },\n    formatToParts(value) {\n      if (!intlNumberFormat) {\n        intlNumberFormat = new Intl.NumberFormat(DevToolsLocale.instance().locale, options);\n      }\n      return intlNumberFormat.formatToParts(value);\n    },\n  };\n}\n\n/**\n * When using 'narrow' unitDisplay, many locales exclude the space between the literal and the unit.\n * We don't like that, so when there is no space literal we inject the provided separator manually.\n */\nfunction formatAndEnsureSpace(formatter: Intl.NumberFormat, value: number, separator = '\\xA0'): string {\n  // TODO(crbug.com/443038315): this method is defined in\n  // models/ai_assistance in the UnitFormatters file. We can't currently\n  // re-use it because various models depend on i18n and that creates a\n  // circular build.\n  // We should move the unit formatters to their own model so it can be\n  // used across the codebase.\n\n  const parts = formatter.formatToParts(value);\n\n  let hasSpace = false;\n  for (const part of parts) {\n    if (part.type === 'literal') {\n      if (part.value === ' ') {\n        hasSpace = true;\n        part.value = separator;\n      } else if (part.value === separator) {\n        hasSpace = true;\n      }\n    }\n  }\n\n  if (hasSpace) {\n    return parts.map(part => part.value).join('');\n  }\n\n  const unitIndex = parts.findIndex(part => part.type === 'unit');\n\n  // Unexpected for there to be no unit, but just in case, handle that.\n  if (unitIndex === -1) {\n    return parts.map(part => part.value).join('');\n  }\n\n  // For locales where the unit comes first (sw), the space has to come after the unit.\n  if (unitIndex === 0) {\n    return parts[0].value + separator + parts.slice(1).map(part => part.value).join('');\n  }\n\n  // Otherwise, it comes before.\n  return parts.slice(0, unitIndex).map(part => part.value).join('') + separator +\n      parts.slice(unitIndex).map(part => part.value).join('');\n}\n"]}