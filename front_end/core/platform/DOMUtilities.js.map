{
  "version": 3,
  "sources": ["../../../../../../front_end/core/platform/DOMUtilities.ts"],
  "sourcesContent": ["// Copyright 2022 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/**\n * `document.activeElement` will not enter shadow roots to find the element\n * that has focus; use this method if you need to traverse through any shadow\n * roots to find the actual, specific focused element.\n */\nexport function deepActiveElement(doc: Document): Element|null {\n  let activeElement: Element|null = doc.activeElement;\n  while (activeElement?.shadowRoot?.activeElement) {\n    activeElement = activeElement.shadowRoot.activeElement;\n  }\n  return activeElement;\n}\n\nexport function getEnclosingShadowRootForNode(node: Node): Node|null {\n  let parentNode = node.parentNodeOrShadowHost();\n  while (parentNode) {\n    if (parentNode instanceof ShadowRoot) {\n      return parentNode;\n    }\n    parentNode = parentNode.parentNodeOrShadowHost();\n  }\n  return null;\n}\n\nexport function rangeOfWord(\n    rootNode: Node, offset: number, stopCharacters: string, stayWithinNode: Node, direction?: string): Range {\n  let startNode;\n  let startOffset = 0;\n  let endNode;\n  let endOffset = 0;\n\n  if (!stayWithinNode) {\n    stayWithinNode = rootNode;\n  }\n\n  if (!direction || direction === 'backward' || direction === 'both') {\n    let node: Node|null = rootNode;\n    while (node) {\n      if (node === stayWithinNode) {\n        if (!startNode) {\n          startNode = stayWithinNode;\n        }\n        break;\n      }\n\n      if (node.nodeType === Node.TEXT_NODE && node.nodeValue !== null) {\n        const start = (node === rootNode ? (offset - 1) : (node.nodeValue.length - 1));\n        for (let i = start; i >= 0; --i) {\n          if (stopCharacters.indexOf(node.nodeValue[i]) !== -1) {\n            startNode = node;\n            startOffset = i + 1;\n            break;\n          }\n        }\n      }\n\n      if (startNode) {\n        break;\n      }\n\n      node = node.traversePreviousNode(stayWithinNode);\n    }\n\n    if (!startNode) {\n      startNode = stayWithinNode;\n      startOffset = 0;\n    }\n  } else {\n    startNode = rootNode;\n    startOffset = offset;\n  }\n\n  if (!direction || direction === 'forward' || direction === 'both') {\n    let node: (Node|null)|Node = rootNode;\n    while (node) {\n      if (node === stayWithinNode) {\n        if (!endNode) {\n          endNode = stayWithinNode;\n        }\n        break;\n      }\n\n      if (node.nodeType === Node.TEXT_NODE && node.nodeValue !== null) {\n        const start = (node === rootNode ? offset : 0);\n        for (let i = start; i < node.nodeValue.length; ++i) {\n          if (stopCharacters.indexOf(node.nodeValue[i]) !== -1) {\n            endNode = node;\n            endOffset = i;\n            break;\n          }\n        }\n      }\n\n      if (endNode) {\n        break;\n      }\n\n      node = node.traverseNextNode(stayWithinNode);\n    }\n\n    if (!endNode) {\n      endNode = stayWithinNode;\n      endOffset = stayWithinNode.nodeType === Node.TEXT_NODE ? stayWithinNode.nodeValue?.length || 0 :\n                                                               stayWithinNode.childNodes.length;\n    }\n  } else {\n    endNode = rootNode;\n    endOffset = offset;\n  }\n\n  if (!rootNode.ownerDocument) {\n    throw new Error('No `ownerDocument` found for rootNode');\n  }\n  const result = rootNode.ownerDocument.createRange();\n  result.setStart(startNode, startOffset);\n  result.setEnd(endNode, endOffset);\n\n  return result;\n}\n\n/**\n * Appends the list of `styles` as individual `<style>` elements to the\n * given `node`.\n *\n * @param node the `Node` to append the `<style>` elements to.\n * @param styles an optional list of styles to append to the `node`.\n */\nexport function appendStyle(node: Node, ...styles: CSSInJS[]): void {\n  for (const cssText of styles) {\n    const style = (node.ownerDocument ?? document).createElement('style');\n    style.textContent = cssText;\n    node.appendChild(style);\n  }\n}\n"],
  "mappings": ";AASO,gBAAS,kBAAkB,KAA6B;AAC7D,MAAI,gBAA8B,IAAI;AACtC,SAAO,eAAe,YAAY,eAAe;AAC/C,oBAAgB,cAAc,WAAW;AAAA,EAC3C;AACA,SAAO;AACT;AAEO,gBAAS,8BAA8B,MAAuB;AACnE,MAAI,aAAa,KAAK,uBAAuB;AAC7C,SAAO,YAAY;AACjB,QAAI,sBAAsB,YAAY;AACpC,aAAO;AAAA,IACT;AACA,iBAAa,WAAW,uBAAuB;AAAA,EACjD;AACA,SAAO;AACT;AAEO,gBAAS,YACZ,UAAgB,QAAgB,gBAAwB,gBAAsB,WAA2B;AAC3G,MAAI;AACJ,MAAI,cAAc;AAClB,MAAI;AACJ,MAAI,YAAY;AAEhB,MAAI,CAAC,gBAAgB;AACnB,qBAAiB;AAAA,EACnB;AAEA,MAAI,CAAC,aAAa,cAAc,cAAc,cAAc,QAAQ;AAClE,QAAI,OAAkB;AACtB,WAAO,MAAM;AACX,UAAI,SAAS,gBAAgB;AAC3B,YAAI,CAAC,WAAW;AACd,sBAAY;AAAA,QACd;AACA;AAAA,MACF;AAEA,UAAI,KAAK,aAAa,KAAK,aAAa,KAAK,cAAc,MAAM;AAC/D,cAAM,QAAS,SAAS,WAAY,SAAS,IAAM,KAAK,UAAU,SAAS;AAC3E,iBAAS,IAAI,OAAO,KAAK,GAAG,EAAE,GAAG;AAC/B,cAAI,eAAe,QAAQ,KAAK,UAAU,CAAC,CAAC,MAAM,IAAI;AACpD,wBAAY;AACZ,0BAAc,IAAI;AAClB;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAEA,UAAI,WAAW;AACb;AAAA,MACF;AAEA,aAAO,KAAK,qBAAqB,cAAc;AAAA,IACjD;AAEA,QAAI,CAAC,WAAW;AACd,kBAAY;AACZ,oBAAc;AAAA,IAChB;AAAA,EACF,OAAO;AACL,gBAAY;AACZ,kBAAc;AAAA,EAChB;AAEA,MAAI,CAAC,aAAa,cAAc,aAAa,cAAc,QAAQ;AACjE,QAAI,OAAyB;AAC7B,WAAO,MAAM;AACX,UAAI,SAAS,gBAAgB;AAC3B,YAAI,CAAC,SAAS;AACZ,oBAAU;AAAA,QACZ;AACA;AAAA,MACF;AAEA,UAAI,KAAK,aAAa,KAAK,aAAa,KAAK,cAAc,MAAM;AAC/D,cAAM,QAAS,SAAS,WAAW,SAAS;AAC5C,iBAAS,IAAI,OAAO,IAAI,KAAK,UAAU,QAAQ,EAAE,GAAG;AAClD,cAAI,eAAe,QAAQ,KAAK,UAAU,CAAC,CAAC,MAAM,IAAI;AACpD,sBAAU;AACV,wBAAY;AACZ;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAEA,UAAI,SAAS;AACX;AAAA,MACF;AAEA,aAAO,KAAK,iBAAiB,cAAc;AAAA,IAC7C;AAEA,QAAI,CAAC,SAAS;AACZ,gBAAU;AACV,kBAAY,eAAe,aAAa,KAAK,YAAY,eAAe,WAAW,UAAU,IACpC,eAAe,WAAW;AAAA,IACrF;AAAA,EACF,OAAO;AACL,cAAU;AACV,gBAAY;AAAA,EACd;AAEA,MAAI,CAAC,SAAS,eAAe;AAC3B,UAAM,IAAI,MAAM,uCAAuC;AAAA,EACzD;AACA,QAAM,SAAS,SAAS,cAAc,YAAY;AAClD,SAAO,SAAS,WAAW,WAAW;AACtC,SAAO,OAAO,SAAS,SAAS;AAEhC,SAAO;AACT;AASO,gBAAS,YAAY,SAAe,QAAyB;AAClE,aAAW,WAAW,QAAQ;AAC5B,UAAM,SAAS,KAAK,iBAAiB,UAAU,cAAc,OAAO;AACpE,UAAM,cAAc;AACpB,SAAK,YAAY,KAAK;AAAA,EACxB;AACF;",
  "names": []
}
