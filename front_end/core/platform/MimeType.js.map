{
  "version": 3,
  "sources": ["../../../../../../front_end/core/platform/MimeType.ts"],
  "sourcesContent": ["// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nexport const enum MimeType {\n  HTML = 'text/html',\n  XML = 'text/xml',\n  PLAIN = 'text/plain',\n  XHTML = 'application/xhtml+xml',\n  SVG = 'image/svg+xml',\n  CSS = 'text/css',\n  XSL = 'text/xsl',\n  VTT = 'text/vtt',\n  PDF = 'application/pdf',\n  EVENTSTREAM = 'text/event-stream',\n}\n\n/**\n * MIME types other than the ones with the \"text\" type that have text content.\n */\nconst ADDITIONAL_TEXT_MIME_TYPES = new Set([\n  'application/ecmascript',\n  'application/javascript',\n  'application/json',\n  'application/json+protobuf',\n  'application/mpegurl',\n  'application/vnd.apple.mpegurl',\n  'application/vnd.dart',\n  'application/xml',\n  'application/x-aspx',\n  'application/x-javascript',\n  'application/x-jsp',\n  'application/x-httpd-php',\n  'application/x-mpegurl',\n  'audio/mpegurl',\n  'audio/x-mpegurl',\n]);\n\n/**\n * @returns true iff `mimeType` has textual content. Concretely we return true if:\n *   - `mimeType` starts with \"text/\" or \"multipart/\"\n *   - `mimeType` ends with \"+xml\"\n *   - `mimeType` contains \"json\"\n *   - if `mimeType` is one of a predefined list textual mime types.\n */\nexport function isTextType(mimeType: string): boolean {\n  return mimeType.startsWith('text/') || mimeType.startsWith('multipart/') || mimeType.includes('json') ||\n      mimeType.endsWith('+xml') || ADDITIONAL_TEXT_MIME_TYPES.has(mimeType);\n}\n\n/**\n * Port of net::HttpUtils::ParseContentType to extract mimeType and charset from\n * the 'Content-Type' header.\n */\nexport function parseContentType(contentType: string): {mimeType: string|null, charset: string|null} {\n  if (contentType === '*/*') {\n    return {mimeType: null, charset: null};\n  }\n\n  const {mimeType, params} = parseMimeType(contentType);\n  const charset = params.get('charset')?.toLowerCase().trim() ?? null;\n  return {mimeType, charset};\n}\n\nfunction parseMimeType(contentType: string): {mimeType: string|null, params: Map<string, string>} {\n  // Remove any leading and trailing whitespace. Note that String.prototype.trim removes a lot more\n  // than what the spec considers whitespace. We are fine with that.\n  contentType = contentType.trim();\n\n  // The mimetype is basically everything until the first ';' (but trimmed).\n  let mimeTypeEnd = findFirstIndexOf(contentType, ' \\t;(');\n  if (mimeTypeEnd < 0) {\n    mimeTypeEnd = contentType.length;\n  }\n\n  const slashPos = contentType.indexOf('/');\n  if (slashPos < 0 || slashPos > mimeTypeEnd) {\n    return {mimeType: null, params: new Map()};\n  }\n  const mimeType = contentType.substring(0, mimeTypeEnd).toLowerCase();\n\n  // Iterate over parameters. We can't split the string around semicolons because quoted\n  // strings may include semicolons.\n  const params = new Map<string, string>();\n  let offset = contentType.indexOf(';', mimeTypeEnd);\n  while (offset >= 0 && offset < contentType.length) {\n    // Trim off the semicolon.\n    ++offset;\n\n    // Trim off whitespace\n    offset = findFirstIndexNotOf(contentType, ' \\t', offset);\n    if (offset < 0) {\n      continue;\n    }\n    const paramNameStart = offset;\n\n    // Extend parameter name until we run into semicolon or equals sign.\n    offset = findFirstIndexOf(contentType, ';=', offset);\n    if (offset < 0 || contentType[offset] === ';') {\n      // Nothing more to do if no more input or there is no parameter value.\n      continue;\n    }\n\n    const paramName = contentType.substring(paramNameStart, offset).toLowerCase();\n\n    //  Trim off the '='.\n    ++offset;\n\n    // Trim off whitespace.\n    offset = findFirstIndexNotOf(contentType, ' \\t', offset);\n\n    let paramValue = '';\n    if (offset < 0 || contentType[offset] === ';') {\n      // Nothing to do here: the value is an unquoted string of only whitespace.\n      continue;\n    } else if (contentType[offset] !== '\"') {\n      // Not a quote so we can copy the value as-is.\n      const valueStart = offset;\n      offset = contentType.indexOf(';', offset);\n      const valueEnd = offset >= 0 ? offset : contentType.length;\n\n      paramValue = contentType.substring(valueStart, valueEnd).trimEnd();\n    } else {\n      // Otherwise append data with special handling for backslashes, until a close quote.\n      // Don't trim whitespace for quoted strings.\n\n      // Trim off the opening quote '\"'\n      ++offset;\n\n      while (offset < contentType.length && contentType[offset] !== '\"') {\n        // Skip over backslash and append the next character, when not at the end\n        // of the string. Otherwise, copy the next character (which may be a backslash).\n        if (contentType[offset] === '\\\\' && offset + 1 < contentType.length) {\n          ++offset;\n        }\n        paramValue += contentType[offset];\n        ++offset;\n      }\n\n      offset = contentType.indexOf(';', offset);\n    }\n    if (!params.has(paramName)) {\n      // The first one wins!\n      params.set(paramName, paramValue);\n    }\n  }\n\n  return {mimeType, params};\n}\n\n/**\n * @returns the smallest index of any character in 'characters' or -1 if none of\n * the characters occur in 'searchString'\n */\nfunction findFirstIndexOf(searchString: string, characters: string, pos = 0): number {\n  for (let i = pos; i < searchString.length; i++) {\n    if (characters.includes(searchString[i])) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n/**\n * @returns the smallest index of any character not in 'characters' or -1 if only\n * 'characters' occur in 'searchString'\n */\nfunction findFirstIndexNotOf(searchString: string, characters: string, pos = 0): number {\n  for (let i = pos; i < searchString.length; i++) {\n    if (!characters.includes(searchString[i])) {\n      return i;\n    }\n  }\n  return -1;\n}\n"],
  "mappings": "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",
  "names": ["MimeType"]
}
