{
  "version": 3,
  "sources": ["../../../../../../front_end/core/platform/TypedArrayUtilities.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/**\n * An object which provides functionality similar to Uint32Array. It may be\n * implemented as:\n * 1. A Uint32Array,\n * 2. An array of Uint32Arrays, to support more data than Uint32Array, or\n * 3. A plain array, in which case the length may change by setting values.\n */\nexport interface BigUint32Array {\n  get length(): number;\n  getValue(index: number): number;\n  setValue(index: number, value: number): void;\n  asUint32ArrayOrFail(): Uint32Array;\n  asArrayOrFail(): number[];\n}\n\n/**\n * @returns A BigUint32Array implementation which is based on Array.\n * This means that its length automatically expands to include the highest index\n * used, and asArrayOrFail will succeed.\n */\nexport function createExpandableBigUint32Array(): BigUint32Array {\n  return new ExpandableBigUint32ArrayImpl();\n}\n\n/**\n * @returns A BigUint32Array implementation which is based on Uint32Array.\n * If the length is small enough to fit in a single Uint32Array, then\n * asUint32ArrayOrFail will succeed. Otherwise, it will throw an exception.\n */\nexport function createFixedBigUint32Array(length: number, maxLengthForTesting?: number): BigUint32Array {\n  try {\n    if (maxLengthForTesting !== undefined && length > maxLengthForTesting) {\n      // Simulate allocation failure.\n      throw new RangeError();\n    }\n    return new BasicBigUint32ArrayImpl(length);\n  } catch {\n    // We couldn't allocate a big enough ArrayBuffer.\n    return new SplitBigUint32ArrayImpl(length, maxLengthForTesting);\n  }\n}\n\nclass BasicBigUint32ArrayImpl extends Uint32Array implements BigUint32Array {\n  getValue(index: number): number {\n    return this[index];\n  }\n  setValue(index: number, value: number): void {\n    this[index] = value;\n  }\n  asUint32ArrayOrFail(): Uint32Array {\n    return this;\n  }\n  asArrayOrFail(): number[] {\n    throw new Error('Not an array');\n  }\n}\n\nclass SplitBigUint32ArrayImpl implements BigUint32Array {\n  #data: Uint32Array[];\n  #partLength: number;\n  length: number;\n\n  constructor(length: number, maxLengthForTesting?: number) {\n    this.#data = [];\n    this.length = length;\n    let partCount = 1;\n    while (true) {\n      partCount *= 2;\n      this.#partLength = Math.ceil(length / partCount);\n      try {\n        if (maxLengthForTesting !== undefined && this.#partLength > maxLengthForTesting) {\n          // Simulate allocation failure.\n          throw new RangeError();\n        }\n        for (let i = 0; i < partCount; ++i) {\n          this.#data[i] = new Uint32Array(this.#partLength);\n        }\n        return;\n      } catch (e) {\n        if (this.#partLength < 1e6) {\n          // The length per part is already small, so continuing to subdivide it\n          // will probably not help.\n          throw e;\n        }\n      }\n    }\n  }\n\n  getValue(index: number): number {\n    if (index >= 0 && index < this.length) {\n      const partLength = this.#partLength;\n      return this.#data[Math.floor(index / partLength)][index % partLength];\n    }\n    // On out-of-bounds accesses, match the behavior of Uint32Array: return an\n    // undefined value that's incorrectly typed as number.\n    return this.#data[0][-1];\n  }\n\n  setValue(index: number, value: number): void {\n    if (index >= 0 && index < this.length) {\n      const partLength = this.#partLength;\n      this.#data[Math.floor(index / partLength)][index % partLength] = value;\n    }\n    // Attempting to set a value out of bounds does nothing, like Uint32Array.\n  }\n\n  asUint32ArrayOrFail(): Uint32Array {\n    throw new Error('Not a Uint32Array');\n  }\n  asArrayOrFail(): number[] {\n    throw new Error('Not an array');\n  }\n}\n\nclass ExpandableBigUint32ArrayImpl extends Array<number> implements BigUint32Array {\n  getValue(index: number): number {\n    return this[index];\n  }\n  setValue(index: number, value: number): void {\n    this[index] = value;\n  }\n  asUint32ArrayOrFail(): Uint32Array {\n    throw new Error('Not a Uint32Array');\n  }\n  asArrayOrFail(): number[] {\n    return this;\n  }\n}\n\nexport interface BitVector {\n  getBit(index: number): boolean;\n  setBit(index: number): void;\n  clearBit(index: number): void;\n  // Returns the last bit before `index` which is set, or -1 if there are none.\n  previous(index: number): number;\n  get buffer(): ArrayBuffer;\n}\n\nexport function createBitVector(lengthOrBuffer: number|ArrayBuffer): BitVector {\n  return new BitVectorImpl(lengthOrBuffer);\n}\n\nclass BitVectorImpl extends Uint8Array {\n  constructor(lengthOrBuffer: number|ArrayBuffer) {\n    if (typeof lengthOrBuffer === 'number') {\n      super(Math.ceil(lengthOrBuffer / 8));\n    } else {\n      super(lengthOrBuffer);\n    }\n  }\n  getBit(index: number): boolean {\n    const value = this[index >> 3] & (1 << (index & 7));\n    return value !== 0;\n  }\n  setBit(index: number): void {\n    this[index >> 3] |= (1 << (index & 7));\n  }\n  clearBit(index: number): void {\n    this[index >> 3] &= ~(1 << (index & 7));\n  }\n  previous(index: number): number {\n    // First, check for more bits in the current byte.\n    while (index !== ((index >> 3) << 3)) {\n      --index;\n      if (this.getBit(index)) {\n        return index;\n      }\n    }\n    // Next, iterate by bytes to skip over ranges of zeros.\n    let byteIndex: number = (index >> 3) - 1;\n    while (byteIndex >= 0 && this[byteIndex] === 0) {\n      --byteIndex;\n    }\n    if (byteIndex < 0) {\n      return -1;\n    }\n    // Finally, iterate the nonzero byte to find the highest bit.\n    for (index = (byteIndex << 3) + 7; index >= (byteIndex << 3); --index) {\n      if (this.getBit(index)) {\n        return index;\n      }\n    }\n    throw new Error('Unreachable');\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
