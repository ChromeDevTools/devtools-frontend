{
  "version": 3,
  "sources": ["Brand.js", "Constructor.js", "../../../../../../front_end/core/platform/ArrayUtilities.ts", "platform.prebundle.ts", "../../../../../../front_end/core/platform/DateUtilities.ts", "../../../../../../front_end/core/platform/DevToolsPath.ts", "../../../../../../front_end/core/platform/DOMUtilities.ts", "../../../../../../front_end/core/platform/KeyboardUtilities.ts", "../../../../../../front_end/core/platform/MapUtilities.ts", "../../../../../../front_end/core/platform/MimeType.ts", "../../../../../../front_end/core/platform/NumberUtilities.ts", "../../../../../../front_end/core/platform/StringUtilities.ts", "../../../../../../front_end/core/platform/Timing.ts", "../../../../../../front_end/core/platform/TypedArrayUtilities.ts", "../../../../../../front_end/core/platform/TypescriptUtilities.ts", "../../../../../../front_end/core/platform/UIString.ts", "../../../../../../front_end/core/platform/UserVisibleError.ts"],
  "sourcesContent": ["\"use strict\";\n//# sourceMappingURL=Brand.js.map\n", "\"use strict\";\n//# sourceMappingURL=Constructor.js.map\n", "// Copyright 2020 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nexport const removeElement = <T>(array: T[], element: T, firstOnly?: boolean): boolean => {\n  let index = array.indexOf(element);\n  if (index === -1) {\n    return false;\n  }\n  if (firstOnly) {\n    array.splice(index, 1);\n    return true;\n  }\n  for (let i = index + 1, n = array.length; i < n; ++i) {\n    if (array[i] !== element) {\n      array[index++] = array[i];\n    }\n  }\n  array.length = index;\n  return true;\n};\n\ntype NumberComparator = (a: number, b: number) => number;\n\nexport function swap<T>(array: T[], i1: number, i2: number): void {\n  const temp = array[i1];\n  array[i1] = array[i2];\n  array[i2] = temp;\n}\n\nfunction partition(\n    array: number[], comparator: NumberComparator, left: number, right: number, pivotIndex: number): number {\n  const pivotValue = array[pivotIndex];\n  swap(array, right, pivotIndex);\n  let storeIndex = left;\n  for (let i = left; i < right; ++i) {\n    if (comparator(array[i], pivotValue) < 0) {\n      swap(array, storeIndex, i);\n      ++storeIndex;\n    }\n  }\n  swap(array, right, storeIndex);\n  return storeIndex;\n}\n\nfunction quickSortRange(\n    array: number[], comparator: NumberComparator, left: number, right: number, sortWindowLeft: number,\n    sortWindowRight: number): void {\n  if (right <= left) {\n    return;\n  }\n  const pivotIndex = Math.floor(Math.random() * (right - left)) + left;\n  const pivotNewIndex = partition(array, comparator, left, right, pivotIndex);\n  if (sortWindowLeft < pivotNewIndex) {\n    quickSortRange(array, comparator, left, pivotNewIndex - 1, sortWindowLeft, sortWindowRight);\n  }\n  if (pivotNewIndex < sortWindowRight) {\n    quickSortRange(array, comparator, pivotNewIndex + 1, right, sortWindowLeft, sortWindowRight);\n  }\n}\n\nexport function sortRange(\n    array: number[], comparator: NumberComparator, leftBound: number, rightBound: number, sortWindowLeft: number,\n    sortWindowRight: number): number[] {\n  if (leftBound === 0 && rightBound === (array.length - 1) && sortWindowLeft === 0 && sortWindowRight >= rightBound) {\n    array.sort(comparator);\n  } else {\n    quickSortRange(array, comparator, leftBound, rightBound, sortWindowLeft, sortWindowRight);\n  }\n  return array;\n}\nexport const binaryIndexOf = <T, S>(array: T[], value: S, comparator: (a: S, b: T) => number): number => {\n  const index = lowerBound(array, value, comparator);\n  return index < array.length && comparator(value, array[index]) === 0 ? index : -1;\n};\n\nfunction mergeOrIntersect<T>(\n    array1: T[], array2: T[], comparator: (a: T, b: T) => number, mergeNotIntersect: boolean): T[] {\n  const result = [];\n  let i = 0;\n  let j = 0;\n  while (i < array1.length && j < array2.length) {\n    const compareValue = comparator(array1[i], array2[j]);\n    if (mergeNotIntersect || !compareValue) {\n      result.push(compareValue <= 0 ? array1[i] : array2[j]);\n    }\n    if (compareValue <= 0) {\n      i++;\n    }\n    if (compareValue >= 0) {\n      j++;\n    }\n  }\n  if (mergeNotIntersect) {\n    while (i < array1.length) {\n      result.push(array1[i++]);\n    }\n    while (j < array2.length) {\n      result.push(array2[j++]);\n    }\n  }\n  return result;\n}\n\nexport const intersectOrdered = <T>(array1: T[], array2: T[], comparator: (a: T, b: T) => number): T[] => {\n  return mergeOrIntersect(array1, array2, comparator, false);\n};\n\nexport const mergeOrdered = <T>(array1: T[], array2: T[], comparator: (a: T, b: T) => number): T[] => {\n  return mergeOrIntersect(array1, array2, comparator, true);\n};\n\nexport const DEFAULT_COMPARATOR = (a: string|number, b: string|number): -1|0|1 => {\n  return a < b ? -1 : (a > b ? 1 : 0);\n};\n\n/**\n * Returns the index of the element closest to the needle that is equal to or\n * greater than it. Assumes that the provided array is sorted.\n *\n * If no element is found, the right bound is returned.\n *\n * Uses the provided comparator function to determine if two items are equal or\n * if one is greater than the other. If you are working with strings or\n * numbers, you can use ArrayUtilities.DEFAULT_COMPARATOR. Otherwise, you\n * should define one that takes the needle element and an element from the\n * array and returns a positive or negative number to indicate which is greater\n * than the other.\n *\n * When specified, |left| (inclusive) and |right| (exclusive) indices\n * define the search window.\n */\nexport function lowerBound<T>(\n    array: Uint32Array|Int32Array, needle: T, comparator: (needle: T, b: number) => number, left?: number,\n    right?: number): number;\nexport function lowerBound<S, T>(\n    array: S[], needle: T, comparator: (needle: T, b: S) => number, left?: number, right?: number): number;\nexport function lowerBound<S, T>(\n    array: readonly S[], needle: T, comparator: (needle: T, b: S) => number, left?: number, right?: number): number;\nexport function lowerBound<S, T, A extends S[]>(\n    array: A, needle: T, comparator: (needle: T, b: S) => number, left?: number, right?: number): number {\n  let l = left || 0;\n  let r = right !== undefined ? right : array.length;\n  while (l < r) {\n    const m = (l + r) >> 1;\n    if (comparator(needle, array[m]) > 0) {\n      l = m + 1;\n    } else {\n      r = m;\n    }\n  }\n  return r;\n}\n\n/**\n * Returns the index of the element closest to the needle that is greater than\n * it. Assumes that the provided array is sorted.\n *\n * If no element is found, the right bound is returned.\n *\n * Uses the provided comparator function to determine if two items are equal or\n * if one is greater than the other. If you are working with strings or\n * numbers, you can use ArrayUtilities.DEFAULT_COMPARATOR. Otherwise, you\n * should define one that takes the needle element and an element from the\n * array and returns a positive or negative number to indicate which is greater\n * than the other.\n *\n * When specified, |left| (inclusive) and |right| (exclusive) indices\n * define the search window.\n */\nexport function upperBound<T>(\n    array: Uint32Array, needle: T, comparator: (needle: T, b: number) => number, left?: number, right?: number): number;\nexport function upperBound<S, T>(\n    array: S[], needle: T, comparator: (needle: T, b: S) => number, left?: number, right?: number): number;\nexport function upperBound<S, T, A extends S[]>(\n    array: A, needle: T, comparator: (needle: T, b: S) => number, left?: number, right?: number): number {\n  let l = left || 0;\n  let r = right !== undefined ? right : array.length;\n  while (l < r) {\n    const m = (l + r) >> 1;\n    if (comparator(needle, array[m]) >= 0) {\n      l = m + 1;\n    } else {\n      r = m;\n    }\n  }\n  return r;\n}\n\nconst enum NearestSearchStart {\n  BEGINNING = 'BEGINNING',\n  END = 'END',\n}\n/**\n * Obtains the first or last item in the array that satisfies the predicate function.\n * So, for example, if the array were arr = [2, 4, 6, 8, 10], and you are looking for\n * the last item arr[i] such that arr[i] < 5  you would be returned 1, because\n * array[1] is 4, the last item in the array that satisfies the\n * predicate function.\n *\n * If instead you were looking for the first item in the same array that satisfies\n * arr[i] > 5 you would be returned 2 because array[2] = 6.\n *\n * Please note: this presupposes that the array is already ordered.\n * This function uses a variation of Binary Search.\n */\nfunction nearestIndex<T>(\n    arr: readonly T[], predicate: (arrayItem: T) => boolean, searchStart: NearestSearchStart): number|null {\n  const searchFromEnd = searchStart === NearestSearchStart.END;\n  if (arr.length === 0) {\n    return null;\n  }\n\n  let left = 0;\n  let right = arr.length - 1;\n  let pivot = 0;\n  let matchesPredicate = false;\n  let moveToTheRight = false;\n  let middle = 0;\n  do {\n    middle = left + (right - left) / 2;\n    pivot = searchFromEnd ? Math.ceil(middle) : Math.floor(middle);\n    matchesPredicate = predicate(arr[pivot]);\n    moveToTheRight = matchesPredicate === searchFromEnd;\n    if (moveToTheRight) {\n      left = Math.min(right, pivot + (left === pivot ? 1 : 0));\n    } else {\n      right = Math.max(left, pivot + (right === pivot ? -1 : 0));\n    }\n  } while (right !== left);\n\n  // Special-case: the indexed item doesn't pass the predicate. This\n  // occurs when none of the items in the array are a match for the\n  // predicate.\n  if (!predicate(arr[left])) {\n    return null;\n  }\n  return left;\n}\n\n/**\n * Obtains the first item in the array that satisfies the predicate function.\n * So, for example, if the array was arr = [2, 4, 6, 8, 10], and you are looking for\n * the first item arr[i] such that arr[i] > 5 you would be returned 2, because\n * array[2] is 6, the first item in the array that satisfies the\n * predicate function.\n *\n * Please note: this presupposes that the array is already ordered.\n */\nexport function nearestIndexFromBeginning<T>(arr: T[], predicate: (arrayItem: T) => boolean): number|null {\n  return nearestIndex(arr, predicate, NearestSearchStart.BEGINNING);\n}\n\n/**\n * Obtains the last item in the array that satisfies the predicate function.\n * So, for example, if the array was arr = [2, 4, 6, 8, 10], and you are looking for\n * the last item arr[i] such that arr[i] < 5 you would be returned 1, because\n * arr[1] is 4, the last item in the array that satisfies the\n * predicate function.\n *\n * Please note: this presupposes that the array is already ordered.\n */\n\nexport function nearestIndexFromEnd<T>(arr: readonly T[], predicate: (arrayItem: T) => boolean): number|null {\n  return nearestIndex(arr, predicate, NearestSearchStart.END);\n}\n\n/** Type guard for ensuring that `arr` does not contain null or undefined **/\nexport function arrayDoesNotContainNullOrUndefined<T>(arr: Array<T|null|undefined>): arr is T[] {\n  return !arr.includes(null) && !arr.includes(undefined);\n}\n", "// Copyright 2019 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as ArrayUtilities from './ArrayUtilities.js';\nimport * as Brand from './Brand.js';\nimport * as Constructor from './Constructor.js';\nimport * as DateUtilities from './DateUtilities.js';\nimport * as DevToolsPath from './DevToolsPath.js';\nimport * as DOMUtilities from './DOMUtilities.js';\nimport * as KeyboardUtilities from './KeyboardUtilities.js';\nimport * as MapUtilities from './MapUtilities.js';\nimport * as MimeType from './MimeType.js';\nimport * as NumberUtilities from './NumberUtilities.js';\nimport * as StringUtilities from './StringUtilities.js';\nimport * as Timing from './Timing.js';\nimport * as TypedArrayUtilities from './TypedArrayUtilities.js';\nimport * as TypeScriptUtilities from './TypescriptUtilities.js';\nimport * as UIString from './UIString.js';\nimport * as UserVisibleError from './UserVisibleError.js';\n\n/* `assertNotNullOrUndefined` also need to be exposed, as TypeScript does\n * not allow `asserts` functions to be used with qualified access (e.g.\n * `Platform.TypeScriptUtilities.assertNotNullOrUndefined` causes a compile\n * error).\n */\nexport {assertNever, assertNotNullOrUndefined, assertUnhandled} from './TypescriptUtilities.js';\nexport {\n  ArrayUtilities,\n  Brand,\n  Constructor,\n  DateUtilities,\n  DevToolsPath,\n  DOMUtilities,\n  KeyboardUtilities,\n  MapUtilities,\n  MimeType,\n  NumberUtilities,\n  StringUtilities,\n  Timing,\n  TypedArrayUtilities,\n  TypeScriptUtilities,\n  UIString,\n  UserVisibleError,\n};\n", "// Copyright 2020 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nexport const isValid = (date: Date): boolean => {\n  return !isNaN(date.getTime());\n};\n\nexport const toISO8601Compact = (date: Date): string => {\n  function leadZero(x: number): string {\n    return (x > 9 ? '' : '0') + x;\n  }\n  return date.getFullYear() + leadZero(date.getMonth() + 1) + leadZero(date.getDate()) + 'T' +\n      leadZero(date.getHours()) + leadZero(date.getMinutes()) + leadZero(date.getSeconds());\n};\n", "// Copyright 2021 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type {Brand} from './Brand.js';\n\n/**\n * URLs are in DevTools are repsented as encoded URL strings.\n *\n * @example 'file:///Hello%20World/file/js'\n */\nexport type UrlString = Brand<string, 'UrlString'>;\nexport const EmptyUrlString = '' as UrlString;\n\n/**\n * Tagged template helper to construct `UrlString`s in a more readable form,\n * without having to sprinkle casts throughout the codebase. Primarily useful\n * for writing unit tests.\n *\n * Usage:\n * ```js\n * const url1 = urlString`https://www.example.com/404.html`;\n * const url2 = urlString`http://${host}/path/to/file.js`;\n * ```\n *\n * This is implemented as a wrapper around `String.raw` for convenience. This\n * function doesn't perform any kind of validation that the returned string is\n * really a valid `UrlString`.\n *\n * @param strings the string parts of the template.\n * @param values the dynamic values of the template.\n * @returns the string constructed from `strings` and `values` casted to an\n *         `UrlString`.\n */\nexport const urlString = (strings: ArrayLike<string>, ...values: any[]): UrlString =>\n    String.raw({raw: strings}, ...values) as UrlString;\n\n/**\n * File paths in DevTools that are represented as unencoded absolute\n * or relative paths.\n *\n * @example '/Hello World/file.js'\n */\nexport type RawPathString = Brand<string, 'RawPathString'>;\nexport const EmptyRawPathString = '' as RawPathString;\n\n/**\n * File paths in DevTools that are represented as encoded paths.\n *\n * @example '/Hello%20World/file.js'\n */\nexport type EncodedPathString = Brand<string, 'EncodedPathString'>;\nexport const EmptyEncodedPathString = '' as EncodedPathString;\n", "// Copyright 2022 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/**\n * `document.activeElement` will not enter shadow roots to find the element\n * that has focus; use this method if you need to traverse through any shadow\n * roots to find the actual, specific focused element.\n */\nexport function deepActiveElement(doc: Document): Element|null {\n  let activeElement: Element|null = doc.activeElement;\n  while (activeElement?.shadowRoot?.activeElement) {\n    activeElement = activeElement.shadowRoot.activeElement;\n  }\n  return activeElement;\n}\n\nexport function getEnclosingShadowRootForNode(node: Node): Node|null {\n  let parentNode = node.parentNodeOrShadowHost();\n  while (parentNode) {\n    if (parentNode instanceof ShadowRoot) {\n      return parentNode;\n    }\n    parentNode = parentNode.parentNodeOrShadowHost();\n  }\n  return null;\n}\n\nexport function rangeOfWord(\n    rootNode: Node, offset: number, stopCharacters: string, stayWithinNode: Node, direction?: string): Range {\n  let startNode;\n  let startOffset = 0;\n  let endNode;\n  let endOffset = 0;\n\n  if (!stayWithinNode) {\n    stayWithinNode = rootNode;\n  }\n\n  if (!direction || direction === 'backward' || direction === 'both') {\n    let node: Node|null = rootNode;\n    while (node) {\n      if (node === stayWithinNode) {\n        if (!startNode) {\n          startNode = stayWithinNode;\n        }\n        break;\n      }\n\n      if (node.nodeType === Node.TEXT_NODE && node.nodeValue !== null) {\n        const start = (node === rootNode ? (offset - 1) : (node.nodeValue.length - 1));\n        for (let i = start; i >= 0; --i) {\n          if (stopCharacters.indexOf(node.nodeValue[i]) !== -1) {\n            startNode = node;\n            startOffset = i + 1;\n            break;\n          }\n        }\n      }\n\n      if (startNode) {\n        break;\n      }\n\n      node = node.traversePreviousNode(stayWithinNode);\n    }\n\n    if (!startNode) {\n      startNode = stayWithinNode;\n      startOffset = 0;\n    }\n  } else {\n    startNode = rootNode;\n    startOffset = offset;\n  }\n\n  if (!direction || direction === 'forward' || direction === 'both') {\n    let node: (Node|null)|Node = rootNode;\n    while (node) {\n      if (node === stayWithinNode) {\n        if (!endNode) {\n          endNode = stayWithinNode;\n        }\n        break;\n      }\n\n      if (node.nodeType === Node.TEXT_NODE && node.nodeValue !== null) {\n        const start = (node === rootNode ? offset : 0);\n        for (let i = start; i < node.nodeValue.length; ++i) {\n          if (stopCharacters.indexOf(node.nodeValue[i]) !== -1) {\n            endNode = node;\n            endOffset = i;\n            break;\n          }\n        }\n      }\n\n      if (endNode) {\n        break;\n      }\n\n      node = node.traverseNextNode(stayWithinNode);\n    }\n\n    if (!endNode) {\n      endNode = stayWithinNode;\n      endOffset = stayWithinNode.nodeType === Node.TEXT_NODE ? stayWithinNode.nodeValue?.length || 0 :\n                                                               stayWithinNode.childNodes.length;\n    }\n  } else {\n    endNode = rootNode;\n    endOffset = offset;\n  }\n\n  if (!rootNode.ownerDocument) {\n    throw new Error('No `ownerDocument` found for rootNode');\n  }\n  const result = rootNode.ownerDocument.createRange();\n  result.setStart(startNode, startOffset);\n  result.setEnd(endNode, endOffset);\n\n  return result;\n}\n\n/**\n * Appends the list of `styles` as individual `<style>` elements to the\n * given `node`.\n *\n * @param node the `Node` to append the `<style>` elements to.\n * @param styles an optional list of styles to append to the `node`.\n */\nexport function appendStyle(node: Node, ...styles: CSSInJS[]): void {\n  for (const cssText of styles) {\n    const style = (node.ownerDocument ?? document).createElement('style');\n    style.textContent = cssText;\n    node.appendChild(style);\n  }\n}\n", "// Copyright 2020 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nexport const enum ArrowKey {\n  UP = 'ArrowUp',\n  DOWN = 'ArrowDown',\n  LEFT = 'ArrowLeft',\n  RIGHT = 'ArrowRight',\n}\n\nexport const enum PageKey {\n  UP = 'PageUp',\n  DOWN = 'PageDown',\n}\n\nexport const ENTER_KEY = 'Enter';\nexport const ESCAPE_KEY = 'Escape';\nexport const TAB_KEY = 'Tab';\n\nexport const ARROW_KEYS = new Set<ArrowKey>([\n  ArrowKey.UP,\n  ArrowKey.DOWN,\n  ArrowKey.LEFT,\n  ArrowKey.RIGHT,\n]);\n\nexport function keyIsArrowKey(key: string): key is ArrowKey {\n  return ARROW_KEYS.has(key as ArrowKey);\n}\n\nexport function isEscKey(event: KeyboardEvent): boolean {\n  return event.key === 'Escape';\n}\n\nexport function isEnterOrSpaceKey(event: KeyboardEvent): boolean {\n  return event.key === 'Enter' || event.key === ' ';\n}\n", "// Copyright 2020 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nexport const inverse = function<K, V>(map: Map<K, V>): Multimap<V, K> {\n  const result = new Multimap<V, K>();\n  for (const [key, value] of map.entries()) {\n    result.set(value, key);\n  }\n  return result;\n};\n\nexport class Multimap<K, V> {\n  private map = new Map<K, Set<V>>();\n\n  set(key: K, value: V): void {\n    let set = this.map.get(key);\n    if (!set) {\n      set = new Set();\n      this.map.set(key, set);\n    }\n    set.add(value);\n  }\n\n  get(key: K): Set<V> {\n    return this.map.get(key) || new Set();\n  }\n\n  has(key: K): boolean {\n    return this.map.has(key);\n  }\n\n  hasValue(key: K, value: V): boolean {\n    const set = this.map.get(key);\n    if (!set) {\n      return false;\n    }\n    return set.has(value);\n  }\n\n  get size(): number {\n    return this.map.size;\n  }\n\n  delete(key: K, value: V): boolean {\n    const values = this.get(key);\n    if (!values) {\n      return false;\n    }\n    const result = values.delete(value);\n    if (!values.size) {\n      this.map.delete(key);\n    }\n    return result;\n  }\n\n  deleteAll(key: K): void {\n    this.map.delete(key);\n  }\n\n  keysArray(): K[] {\n    return [...this.map.keys()];\n  }\n\n  keys(): IterableIterator<K> {\n    return this.map.keys();\n  }\n\n  valuesArray(): V[] {\n    const result = [];\n    for (const set of this.map.values()) {\n      result.push(...set.values());\n    }\n    return result;\n  }\n\n  clear(): void {\n    this.map.clear();\n  }\n}\n\n/**\n * Gets value for key, assigning a default if value is falsy.\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport function getWithDefault<K extends {}, V>(\n    map: WeakMap<K, V>|Map<K, V>, key: K, defaultValueFactory: (key?: K) => V): V {\n  let value = map.get(key);\n  if (value === undefined || value === null) {\n    value = defaultValueFactory(key);\n    map.set(key, value);\n  }\n\n  return value;\n}\n", "// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nexport const enum MimeType {\n  HTML = 'text/html',\n  XML = 'text/xml',\n  PLAIN = 'text/plain',\n  XHTML = 'application/xhtml+xml',\n  SVG = 'image/svg+xml',\n  CSS = 'text/css',\n  XSL = 'text/xsl',\n  VTT = 'text/vtt',\n  PDF = 'application/pdf',\n  EVENTSTREAM = 'text/event-stream',\n}\n\n/**\n * MIME types other than the ones with the \"text\" type that have text content.\n */\nconst ADDITIONAL_TEXT_MIME_TYPES = new Set([\n  'application/ecmascript',\n  'application/javascript',\n  'application/json',\n  'application/json+protobuf',\n  'application/mpegurl',\n  'application/vnd.apple.mpegurl',\n  'application/vnd.dart',\n  'application/xml',\n  'application/x-aspx',\n  'application/x-javascript',\n  'application/x-jsp',\n  'application/x-httpd-php',\n  'application/x-mpegurl',\n  'audio/mpegurl',\n  'audio/x-mpegurl',\n]);\n\n/**\n * @returns true iff `mimeType` has textual content. Concretely we return true if:\n *   - `mimeType` starts with \"text/\" or \"multipart/\"\n *   - `mimeType` ends with \"+xml\"\n *   - `mimeType` contains \"json\"\n *   - if `mimeType` is one of a predefined list textual mime types.\n */\nexport function isTextType(mimeType: string): boolean {\n  return mimeType.startsWith('text/') || mimeType.startsWith('multipart/') || mimeType.includes('json') ||\n      mimeType.endsWith('+xml') || ADDITIONAL_TEXT_MIME_TYPES.has(mimeType);\n}\n\n/**\n * Port of net::HttpUtils::ParseContentType to extract mimeType and charset from\n * the 'Content-Type' header.\n */\nexport function parseContentType(contentType: string): {mimeType: string|null, charset: string|null} {\n  if (contentType === '*/*') {\n    return {mimeType: null, charset: null};\n  }\n\n  const {mimeType, params} = parseMimeType(contentType);\n  const charset = params.get('charset')?.toLowerCase().trim() ?? null;\n  return {mimeType, charset};\n}\n\nfunction parseMimeType(contentType: string): {mimeType: string|null, params: Map<string, string>} {\n  // Remove any leading and trailing whitespace. Note that String.prototype.trim removes a lot more\n  // than what the spec considers whitespace. We are fine with that.\n  contentType = contentType.trim();\n\n  // The mimetype is basically everything until the first ';' (but trimmed).\n  let mimeTypeEnd = findFirstIndexOf(contentType, ' \\t;(');\n  if (mimeTypeEnd < 0) {\n    mimeTypeEnd = contentType.length;\n  }\n\n  const slashPos = contentType.indexOf('/');\n  if (slashPos < 0 || slashPos > mimeTypeEnd) {\n    return {mimeType: null, params: new Map()};\n  }\n  const mimeType = contentType.substring(0, mimeTypeEnd).toLowerCase();\n\n  // Iterate over parameters. We can't split the string around semicolons because quoted\n  // strings may include semicolons.\n  const params = new Map<string, string>();\n  let offset = contentType.indexOf(';', mimeTypeEnd);\n  while (offset >= 0 && offset < contentType.length) {\n    // Trim off the semicolon.\n    ++offset;\n\n    // Trim off whitespace\n    offset = findFirstIndexNotOf(contentType, ' \\t', offset);\n    if (offset < 0) {\n      continue;\n    }\n    const paramNameStart = offset;\n\n    // Extend parameter name until we run into semicolon or equals sign.\n    offset = findFirstIndexOf(contentType, ';=', offset);\n    if (offset < 0 || contentType[offset] === ';') {\n      // Nothing more to do if no more input or there is no parameter value.\n      continue;\n    }\n\n    const paramName = contentType.substring(paramNameStart, offset).toLowerCase();\n\n    //  Trim off the '='.\n    ++offset;\n\n    // Trim off whitespace.\n    offset = findFirstIndexNotOf(contentType, ' \\t', offset);\n\n    let paramValue = '';\n    if (offset < 0 || contentType[offset] === ';') {\n      // Nothing to do here: the value is an unquoted string of only whitespace.\n      continue;\n    } else if (contentType[offset] !== '\"') {\n      // Not a quote so we can copy the value as-is.\n      const valueStart = offset;\n      offset = contentType.indexOf(';', offset);\n      const valueEnd = offset >= 0 ? offset : contentType.length;\n\n      paramValue = contentType.substring(valueStart, valueEnd).trimEnd();\n    } else {\n      // Otherwise append data with special handling for backslashes, until a close quote.\n      // Don't trim whitespace for quoted strings.\n\n      // Trim off the opening quote '\"'\n      ++offset;\n\n      while (offset < contentType.length && contentType[offset] !== '\"') {\n        // Skip over backslash and append the next character, when not at the end\n        // of the string. Otherwise, copy the next character (which may be a backslash).\n        if (contentType[offset] === '\\\\' && offset + 1 < contentType.length) {\n          ++offset;\n        }\n        paramValue += contentType[offset];\n        ++offset;\n      }\n\n      offset = contentType.indexOf(';', offset);\n    }\n    if (!params.has(paramName)) {\n      // The first one wins!\n      params.set(paramName, paramValue);\n    }\n  }\n\n  return {mimeType, params};\n}\n\n/**\n * @returns the smallest index of any character in 'characters' or -1 if none of\n * the characters occur in 'searchString'\n */\nfunction findFirstIndexOf(searchString: string, characters: string, pos = 0): number {\n  for (let i = pos; i < searchString.length; i++) {\n    if (characters.includes(searchString[i])) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n/**\n * @returns the smallest index of any character not in 'characters' or -1 if only\n * 'characters' occur in 'searchString'\n */\nfunction findFirstIndexNotOf(searchString: string, characters: string, pos = 0): number {\n  for (let i = pos; i < searchString.length; i++) {\n    if (!characters.includes(searchString[i])) {\n      return i;\n    }\n  }\n  return -1;\n}\n", "// Copyright 2020 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nexport const clamp = (num: number, min: number, max: number): number => {\n  let clampedNumber = num;\n  if (num < min) {\n    clampedNumber = min;\n  } else if (num > max) {\n    clampedNumber = max;\n  }\n  return clampedNumber;\n};\n\nexport const mod = (m: number, n: number): number => {\n  return ((m % n) + n) % n;\n};\n\nexport const toFixedIfFloating = (value: string): string => {\n  if (!value || Number.isNaN(Number(value))) {\n    return value;\n  }\n  const number = Number(value);\n  return number % 1 ? number.toFixed(3) : String(number);\n};\n\n/**\n * Rounds a number (including float) down.\n */\nexport const floor = (value: number, precision = 0): number => {\n  // Allows for rounding to the nearest whole number.\n  // Ex: 1 / 10 -> round down to nearest 10th place\n  // Ex: 1 / 5 -> round down to nearest 5\n  // Ex: 1 / 50 -> round down to nearest 50\n  if (precision > 0 && precision < 1) {\n    precision = 1 / precision;\n    return Math.floor(value / precision) * precision;\n  }\n\n  const mult = Math.pow(10, precision);\n  return Math.floor(value * mult) / mult;\n};\n\n/**\n * Computes the great common divisor for two numbers.\n * If the numbers are floats, they will be rounded to an integer.\n */\nexport const greatestCommonDivisor = (a: number, b: number): number => {\n  a = Math.round(a);\n  b = Math.round(b);\n  while (b !== 0) {\n    const t = b;\n    b = a % b;\n    a = t;\n  }\n  return a;\n};\n\nconst commonRatios = new Map([\n  ['8\u22365', '16\u223610'],\n]);\n\nexport const aspectRatio = (width: number, height: number): string => {\n  const divisor = greatestCommonDivisor(width, height);\n  if (divisor !== 0) {\n    width /= divisor;\n    height /= divisor;\n  }\n  const result = `${width}\u2236${height}`;\n  return commonRatios.get(result) || result;\n};\n\nexport const withThousandsSeparator = function(num: number): string {\n  let str = String(num);\n  const re = /(\\d+)(\\d{3})/;\n  while (str.match(re)) {\n    str = str.replace(re, '$1\\xA0$2');\n  }  // \\xa0 is a non-breaking space\n  return str;\n};\n", "// Copyright 2020 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type {Brand} from './Brand.js';\n\nexport const escapeCharacters = (inputString: string, charsToEscape: string): string => {\n  let foundChar = false;\n  for (let i = 0; i < charsToEscape.length; ++i) {\n    if (inputString.indexOf(charsToEscape.charAt(i)) !== -1) {\n      foundChar = true;\n      break;\n    }\n  }\n\n  if (!foundChar) {\n    return String(inputString);\n  }\n\n  let result = '';\n  for (let i = 0; i < inputString.length; ++i) {\n    if (charsToEscape.indexOf(inputString.charAt(i)) !== -1) {\n      result += '\\\\';\n    }\n    result += inputString.charAt(i);\n  }\n\n  return result;\n};\n\nconst toHexadecimal = (charCode: number, padToLength: number): string => {\n  return charCode.toString(16).toUpperCase().padStart(padToLength, '0');\n};\n\n// Remember to update the third group in the regexps patternsToEscape and\n// patternsToEscapePlusSingleQuote when adding new entries in this map.\nconst escapedReplacements = new Map([\n  ['\\b', '\\\\b'],\n  ['\\f', '\\\\f'],\n  ['\\n', '\\\\n'],\n  ['\\r', '\\\\r'],\n  ['\\t', '\\\\t'],\n  ['\\v', '\\\\v'],\n  ['\\'', '\\\\\\''],\n  ['\\\\', '\\\\\\\\'],\n  ['<!--', '\\\\x3C!--'],\n  ['<script', '\\\\x3Cscript'],\n  ['</script', '\\\\x3C/script'],\n]);\n\nexport const formatAsJSLiteral = (content: string): string => {\n  const patternsToEscape = /(\\\\|<(?:!--|\\/?script))|(\\p{Control})|(\\p{Surrogate})/gu;\n  const patternsToEscapePlusSingleQuote = /(\\\\|'|<(?:!--|\\/?script))|(\\p{Control})|(\\p{Surrogate})/gu;\n  const escapePattern = (match: string, pattern: string, controlChar: string, loneSurrogate: string): string => {\n    if (controlChar) {\n      if (escapedReplacements.has(controlChar)) {\n        // @ts-expect-error https://github.com/microsoft/TypeScript/issues/13086\n        return escapedReplacements.get(controlChar);\n      }\n      const twoDigitHex = toHexadecimal(controlChar.charCodeAt(0), 2);\n      return '\\\\x' + twoDigitHex;\n    }\n    if (loneSurrogate) {\n      const fourDigitHex = toHexadecimal(loneSurrogate.charCodeAt(0), 4);\n      return '\\\\u' + fourDigitHex;\n    }\n    if (pattern) {\n      return escapedReplacements.get(pattern) || '';\n    }\n    return match;\n  };\n\n  let escapedContent = '';\n  let quote = '';\n  if (!content.includes('\\'')) {\n    quote = '\\'';\n    escapedContent = content.replaceAll(patternsToEscape, escapePattern);\n  } else if (!content.includes('\"')) {\n    quote = '\"';\n    escapedContent = content.replaceAll(patternsToEscape, escapePattern);\n  } else if (!content.includes('`') && !content.includes('${')) {\n    quote = '`';\n    escapedContent = content.replaceAll(patternsToEscape, escapePattern);\n  } else {\n    quote = '\\'';\n    escapedContent = content.replaceAll(patternsToEscapePlusSingleQuote, escapePattern);\n  }\n  return `${quote}${escapedContent}${quote}`;\n};\n\n/**\n * This implements a subset of the sprintf() function described in the Single UNIX\n * Specification. It supports the %s, %f, %d, and %% formatting specifiers, and\n * understands the %m$d notation to select the m-th parameter for this substitution,\n * as well as the optional precision for %s, %f, and %d.\n *\n * @param fmt format string.\n * @param args parameters to the format string.\n * @returns the formatted output string.\n */\nexport const sprintf = (fmt: string, ...args: unknown[]): string => {\n  let argIndex = 0;\n  const RE = /%(?:(\\d+)\\$)?(?:\\.(\\d*))?([%dfs])/g;\n  return fmt.replaceAll(RE, (_: string, index?: string, precision?: string, specifier?: string) => {\n    if (specifier === '%') {\n      return '%';\n    }\n    if (index !== undefined) {\n      argIndex = parseInt(index, 10) - 1;\n      if (argIndex < 0) {\n        throw new RangeError(`Invalid parameter index ${argIndex + 1}`);\n      }\n    }\n    if (argIndex >= args.length) {\n      throw new RangeError(`Expected at least ${argIndex + 1} format parameters, but only ${args.length} where given.`);\n    }\n    if (specifier === 's') {\n      const argValue = String(args[argIndex++]);\n      if (precision !== undefined) {\n        return argValue.substring(0, Number(precision));\n      }\n      return argValue;\n    }\n    let argValue = Number(args[argIndex++]);\n    if (isNaN(argValue)) {\n      argValue = 0;\n    }\n    if (specifier === 'd') {\n      return String(Math.floor(argValue)).padStart(Number(precision), '0');\n    }\n    if (precision !== undefined) {\n      return argValue.toFixed(Number(precision));\n    }\n    return String(argValue);\n  });\n};\n\nexport const toBase64 = (inputString: string): string => {\n  /* note to the reader: we can't use btoa here because we need to\n   * support Unicode correctly. See the test cases for this function and\n   * also\n   * https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding#The_Unicode_Problem\n   */\n\n  function encodeBits(b: number): number {\n    return b < 26 ? b + 65 : b < 52 ? b + 71 : b < 62 ? b - 4 : b === 62 ? 43 : b === 63 ? 47 : 65;\n  }\n  const encoder = new TextEncoder();\n  const data = encoder.encode(inputString.toString());\n  const n = data.length;\n  let encoded = '';\n  if (n === 0) {\n    return encoded;\n  }\n  let shift;\n  let v = 0;\n  for (let i = 0; i < n; i++) {\n    shift = i % 3;\n    v |= data[i] << (16 >>> shift & 24);\n    if (shift === 2) {\n      encoded += String.fromCharCode(\n          encodeBits(v >>> 18 & 63), encodeBits(v >>> 12 & 63), encodeBits(v >>> 6 & 63), encodeBits(v & 63));\n      v = 0;\n    }\n  }\n  if (shift === 0) {\n    encoded += String.fromCharCode(encodeBits(v >>> 18 & 63), encodeBits(v >>> 12 & 63), 61, 61);\n  } else if (shift === 1) {\n    encoded += String.fromCharCode(encodeBits(v >>> 18 & 63), encodeBits(v >>> 12 & 63), encodeBits(v >>> 6 & 63), 61);\n  }\n  return encoded;\n};\n\nexport const findIndexesOfSubString = (inputString: string, searchString: string): number[] => {\n  const matches = [];\n  let i = inputString.indexOf(searchString);\n  while (i !== -1) {\n    matches.push(i);\n    i = inputString.indexOf(searchString, i + searchString.length);\n  }\n  return matches;\n};\n\nexport const findLineEndingIndexes = (inputString: string): number[] => {\n  const endings = findIndexesOfSubString(inputString, '\\n');\n  endings.push(inputString.length);\n  return endings;\n};\n\nexport const isWhitespace = (inputString: string): boolean => {\n  return /^\\s*$/.test(inputString);\n};\n\nexport const trimURL = (url: string, baseURLDomain?: string): string => {\n  let result = url.replace(/^(https|http|file):\\/\\//i, '');\n  if (baseURLDomain) {\n    if (result.toLowerCase().startsWith(baseURLDomain.toLowerCase())) {\n      result = result.substr(baseURLDomain.length);\n    }\n  }\n  return result;\n};\n\nexport const collapseWhitespace = (inputString: string): string => {\n  return inputString.replace(/[\\s\\xA0]+/g, ' ');\n};\n\nexport const reverse = (inputString: string): string => {\n  return inputString.split('').reverse().join('');\n};\n\nexport const replaceControlCharacters = (inputString: string): string => {\n  // Replace C0 and C1 control character sets with replacement character.\n  // Do not replace '\\t', \\n' and '\\r'.\n  return inputString.replace(/[\\0-\\x08\\x0B\\f\\x0E-\\x1F\\x80-\\x9F]/g, '\\uFFFD');\n};\n\nexport const countWtf8Bytes = (inputString: string): number => {\n  let count = 0;\n  for (let i = 0; i < inputString.length; i++) {\n    const c = inputString.charCodeAt(i);\n    if (c <= 0x7F) {\n      count++;\n    } else if (c <= 0x07FF) {\n      count += 2;\n    } else if (c < 0xD800 || 0xDFFF < c) {\n      count += 3;\n    } else {\n      if (c <= 0xDBFF && i + 1 < inputString.length) {\n        // The current character is a leading surrogate, and there is a\n        // next character.\n        const next = inputString.charCodeAt(i + 1);\n        if (0xDC00 <= next && next <= 0xDFFF) {\n          // The next character is a trailing surrogate, meaning this\n          // is a surrogate pair.\n          count += 4;\n          i++;\n          continue;\n        }\n      }\n      count += 3;\n    }\n  }\n  return count;\n};\n\nexport const stripLineBreaks = (inputStr: string): string => {\n  return inputStr.replace(/(\\r)?\\n/g, '');\n};\n\nconst EXTENDED_KEBAB_CASE_REGEXP = /^([a-z0-9]+(?:-[a-z0-9]+)*\\.)*[a-z0-9]+(?:-[a-z0-9]+)*$/;\n\n/**\n * Tests if the `inputStr` is following the extended Kebab Case naming convention,\n * where words are separated with either a dash (`-`) or a dot (`.`), and all\n * characters must be lower-case alphanumeric.\n *\n * For example, it will yield `true` for `'my.amazing-string.literal'`, but `false`\n * for `'Another.AmazingLiteral'` or '`another_amazing_literal'`.\n *\n * @param inputStr the input string to test.\n * @returns `true` if the `inputStr` follows the extended Kebab Case convention.\n */\nexport const isExtendedKebabCase = (inputStr: string): boolean => {\n  return EXTENDED_KEBAB_CASE_REGEXP.test(inputStr);\n};\n\nexport const toTitleCase = (inputStr: string): string => {\n  return inputStr.substring(0, 1).toUpperCase() + inputStr.substring(1);\n};\n\nexport const removeURLFragment = (inputStr: string): string => {\n  const url = new URL(inputStr);\n  url.hash = '';\n  return url.toString();\n};\n\nconst SPECIAL_REGEX_CHARACTERS = '^[]{}()\\\\.^$*+?|-,';\n\nexport const regexSpecialCharacters = function(): string {\n  return SPECIAL_REGEX_CHARACTERS;\n};\n\nexport const filterRegex = function(query: string): RegExp {\n  let regexString = '^(?:.*\\\\0)?';  // Start from beginning or after a \\0\n  for (let i = 0; i < query.length; ++i) {\n    let c = query.charAt(i);\n    if (SPECIAL_REGEX_CHARACTERS.indexOf(c) !== -1) {\n      c = '\\\\' + c;\n    }\n    regexString += '[^\\\\0' + c + ']*' + c;\n  }\n  return new RegExp(regexString, 'i');\n};\n\nexport const createSearchRegex = function(\n    query: string, caseSensitive: boolean, isRegex: boolean, matchWholeWord = false): RegExp {\n  const regexFlags = caseSensitive ? 'g' : 'gi';\n  let regexObject;\n\n  if (isRegex) {\n    try {\n      regexObject = new RegExp(query, regexFlags);\n    } catch {\n      // Silent catch.\n    }\n  }\n\n  if (!regexObject) {\n    regexObject = createPlainTextSearchRegex(query, regexFlags);\n  }\n\n  if (matchWholeWord && regexObject) {\n    regexObject = new RegExp(`\\\\b${regexObject.source}\\\\b`, regexFlags);\n  }\n\n  return regexObject;\n};\n\nexport const caseInsensetiveComparator = function(a: string, b: string): number {\n  a = a.toUpperCase();\n  b = b.toUpperCase();\n  if (a === b) {\n    return 0;\n  }\n  return a > b ? 1 : -1;\n};\n\nexport const hashCode = function(string?: string): number {\n  if (!string) {\n    return 0;\n  }\n  // Hash algorithm for substrings is described in \"\u00DCber die Komplexit\u00E4t der Multiplikation in\n  // eingeschr\u00E4nkten Branchingprogrammmodellen\" by Woelfe.\n  // http://opendatastructures.org/versions/edition-0.1d/ods-java/node33.html#SECTION00832000000000000000\n  const p = ((1 << 30) * 4 - 5);  // prime: 2^32 - 5\n  const z = 0x5033d967;           // 32 bits from random.org\n  const z2 = 0x59d2f15d;          // random odd 32 bit number\n  let s = 0;\n  let zi = 1;\n  for (let i = 0; i < string.length; i++) {\n    const xi = string.charCodeAt(i) * z2;\n    s = (s + zi * xi) % p;\n    zi = (zi * z) % p;\n  }\n  s = (s + zi * (p - 1)) % p;\n  return Math.abs(s | 0);\n};\n\nexport const compare = (a: string, b: string): number => {\n  if (a > b) {\n    return 1;\n  }\n  if (a < b) {\n    return -1;\n  }\n  return 0;\n};\n\nexport const trimMiddle = (str: string, maxLength: number): string => {\n  if (str.length <= maxLength) {\n    return String(str);\n  }\n  let leftHalf = maxLength >> 1;\n  let rightHalf = maxLength - leftHalf - 1;\n  if ((str.codePointAt(str.length - rightHalf - 1) as number) >= 0x10000) {\n    --rightHalf;\n    ++leftHalf;\n  }\n  if (leftHalf > 0 && (str.codePointAt(leftHalf - 1) as number) >= 0x10000) {\n    --leftHalf;\n  }\n  return str.substr(0, leftHalf) + '\u2026' + str.substr(str.length - rightHalf, rightHalf);\n};\n\nexport const trimEndWithMaxLength = (str: string, maxLength: number): string => {\n  if (str.length <= maxLength) {\n    return String(str);\n  }\n  return str.substr(0, maxLength - 1) + '\u2026';\n};\n\nexport const escapeForRegExp = (str: string): string => {\n  return escapeCharacters(str, SPECIAL_REGEX_CHARACTERS);\n};\n\nexport const naturalOrderComparator = (a: string, b: string): number => {\n  const chunk = /^\\d+|^\\D+/;\n  let chunkA, chunkB, numA, numB;\n  while (true) {\n    if (a) {\n      if (!b) {\n        return 1;\n      }\n    } else {\n      if (b) {\n        return -1;\n      }\n      return 0;\n    }\n    chunkA = (a.match(chunk) as string[])[0];\n    chunkB = (b.match(chunk) as string[])[0];\n    numA = !Number.isNaN(Number(chunkA));\n    numB = !Number.isNaN(Number(chunkB));\n    if (numA && !numB) {\n      return -1;\n    }\n    if (numB && !numA) {\n      return 1;\n    }\n    if (numA && numB) {\n      const diff = Number(chunkA) - Number(chunkB);\n      if (diff) {\n        return diff;\n      }\n      if (chunkA.length !== chunkB.length) {\n        if (!Number(chunkA) && !Number(chunkB)) {  // chunks are strings of all 0s (special case)\n          return chunkA.length - chunkB.length;\n        }\n        return chunkB.length - chunkA.length;\n      }\n    } else if (chunkA !== chunkB) {\n      return (chunkA < chunkB) ? -1 : 1;\n    }\n    a = a.substring(chunkA.length);\n    b = b.substring(chunkB.length);\n  }\n};\n\nexport const base64ToSize = function(content: string|null): number {\n  if (!content) {\n    return 0;\n  }\n  let size = content.length * 3 / 4;\n  if (content[content.length - 1] === '=') {\n    size--;\n  }\n  if (content.length > 1 && content[content.length - 2] === '=') {\n    size--;\n  }\n  return size;\n};\n\nexport const SINGLE_QUOTE = '\\'';\nexport const DOUBLE_QUOTE = '\"';\nconst BACKSLASH = '\\\\';\n\nexport const findUnclosedCssQuote = function(str: string): string {\n  let unmatchedQuote = '';\n  for (let i = 0; i < str.length; ++i) {\n    const char = str[i];\n    if (char === BACKSLASH) {\n      i++;\n      continue;\n    }\n    if (char === SINGLE_QUOTE || char === DOUBLE_QUOTE) {\n      if (unmatchedQuote === char) {\n        unmatchedQuote = '';\n      } else if (unmatchedQuote === '') {\n        unmatchedQuote = char;\n      }\n    }\n  }\n  return unmatchedQuote;\n};\n\nexport const countUnmatchedLeftParentheses = (str: string): number => {\n  const stringLiteralRegex = /'(?:\\\\.|[^'\\\\])*'|\"(?:\\\\.|[^\"\\\\])*\"/g;\n  // Remove all matched string literals from the original string.\n  const strWithoutStrings = str.replace(stringLiteralRegex, '');\n\n  let unmatchedCount = 0;\n  for (const c of strWithoutStrings) {\n    if (c === '(') {\n      unmatchedCount++;\n    } else if (c === ')' && unmatchedCount > 0) {\n      unmatchedCount--;\n    }\n  }\n  return unmatchedCount;\n};\n\nexport const createPlainTextSearchRegex = function(query: string, flags?: string): RegExp {\n  // This should be kept the same as the one in StringUtil.cpp.\n  let regex = '';\n  for (let i = 0; i < query.length; ++i) {\n    const c = query.charAt(i);\n    if (regexSpecialCharacters().indexOf(c) !== -1) {\n      regex += '\\\\';\n    }\n    regex += c;\n  }\n  return new RegExp(regex, flags || '');\n};\n\nexport type LowerCaseString = Brand<string, 'lowerCaseStringTag'>;\n\nexport const toLowerCaseString = function(input: string): LowerCaseString {\n  return input.toLowerCase() as LowerCaseString;\n};\n\n/**\n * 1: two or more consecutive uppercase letters. This is useful for identifying acronyms\n * 2: lookahead assertion that matches a word boundary\n * 3: numeronym: single letter followed by number and another letter\n * 4: word starting with an optional uppercase letter\n * 5: single digit followed by word to handle '3D' or '2px' (this might be controverial)\n * 6: single uppercase letter or number\n * 7: a dot character. We extract it into a separate word and remove dashes around it later.\n * This is makes more sense conceptually and allows accounting for all possible word variants.\n * Making dot a part of a word prevent us from handling acronyms or numeronyms after the word\n * correctly without making the RegExp prohibitively complicated.\n * https://regex101.com/r/FhMVKc/1\n *            <---1---><------------2-----------> <---------3--------> <-----4----> <------5-----> <-----6----> <7>\n */\nconst WORD = /[A-Z]{2,}(?=[A-Z0-9][a-z0-9]+|\\b|_)|[A-Za-z][0-9]+[a-z]?|[A-Z]?[a-z]+|[0-9][A-Za-z]+|[A-Z]|[0-9]+|[.]/g;\n\nexport const toKebabCase = function(input: string): Lowercase<string> {\n  return (input.match?.(WORD)?.map(w => w.toLowerCase()).join('-').replaceAll('-.-', '.') || input) as\n      Lowercase<string>;\n};\n\nexport function toKebabCaseKeys<T>(settingValue: Record<string, T>): Record<string, T> {\n  return Object.fromEntries(Object.entries(settingValue).map(([key, value]) => [toKebabCase(key), value]));\n}\n\n/**\n * Converts a given string to snake_case.\n * This function handles camelCase, PascalCase, and acronyms, including transitions between letters and numbers.\n * It uses Unicode-aware regular expressions (`\\p{L}`, `\\p{N}`, `\\p{Lu}`, `\\p{Ll}` with the `u` flag)\n * to correctly process letters and numbers from various languages.\n *\n * @param text The input string to convert to snake_case.\n * @returns The snake_case version of the input string.\n */\nexport function toSnakeCase(text: string): string {\n  if (!text) {\n    return '';\n  }\n  // First, handle case-based transformations to insert underscores correctly.\n  // 1. Add underscore between a letter and a number.\n  //    e.g., \"version2\" -> \"version_2\"\n  // 2. Add underscore between an uppercase letter sequence and a following uppercase+lowercase sequence.\n  //    e.g., \"APIFlags\" -> \"API_Flags\"\n  // 3. Add underscore between a lowercase/number and an uppercase letter.\n  //    e.g., \"lastName\" -> \"last_Name\", \"version_2Update\" -> \"version_2_Update\"\n  // 4. Replace sequences of non-alphanumeric with a single underscore\n  // 5. Remove any leading or trailing underscores.\n  const result = text.replace(/(\\p{L})(\\p{N})/gu, '$1_$2')           // 1\n                     .replace(/(\\p{Lu}+)(\\p{Lu}\\p{Ll})/gu, '$1_$2')  // 2\n                     .replace(/(\\p{Ll}|\\p{N})(\\p{Lu})/gu, '$1_$2')   // 3\n                     .toLowerCase()\n                     .replace(/[^\\p{L}\\p{N}]+/gu, '_')  // 4\n                     .replace(/^_|_$/g, '');            // 5\n\n  return result;\n}\n\n/** Replaces the last occurrence of parameter `search` with parameter `replacement` in `input` **/\nexport const replaceLast = function(input: string, search: string, replacement: string): string {\n  const replacementStartIndex = input.lastIndexOf(search);\n  if (replacementStartIndex === -1) {\n    return input;\n  }\n\n  return input.slice(0, replacementStartIndex) + input.slice(replacementStartIndex).replace(search, replacement);\n};\n\nexport const stringifyWithPrecision = function stringifyWithPrecision(s: number, precision = 2): string {\n  if (precision === 0) {\n    return s.toFixed(0);\n  }\n  const string = s.toFixed(precision).replace(/\\.?0*$/, '');\n  return string === '-0' ? '0' : string;\n};\n\n/**\n * Somewhat efficiently concatenates 2 base64 encoded strings.\n */\nexport const concatBase64 = function(lhs: string, rhs: string): string {\n  if (lhs.length === 0 || !lhs.endsWith('=')) {\n    // Empty string or no padding, we can straight-up concatenate.\n    return lhs + rhs;\n  }\n  const lhsLeaveAsIs = lhs.substring(0, lhs.length - 4);\n  const lhsToDecode = lhs.substring(lhs.length - 4);\n  return lhsLeaveAsIs + window.btoa(window.atob(lhsToDecode) + window.atob(rhs));\n};\n", "// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type {Brand} from './Brand.js';\n\nexport type Seconds = Brand<number, 'Seconds'>;\nexport type MilliSeconds = Brand<number, 'MilliSeconds'>;\nexport type MicroSeconds = Brand<number, 'MicroSeconds'>;\n\nexport function milliSecondsToSeconds(x: MilliSeconds): Seconds {\n  return (x / 1000) as Seconds;\n}\n\nexport function microSecondsToMilliSeconds(x: MicroSeconds): MilliSeconds {\n  return (x / 1000) as MilliSeconds;\n}\n", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/**\n * An object which provides functionality similar to Uint32Array. It may be\n * implemented as:\n * 1. A Uint32Array,\n * 2. An array of Uint32Arrays, to support more data than Uint32Array, or\n * 3. A plain array, in which case the length may change by setting values.\n */\nexport interface BigUint32Array {\n  get length(): number;\n  getValue(index: number): number;\n  setValue(index: number, value: number): void;\n  asUint32ArrayOrFail(): Uint32Array;\n  asArrayOrFail(): number[];\n}\n\n/**\n * @returns A BigUint32Array implementation which is based on Array.\n * This means that its length automatically expands to include the highest index\n * used, and asArrayOrFail will succeed.\n */\nexport function createExpandableBigUint32Array(): BigUint32Array {\n  return new ExpandableBigUint32ArrayImpl();\n}\n\n/**\n * @returns A BigUint32Array implementation which is based on Uint32Array.\n * If the length is small enough to fit in a single Uint32Array, then\n * asUint32ArrayOrFail will succeed. Otherwise, it will throw an exception.\n */\nexport function createFixedBigUint32Array(length: number, maxLengthForTesting?: number): BigUint32Array {\n  try {\n    if (maxLengthForTesting !== undefined && length > maxLengthForTesting) {\n      // Simulate allocation failure.\n      throw new RangeError();\n    }\n    return new BasicBigUint32ArrayImpl(length);\n  } catch {\n    // We couldn't allocate a big enough ArrayBuffer.\n    return new SplitBigUint32ArrayImpl(length, maxLengthForTesting);\n  }\n}\n\nclass BasicBigUint32ArrayImpl extends Uint32Array implements BigUint32Array {\n  getValue(index: number): number {\n    return this[index];\n  }\n  setValue(index: number, value: number): void {\n    this[index] = value;\n  }\n  asUint32ArrayOrFail(): Uint32Array {\n    return this;\n  }\n  asArrayOrFail(): number[] {\n    throw new Error('Not an array');\n  }\n}\n\nclass SplitBigUint32ArrayImpl implements BigUint32Array {\n  #data: Uint32Array[];\n  #partLength: number;\n  length: number;\n\n  constructor(length: number, maxLengthForTesting?: number) {\n    this.#data = [];\n    this.length = length;\n    let partCount = 1;\n    while (true) {\n      partCount *= 2;\n      this.#partLength = Math.ceil(length / partCount);\n      try {\n        if (maxLengthForTesting !== undefined && this.#partLength > maxLengthForTesting) {\n          // Simulate allocation failure.\n          throw new RangeError();\n        }\n        for (let i = 0; i < partCount; ++i) {\n          this.#data[i] = new Uint32Array(this.#partLength);\n        }\n        return;\n      } catch (e) {\n        if (this.#partLength < 1e6) {\n          // The length per part is already small, so continuing to subdivide it\n          // will probably not help.\n          throw e;\n        }\n      }\n    }\n  }\n\n  getValue(index: number): number {\n    if (index >= 0 && index < this.length) {\n      const partLength = this.#partLength;\n      return this.#data[Math.floor(index / partLength)][index % partLength];\n    }\n    // On out-of-bounds accesses, match the behavior of Uint32Array: return an\n    // undefined value that's incorrectly typed as number.\n    return this.#data[0][-1];\n  }\n\n  setValue(index: number, value: number): void {\n    if (index >= 0 && index < this.length) {\n      const partLength = this.#partLength;\n      this.#data[Math.floor(index / partLength)][index % partLength] = value;\n    }\n    // Attempting to set a value out of bounds does nothing, like Uint32Array.\n  }\n\n  asUint32ArrayOrFail(): Uint32Array {\n    throw new Error('Not a Uint32Array');\n  }\n  asArrayOrFail(): number[] {\n    throw new Error('Not an array');\n  }\n}\n\nclass ExpandableBigUint32ArrayImpl extends Array<number> implements BigUint32Array {\n  getValue(index: number): number {\n    return this[index];\n  }\n  setValue(index: number, value: number): void {\n    this[index] = value;\n  }\n  asUint32ArrayOrFail(): Uint32Array {\n    throw new Error('Not a Uint32Array');\n  }\n  asArrayOrFail(): number[] {\n    return this;\n  }\n}\n\nexport interface BitVector {\n  getBit(index: number): boolean;\n  setBit(index: number): void;\n  clearBit(index: number): void;\n  // Returns the last bit before `index` which is set, or -1 if there are none.\n  previous(index: number): number;\n  get buffer(): ArrayBuffer;\n}\n\nexport function createBitVector(lengthOrBuffer: number|ArrayBuffer): BitVector {\n  return new BitVectorImpl(lengthOrBuffer);\n}\n\nclass BitVectorImpl extends Uint8Array {\n  constructor(lengthOrBuffer: number|ArrayBuffer) {\n    if (typeof lengthOrBuffer === 'number') {\n      super(Math.ceil(lengthOrBuffer / 8));\n    } else {\n      super(lengthOrBuffer);\n    }\n  }\n  getBit(index: number): boolean {\n    const value = this[index >> 3] & (1 << (index & 7));\n    return value !== 0;\n  }\n  setBit(index: number): void {\n    this[index >> 3] |= (1 << (index & 7));\n  }\n  clearBit(index: number): void {\n    this[index >> 3] &= ~(1 << (index & 7));\n  }\n  previous(index: number): number {\n    // First, check for more bits in the current byte.\n    while (index !== ((index >> 3) << 3)) {\n      --index;\n      if (this.getBit(index)) {\n        return index;\n      }\n    }\n    // Next, iterate by bytes to skip over ranges of zeros.\n    let byteIndex: number = (index >> 3) - 1;\n    while (byteIndex >= 0 && this[byteIndex] === 0) {\n      --byteIndex;\n    }\n    if (byteIndex < 0) {\n      return -1;\n    }\n    // Finally, iterate the nonzero byte to find the highest bit.\n    for (index = (byteIndex << 3) + 7; index >= (byteIndex << 3); --index) {\n      if (this.getBit(index)) {\n        return index;\n      }\n    }\n    throw new Error('Unreachable');\n  }\n}\n", "// Copyright 2020 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/**\n * This is useful to keep TypeScript happy in a test - if you have a value\n * that's potentially `null` you can use this function to assert that it isn't,\n * and satisfy TypeScript that the value is present.\n */\nexport function assertNotNullOrUndefined<T>(val: T, message?: string): asserts val is NonNullable<T> {\n  if (val === null || val === undefined) {\n    throw new Error(`Expected given value to not be null/undefined but it was: ${val}${message ? `\\n${message}` : ''}`);\n  }\n}\n\nexport function assertNever(_type: never, message: string): never {\n  throw new Error(message);\n}\n\n/**\n * This is useful to check on the type-level that the unhandled cases of\n * a switch are exactly `T` (where T is usually a union type of enum values).\n * @param caseVariable\n */\nexport function assertUnhandled<T>(_caseVariable: T): T {\n  return _caseVariable;\n}\n\nexport type FieldsThatExtend<Type, Selector> = {\n  [Key in keyof Type]: Type[Key] extends Selector ? Key : never;\n}[keyof Type];\n\nexport type PickFieldsThatExtend<Type, Selector> = Pick<Type, FieldsThatExtend<Type, Selector>>;\n\n/**\n * Turns a Union type (a | b) into an Intersection type (a & b).\n * This is a helper type to implement the \"NoUnion\" guard.\n *\n * Adapted from https://stackoverflow.com/a/50375286.\n *\n * The tautological `T extends any` is necessary to trigger distributivity for\n * plain unions, e.g. in IntersectionFromUnion<'a'|'b'> TypeScript expands it\n * to  ('a' extends any ? (arg: 'a') => void : never)\n *  |  ('b' extends any ? (arg: 'b') => void : never)\n *\n * The second extends clause then asks TypeScript to find a type of the form\n * `(arg: infer U) => void` that upper-bounds the union, i.e., intuitively,\n * a type that converts to each of the union members. This forces U to be the\n * intersection of 'a' and 'b' in the example.\n *\n * Please note that some intersection types are simply impossible, e.g.\n * `string & number`. There is no type that fulfills both at the same time. A\n * union of this kind is reduced to `never`.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype IntersectionFromUnion<T> = (T extends any ? (arg: T) => void : never) extends((arg: infer U) => void) ? U : never;\n\n/**\n * When writing generic code it may be desired to disallow Union types from\n * being passed. This type can be used in those cases.\n *\n *   function foo<T>(argument: NoUnion<T>) {...}\n *\n * Would result in a compile error for foo<a|b>(...); invocations as `argument`\n * would be typed as `never`.\n *\n * Adapted from https://stackoverflow.com/a/50641073.\n *\n * Conditional types become distributive when receiving a union type. To\n * prevent this from happening, we use `[T] extends [IntersectionFromUnion<T>]`\n * instead of `T extends IntersectionFromUnion<T>`.\n * See: https://www.typescriptlang.org/docs/handbook/2/conditional-types.html\n */\nexport type NoUnion<T> = [T] extends [IntersectionFromUnion<T>] ? T : never;\n\nexport type RecursivePartial<T> = {\n  [P in keyof T]?: RecursivePartial<T[P]>;\n};\n\n/**\n * Note this does not recursively\n * make Array items readonly at the moment\n */\nexport type RecursiveReadonly<T> = {\n  [P in keyof T]: Readonly<RecursiveReadonly<T[P]>>;\n};\n", "// Copyright 2021 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/*\n * Copyright (C) 2011 Google Inc.  All rights reserved.\n * Copyright (C) 2006, 2007, 2008 Apple Inc.  All rights reserved.\n * Copyright (C) 2007 Matt Lilek (pewtermoose@gmail.com).\n * Copyright (C) 2009 Joseph Pecoraro\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1.  Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n * 2.  Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n * 3.  Neither the name of Apple Computer, Inc. (\"Apple\") nor the names of\n *     its contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport type {Brand} from './Brand.js';\n\nexport type LocalizedString = Brand<string, 'LocalizedString'>;\nexport const LocalizedEmptyString = '' as LocalizedString;\n", "// Copyright 2021 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type {LocalizedString} from './UIString.js';\n\n/**\n * Represents an error that might become visible to the user. Where errors\n * might be surfaced to the user (such as by displaying the message to the\n * console), this class should be used to enforce that the message is\n * localized on the way in.\n */\nexport class UserVisibleError extends Error {\n  override readonly message: LocalizedString;\n\n  constructor(message: LocalizedString) {\n    super(message);\n    this.message = message;\n  }\n}\n\nexport function isUserVisibleError(error: unknown): error is UserVisibleError {\n  if (typeof error === 'object' && error !== null) {\n    return error instanceof UserVisibleError;\n  }\n\n  return false;\n}\n"],
  "mappings": "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",
  "names": ["ArrowKey", "PageKey", "MimeType", "argValue", "stringifyWithPrecision"]
}
