{
  "version": 3,
  "sources": ["../../../../../../front_end/core/platform/ArrayUtilities.ts", "../../../../../../front_end/core/platform/Brand.ts", "../../../../../../front_end/core/platform/Constructor.ts", "../../../../../../front_end/core/platform/DateUtilities.ts", "../../../../../../front_end/core/platform/DevToolsPath.ts", "../../../../../../front_end/core/platform/HostRuntime.ts", "../../../../../../front_end/core/platform/KeyboardUtilities.ts", "../../../../../../front_end/core/platform/MapUtilities.ts", "../../../../../../front_end/core/platform/MimeType.ts", "../../../../../../front_end/core/platform/NumberUtilities.ts", "../../../../../../front_end/core/platform/StringUtilities.ts", "../../../../../../front_end/core/platform/Timing.ts", "../../../../../../front_end/core/platform/TypedArrayUtilities.ts", "../../../../../../front_end/core/platform/TypescriptUtilities.ts", "../../../../../../front_end/core/platform/UIString.ts", "../../../../../../front_end/core/platform/UserVisibleError.ts"],
  "sourcesContent": ["// Copyright 2020 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nexport const removeElement = <T>(array: T[], element: T, firstOnly?: boolean): boolean => {\n  let index = array.indexOf(element);\n  if (index === -1) {\n    return false;\n  }\n  if (firstOnly) {\n    array.splice(index, 1);\n    return true;\n  }\n  for (let i = index + 1, n = array.length; i < n; ++i) {\n    if (array[i] !== element) {\n      array[index++] = array[i];\n    }\n  }\n  array.length = index;\n  return true;\n};\n\ntype NumberComparator = (a: number, b: number) => number;\n\nexport function swap<T>(array: T[], i1: number, i2: number): void {\n  const temp = array[i1];\n  array[i1] = array[i2];\n  array[i2] = temp;\n}\n\nfunction partition(\n    array: number[], comparator: NumberComparator, left: number, right: number, pivotIndex: number): number {\n  const pivotValue = array[pivotIndex];\n  swap(array, right, pivotIndex);\n  let storeIndex = left;\n  for (let i = left; i < right; ++i) {\n    if (comparator(array[i], pivotValue) < 0) {\n      swap(array, storeIndex, i);\n      ++storeIndex;\n    }\n  }\n  swap(array, right, storeIndex);\n  return storeIndex;\n}\n\nfunction quickSortRange(\n    array: number[], comparator: NumberComparator, left: number, right: number, sortWindowLeft: number,\n    sortWindowRight: number): void {\n  if (right <= left) {\n    return;\n  }\n  const pivotIndex = Math.floor(Math.random() * (right - left)) + left;\n  const pivotNewIndex = partition(array, comparator, left, right, pivotIndex);\n  if (sortWindowLeft < pivotNewIndex) {\n    quickSortRange(array, comparator, left, pivotNewIndex - 1, sortWindowLeft, sortWindowRight);\n  }\n  if (pivotNewIndex < sortWindowRight) {\n    quickSortRange(array, comparator, pivotNewIndex + 1, right, sortWindowLeft, sortWindowRight);\n  }\n}\n\nexport function sortRange(\n    array: number[], comparator: NumberComparator, leftBound: number, rightBound: number, sortWindowLeft: number,\n    sortWindowRight: number): number[] {\n  if (leftBound === 0 && rightBound === (array.length - 1) && sortWindowLeft === 0 && sortWindowRight >= rightBound) {\n    array.sort(comparator);\n  } else {\n    quickSortRange(array, comparator, leftBound, rightBound, sortWindowLeft, sortWindowRight);\n  }\n  return array;\n}\nexport const binaryIndexOf = <T, S>(array: T[], value: S, comparator: (a: S, b: T) => number): number => {\n  const index = lowerBound(array, value, comparator);\n  return index < array.length && comparator(value, array[index]) === 0 ? index : -1;\n};\n\nfunction mergeOrIntersect<T>(\n    array1: T[], array2: T[], comparator: (a: T, b: T) => number, mergeNotIntersect: boolean): T[] {\n  const result = [];\n  let i = 0;\n  let j = 0;\n  while (i < array1.length && j < array2.length) {\n    const compareValue = comparator(array1[i], array2[j]);\n    if (mergeNotIntersect || !compareValue) {\n      result.push(compareValue <= 0 ? array1[i] : array2[j]);\n    }\n    if (compareValue <= 0) {\n      i++;\n    }\n    if (compareValue >= 0) {\n      j++;\n    }\n  }\n  if (mergeNotIntersect) {\n    while (i < array1.length) {\n      result.push(array1[i++]);\n    }\n    while (j < array2.length) {\n      result.push(array2[j++]);\n    }\n  }\n  return result;\n}\n\nexport const intersectOrdered = <T>(array1: T[], array2: T[], comparator: (a: T, b: T) => number): T[] => {\n  return mergeOrIntersect(array1, array2, comparator, false);\n};\n\nexport const mergeOrdered = <T>(array1: T[], array2: T[], comparator: (a: T, b: T) => number): T[] => {\n  return mergeOrIntersect(array1, array2, comparator, true);\n};\n\nexport const DEFAULT_COMPARATOR = (a: string|number, b: string|number): -1|0|1 => {\n  return a < b ? -1 : (a > b ? 1 : 0);\n};\n\n/**\n * Returns the index of the element closest to the needle that is equal to or\n * greater than it. Assumes that the provided array is sorted.\n *\n * If no element is found, the right bound is returned.\n *\n * Uses the provided comparator function to determine if two items are equal or\n * if one is greater than the other. If you are working with strings or\n * numbers, you can use ArrayUtilities.DEFAULT_COMPARATOR. Otherwise, you\n * should define one that takes the needle element and an element from the\n * array and returns a positive or negative number to indicate which is greater\n * than the other.\n *\n * When specified, |left| (inclusive) and |right| (exclusive) indices\n * define the search window.\n */\nexport function lowerBound<T>(\n    array: Uint32Array|Int32Array, needle: T, comparator: (needle: T, b: number) => number, left?: number,\n    right?: number): number;\nexport function lowerBound<S, T>(\n    array: S[], needle: T, comparator: (needle: T, b: S) => number, left?: number, right?: number): number;\nexport function lowerBound<S, T>(\n    array: readonly S[], needle: T, comparator: (needle: T, b: S) => number, left?: number, right?: number): number;\nexport function lowerBound<S, T, A extends S[]>(\n    array: A, needle: T, comparator: (needle: T, b: S) => number, left?: number, right?: number): number {\n  let l = left || 0;\n  let r = right !== undefined ? right : array.length;\n  while (l < r) {\n    const m = (l + r) >> 1;\n    if (comparator(needle, array[m]) > 0) {\n      l = m + 1;\n    } else {\n      r = m;\n    }\n  }\n  return r;\n}\n\n/**\n * Returns the index of the element closest to the needle that is greater than\n * it. Assumes that the provided array is sorted.\n *\n * If no element is found, the right bound is returned.\n *\n * Uses the provided comparator function to determine if two items are equal or\n * if one is greater than the other. If you are working with strings or\n * numbers, you can use ArrayUtilities.DEFAULT_COMPARATOR. Otherwise, you\n * should define one that takes the needle element and an element from the\n * array and returns a positive or negative number to indicate which is greater\n * than the other.\n *\n * When specified, |left| (inclusive) and |right| (exclusive) indices\n * define the search window.\n */\nexport function upperBound<T>(\n    array: Uint32Array, needle: T, comparator: (needle: T, b: number) => number, left?: number, right?: number): number;\nexport function upperBound<S, T>(\n    array: S[], needle: T, comparator: (needle: T, b: S) => number, left?: number, right?: number): number;\nexport function upperBound<S, T, A extends S[]>(\n    array: A, needle: T, comparator: (needle: T, b: S) => number, left?: number, right?: number): number {\n  let l = left || 0;\n  let r = right !== undefined ? right : array.length;\n  while (l < r) {\n    const m = (l + r) >> 1;\n    if (comparator(needle, array[m]) >= 0) {\n      l = m + 1;\n    } else {\n      r = m;\n    }\n  }\n  return r;\n}\n\nconst enum NearestSearchStart {\n  BEGINNING = 'BEGINNING',\n  END = 'END',\n}\n/**\n * Obtains the first or last item in the array that satisfies the predicate function.\n * So, for example, if the array were arr = [2, 4, 6, 8, 10], and you are looking for\n * the last item arr[i] such that arr[i] < 5  you would be returned 1, because\n * array[1] is 4, the last item in the array that satisfies the\n * predicate function.\n *\n * If instead you were looking for the first item in the same array that satisfies\n * arr[i] > 5 you would be returned 2 because array[2] = 6.\n *\n * Please note: this presupposes that the array is already ordered.\n * This function uses a variation of Binary Search.\n */\nfunction nearestIndex<T>(\n    arr: readonly T[], predicate: (arrayItem: T) => boolean, searchStart: NearestSearchStart): number|null {\n  const searchFromEnd = searchStart === NearestSearchStart.END;\n  if (arr.length === 0) {\n    return null;\n  }\n\n  let left = 0;\n  let right = arr.length - 1;\n  let pivot = 0;\n  let matchesPredicate = false;\n  let moveToTheRight = false;\n  let middle = 0;\n  do {\n    middle = left + (right - left) / 2;\n    pivot = searchFromEnd ? Math.ceil(middle) : Math.floor(middle);\n    matchesPredicate = predicate(arr[pivot]);\n    moveToTheRight = matchesPredicate === searchFromEnd;\n    if (moveToTheRight) {\n      left = Math.min(right, pivot + (left === pivot ? 1 : 0));\n    } else {\n      right = Math.max(left, pivot + (right === pivot ? -1 : 0));\n    }\n  } while (right !== left);\n\n  // Special-case: the indexed item doesn't pass the predicate. This\n  // occurs when none of the items in the array are a match for the\n  // predicate.\n  if (!predicate(arr[left])) {\n    return null;\n  }\n  return left;\n}\n\n/**\n * Obtains the first item in the array that satisfies the predicate function.\n * So, for example, if the array was arr = [2, 4, 6, 8, 10], and you are looking for\n * the first item arr[i] such that arr[i] > 5 you would be returned 2, because\n * array[2] is 6, the first item in the array that satisfies the\n * predicate function.\n *\n * Please note: this presupposes that the array is already ordered.\n */\nexport function nearestIndexFromBeginning<T>(arr: T[], predicate: (arrayItem: T) => boolean): number|null {\n  return nearestIndex(arr, predicate, NearestSearchStart.BEGINNING);\n}\n\n/**\n * Obtains the last item in the array that satisfies the predicate function.\n * So, for example, if the array was arr = [2, 4, 6, 8, 10], and you are looking for\n * the last item arr[i] such that arr[i] < 5 you would be returned 1, because\n * arr[1] is 4, the last item in the array that satisfies the\n * predicate function.\n *\n * Please note: this presupposes that the array is already ordered.\n */\n\nexport function nearestIndexFromEnd<T>(arr: readonly T[], predicate: (arrayItem: T) => boolean): number|null {\n  return nearestIndex(arr, predicate, NearestSearchStart.END);\n}\n\n/** Type guard for ensuring that `arr` does not contain null or undefined **/\nexport function arrayDoesNotContainNullOrUndefined<T>(arr: Array<T|null|undefined>): arr is T[] {\n  return !arr.includes(null) && !arr.includes(undefined);\n}\n\nexport function assertArrayIsSorted<T>(arr: readonly T[], compareFn?: (a: T, b: T) => number): void {\n  const comparator = compareFn || (DEFAULT_COMPARATOR as unknown as (a: T, b: T) => number);\n\n  for (let i = 0; i < arr.length - 1; i++) {\n    const current = arr[i];\n    const next = arr[i + 1];\n\n    if (comparator(current, next) > 0) {\n      throw new Error(`Array is not sorted at index ${i}: ${JSON.stringify(current)} > ${JSON.stringify(next)}`);\n    }\n  }\n}\n", "// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/**\n * Helper type to introduce new branded types.\n *\n * `Base` is the underlying data type and `Tag` must be unique symbol/string.\n *\n * Usage:\n * ```ts\n *   type LineNumber = Brand<number, \"LineNumber\">;\n *   type RawUrl = Brand<string, \"RawUrl\">;\n * ```\n *\n * We purposefully use the string index of `_tag` rather then creating a Symbol\n * wrapper that would hide if in IDEs and fail build. This means that at build\n * time if one uses `<branded-var>._tag`, it will build without error and have\n * potentially having a runtime error. This allows us to have multiple places\n * where we define the brands and they will overlap. Also a use case for reusing\n * the type in other downstream projects is simplified.\n */\nexport type Brand<Base, Tag> = Base&{_tag: Tag};\n", "// Copyright 2025 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Constructor<T, Args extends any[] = any[]> = new (...args: Args) => T;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type AbstractConstructor<T, Args extends any[] = any[]> = (abstract new (...args: Args) => T);\n\nexport type ConstructorOrAbstract<T> = Constructor<T>|AbstractConstructor<T>;\n", "// Copyright 2020 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nexport const isValid = (date: Date): boolean => {\n  return !isNaN(date.getTime());\n};\n\nexport const toISO8601Compact = (date: Date): string => {\n  function leadZero(x: number): string {\n    return (x > 9 ? '' : '0') + x;\n  }\n  return date.getFullYear() + leadZero(date.getMonth() + 1) + leadZero(date.getDate()) + 'T' +\n      leadZero(date.getHours()) + leadZero(date.getMinutes()) + leadZero(date.getSeconds());\n};\n", "// Copyright 2021 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type {Brand} from './Brand.js';\n\n/**\n * URLs are in DevTools are repsented as encoded URL strings.\n *\n * @example 'file:///Hello%20World/file/js'\n */\nexport type UrlString = Brand<string, 'UrlString'>;\nexport const EmptyUrlString = '' as UrlString;\n\n/**\n * Tagged template helper to construct `UrlString`s in a more readable form,\n * without having to sprinkle casts throughout the codebase. Primarily useful\n * for writing unit tests.\n *\n * Usage:\n * ```js\n * const url1 = urlString`https://www.example.com/404.html`;\n * const url2 = urlString`http://${host}/path/to/file.js`;\n * ```\n *\n * This is implemented as a wrapper around `String.raw` for convenience. This\n * function doesn't perform any kind of validation that the returned string is\n * really a valid `UrlString`.\n *\n * @param strings the string parts of the template.\n * @param values the dynamic values of the template.\n * @returns the string constructed from `strings` and `values` casted to an\n *         `UrlString`.\n */\nexport const urlString = (strings: ArrayLike<string>, ...values: any[]): UrlString =>\n    String.raw({raw: strings}, ...values) as UrlString;\n\n/**\n * File paths in DevTools that are represented as unencoded absolute\n * or relative paths.\n *\n * @example '/Hello World/file.js'\n */\nexport type RawPathString = Brand<string, 'RawPathString'>;\nexport const EmptyRawPathString = '' as RawPathString;\n\n/**\n * File paths in DevTools that are represented as encoded paths.\n *\n * @example '/Hello%20World/file.js'\n */\nexport type EncodedPathString = Brand<string, 'EncodedPathString'>;\nexport const EmptyEncodedPathString = '' as EncodedPathString;\n", "// Copyright 2025 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Api from './api/api.js';\n\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore 'process' is not available when type-checking against browser types.\nexport const IS_NODE = typeof (process as unknown) !== 'undefined' && process.versions?.node !== null;\n\nexport const IS_BROWSER =\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore 'window' is not available when type-checking against node.js types.\n    typeof window !== 'undefined' || (typeof self !== 'undefined' && typeof self.postMessage === 'function');\n\nexport const HOST_RUNTIME = await (async(): Promise<Api.HostRuntime.HostRuntime> => {\n  if (IS_NODE) {\n    return (await import('./node/node.js')).HostRuntime.HOST_RUNTIME;\n  }\n  if (IS_BROWSER) {\n    return (await import('./browser/browser.js')).HostRuntime.HOST_RUNTIME;\n  }\n\n  throw new Error('Unknown runtime!');\n})();\n", "// Copyright 2020 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nexport const enum ArrowKey {\n  UP = 'ArrowUp',\n  DOWN = 'ArrowDown',\n  LEFT = 'ArrowLeft',\n  RIGHT = 'ArrowRight',\n}\n\nexport const enum PageKey {\n  UP = 'PageUp',\n  DOWN = 'PageDown',\n}\n\nexport const ENTER_KEY = 'Enter';\nexport const ESCAPE_KEY = 'Escape';\nexport const TAB_KEY = 'Tab';\n\nexport const ARROW_KEYS = new Set<ArrowKey>([\n  ArrowKey.UP,\n  ArrowKey.DOWN,\n  ArrowKey.LEFT,\n  ArrowKey.RIGHT,\n]);\n\nexport function keyIsArrowKey(key: string): key is ArrowKey {\n  return ARROW_KEYS.has(key as ArrowKey);\n}\n\nexport function isEscKey(event: {readonly key: string}): boolean {\n  return event.key === 'Escape';\n}\n\nexport function isEnterOrSpaceKey(event: {readonly key: string}): boolean {\n  return event.key === 'Enter' || event.key === ' ';\n}\n", "// Copyright 2020 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nexport const inverse = function<K, V>(map: Map<K, V>): Multimap<V, K> {\n  const result = new Multimap<V, K>();\n  for (const [key, value] of map.entries()) {\n    result.set(value, key);\n  }\n  return result;\n};\n\nexport class Multimap<K, V> {\n  private map = new Map<K, Set<V>>();\n\n  set(key: K, value: V): void {\n    let set = this.map.get(key);\n    if (!set) {\n      set = new Set();\n      this.map.set(key, set);\n    }\n    set.add(value);\n  }\n\n  get(key: K): Set<V> {\n    return this.map.get(key) || new Set();\n  }\n\n  has(key: K): boolean {\n    return this.map.has(key);\n  }\n\n  hasValue(key: K, value: V): boolean {\n    const set = this.map.get(key);\n    if (!set) {\n      return false;\n    }\n    return set.has(value);\n  }\n\n  get size(): number {\n    return this.map.size;\n  }\n\n  delete(key: K, value: V): boolean {\n    const values = this.get(key);\n    if (!values) {\n      return false;\n    }\n    const result = values.delete(value);\n    if (!values.size) {\n      this.map.delete(key);\n    }\n    return result;\n  }\n\n  deleteAll(key: K): void {\n    this.map.delete(key);\n  }\n\n  keysArray(): K[] {\n    return [...this.map.keys()];\n  }\n\n  keys(): IterableIterator<K> {\n    return this.map.keys();\n  }\n\n  valuesArray(): V[] {\n    const result = [];\n    for (const set of this.map.values()) {\n      result.push(...set.values());\n    }\n    return result;\n  }\n\n  clear(): void {\n    this.map.clear();\n  }\n}\n\n/**\n * Gets value for key, assigning a default if value is falsy.\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport function getWithDefault<K extends {}, V>(\n    map: WeakMap<K, V>|Map<K, V>, key: K, defaultValueFactory: (key?: K) => V): V {\n  let value = map.get(key);\n  if (value === undefined || value === null) {\n    value = defaultValueFactory(key);\n    map.set(key, value);\n  }\n\n  return value;\n}\n", "// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nexport const enum MimeType {\n  HTML = 'text/html',\n  XML = 'text/xml',\n  PLAIN = 'text/plain',\n  XHTML = 'application/xhtml+xml',\n  SVG = 'image/svg+xml',\n  CSS = 'text/css',\n  XSL = 'text/xsl',\n  VTT = 'text/vtt',\n  PDF = 'application/pdf',\n  EVENTSTREAM = 'text/event-stream',\n}\n\n/**\n * MIME types other than the ones with the \"text\" type that have text content.\n */\nconst ADDITIONAL_TEXT_MIME_TYPES = new Set([\n  'application/ecmascript',\n  'application/javascript',\n  'application/json',\n  'application/json+protobuf',\n  'application/mpegurl',\n  'application/vnd.apple.mpegurl',\n  'application/vnd.dart',\n  'application/xml',\n  'application/x-aspx',\n  'application/x-javascript',\n  'application/x-jsp',\n  'application/x-httpd-php',\n  'application/x-mpegurl',\n  'audio/mpegurl',\n  'audio/x-mpegurl',\n]);\n\n/**\n * @returns true iff `mimeType` has textual content. Concretely we return true if:\n *   - `mimeType` starts with \"text/\" or \"multipart/\"\n *   - `mimeType` ends with \"+xml\"\n *   - `mimeType` contains \"json\"\n *   - if `mimeType` is one of a predefined list textual mime types.\n */\nexport function isTextType(mimeType: string): boolean {\n  return mimeType.startsWith('text/') || mimeType.startsWith('multipart/') || mimeType.includes('json') ||\n      mimeType.endsWith('+xml') || ADDITIONAL_TEXT_MIME_TYPES.has(mimeType);\n}\n\n/**\n * Port of net::HttpUtils::ParseContentType to extract mimeType and charset from\n * the 'Content-Type' header.\n */\nexport function parseContentType(contentType: string): {mimeType: string|null, charset: string|null} {\n  if (contentType === '*/*') {\n    return {mimeType: null, charset: null};\n  }\n\n  const {mimeType, params} = parseMimeType(contentType);\n  const charset = params.get('charset')?.toLowerCase().trim() ?? null;\n  return {mimeType, charset};\n}\n\nfunction parseMimeType(contentType: string): {mimeType: string|null, params: Map<string, string>} {\n  // Remove any leading and trailing whitespace. Note that String.prototype.trim removes a lot more\n  // than what the spec considers whitespace. We are fine with that.\n  contentType = contentType.trim();\n\n  // The mimetype is basically everything until the first ';' (but trimmed).\n  let mimeTypeEnd = findFirstIndexOf(contentType, ' \\t;(');\n  if (mimeTypeEnd < 0) {\n    mimeTypeEnd = contentType.length;\n  }\n\n  const slashPos = contentType.indexOf('/');\n  if (slashPos < 0 || slashPos > mimeTypeEnd) {\n    return {mimeType: null, params: new Map()};\n  }\n  const mimeType = contentType.substring(0, mimeTypeEnd).toLowerCase();\n\n  // Iterate over parameters. We can't split the string around semicolons because quoted\n  // strings may include semicolons.\n  const params = new Map<string, string>();\n  let offset = contentType.indexOf(';', mimeTypeEnd);\n  while (offset >= 0 && offset < contentType.length) {\n    // Trim off the semicolon.\n    ++offset;\n\n    // Trim off whitespace\n    offset = findFirstIndexNotOf(contentType, ' \\t', offset);\n    if (offset < 0) {\n      continue;\n    }\n    const paramNameStart = offset;\n\n    // Extend parameter name until we run into semicolon or equals sign.\n    offset = findFirstIndexOf(contentType, ';=', offset);\n    if (offset < 0 || contentType[offset] === ';') {\n      // Nothing more to do if no more input or there is no parameter value.\n      continue;\n    }\n\n    const paramName = contentType.substring(paramNameStart, offset).toLowerCase();\n\n    //  Trim off the '='.\n    ++offset;\n\n    // Trim off whitespace.\n    offset = findFirstIndexNotOf(contentType, ' \\t', offset);\n\n    let paramValue = '';\n    if (offset < 0 || contentType[offset] === ';') {\n      // Nothing to do here: the value is an unquoted string of only whitespace.\n      continue;\n    } else if (contentType[offset] !== '\"') {\n      // Not a quote so we can copy the value as-is.\n      const valueStart = offset;\n      offset = contentType.indexOf(';', offset);\n      const valueEnd = offset >= 0 ? offset : contentType.length;\n\n      paramValue = contentType.substring(valueStart, valueEnd).trimEnd();\n    } else {\n      // Otherwise append data with special handling for backslashes, until a close quote.\n      // Don't trim whitespace for quoted strings.\n\n      // Trim off the opening quote '\"'\n      ++offset;\n\n      while (offset < contentType.length && contentType[offset] !== '\"') {\n        // Skip over backslash and append the next character, when not at the end\n        // of the string. Otherwise, copy the next character (which may be a backslash).\n        if (contentType[offset] === '\\\\' && offset + 1 < contentType.length) {\n          ++offset;\n        }\n        paramValue += contentType[offset];\n        ++offset;\n      }\n\n      offset = contentType.indexOf(';', offset);\n    }\n    if (!params.has(paramName)) {\n      // The first one wins!\n      params.set(paramName, paramValue);\n    }\n  }\n\n  return {mimeType, params};\n}\n\n/**\n * @returns the smallest index of any character in 'characters' or -1 if none of\n * the characters occur in 'searchString'\n */\nfunction findFirstIndexOf(searchString: string, characters: string, pos = 0): number {\n  for (let i = pos; i < searchString.length; i++) {\n    if (characters.includes(searchString[i])) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n/**\n * @returns the smallest index of any character not in 'characters' or -1 if only\n * 'characters' occur in 'searchString'\n */\nfunction findFirstIndexNotOf(searchString: string, characters: string, pos = 0): number {\n  for (let i = pos; i < searchString.length; i++) {\n    if (!characters.includes(searchString[i])) {\n      return i;\n    }\n  }\n  return -1;\n}\n", "// Copyright 2020 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nexport const clamp = (num: number, min: number, max: number): number => {\n  let clampedNumber = num;\n  if (num < min) {\n    clampedNumber = min;\n  } else if (num > max) {\n    clampedNumber = max;\n  }\n  return clampedNumber;\n};\n\nexport const mod = (m: number, n: number): number => {\n  return ((m % n) + n) % n;\n};\n\nexport const toFixedIfFloating = (value: string): string => {\n  if (!value || Number.isNaN(Number(value))) {\n    return value;\n  }\n  const number = Number(value);\n  return number % 1 ? number.toFixed(3) : String(number);\n};\n\n/**\n * Rounds a number (including float) down.\n */\nexport const floor = (value: number, precision = 0): number => {\n  // Allows for rounding to the nearest whole number.\n  // Ex: 1 / 10 -> round down to nearest 10th place\n  // Ex: 1 / 5 -> round down to nearest 5\n  // Ex: 1 / 50 -> round down to nearest 50\n  if (precision > 0 && precision < 1) {\n    precision = 1 / precision;\n    return Math.floor(value / precision) * precision;\n  }\n\n  const mult = Math.pow(10, precision);\n  return Math.floor(value * mult) / mult;\n};\n\n/**\n * Computes the great common divisor for two numbers.\n * If the numbers are floats, they will be rounded to an integer.\n */\nexport const greatestCommonDivisor = (a: number, b: number): number => {\n  a = Math.round(a);\n  b = Math.round(b);\n  while (b !== 0) {\n    const t = b;\n    b = a % b;\n    a = t;\n  }\n  return a;\n};\n\nconst commonRatios = new Map([\n  ['8∶5', '16∶10'],\n]);\n\nexport const aspectRatio = (width: number, height: number): string => {\n  const divisor = greatestCommonDivisor(width, height);\n  if (divisor !== 0) {\n    width /= divisor;\n    height /= divisor;\n  }\n  const result = `${width}∶${height}`;\n  return commonRatios.get(result) || result;\n};\n\nexport const withThousandsSeparator = function(num: number): string {\n  let str = String(num);\n  const re = /(\\d+)(\\d{3})/;\n  while (str.match(re)) {\n    str = str.replace(re, '$1\\xA0$2');\n  }  // \\xa0 is a non-breaking space\n  return str;\n};\n", "// Copyright 2020 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type {Brand} from './Brand.js';\n\nexport const escapeCharacters = (inputString: string, charsToEscape: string): string => {\n  let foundChar = false;\n  for (let i = 0; i < charsToEscape.length; ++i) {\n    if (inputString.indexOf(charsToEscape.charAt(i)) !== -1) {\n      foundChar = true;\n      break;\n    }\n  }\n\n  if (!foundChar) {\n    return String(inputString);\n  }\n\n  let result = '';\n  for (let i = 0; i < inputString.length; ++i) {\n    if (charsToEscape.indexOf(inputString.charAt(i)) !== -1) {\n      result += '\\\\';\n    }\n    result += inputString.charAt(i);\n  }\n\n  return result;\n};\n\nconst toHexadecimal = (charCode: number, padToLength: number): string => {\n  return charCode.toString(16).toUpperCase().padStart(padToLength, '0');\n};\n\n// Remember to update the third group in the regexps patternsToEscape and\n// patternsToEscapePlusSingleQuote when adding new entries in this map.\nconst escapedReplacements = new Map([\n  ['\\b', '\\\\b'],\n  ['\\f', '\\\\f'],\n  ['\\n', '\\\\n'],\n  ['\\r', '\\\\r'],\n  ['\\t', '\\\\t'],\n  ['\\v', '\\\\v'],\n  ['\\'', '\\\\\\''],\n  ['\\\\', '\\\\\\\\'],\n  ['<!--', '\\\\x3C!--'],\n  ['<script', '\\\\x3Cscript'],\n  ['</script', '\\\\x3C/script'],\n]);\n\nexport const formatAsJSLiteral = (content: string): string => {\n  const patternsToEscape = /(\\\\|<(?:!--|\\/?script))|(\\p{Control})|(\\p{Surrogate})/gu;\n  const patternsToEscapePlusSingleQuote = /(\\\\|'|<(?:!--|\\/?script))|(\\p{Control})|(\\p{Surrogate})/gu;\n  const escapePattern = (match: string, pattern: string, controlChar: string, loneSurrogate: string): string => {\n    if (controlChar) {\n      if (escapedReplacements.has(controlChar)) {\n        // @ts-expect-error https://github.com/microsoft/TypeScript/issues/13086\n        return escapedReplacements.get(controlChar);\n      }\n      const twoDigitHex = toHexadecimal(controlChar.charCodeAt(0), 2);\n      return '\\\\x' + twoDigitHex;\n    }\n    if (loneSurrogate) {\n      const fourDigitHex = toHexadecimal(loneSurrogate.charCodeAt(0), 4);\n      return '\\\\u' + fourDigitHex;\n    }\n    if (pattern) {\n      return escapedReplacements.get(pattern) || '';\n    }\n    return match;\n  };\n\n  let escapedContent = '';\n  let quote = '';\n  if (!content.includes('\\'')) {\n    quote = '\\'';\n    escapedContent = content.replaceAll(patternsToEscape, escapePattern);\n  } else if (!content.includes('\"')) {\n    quote = '\"';\n    escapedContent = content.replaceAll(patternsToEscape, escapePattern);\n  } else if (!content.includes('`') && !content.includes('${')) {\n    quote = '`';\n    escapedContent = content.replaceAll(patternsToEscape, escapePattern);\n  } else {\n    quote = '\\'';\n    escapedContent = content.replaceAll(patternsToEscapePlusSingleQuote, escapePattern);\n  }\n  return `${quote}${escapedContent}${quote}`;\n};\n\n/**\n * This implements a subset of the sprintf() function described in the Single UNIX\n * Specification. It supports the %s, %f, %d, and %% formatting specifiers, and\n * understands the %m$d notation to select the m-th parameter for this substitution,\n * as well as the optional precision for %s, %f, and %d.\n *\n * @param fmt format string.\n * @param args parameters to the format string.\n * @returns the formatted output string.\n */\nexport const sprintf = (fmt: string, ...args: unknown[]): string => {\n  let argIndex = 0;\n  const RE = /%(?:(\\d+)\\$)?(?:\\.(\\d*))?([%dfs])/g;\n  return fmt.replaceAll(RE, (_: string, index?: string, precision?: string, specifier?: string) => {\n    if (specifier === '%') {\n      return '%';\n    }\n    if (index !== undefined) {\n      argIndex = parseInt(index, 10) - 1;\n      if (argIndex < 0) {\n        throw new RangeError(`Invalid parameter index ${argIndex + 1}`);\n      }\n    }\n    if (argIndex >= args.length) {\n      throw new RangeError(`Expected at least ${argIndex + 1} format parameters, but only ${args.length} where given.`);\n    }\n    if (specifier === 's') {\n      const argValue = String(args[argIndex++]);\n      if (precision !== undefined) {\n        return argValue.substring(0, Number(precision));\n      }\n      return argValue;\n    }\n    let argValue = Number(args[argIndex++]);\n    if (isNaN(argValue)) {\n      argValue = 0;\n    }\n    if (specifier === 'd') {\n      return String(Math.floor(argValue)).padStart(Number(precision), '0');\n    }\n    if (precision !== undefined) {\n      return argValue.toFixed(Number(precision));\n    }\n    return String(argValue);\n  });\n};\n\nexport const toBase64 = (inputString: string): string => {\n  /* note to the reader: we can't use btoa here because we need to\n   * support Unicode correctly. See the test cases for this function and\n   * also\n   * https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding#The_Unicode_Problem\n   */\n\n  function encodeBits(b: number): number {\n    return b < 26 ? b + 65 : b < 52 ? b + 71 : b < 62 ? b - 4 : b === 62 ? 43 : b === 63 ? 47 : 65;\n  }\n  const encoder = new TextEncoder();\n  const data = encoder.encode(inputString.toString());\n  const n = data.length;\n  let encoded = '';\n  if (n === 0) {\n    return encoded;\n  }\n  let shift;\n  let v = 0;\n  for (let i = 0; i < n; i++) {\n    shift = i % 3;\n    v |= data[i] << (16 >>> shift & 24);\n    if (shift === 2) {\n      encoded += String.fromCharCode(\n          encodeBits(v >>> 18 & 63), encodeBits(v >>> 12 & 63), encodeBits(v >>> 6 & 63), encodeBits(v & 63));\n      v = 0;\n    }\n  }\n  if (shift === 0) {\n    encoded += String.fromCharCode(encodeBits(v >>> 18 & 63), encodeBits(v >>> 12 & 63), 61, 61);\n  } else if (shift === 1) {\n    encoded += String.fromCharCode(encodeBits(v >>> 18 & 63), encodeBits(v >>> 12 & 63), encodeBits(v >>> 6 & 63), 61);\n  }\n  return encoded;\n};\n\nexport const findIndexesOfSubString = (inputString: string, searchString: string): number[] => {\n  const matches = [];\n  let i = inputString.indexOf(searchString);\n  while (i !== -1) {\n    matches.push(i);\n    i = inputString.indexOf(searchString, i + searchString.length);\n  }\n  return matches;\n};\n\nexport const findLineEndingIndexes = (inputString: string): number[] => {\n  const endings = findIndexesOfSubString(inputString, '\\n');\n  endings.push(inputString.length);\n  return endings;\n};\n\nexport const isWhitespace = (inputString: string): boolean => {\n  return /^\\s*$/.test(inputString);\n};\n\nexport const trimURL = (url: string, baseURLDomain?: string): string => {\n  let result = url.replace(/^(https|http|file):\\/\\//i, '');\n  if (baseURLDomain) {\n    if (result.toLowerCase().startsWith(baseURLDomain.toLowerCase())) {\n      result = result.substr(baseURLDomain.length);\n    }\n  }\n  return result;\n};\n\nexport const collapseWhitespace = (inputString: string): string => {\n  return inputString.replace(/[\\s\\xA0]+/g, ' ');\n};\n\nexport const reverse = (inputString: string): string => {\n  return inputString.split('').reverse().join('');\n};\n\nexport const replaceControlCharacters = (inputString: string): string => {\n  // Replace C0 and C1 control character sets with replacement character.\n  // Do not replace '\\t', \\n' and '\\r'.\n  return inputString.replace(/[\\0-\\x08\\x0B\\f\\x0E-\\x1F\\x80-\\x9F]/g, '\\uFFFD');\n};\n\nexport const countWtf8Bytes = (inputString: string): number => {\n  let count = 0;\n  for (let i = 0; i < inputString.length; i++) {\n    const c = inputString.charCodeAt(i);\n    if (c <= 0x7F) {\n      count++;\n    } else if (c <= 0x07FF) {\n      count += 2;\n    } else if (c < 0xD800 || 0xDFFF < c) {\n      count += 3;\n    } else {\n      if (c <= 0xDBFF && i + 1 < inputString.length) {\n        // The current character is a leading surrogate, and there is a\n        // next character.\n        const next = inputString.charCodeAt(i + 1);\n        if (0xDC00 <= next && next <= 0xDFFF) {\n          // The next character is a trailing surrogate, meaning this\n          // is a surrogate pair.\n          count += 4;\n          i++;\n          continue;\n        }\n      }\n      count += 3;\n    }\n  }\n  return count;\n};\n\nexport const stripLineBreaks = (inputStr: string): string => {\n  return inputStr.replace(/(\\r)?\\n/g, '');\n};\n\nconst EXTENDED_KEBAB_CASE_REGEXP = /^([a-z0-9]+(?:-[a-z0-9]+)*\\.)*[a-z0-9]+(?:-[a-z0-9]+)*$/;\n\n/**\n * Tests if the `inputStr` is following the extended Kebab Case naming convention,\n * where words are separated with either a dash (`-`) or a dot (`.`), and all\n * characters must be lower-case alphanumeric.\n *\n * For example, it will yield `true` for `'my.amazing-string.literal'`, but `false`\n * for `'Another.AmazingLiteral'` or '`another_amazing_literal'`.\n *\n * @param inputStr the input string to test.\n * @returns `true` if the `inputStr` follows the extended Kebab Case convention.\n */\nexport const isExtendedKebabCase = (inputStr: string): boolean => {\n  return EXTENDED_KEBAB_CASE_REGEXP.test(inputStr);\n};\n\nexport const toTitleCase = (inputStr: string): string => {\n  return inputStr.substring(0, 1).toUpperCase() + inputStr.substring(1);\n};\n\nexport const removeURLFragment = (inputStr: string): string => {\n  const url = new URL(inputStr);\n  url.hash = '';\n  return url.toString();\n};\n\nconst SPECIAL_REGEX_CHARACTERS = '^[]{}()\\\\.^$*+?|-,';\n\nexport const regexSpecialCharacters = function(): string {\n  return SPECIAL_REGEX_CHARACTERS;\n};\n\nexport const filterRegex = function(query: string): RegExp {\n  let regexString = '^(?:.*\\\\0)?';  // Start from beginning or after a \\0\n  for (let i = 0; i < query.length; ++i) {\n    let c = query.charAt(i);\n    if (SPECIAL_REGEX_CHARACTERS.indexOf(c) !== -1) {\n      c = '\\\\' + c;\n    }\n    regexString += '[^\\\\0' + c + ']*' + c;\n  }\n  return new RegExp(regexString, 'i');\n};\n\nexport const createSearchRegex = function(\n    query: string, caseSensitive: boolean, isRegex: boolean, matchWholeWord = false): RegExp {\n  const regexFlags = caseSensitive ? 'g' : 'gi';\n  let regexObject;\n\n  if (isRegex) {\n    try {\n      regexObject = new RegExp(query, regexFlags);\n    } catch {\n      // Silent catch.\n    }\n  }\n\n  if (!regexObject) {\n    regexObject = createPlainTextSearchRegex(query, regexFlags);\n  }\n\n  if (matchWholeWord && regexObject) {\n    regexObject = new RegExp(`\\\\b${regexObject.source}\\\\b`, regexFlags);\n  }\n\n  return regexObject;\n};\n\nexport const caseInsensetiveComparator = function(a: string, b: string): number {\n  a = a.toUpperCase();\n  b = b.toUpperCase();\n  if (a === b) {\n    return 0;\n  }\n  return a > b ? 1 : -1;\n};\n\nexport const hashCode = function(string?: string): number {\n  if (!string) {\n    return 0;\n  }\n  // Hash algorithm for substrings is described in \"Über die Komplexität der Multiplikation in\n  // eingeschränkten Branchingprogrammmodellen\" by Woelfe.\n  // http://opendatastructures.org/versions/edition-0.1d/ods-java/node33.html#SECTION00832000000000000000\n  const p = ((1 << 30) * 4 - 5);  // prime: 2^32 - 5\n  const z = 0x5033d967;           // 32 bits from random.org\n  const z2 = 0x59d2f15d;          // random odd 32 bit number\n  let s = 0;\n  let zi = 1;\n  for (let i = 0; i < string.length; i++) {\n    const xi = string.charCodeAt(i) * z2;\n    s = (s + zi * xi) % p;\n    zi = (zi * z) % p;\n  }\n  s = (s + zi * (p - 1)) % p;\n  return Math.abs(s | 0);\n};\n\nexport const compare = (a: string, b: string): number => {\n  if (a > b) {\n    return 1;\n  }\n  if (a < b) {\n    return -1;\n  }\n  return 0;\n};\n\nexport const trimMiddle = (str: string, maxLength: number): string => {\n  if (str.length <= maxLength) {\n    return String(str);\n  }\n  let leftHalf = maxLength >> 1;\n  let rightHalf = maxLength - leftHalf - 1;\n  if ((str.codePointAt(str.length - rightHalf - 1) as number) >= 0x10000) {\n    --rightHalf;\n    ++leftHalf;\n  }\n  if (leftHalf > 0 && (str.codePointAt(leftHalf - 1) as number) >= 0x10000) {\n    --leftHalf;\n  }\n  return str.substr(0, leftHalf) + '…' + str.substr(str.length - rightHalf, rightHalf);\n};\n\nexport const trimEndWithMaxLength = (str: string, maxLength: number): string => {\n  if (str.length <= maxLength) {\n    return String(str);\n  }\n  return str.substr(0, maxLength - 1) + '…';\n};\n\nexport const escapeForRegExp = (str: string): string => {\n  return escapeCharacters(str, SPECIAL_REGEX_CHARACTERS);\n};\n\nexport const naturalOrderComparator = (a: string, b: string): number => {\n  const chunk = /^\\d+|^\\D+/;\n  let chunkA, chunkB, numA, numB;\n  while (true) {\n    if (a) {\n      if (!b) {\n        return 1;\n      }\n    } else {\n      if (b) {\n        return -1;\n      }\n      return 0;\n    }\n    chunkA = (a.match(chunk) as string[])[0];\n    chunkB = (b.match(chunk) as string[])[0];\n    numA = !Number.isNaN(Number(chunkA));\n    numB = !Number.isNaN(Number(chunkB));\n    if (numA && !numB) {\n      return -1;\n    }\n    if (numB && !numA) {\n      return 1;\n    }\n    if (numA && numB) {\n      const diff = Number(chunkA) - Number(chunkB);\n      if (diff) {\n        return diff;\n      }\n      if (chunkA.length !== chunkB.length) {\n        if (!Number(chunkA) && !Number(chunkB)) {  // chunks are strings of all 0s (special case)\n          return chunkA.length - chunkB.length;\n        }\n        return chunkB.length - chunkA.length;\n      }\n    } else if (chunkA !== chunkB) {\n      return (chunkA < chunkB) ? -1 : 1;\n    }\n    a = a.substring(chunkA.length);\n    b = b.substring(chunkB.length);\n  }\n};\n\nexport const base64ToSize = function(content: string|null): number {\n  if (!content) {\n    return 0;\n  }\n  let size = content.length * 3 / 4;\n  if (content[content.length - 1] === '=') {\n    size--;\n  }\n  if (content.length > 1 && content[content.length - 2] === '=') {\n    size--;\n  }\n  return size;\n};\n\nexport const SINGLE_QUOTE = '\\'';\nexport const DOUBLE_QUOTE = '\"';\nconst BACKSLASH = '\\\\';\n\nexport const findUnclosedCssQuote = function(str: string): string {\n  let unmatchedQuote = '';\n  for (let i = 0; i < str.length; ++i) {\n    const char = str[i];\n    if (char === BACKSLASH) {\n      i++;\n      continue;\n    }\n    if (char === SINGLE_QUOTE || char === DOUBLE_QUOTE) {\n      if (unmatchedQuote === char) {\n        unmatchedQuote = '';\n      } else if (unmatchedQuote === '') {\n        unmatchedQuote = char;\n      }\n    }\n  }\n  return unmatchedQuote;\n};\n\nexport const countUnmatchedLeftParentheses = (str: string): number => {\n  const stringLiteralRegex = /'(?:\\\\.|[^'\\\\])*'|\"(?:\\\\.|[^\"\\\\])*\"/g;\n  // Remove all matched string literals from the original string.\n  const strWithoutStrings = str.replace(stringLiteralRegex, '');\n\n  let unmatchedCount = 0;\n  for (const c of strWithoutStrings) {\n    if (c === '(') {\n      unmatchedCount++;\n    } else if (c === ')' && unmatchedCount > 0) {\n      unmatchedCount--;\n    }\n  }\n  return unmatchedCount;\n};\n\nexport const createPlainTextSearchRegex = function(query: string, flags?: string): RegExp {\n  // This should be kept the same as the one in StringUtil.cpp.\n  let regex = '';\n  for (let i = 0; i < query.length; ++i) {\n    const c = query.charAt(i);\n    if (regexSpecialCharacters().indexOf(c) !== -1) {\n      regex += '\\\\';\n    }\n    regex += c;\n  }\n  return new RegExp(regex, flags || '');\n};\n\nexport type LowerCaseString = Brand<string, 'lowerCaseStringTag'>;\n\nexport const toLowerCaseString = function(input: string): LowerCaseString {\n  return input.toLowerCase() as LowerCaseString;\n};\n\n/**\n * 1: two or more consecutive uppercase letters. This is useful for identifying acronyms\n * 2: lookahead assertion that matches a word boundary\n * 3: numeronym: single letter followed by number and another letter\n * 4: word starting with an optional uppercase letter\n * 5: single digit followed by word to handle '3D' or '2px' (this might be controverial)\n * 6: single uppercase letter or number\n * 7: a dot character. We extract it into a separate word and remove dashes around it later.\n * This is makes more sense conceptually and allows accounting for all possible word variants.\n * Making dot a part of a word prevent us from handling acronyms or numeronyms after the word\n * correctly without making the RegExp prohibitively complicated.\n * https://regex101.com/r/FhMVKc/1\n *            <---1---><------------2-----------> <---------3--------> <-----4----> <------5-----> <-----6----> <7>\n */\nconst WORD = /[A-Z]{2,}(?=[A-Z0-9][a-z0-9]+|\\b|_)|[A-Za-z][0-9]+[a-z]?|[A-Z]?[a-z]+|[0-9][A-Za-z]+|[A-Z]|[0-9]+|[.]/g;\n\nexport const toKebabCase = function(input: string): Lowercase<string> {\n  return (input.match?.(WORD)?.map(w => w.toLowerCase()).join('-').replaceAll('-.-', '.') || input) as\n      Lowercase<string>;\n};\n\nexport function toKebabCaseKeys<T>(settingValue: Record<string, T>): Record<string, T> {\n  return Object.fromEntries(Object.entries(settingValue).map(([key, value]) => [toKebabCase(key), value]));\n}\n\n/**\n * Converts a given string to snake_case.\n * This function handles camelCase, PascalCase, and acronyms, including transitions between letters and numbers.\n * It uses Unicode-aware regular expressions (`\\p{L}`, `\\p{N}`, `\\p{Lu}`, `\\p{Ll}` with the `u` flag)\n * to correctly process letters and numbers from various languages.\n *\n * @param text The input string to convert to snake_case.\n * @returns The snake_case version of the input string.\n */\nexport function toSnakeCase(text: string): string {\n  if (!text) {\n    return '';\n  }\n  // First, handle case-based transformations to insert underscores correctly.\n  // 1. Add underscore between a letter and a number.\n  //    e.g., \"version2\" -> \"version_2\"\n  // 2. Add underscore between an uppercase letter sequence and a following uppercase+lowercase sequence.\n  //    e.g., \"APIFlags\" -> \"API_Flags\"\n  // 3. Add underscore between a lowercase/number and an uppercase letter.\n  //    e.g., \"lastName\" -> \"last_Name\", \"version_2Update\" -> \"version_2_Update\"\n  // 4. Replace sequences of non-alphanumeric with a single underscore\n  // 5. Remove any leading or trailing underscores.\n  const result = text.replace(/(\\p{L})(\\p{N})/gu, '$1_$2')           // 1\n                     .replace(/(\\p{Lu}+)(\\p{Lu}\\p{Ll})/gu, '$1_$2')  // 2\n                     .replace(/(\\p{Ll}|\\p{N})(\\p{Lu})/gu, '$1_$2')   // 3\n                     .toLowerCase()\n                     .replace(/[^\\p{L}\\p{N}]+/gu, '_')  // 4\n                     .replace(/^_|_$/g, '');            // 5\n\n  return result;\n}\n\n/** Replaces the last occurrence of parameter `search` with parameter `replacement` in `input` **/\nexport const replaceLast = function(input: string, search: string, replacement: string): string {\n  const replacementStartIndex = input.lastIndexOf(search);\n  if (replacementStartIndex === -1) {\n    return input;\n  }\n\n  return input.slice(0, replacementStartIndex) + input.slice(replacementStartIndex).replace(search, replacement);\n};\n\nexport const stringifyWithPrecision = function stringifyWithPrecision(s: number, precision = 2): string {\n  if (precision === 0) {\n    return s.toFixed(0);\n  }\n  const string = s.toFixed(precision).replace(/\\.?0*$/, '');\n  return string === '-0' ? '0' : string;\n};\n\n/**\n * Somewhat efficiently concatenates 2 base64 encoded strings.\n */\nexport const concatBase64 = function(lhs: string, rhs: string): string {\n  if (lhs.length === 0 || !lhs.endsWith('=')) {\n    // Empty string or no padding, we can straight-up concatenate.\n    return lhs + rhs;\n  }\n  const lhsLeaveAsIs = lhs.substring(0, lhs.length - 4);\n  const lhsToDecode = lhs.substring(lhs.length - 4);\n  return lhsLeaveAsIs + globalThis.btoa(globalThis.atob(lhsToDecode) + globalThis.atob(rhs));\n};\n", "// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type {Brand} from './Brand.js';\n\nexport type Seconds = Brand<number, 'Seconds'>;\nexport type MilliSeconds = Brand<number, 'MilliSeconds'>;\nexport type MicroSeconds = Brand<number, 'MicroSeconds'>;\n\nexport function milliSecondsToSeconds(x: MilliSeconds): Seconds {\n  return (x / 1000) as Seconds;\n}\n\nexport function microSecondsToMilliSeconds(x: MicroSeconds): MilliSeconds {\n  return (x / 1000) as MilliSeconds;\n}\n", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/**\n * An object which provides functionality similar to Uint32Array. It may be\n * implemented as:\n * 1. A Uint32Array,\n * 2. An array of Uint32Arrays, to support more data than Uint32Array, or\n * 3. A plain array, in which case the length may change by setting values.\n */\nexport interface BigUint32Array {\n  get length(): number;\n  getValue(index: number): number;\n  setValue(index: number, value: number): void;\n  asUint32ArrayOrFail(): Uint32Array;\n  asArrayOrFail(): number[];\n}\n\n/**\n * @returns A BigUint32Array implementation which is based on Array.\n * This means that its length automatically expands to include the highest index\n * used, and asArrayOrFail will succeed.\n */\nexport function createExpandableBigUint32Array(): BigUint32Array {\n  return new ExpandableBigUint32ArrayImpl();\n}\n\n/**\n * @returns A BigUint32Array implementation which is based on Uint32Array.\n * If the length is small enough to fit in a single Uint32Array, then\n * asUint32ArrayOrFail will succeed. Otherwise, it will throw an exception.\n */\nexport function createFixedBigUint32Array(length: number, maxLengthForTesting?: number): BigUint32Array {\n  try {\n    if (maxLengthForTesting !== undefined && length > maxLengthForTesting) {\n      // Simulate allocation failure.\n      throw new RangeError();\n    }\n    return new BasicBigUint32ArrayImpl(length);\n  } catch {\n    // We couldn't allocate a big enough ArrayBuffer.\n    return new SplitBigUint32ArrayImpl(length, maxLengthForTesting);\n  }\n}\n\nclass BasicBigUint32ArrayImpl extends Uint32Array implements BigUint32Array {\n  getValue(index: number): number {\n    return this[index];\n  }\n  setValue(index: number, value: number): void {\n    this[index] = value;\n  }\n  asUint32ArrayOrFail(): Uint32Array {\n    return this;\n  }\n  asArrayOrFail(): number[] {\n    throw new Error('Not an array');\n  }\n}\n\nclass SplitBigUint32ArrayImpl implements BigUint32Array {\n  #data: Uint32Array[];\n  #partLength: number;\n  length: number;\n\n  constructor(length: number, maxLengthForTesting?: number) {\n    this.#data = [];\n    this.length = length;\n    let partCount = 1;\n    while (true) {\n      partCount *= 2;\n      this.#partLength = Math.ceil(length / partCount);\n      try {\n        if (maxLengthForTesting !== undefined && this.#partLength > maxLengthForTesting) {\n          // Simulate allocation failure.\n          throw new RangeError();\n        }\n        for (let i = 0; i < partCount; ++i) {\n          this.#data[i] = new Uint32Array(this.#partLength);\n        }\n        return;\n      } catch (e) {\n        if (this.#partLength < 1e6) {\n          // The length per part is already small, so continuing to subdivide it\n          // will probably not help.\n          throw e;\n        }\n      }\n    }\n  }\n\n  getValue(index: number): number {\n    if (index >= 0 && index < this.length) {\n      const partLength = this.#partLength;\n      return this.#data[Math.floor(index / partLength)][index % partLength];\n    }\n    // On out-of-bounds accesses, match the behavior of Uint32Array: return an\n    // undefined value that's incorrectly typed as number.\n    return this.#data[0][-1];\n  }\n\n  setValue(index: number, value: number): void {\n    if (index >= 0 && index < this.length) {\n      const partLength = this.#partLength;\n      this.#data[Math.floor(index / partLength)][index % partLength] = value;\n    }\n    // Attempting to set a value out of bounds does nothing, like Uint32Array.\n  }\n\n  asUint32ArrayOrFail(): Uint32Array {\n    throw new Error('Not a Uint32Array');\n  }\n  asArrayOrFail(): number[] {\n    throw new Error('Not an array');\n  }\n}\n\nclass ExpandableBigUint32ArrayImpl extends Array<number> implements BigUint32Array {\n  getValue(index: number): number {\n    return this[index];\n  }\n  setValue(index: number, value: number): void {\n    this[index] = value;\n  }\n  asUint32ArrayOrFail(): Uint32Array {\n    throw new Error('Not a Uint32Array');\n  }\n  asArrayOrFail(): number[] {\n    return this;\n  }\n}\n\nexport interface BitVector {\n  getBit(index: number): boolean;\n  setBit(index: number): void;\n  clearBit(index: number): void;\n  // Returns the last bit before `index` which is set, or -1 if there are none.\n  previous(index: number): number;\n  get buffer(): ArrayBuffer;\n}\n\nexport function createBitVector(lengthOrBuffer: number|ArrayBuffer): BitVector {\n  return new BitVectorImpl(lengthOrBuffer);\n}\n\nclass BitVectorImpl extends Uint8Array {\n  constructor(lengthOrBuffer: number|ArrayBuffer) {\n    if (typeof lengthOrBuffer === 'number') {\n      super(Math.ceil(lengthOrBuffer / 8));\n    } else {\n      super(lengthOrBuffer);\n    }\n  }\n  getBit(index: number): boolean {\n    const value = this[index >> 3] & (1 << (index & 7));\n    return value !== 0;\n  }\n  setBit(index: number): void {\n    this[index >> 3] |= (1 << (index & 7));\n  }\n  clearBit(index: number): void {\n    this[index >> 3] &= ~(1 << (index & 7));\n  }\n  previous(index: number): number {\n    // First, check for more bits in the current byte.\n    while (index !== ((index >> 3) << 3)) {\n      --index;\n      if (this.getBit(index)) {\n        return index;\n      }\n    }\n    // Next, iterate by bytes to skip over ranges of zeros.\n    let byteIndex: number = (index >> 3) - 1;\n    while (byteIndex >= 0 && this[byteIndex] === 0) {\n      --byteIndex;\n    }\n    if (byteIndex < 0) {\n      return -1;\n    }\n    // Finally, iterate the nonzero byte to find the highest bit.\n    for (index = (byteIndex << 3) + 7; index >= (byteIndex << 3); --index) {\n      if (this.getBit(index)) {\n        return index;\n      }\n    }\n    throw new Error('Unreachable');\n  }\n}\n", "// Copyright 2020 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/**\n * This is useful to keep TypeScript happy in a test - if you have a value\n * that's potentially `null` you can use this function to assert that it isn't,\n * and satisfy TypeScript that the value is present.\n */\nexport function assertNotNullOrUndefined<T>(val: T, message?: string): asserts val is NonNullable<T> {\n  if (val === null || val === undefined) {\n    throw new Error(`Expected given value to not be null/undefined but it was: ${val}${message ? `\\n${message}` : ''}`);\n  }\n}\n\nexport function assertNever(_type: never, message: string): never {\n  throw new Error(message);\n}\n\n/**\n * This is useful to check on the type-level that the unhandled cases of\n * a switch are exactly `T` (where T is usually a union type of enum values).\n * @param caseVariable\n */\nexport function assertUnhandled<T>(_caseVariable: T): T {\n  return _caseVariable;\n}\n\nexport type FieldsThatExtend<Type, Selector> = {\n  [Key in keyof Type]: Type[Key] extends Selector ? Key : never;\n}[keyof Type];\n\nexport type PickFieldsThatExtend<Type, Selector> = Pick<Type, FieldsThatExtend<Type, Selector>>;\n\n/**\n * Turns a Union type (a | b) into an Intersection type (a & b).\n * This is a helper type to implement the \"NoUnion\" guard.\n *\n * Adapted from https://stackoverflow.com/a/50375286.\n *\n * The tautological `T extends any` is necessary to trigger distributivity for\n * plain unions, e.g. in IntersectionFromUnion<'a'|'b'> TypeScript expands it\n * to  ('a' extends any ? (arg: 'a') => void : never)\n *  |  ('b' extends any ? (arg: 'b') => void : never)\n *\n * The second extends clause then asks TypeScript to find a type of the form\n * `(arg: infer U) => void` that upper-bounds the union, i.e., intuitively,\n * a type that converts to each of the union members. This forces U to be the\n * intersection of 'a' and 'b' in the example.\n *\n * Please note that some intersection types are simply impossible, e.g.\n * `string & number`. There is no type that fulfills both at the same time. A\n * union of this kind is reduced to `never`.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype IntersectionFromUnion<T> = (T extends any ? (arg: T) => void : never) extends((arg: infer U) => void) ? U : never;\n\n/**\n * When writing generic code it may be desired to disallow Union types from\n * being passed. This type can be used in those cases.\n *\n *   function foo<T>(argument: NoUnion<T>) {...}\n *\n * Would result in a compile error for foo<a|b>(...); invocations as `argument`\n * would be typed as `never`.\n *\n * Adapted from https://stackoverflow.com/a/50641073.\n *\n * Conditional types become distributive when receiving a union type. To\n * prevent this from happening, we use `[T] extends [IntersectionFromUnion<T>]`\n * instead of `T extends IntersectionFromUnion<T>`.\n * See: https://www.typescriptlang.org/docs/handbook/2/conditional-types.html\n */\nexport type NoUnion<T> = [T] extends [IntersectionFromUnion<T>] ? T : never;\n\nexport type RecursivePartial<T> = {\n  [P in keyof T]?: RecursivePartial<T[P]>;\n};\n\n/**\n * Note this does not recursively\n * make Array items readonly at the moment\n */\nexport type RecursiveReadonly<T> = {\n  [P in keyof T]: Readonly<RecursiveReadonly<T[P]>>;\n};\n", "// Copyright 2021 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/*\n * Copyright (C) 2011 Google Inc.  All rights reserved.\n * Copyright (C) 2006, 2007, 2008 Apple Inc.  All rights reserved.\n * Copyright (C) 2007 Matt Lilek (pewtermoose@gmail.com).\n * Copyright (C) 2009 Joseph Pecoraro\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1.  Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n * 2.  Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n * 3.  Neither the name of Apple Computer, Inc. (\"Apple\") nor the names of\n *     its contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport type {Brand} from './Brand.js';\n\nexport type LocalizedString = Brand<string, 'LocalizedString'>;\nexport const LocalizedEmptyString = '' as LocalizedString;\n", "// Copyright 2021 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type {LocalizedString} from './UIString.js';\n\n/**\n * Represents an error that might become visible to the user. Where errors\n * might be surfaced to the user (such as by displaying the message to the\n * console), this class should be used to enforce that the message is\n * localized on the way in.\n */\nexport class UserVisibleError extends Error {\n  override readonly message: LocalizedString;\n\n  constructor(message: LocalizedString) {\n    super(message);\n    this.message = message;\n  }\n}\n\nexport function isUserVisibleError(error: unknown): error is UserVisibleError {\n  if (typeof error === 'object' && error !== null) {\n    return error instanceof UserVisibleError;\n  }\n\n  return false;\n}\n"],
  "mappings": "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",
  "names": ["argValue", "stringifyWithPrecision"]
}
