{"version":3,"file":"CDPConnection.js","sourceRoot":"","sources":["../../../../../../front_end/core/protocol_client/CDPConnection.ts"],"names":[],"mappings":"AAAA,sCAAsC;AACtC,yEAAyE;AACzE,6BAA6B;AA8B7B;;GAEG;AACH,MAAM,CAAN,IAAY,cASX;AATD,WAAY,cAAc;IACxB,sEAAoB,CAAA;IACpB,8EAAwB,CAAA;IACxB,gFAAyB,CAAA;IACzB,4EAAuB,CAAA;IACvB,4EAAuB,CAAA;IACvB,wEAAqB,CAAA;IACrB,kFAAoC,CAAA;IACpC,sFAA4B,CAAA;AAC9B,CAAC,EATW,cAAc,KAAd,cAAc,QASzB","sourcesContent":["// Copyright 2025 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type {ProtocolMapping} from '../../generated/protocol-mapping.js';\n\nexport type Command = keyof ProtocolMapping.Commands;\nexport type CommandParams<T extends Command> = ProtocolMapping.Commands[T]['paramsType'][0];\nexport type CommandResult<T extends Command> = Omit<ProtocolMapping.Commands[T]['returnType'], 'getError'>;\nexport type Event = keyof ProtocolMapping.Events;\nexport type EventParams<T extends keyof ProtocolMapping.Events> = ProtocolMapping.Events[T][0];\n\nexport interface CDPBaseMessage {\n  sessionId?: string;\n}\n\nexport interface CDPCommandRequest<T extends Command> extends CDPBaseMessage {\n  id: number;\n  method: T;\n  params: CommandParams<T>;\n}\n\nexport interface CDPCommandResponse<T extends Command> extends CDPBaseMessage {\n  id: number;\n  result: CommandResult<T>;\n}\n\nexport interface CDPEvent<T extends Event> extends CDPBaseMessage {\n  method: T;\n  params: EventParams<T>;\n}\n\n/**\n * Keep this in sync with https://source.chromium.org/chromium/chromium/src/+/main:third_party/inspector_protocol/crdtp/dispatch.h.\n */\nexport enum CDPErrorStatus {\n  PARSE_ERROR = -32700,\n  INVALID_REQUEST = -32600,\n  METHOD_NOT_FOUND = -32601,\n  INVALID_PARAMS = -32602,\n  INTERNAL_ERROR = -32603,\n  SERVER_ERROR = -32000,\n  SESSION_NOT_FOUND = SERVER_ERROR - 1,\n  DEVTOOLS_STUB_ERROR = -32015,\n}\n\nexport interface CDPError {\n  code: CDPErrorStatus;\n  message: string;\n  data?: string;\n}\n\nexport interface CDPErrorMessage extends CDPBaseMessage {\n  id?: number;\n  error: CDPError;\n}\n\nexport type CDPReceivableMessage = CDPCommandResponse<Command>|CDPEvent<Event>|CDPErrorMessage;\n\n/**\n * Allows the sending and receiving of CDP commands and the notification of CDP events to observers.\n *\n * An instance of a CDPConnection \"owns\" the full transport channel and no other CDP traffic must\n * be proxied over it. This is because each implementation needs to manage \"message IDs\", which\n * would conflict with any other shared traffic.\n */\nexport interface CDPConnection {\n  send<T extends Command>(method: T, params: CommandParams<T>, sessionId: string|undefined):\n      Promise<{result: CommandResult<T>}|{error: CDPError}>;\n\n  observe(observer: CDPConnectionObserver): void;\n  unobserve(observer: CDPConnectionObserver): void;\n}\n\nexport interface CDPConnectionObserver {\n  onEvent<T extends Event>(event: CDPEvent<T>): void;\n  onDisconnect(reason: string): void;\n}\n\n/**\n * The protocol monitor and test harness require inspection of raw CDP message traffic.\n */\nexport interface DebuggableCDPConnection extends CDPConnection {\n  observeMessages(observer: RawMessageObserver): void;\n  unobserveMessages(observer: RawMessageObserver): void;\n}\n\nexport interface RawMessageObserver {\n  onMessageReceived(message: CDPReceivableMessage): void;\n  onMessageSent(message: CDPCommandRequest<Command>): void;\n}\n"]}