{"version":3,"file":"CSSPropertyParser.js","sourceRoot":"","sources":["../../../../../../front_end/core/sdk/CSSPropertyParser.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2020 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Platform from '../../core/platform/platform.js';\nimport * as CodeMirror from '../../third_party/codemirror.next/codemirror.next.js';\n\nimport {TextMatcher} from './CSSPropertyParserMatchers.js';\n\nconst globalValues = new Set<string>(['inherit', 'initial', 'unset']);\n\nconst tagRegexp = /[\\x20-\\x7E]{4}/;\nconst numRegexp = /[+-]?(?:\\d*\\.)?\\d+(?:[eE]\\d+)?/;\nconst fontVariationSettingsRegexp =\n    new RegExp(`(?:'(${tagRegexp.source})')|(?:\"(${tagRegexp.source})\")\\\\s+(${numRegexp.source})`);\n\n/**\n * Extracts information about font variation settings assuming\n * value is valid according to the spec: https://drafts.csswg.org/css-fonts-4/#font-variation-settings-def\n */\nexport function parseFontVariationSettings(value: string): Array<{\n  tag: string,\n  value: number,\n}> {\n  if (globalValues.has(value.trim()) || value.trim() === 'normal') {\n    return [];\n  }\n  const results = [];\n  for (const setting of splitByComma(stripComments(value))) {\n    const match = setting.match(fontVariationSettingsRegexp);\n    if (match) {\n      results.push({\n        tag: match[1] || match[2],\n        value: parseFloat(match[3]),\n      });\n    }\n  }\n  return results;\n}\n\n// \"str\" or 'str'\nconst fontFamilyRegexp = /^\"(.+)\"|'(.+)'$/;\n\n/**\n * Extracts font families assuming the value is valid according to\n * the spec: https://drafts.csswg.org/css-fonts-4/#font-family-prop\n */\nexport function parseFontFamily(value: string): string[] {\n  if (globalValues.has(value.trim())) {\n    return [];\n  }\n  const results = [];\n  for (const family of splitByComma(stripComments(value))) {\n    const match = family.match(fontFamilyRegexp);\n    if (match) {\n      // Either the 1st or 2nd group matches if the value is in quotes\n      results.push(match[1] || match[2]);\n    } else {\n      // Value without without quotes.\n      results.push(family);\n    }\n  }\n  return results;\n}\n\n/**\n * Splits a list of values by comma and trims parts\n */\nexport function splitByComma(value: string): string[] {\n  return value.split(',').map(part => part.trim());\n}\n\nexport function stripComments(value: string): string {\n  return value.replaceAll(/(\\/\\*(?:.|\\s)*?\\*\\/)/g, '');\n}\n\nfunction nodeText(node: CodeMirror.SyntaxNode, text: string): string {\n  return nodeTextRange(node, node, text);\n}\nfunction nodeTextRange(from: CodeMirror.SyntaxNode, to: CodeMirror.SyntaxNode, text: string): string {\n  return text.substring(from.from, to.to);\n}\n\nexport class SyntaxTree {\n  readonly propertyValue: string;\n  readonly rule: string;\n  readonly tree: CodeMirror.SyntaxNode;\n  readonly trailingNodes: CodeMirror.SyntaxNode[];\n  readonly propertyName: string|undefined;\n  constructor(\n      propertyValue: string, rule: string, tree: CodeMirror.SyntaxNode, propertyName?: string,\n      trailingNodes: CodeMirror.SyntaxNode[] = []) {\n    this.propertyName = propertyName;\n    this.propertyValue = propertyValue;\n    this.rule = rule;\n    this.tree = tree;\n    this.trailingNodes = trailingNodes;\n  }\n\n  text(node?: CodeMirror.SyntaxNode|null): string {\n    if (node === null) {\n      return '';\n    }\n    return nodeText(node ?? this.tree, this.rule);\n  }\n\n  textRange(from: CodeMirror.SyntaxNode|undefined, to: CodeMirror.SyntaxNode|undefined): string {\n    if (!from || !to) {\n      return '';\n    }\n    return nodeTextRange(from, to, this.rule);\n  }\n\n  subtree(node: CodeMirror.SyntaxNode): SyntaxTree {\n    return new SyntaxTree(this.propertyValue, this.rule, node);\n  }\n}\n\nexport interface SyntaxNodeRef {\n  node: CodeMirror.SyntaxNode;\n}\n\nexport abstract class TreeWalker {\n  readonly ast: SyntaxTree;\n  constructor(ast: SyntaxTree) {\n    this.ast = ast;\n  }\n  static walkExcludingSuccessors<T extends TreeWalker, ArgTs extends unknown[]>(\n      this: {new(ast: SyntaxTree, ...args: ArgTs): T}, propertyValue: SyntaxTree, ...args: ArgTs): T {\n    const instance = new this(propertyValue, ...args);\n    if (propertyValue.tree.name === 'Declaration') {\n      instance.iterateDeclaration(propertyValue.tree);\n    } else {\n      instance.iterateExcludingSuccessors(propertyValue.tree);\n    }\n    return instance;\n  }\n  static walk<T extends TreeWalker, ArgTs extends unknown[]>(\n      this: {new(ast: SyntaxTree, ...args: ArgTs): T}, propertyValue: SyntaxTree, ...args: ArgTs): T {\n    const instance = new this(propertyValue, ...args);\n    if (propertyValue.tree.name === 'Declaration') {\n      instance.iterateDeclaration(propertyValue.tree);\n    } else {\n      instance.iterate(propertyValue.tree);\n    }\n    return instance;\n  }\n\n  iterateDeclaration(tree: CodeMirror.SyntaxNode): void {\n    if (tree.name !== 'Declaration') {\n      return;\n    }\n    if (this.enter(tree)) {\n      for (const sibling of ASTUtils.siblings(ASTUtils.declValue(tree))) {\n        sibling.cursor().iterate(this.enter.bind(this), this.leave.bind(this));\n      }\n    }\n    this.leave(tree);\n  }\n\n  protected iterate(tree: CodeMirror.SyntaxNode): void {\n    // Includes siblings of tree.\n    for (const sibling of ASTUtils.siblings(tree)) {\n      sibling.cursor().iterate(this.enter.bind(this), this.leave.bind(this));\n    }\n  }\n\n  protected iterateExcludingSuccessors(tree: CodeMirror.SyntaxNode): void {\n    tree.cursor().iterate(this.enter.bind(this), this.leave.bind(this));\n  }\n\n  protected enter(_node: SyntaxNodeRef): boolean {\n    return true;\n  }\n\n  protected leave(_node: SyntaxNodeRef): void {\n  }\n}\n\nexport interface Match {\n  readonly text: string;\n  readonly node: CodeMirror.SyntaxNode;\n  computedText?(): string|null;\n}\n\nexport interface Matcher<MatchT extends Match> {\n  readonly matchType: Platform.Constructor.ConstructorOrAbstract<MatchT>;\n  accepts(propertyName: string): boolean;\n  matches(node: CodeMirror.SyntaxNode, matching: BottomUpTreeMatching): MatchT|null;\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\nexport function matcherBase<MatchT extends Match>(matchT: Platform.Constructor.ConstructorOrAbstract<MatchT>) {\n  class MatcherBase implements Matcher<MatchT> {\n    matchType = matchT;\n    accepts(_propertyName: string): boolean {\n      return true;\n    }\n\n    matches(_node: CodeMirror.SyntaxNode, _matching: BottomUpTreeMatching): MatchT|null {\n      return null;\n    }\n  }\n  return MatcherBase;\n}\n\ntype MatchKey = Platform.Brand.Brand<string, 'MatchKey'>;\nexport class BottomUpTreeMatching extends TreeWalker {\n  readonly #matchers: Array<Matcher<Match>> = [];\n  readonly #matchedNodes = new Map<MatchKey, Match>();\n  readonly computedText: ComputedText;\n\n  #key(node: CodeMirror.SyntaxNode): MatchKey {\n    return `${node.from}:${node.to}` as MatchKey;\n  }\n\n  constructor(ast: SyntaxTree, matchers: Array<Matcher<Match>>) {\n    super(ast);\n    this.computedText = new ComputedText(ast.rule.substring(ast.tree.from));\n    this.#matchers.push(...matchers.filter(m => !ast.propertyName || m.accepts(ast.propertyName)));\n    this.#matchers.push(new TextMatcher());\n  }\n\n  protected override leave({node}: SyntaxNodeRef): void {\n    for (const matcher of this.#matchers) {\n      const match = matcher.matches(node, this);\n      if (match) {\n        this.computedText.push(match, node.from - this.ast.tree.from);\n        this.#matchedNodes.set(this.#key(node), match);\n        break;\n      }\n    }\n  }\n\n  matchText(node: CodeMirror.SyntaxNode): void {\n    const matchers = this.#matchers.splice(0);\n    this.#matchers.push(new TextMatcher());\n    this.iterateExcludingSuccessors(node);\n    this.#matchers.push(...matchers);\n  }\n\n  hasMatches(...matchTypes: Array<Platform.Constructor.Constructor<Match>>): boolean {\n    return Boolean(this.#matchedNodes.values().find(match => matchTypes.some(matchType => match instanceof matchType)));\n  }\n\n  getMatch(node: CodeMirror.SyntaxNode): Match|undefined {\n    return this.#matchedNodes.get(this.#key(node));\n  }\n\n  hasUnresolvedSubstitutions(node: CodeMirror.SyntaxNode): boolean {\n    return this.hasUnresolvedSubstitutionsRange(node, node);\n  }\n\n  hasUnresolvedSubstitutionsRange(from: CodeMirror.SyntaxNode, to: CodeMirror.SyntaxNode): boolean {\n    return this.computedText.hasUnresolvedSubstitutions(from.from - this.ast.tree.from, to.to - this.ast.tree.from);\n  }\n\n  getComputedText(node: CodeMirror.SyntaxNode, substitutionHook?: (match: Match) => string | null): string {\n    return this.getComputedTextRange(node, node, substitutionHook);\n  }\n\n  getLonghandValuesCount(): number {\n    const [from, to] = ASTUtils.range(ASTUtils.siblings(ASTUtils.declValue(this.ast.tree)));\n    if (!from || !to) {\n      return 0;\n    }\n    return this.computedText.countTopLevelValues(from.from - this.ast.tree.from, to.to - this.ast.tree.from);\n  }\n\n  getComputedLonghandName(to: CodeMirror.SyntaxNode): number {\n    const from = ASTUtils.declValue(this.ast.tree) ?? this.ast.tree;\n    return this.computedText.countTopLevelValues(from.from - this.ast.tree.from, to.from - this.ast.tree.from);\n  }\n\n  getComputedPropertyValueText(substitutionHook?: (match: Match) => string | null): string {\n    const [from, to] = ASTUtils.range(ASTUtils.siblings(ASTUtils.declValue(this.ast.tree)));\n    return this.getComputedTextRange(from ?? this.ast.tree, to ?? this.ast.tree, substitutionHook);\n  }\n\n  getComputedTextRange(\n      from: CodeMirror.SyntaxNode|undefined, to: CodeMirror.SyntaxNode|undefined,\n      substitutionHook?: (match: Match) => string | null): string {\n    if (!from || !to) {\n      return '';\n    }\n    return this.computedText.get(from.from - this.ast.tree.from, to.to - this.ast.tree.from, substitutionHook);\n  }\n}\n\ntype MatchWithComputedText = Match&{computedText: NonNullable<Match['computedText']>};\nclass ComputedTextChunk {\n  #cachedComputedText: string|null = null;\n  #topLevelValueCount: number|null = null;\n  constructor(readonly match: MatchWithComputedText, readonly offset: number) {\n  }\n\n  get end(): number {\n    return this.offset + this.length;\n  }\n\n  get length(): number {\n    return this.match.text.length;\n  }\n\n  get computedText(): string|null {\n    if (this.#cachedComputedText === null) {\n      this.#cachedComputedText = this.match.computedText();\n    }\n    return this.#cachedComputedText;\n  }\n\n  // If the match is top-level, i.e. is an outermost sub-expression in the property value, count the number of outermost\n  // sub-expressions after applying any potential substitutions.\n  get topLevelValueCount(): number {\n    if (this.match.node.parent?.name !== 'Declaration') {\n      // Not a top-level match.\n      return 0;\n    }\n    const computedText = this.computedText;\n    if (computedText === '') {\n      // Substitutions elided the match altogether.\n      return 0;\n    }\n    if (this.#topLevelValueCount === null) {\n      // computedText may be null, in which case the match text was not replaced.\n      this.#topLevelValueCount =\n          ASTUtils\n              .siblings(ASTUtils.declValue(tokenizeDeclaration('--p', computedText ?? this.match.text)?.tree ?? null))\n              .length;\n    }\n    return this.#topLevelValueCount;\n  }\n}\n\n/**\n * This class constructs the \"computed\" text from the input property text, i.e., it will strip comments and substitute\n * var() functions if possible. It's intended for use during the bottom-up tree matching process. The original text is\n * not modified. Instead, computed text slices are produced on the fly. During bottom-up matching, the sequence of\n * top-level comments and var() matches will be recorded. This produces an ordered sequence of text pieces that need to\n * be substituted into the original text. When a computed text slice is requested, it is generated by piecing together\n * original and computed slices as required.\n **/\nexport class ComputedText {\n  readonly #chunks: ComputedTextChunk[] = [];\n  readonly text: string;\n  readonly #topLevelValueCounts = new Map<string, number>();\n\n  #sorted = true;\n  constructor(text: string) {\n    this.text = text;\n  }\n\n  clear(): void {\n    this.#chunks.splice(0);\n    this.#topLevelValueCounts.clear();\n  }\n\n  get chunkCount(): number {\n    return this.#chunks.length;\n  }\n\n  #sortIfNecessary(): void {\n    if (this.#sorted) {\n      return;\n    }\n    // Sort intervals by offset, with longer intervals first if the offset is identical.\n    this.#chunks.sort((a, b) => {\n      if (a.offset < b.offset) {\n        return -1;\n      }\n      if (b.offset < a.offset) {\n        return 1;\n      }\n      if (a.end > b.end) {\n        return -1;\n      }\n      if (a.end < b.end) {\n        return 1;\n      }\n      return 0;\n    });\n    this.#sorted = true;\n  }\n\n  // Add another substitutable match. The match will either be appended to the list of existing matches or it will\n  // be substituted for the last match(es) if it encompasses them.\n  push(match: Match, offset: number): void {\n    function hasComputedText(match: Match): match is MatchWithComputedText {\n      return Boolean(match.computedText);\n    }\n    if (!hasComputedText(match) || offset < 0 || offset >= this.text.length) {\n      return;\n    }\n    const chunk = new ComputedTextChunk(match, offset);\n    if (chunk.end > this.text.length) {\n      return;\n    }\n    this.#sorted = false;\n    this.#chunks.push(chunk);\n  }\n\n  * #range(begin: number, end: number): Generator<ComputedTextChunk> {\n    this.#sortIfNecessary();\n    let i = this.#chunks.findIndex(c => c.offset >= begin);\n    while (i >= 0 && i < this.#chunks.length && this.#chunks[i].end > begin && begin < end) {\n      if (this.#chunks[i].end > end) {\n        i++;\n        continue;\n      }\n      yield this.#chunks[i];\n      begin = this.#chunks[i].end;\n      while (begin < end && i < this.#chunks.length && this.#chunks[i].offset < begin) {\n        i++;\n      }\n    }\n  }\n\n  hasUnresolvedSubstitutions(begin: number, end: number): boolean {\n    for (const chunk of this.#range(begin, end)) {\n      if (chunk.computedText === null) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  * #getPieces(begin: number, end: number): Generator<string|ComputedTextChunk> {\n    for (const chunk of this.#range(begin, end)) {\n      const piece = this.text.substring(begin, Math.min(chunk.offset, end));\n      yield piece;\n      if (end >= chunk.end) {\n        yield chunk;\n      }\n      begin = chunk.end;\n    }\n    if (begin < end) {\n      const piece = this.text.substring(begin, end);\n      yield piece;\n    }\n  }\n\n  // Get a slice of the computed text corresponding to the property text in the range [begin, end). The slice may not\n  // start within a substitution chunk, e.g., it's invalid to request the computed text for the property value text\n  // slice \"1px var(--\".\n  get(begin: number, end: number, substitutionHook?: (match: Match) => string | null): string {\n    const pieces: string[] = [];\n    const getText = (piece: string|ComputedTextChunk): string => {\n      if (typeof piece === 'string') {\n        return piece;\n      }\n      const substitution = substitutionHook?.(piece.match) ?? null;\n      if (substitution !== null) {\n        return getText(substitution);\n      }\n      return piece.computedText ?? piece.match.text;\n    };\n\n    for (const piece of this.#getPieces(begin, end)) {\n      const text = getText(piece);\n      if (text.length === 0) {\n        continue;\n      }\n      if (pieces.length > 0 && requiresSpace(pieces[pieces.length - 1], text)) {\n        pieces.push(' ');\n      }\n      pieces.push(text);\n    }\n    return pieces.join('');\n  }\n\n  #countTopLevelValuesInStringPiece(piece: string): number {\n    let count = this.#topLevelValueCounts.get(piece);\n    if (count === undefined) {\n      count = ASTUtils.siblings(ASTUtils.declValue(tokenizeDeclaration('--p', piece)?.tree ?? null)).length;\n      this.#topLevelValueCounts.set(piece, count);\n    }\n    return count;\n  }\n\n  countTopLevelValues(begin: number, end: number): number {\n    const pieces = Array.from(this.#getPieces(begin, end));\n    const counts = pieces.map(\n        chunk =>\n            (chunk instanceof ComputedTextChunk ? chunk.topLevelValueCount :\n                                                  this.#countTopLevelValuesInStringPiece(chunk)));\n    const count = counts.reduce((sum, v) => sum + v, 0);\n    return count;\n  }\n}\n\n/**\n * This function determines whether concatenating two pieces of text requires any spacing in between. For example, there\n * shouldn't be any space between 'var' and '(', but there should be a space between '1px' and 'solid'. The node\n * sequences that make up the pieces of text may contain non-text nodes/trees. Any such element in between the texts is\n * ignored for the spacing requirement.\n **/\nexport function requiresSpace(a: string, b: string): boolean;\nexport function requiresSpace(a: Node[], b: Node[]): boolean;\nexport function requiresSpace(a: Node[]|string|undefined, b: Node[]|string|undefined): boolean {\n  const tail = Array.isArray(a) ? a.findLast(node => node.textContent)?.textContent : a;\n  const head = Array.isArray(b) ? b.find(node => node.textContent)?.textContent : b;\n  const trailingChar = tail ? tail[tail.length - 1] : '';\n  const leadingChar = head ? head[0] : '';\n\n  const noSpaceAfter = ['', '(', '{', '}', ';', '['];\n  const noSpaceBefore = ['', '(', ')', ',', ':', '*', '{', ';', ']'];\n  return !/\\s/.test(trailingChar) && !/\\s/.test(leadingChar) && !noSpaceAfter.includes(trailingChar) &&\n      !noSpaceBefore.includes(leadingChar);\n}\n\nexport const CSSControlMap = Map<string, HTMLElement[]>;\nexport type CSSControlMap = Map<string, HTMLElement[]>;\nexport namespace ASTUtils {\n  export function siblings(node: CodeMirror.SyntaxNode|null): CodeMirror.SyntaxNode[] {\n    const result = [];\n    while (node) {\n      result.push(node);\n      node = node.nextSibling;\n    }\n    return result;\n  }\n\n  export function children(node: CodeMirror.SyntaxNode|null): CodeMirror.SyntaxNode[] {\n    return siblings(node?.firstChild ?? null);\n  }\n\n  export function range(node: CodeMirror.SyntaxNode[]):\n      [CodeMirror.SyntaxNode|undefined, CodeMirror.SyntaxNode|undefined] {\n    return [node[0], node[node.length - 1]];\n  }\n\n  export function declValue(node: CodeMirror.SyntaxNode|null): CodeMirror.SyntaxNode|null {\n    if (node?.name !== 'Declaration') {\n      return null;\n    }\n    return children(node).find(node => node.name === ':')?.nextSibling ?? null;\n  }\n\n  export function* stripComments(nodes: CodeMirror.SyntaxNode[]): Generator<CodeMirror.SyntaxNode> {\n    for (const node of nodes) {\n      if (node.type.name !== 'Comment') {\n        yield node;\n      }\n    }\n  }\n\n  export function split(nodes: CodeMirror.SyntaxNode[]): CodeMirror.SyntaxNode[][] {\n    const result = [];\n    let current = [];\n    for (const node of nodes) {\n      if (node.name === ',') {\n        result.push(current);\n        current = [];\n      } else {\n        current.push(node);\n      }\n    }\n    if (nodes.length > 0) {\n      result.push(current);\n    }\n    return result;\n  }\n\n  export function callArgs(node: CodeMirror.SyntaxNode|null): CodeMirror.SyntaxNode[][] {\n    const args = children(node?.getChild('ArgList') ?? null);\n    const openParen = args.splice(0, 1)[0];\n    const closingParen = args.pop();\n\n    if (openParen?.name !== '(' || closingParen?.name !== ')') {\n      return [];\n    }\n\n    return split(args);\n  }\n\n  export function equals(a: CodeMirror.SyntaxNode, b: CodeMirror.SyntaxNode): boolean {\n    return a.name === b.name && a.from === b.from && a.to === b.to;\n  }\n}\n\nfunction declaration(rule: string): CodeMirror.SyntaxNode|null {\n  const cssParser = CodeMirror.css.cssLanguage.parser;\n  return cssParser.parse(rule).topNode.getChild('RuleSet')?.getChild('Block')?.getChild('Declaration') ?? null;\n}\n\nexport function tokenizeDeclaration(propertyName: string, propertyValue: string): SyntaxTree|null {\n  const name = tokenizePropertyName(propertyName);\n  if (!name) {\n    return null;\n  }\n  const rule = `*{${name}: ${propertyValue};}`;\n  const decl = declaration(rule);\n  if (!decl || decl.type.isError) {\n    return null;\n  }\n\n  const childNodes = ASTUtils.children(decl);\n  if (childNodes.length < 2) {\n    return null;\n  }\n  const [varName, colon, tree] = childNodes;\n  if (!varName || varName.type.isError || !colon || colon.type.isError || tree?.type.isError) {\n    return null;\n  }\n\n  // It's possible that there are nodes following the declaration when there are comments or syntax errors. We want to\n  // render any comments, so pick up any trailing nodes following the declaration excluding the final semicolon and\n  // brace.\n  const trailingNodes = ASTUtils.siblings(decl).slice(1);\n  const [semicolon, brace] = trailingNodes.splice(trailingNodes.length - 2, 2);\n  if (semicolon?.name !== ';' && brace?.name !== '}') {\n    return null;\n  }\n\n  const ast = new SyntaxTree(propertyValue, rule, decl, name, trailingNodes);\n  if (ast.text(varName) !== name || colon.name !== ':') {\n    return null;\n  }\n  return ast;\n}\n\nexport function tokenizePropertyName(name: string): string|null {\n  const rule = `*{${name}: inherit;}`;\n  const decl = declaration(rule);\n  if (!decl || decl.type.isError) {\n    return null;\n  }\n\n  const propertyName = decl.getChild('PropertyName') ?? decl.getChild('VariableName');\n  if (!propertyName) {\n    return null;\n  }\n\n  return nodeText(propertyName, rule);\n}\n\nexport function matchDeclaration(name: string, value: string, matchers: Array<Matcher<Match>>): BottomUpTreeMatching|\n    null {\n  const ast = tokenizeDeclaration(name, value);\n  const matchedResult = ast && BottomUpTreeMatching.walk(ast, matchers);\n  ast?.trailingNodes.forEach(n => matchedResult?.matchText(n));\n  return matchedResult;\n}\n\nexport class TreeSearch extends TreeWalker {\n  #found: CodeMirror.SyntaxNode|null = null;\n  #predicate: (node: CodeMirror.SyntaxNode) => boolean;\n\n  constructor(ast: SyntaxTree, predicate: (node: CodeMirror.SyntaxNode) => boolean) {\n    super(ast);\n    this.#predicate = predicate;\n  }\n\n  protected override enter({node}: SyntaxNodeRef): boolean {\n    if (this.#found) {\n      return false;\n    }\n\n    if (this.#predicate(node)) {\n      this.#found = this.#found ?? node;\n      return false;\n    }\n    return true;\n  }\n\n  static find(ast: SyntaxTree, predicate: (node: CodeMirror.SyntaxNode) => boolean): CodeMirror.SyntaxNode|null {\n    return TreeSearch.walk(ast, predicate).#found;\n  }\n\n  static findAll(ast: SyntaxTree, predicate: (node: CodeMirror.SyntaxNode) => boolean): CodeMirror.SyntaxNode[] {\n    const foundNodes: CodeMirror.SyntaxNode[] = [];\n    TreeSearch.walk(ast, (node: CodeMirror.SyntaxNode) => {\n      if (predicate(node)) {\n        foundNodes.push(node);\n      }\n\n      return false;\n    });\n    return foundNodes;\n  }\n}\n"]}