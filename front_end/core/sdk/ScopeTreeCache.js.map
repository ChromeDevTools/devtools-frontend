{"version":3,"file":"ScopeTreeCache.js","sourceRoot":"","sources":["../../../../../../front_end/core/sdk/ScopeTreeCache.ts"],"names":[],"mappings":"AAAA,sCAAsC;AACtC,yEAAyE;AACzE,6BAA6B;AAE7B,OAAO,KAAK,SAAS,MAAM,qCAAqC,CAAC;AACjE,OAAO,KAAK,SAAS,MAAM,uCAAuC,CAAC;AAOnE,4FAA4F;AAC5F,MAAM,UAAU,GAAG,IAAI,OAAO,EAAgE,CAAC;AAE/F;;;;;;;;;;GAUG;AACH,MAAM,UAAU,kBAAkB,CAAC,MAAc;IAC/C,IAAI,OAAO,GAAG,UAAU,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;IACrC,IAAI,OAAO,KAAK,SAAS,EAAE,CAAC;QAC1B,OAAO,GAAG,MAAM,CAAC,kBAAkB,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE;YACnD,IAAI,SAAS,CAAC,WAAW,CAAC,WAAW,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC;gBACvD,OAAO,IAAI,CAAC;YACd,CAAC;YAED,MAAM,UAAU,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,QAAQ,CAAC;YACzD,OAAO,SAAS,CAAC,mBAAmB,CAAC,mBAAmB,EAAE;iBACrD,mBAAmB,CAAC,OAAO,CAAC,IAAI,EAAE,UAAU,CAAC;iBAC7C,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,EAAC,SAAS,EAAE,IAAI,EAAE,OAAO,CAAC,OAAO,EAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;iBAC1E,KAAK,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,CAAC;QACzB,CAAC,CAAC,CAAC;QACH,UAAU,CAAC,GAAG,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;IAClC,CAAC;IACD,kFAAkF;IAClF,OAAO,OAAO,CAAC;AACjB,CAAC","sourcesContent":["// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Formatter from '../../models/formatter/formatter.js';\nimport * as TextUtils from '../../models/text_utils/text_utils.js';\n\nimport type {Script} from './Script.js';\n\ntype ScopeTreeNode = Formatter.FormatterWorkerPool.ScopeTreeNode;\ntype Text = TextUtils.Text.Text;\n\n/** If a script failed to parse, we stash null in order to prevent unnecessary re-parsing */\nconst scopeTrees = new WeakMap<Script, Promise<{scopeTree: ScopeTreeNode, text: Text}|null>>();\n\n/**\n * Computes and caches the scope tree for `script`.\n *\n * We use {@link Script} as a key to uniquely identify scripts.\n * {@link Script} boils down to \"target\" + \"script ID\". This\n * duplicates work in case of identical script running on multiple targets\n * (e.g. workers).\n *\n * We also return a {@link TextUtils.Text.Text} instance. The scope tree uses offsets\n * and the text allows conversion from/to line/column numbers.\n */\nexport function scopeTreeForScript(script: Script): Promise<{scopeTree: ScopeTreeNode, text: Text}|null> {\n  let promise = scopeTrees.get(script);\n  if (promise === undefined) {\n    promise = script.requestContentData().then(content => {\n      if (TextUtils.ContentData.ContentData.isError(content)) {\n        return null;\n      }\n\n      const sourceType = script.isModule ? 'module' : 'script';\n      return Formatter.FormatterWorkerPool.formatterWorkerPool()\n          .javaScriptScopeTree(content.text, sourceType)\n          .then(scopeTree => scopeTree ? ({scopeTree, text: content.textObj}) : null)\n          .catch(() => null);\n    });\n    scopeTrees.set(script, promise);\n  }\n  // We intentionally return `null` here if the script already failed to parse once.\n  return promise;\n}\n"]}