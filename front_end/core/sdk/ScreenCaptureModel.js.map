{"version":3,"file":"ScreenCaptureModel.js","sourceRoot":"","sources":["../../../../../../front_end/core/sdk/ScreenCaptureModel.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2017 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as ProtocolProxyApi from '../../generated/protocol-proxy-api.js';\nimport type * as Protocol from '../../generated/protocol.js';\n\nimport {OverlayModel} from './OverlayModel.js';\nimport {SDKModel} from './SDKModel.js';\nimport {Capability, type Target} from './Target.js';\n\nexport const enum ScreenshotMode {\n  FROM_VIEWPORT = 'fromViewport',\n  FROM_CLIP = 'fromClip',\n  FULLPAGE = 'fullpage',\n}\n\n/**\n * This structure holds a specific `startScreencast` request's parameters\n * and its callbacks so that they can be re-started if needed.\n **/\ninterface ScreencastOperation {\n  id: number;\n  request: {\n    format: Protocol.Page.StartScreencastRequestFormat,\n    quality: number,\n    maxWidth: number|undefined,\n    maxHeight: number|undefined,\n    everyNthFrame: number|undefined,\n  };\n  callbacks: {\n    onScreencastFrame: ScreencastFrameCallback,\n    onScreencastVisibilityChanged: ScreencastVisibilityChangedCallback,\n  };\n}\n\ntype ScreencastFrameCallback = ((arg0: Protocol.binary, arg1: Protocol.Page.ScreencastFrameMetadata) => void);\ntype ScreencastVisibilityChangedCallback = ((arg0: boolean) => void);\n\n/**\n * Manages concurrent screencast requests by queuing and prioritizing.\n *\n * When startScreencast is invoked:\n * - If a screencast is currently active, the existing screencast's parameters and callbacks are\n * saved in the #screencastOperations array.\n * - The active screencast is then stopped.\n * - A new screencast is initiated using the parameters and callbacks from the current startScreencast call.\n *\n * When stopScreencast is invoked:\n * - The currently active screencast is stopped.\n * - The #screencastOperations is checked for interrupted screencast operations.\n * - If any operations are found, the latest one is started\n * using its saved parameters and callbacks.\n *\n * This ensures that:\n * - Only one screencast is active at a time.\n * - Interrupted screencasts are resumed after the current screencast is stopped.\n * This ensures animation previews, which use screencasting, don't disrupt ongoing remote debugging sessions. Without this mechanism, stopping a preview screencast would terminate the debugging screencast, freezing the ScreencastView.\n **/\nexport class ScreenCaptureModel extends SDKModel<void> implements ProtocolProxyApi.PageDispatcher {\n  readonly #agent: ProtocolProxyApi.PageApi;\n  #nextScreencastOperationId = 1;\n  #screencastOperations: ScreencastOperation[] = [];\n  constructor(target: Target) {\n    super(target);\n    this.#agent = target.pageAgent();\n    target.registerPageDispatcher(this);\n  }\n\n  async startScreencast(\n      format: Protocol.Page.StartScreencastRequestFormat, quality: number, maxWidth: number|undefined,\n      maxHeight: number|undefined, everyNthFrame: number|undefined, onFrame: ScreencastFrameCallback,\n      onVisibilityChanged: ScreencastVisibilityChangedCallback): Promise<number> {\n    const currentRequest = this.#screencastOperations.at(-1);\n    if (currentRequest) {\n      // If there already is a screencast operation in progress, we need to stop it now and handle the\n      // incoming request. Once that request is stopped, we'll return back to handling the stopped operation.\n      await this.#agent.invoke_stopScreencast();\n    }\n\n    const operation = {\n      id: this.#nextScreencastOperationId++,\n      request: {\n        format,\n        quality,\n        maxWidth,\n        maxHeight,\n        everyNthFrame,\n      },\n      callbacks: {\n        onScreencastFrame: onFrame,\n        onScreencastVisibilityChanged: onVisibilityChanged,\n      }\n    };\n    this.#screencastOperations.push(operation);\n    void this.#agent.invoke_startScreencast({format, quality, maxWidth, maxHeight, everyNthFrame});\n\n    return operation.id;\n  }\n\n  stopScreencast(id: number): void {\n    const operationToStop = this.#screencastOperations.pop();\n    if (!operationToStop) {\n      throw new Error('There is no screencast operation to stop.');\n    }\n\n    if (operationToStop.id !== id) {\n      throw new Error('Trying to stop a screencast operation that is not being served right now.');\n    }\n    void this.#agent.invoke_stopScreencast();\n\n    // The latest operation is concluded, let's return back to the previous request now, if it exists.\n    const nextOperation = this.#screencastOperations.at(-1);\n    if (nextOperation) {\n      void this.#agent.invoke_startScreencast({\n        format: nextOperation.request.format,\n        quality: nextOperation.request.quality,\n        maxWidth: nextOperation.request.maxWidth,\n        maxHeight: nextOperation.request.maxHeight,\n        everyNthFrame: nextOperation.request.everyNthFrame,\n      });\n    }\n  }\n\n  async captureScreenshot(\n      format: Protocol.Page.CaptureScreenshotRequestFormat, quality: number, mode: ScreenshotMode,\n      clip?: Protocol.Page.Viewport): Promise<string|null> {\n    const properties: Protocol.Page.CaptureScreenshotRequest = {\n      format,\n      quality,\n      fromSurface: true,\n    };\n    switch (mode) {\n      case ScreenshotMode.FROM_CLIP:\n        properties.captureBeyondViewport = true;\n        properties.clip = clip;\n        break;\n      case ScreenshotMode.FULLPAGE:\n        properties.captureBeyondViewport = true;\n        break;\n      case ScreenshotMode.FROM_VIEWPORT:\n        properties.captureBeyondViewport = false;\n        break;\n      default:\n        throw new Error('Unexpected or unspecified screnshotMode');\n    }\n\n    await OverlayModel.muteHighlight();\n    const result = await this.#agent.invoke_captureScreenshot(properties);\n    await OverlayModel.unmuteHighlight();\n    return result.data;\n  }\n\n  screencastFrame({data, metadata, sessionId}: Protocol.Page.ScreencastFrameEvent): void {\n    void this.#agent.invoke_screencastFrameAck({sessionId});\n\n    const currentRequest = this.#screencastOperations.at(-1);\n    if (currentRequest) {\n      currentRequest.callbacks.onScreencastFrame.call(null, data, metadata);\n    }\n  }\n\n  screencastVisibilityChanged({visible}: Protocol.Page.ScreencastVisibilityChangedEvent): void {\n    const currentRequest = this.#screencastOperations.at(-1);\n    if (currentRequest) {\n      currentRequest.callbacks.onScreencastVisibilityChanged.call(null, visible);\n    }\n  }\n\n  backForwardCacheNotUsed(_params: Protocol.Page.BackForwardCacheNotUsedEvent): void {\n  }\n\n  domContentEventFired(_params: Protocol.Page.DomContentEventFiredEvent): void {\n  }\n\n  loadEventFired(_params: Protocol.Page.LoadEventFiredEvent): void {\n  }\n\n  lifecycleEvent(_params: Protocol.Page.LifecycleEventEvent): void {\n  }\n\n  navigatedWithinDocument(_params: Protocol.Page.NavigatedWithinDocumentEvent): void {\n  }\n\n  frameAttached(_params: Protocol.Page.FrameAttachedEvent): void {\n  }\n\n  frameNavigated(_params: Protocol.Page.FrameNavigatedEvent): void {\n  }\n\n  documentOpened(_params: Protocol.Page.DocumentOpenedEvent): void {\n  }\n\n  frameDetached(_params: Protocol.Page.FrameDetachedEvent): void {\n  }\n\n  frameStartedLoading(_params: Protocol.Page.FrameStartedLoadingEvent): void {\n  }\n\n  frameStoppedLoading(_params: Protocol.Page.FrameStoppedLoadingEvent): void {\n  }\n\n  frameRequestedNavigation(_params: Protocol.Page.FrameRequestedNavigationEvent): void {\n  }\n\n  frameStartedNavigating(_params: Protocol.Page.FrameStartedNavigatingEvent): void {\n  }\n\n  frameSubtreeWillBeDetached(_params: Protocol.Page.FrameSubtreeWillBeDetachedEvent): void {\n  }\n\n  frameScheduledNavigation(_params: Protocol.Page.FrameScheduledNavigationEvent): void {\n  }\n\n  frameClearedScheduledNavigation(_params: Protocol.Page.FrameClearedScheduledNavigationEvent): void {\n  }\n\n  frameResized(): void {\n  }\n\n  javascriptDialogOpening(_params: Protocol.Page.JavascriptDialogOpeningEvent): void {\n  }\n\n  javascriptDialogClosed(_params: Protocol.Page.JavascriptDialogClosedEvent): void {\n  }\n\n  interstitialShown(): void {\n  }\n\n  interstitialHidden(): void {\n  }\n\n  windowOpen(_params: Protocol.Page.WindowOpenEvent): void {\n  }\n\n  fileChooserOpened(_params: Protocol.Page.FileChooserOpenedEvent): void {\n  }\n\n  compilationCacheProduced(_params: Protocol.Page.CompilationCacheProducedEvent): void {\n  }\n\n  downloadWillBegin(_params: Protocol.Page.DownloadWillBeginEvent): void {\n  }\n\n  downloadProgress(): void {\n  }\n\n  prefetchStatusUpdated(_params: Protocol.Preload.PrefetchStatusUpdatedEvent): void {\n  }\n\n  prerenderStatusUpdated(_params: Protocol.Preload.PrerenderStatusUpdatedEvent): void {\n  }\n}\n\nSDKModel.register(ScreenCaptureModel, {capabilities: Capability.SCREEN_CAPTURE, autostart: false});\n"]}