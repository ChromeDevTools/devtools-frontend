{"version":3,"file":"ServerSentEvents.js","sourceRoot":"","sources":["../../../../../../front_end/core/sdk/ServerSentEvents.ts"],"names":[],"mappings":"AAAA,sCAAsC;AACtC,yEAAyE;AACzE,6BAA6B;AAE7B,OAAO,KAAK,SAAS,MAAM,uCAAuC,CAAC;AAEnE,OAAO,EAAC,MAAM,EAA+C,MAAM,qBAAqB,CAAC;AACzF,OAAO,EAAC,sBAAsB,EAAC,MAAM,+BAA+B,CAAC;AAErE;;;;;;;;;GASG;AACH,MAAM,OAAO,gBAAgB;IAClB,QAAQ,CAAiB;IACzB,OAAO,CAA0B;IAE1C,6FAA6F;IAC7F,6EAA6E;IAC7E,qBAAqB,GAAG,CAAC,CAAC;IAEjB,oBAAoB,GAAyB,EAAE,CAAC;IAEzD,YAAY,OAAuB,EAAE,qBAA8B;QACjE,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QAExB,mEAAmE;QACnE,IAAI,qBAAqB,EAAE,CAAC;YAC1B,IAAI,CAAC,qBAAqB,GAAG,OAAO,CAAC,cAAc,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;YACvE,IAAI,CAAC,OAAO,GAAG,IAAI,sBAAsB,CAAC,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,OAAO,CAAC,OAAO,EAAE,IAAI,SAAS,CAAC,CAAC;YAE1G,uFAAuF;YACvF,yBAAyB;YACzB,KAAK,IAAI,CAAC,QAAQ,CAAC,uBAAuB,EAAE,CAAC,IAAI,CAAC,oBAAoB,CAAC,EAAE;gBACvE,IAAI,CAAC,SAAS,CAAC,oBAAoB,CAAC,OAAO,CAAC,oBAAoB,CAAC,EAAE,CAAC;oBAClE,KAAK,IAAI,CAAC,OAAO,EAAE,cAAc,CAAC,oBAAoB,CAAC,OAAO,EAAE,CAAC,MAAM,CAAC,CAAC;oBACzE,oBAAoB,CAAC,gBAAgB,uEACkB,CAAC,EAAC,IAAI,EAAE,EAAC,KAAK,EAAC,EAAC,EAAE,EAAE;wBACrE,IAAI,CAAC,qBAAqB,GAAG,OAAO,CAAC,cAAc,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;wBACrE,KAAK,IAAI,CAAC,OAAO,EAAE,cAAc,CAAC,KAAK,CAAC,CAAC;oBAC3C,CAAC,CAAC,CAAC;gBACT,CAAC;YACH,CAAC,CAAC,CAAC;QACL,CAAC;IACH,CAAC;IAED,IAAI,mBAAmB;QACrB,OAAO,IAAI,CAAC,oBAAoB,CAAC;IACnC,CAAC;IAED,oDAAoD;IACpD,oCAAoC,CAAC,SAAiB,EAAE,IAAY,EAAE,OAAe,EAAE,IAAY;QACjG,IAAI,CAAC,8BAA8B,CAAC;YAClC,SAAS;YACT,OAAO;YACP,IAAI;YACJ,IAAI;SACL,CAAC,CAAC;IACL,CAAC;IAED,cAAc,CAAC,SAAiB,EAAE,IAAY,EAAE,OAAe;QAC7D,IAAI,CAAC,8BAA8B,CAAC;YAClC,SAAS;YACT,OAAO;YACP,IAAI;YACJ,IAAI,EAAE,IAAI,CAAC,qBAAqB;SACjC,CAAC,CAAC;IACL,CAAC;IAED,8BAA8B,CAAC,OAA2B;QACxD,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QACxC,IAAI,CAAC,QAAQ,CAAC,wBAAwB,CAAC,MAAM,CAAC,0BAA0B,EAAE,OAAO,CAAC,CAAC;IACrF,CAAC;CACF","sourcesContent":["// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as TextUtils from '../../models/text_utils/text_utils.js';\n\nimport {Events, type EventSourceMessage, type NetworkRequest} from './NetworkRequest.js';\nimport {ServerSentEventsParser} from './ServerSentEventsProtocol.js';\n\n/**\n * Server sent events only arrive via CDP (Explicit Network.eventSourceMessageReceived) when\n * the page uses \"EventSource\" in the code.\n *\n * If the page manually uses 'fetch' or XHR we have to do the protocol parsing\n * ourselves.\n *\n * `ServerSentEvents` is a small helper class that manages this distinction for a specific\n * request, stores the event data and sends out \"EventSourceMessageAdded\" events for a request.\n */\nexport class ServerSentEvents {\n  readonly #request: NetworkRequest;\n  readonly #parser?: ServerSentEventsParser;\n\n  // In the case where we parse the events ourselves we use the time of the last 'dataReceived'\n  // event for all the events that come out of the corresponding chunk of data.\n  #lastDataReceivedTime = 0;\n\n  readonly #eventSourceMessages: EventSourceMessage[] = [];\n\n  constructor(request: NetworkRequest, parseFromStreamedData: boolean) {\n    this.#request = request;\n\n    // Only setup parsing if we don't get the events over CDP directly.\n    if (parseFromStreamedData) {\n      this.#lastDataReceivedTime = request.pseudoWallTime(request.startTime);\n      this.#parser = new ServerSentEventsParser(this.#onParserEvent.bind(this), request.charset() ?? undefined);\n\n      // Get the streaming content and add the already received bytes if someone else started\n      // the streaming earlier.\n      void this.#request.requestStreamingContent().then(streamingContentData => {\n        if (!TextUtils.StreamingContentData.isError(streamingContentData)) {\n          void this.#parser?.addBase64Chunk(streamingContentData.content().base64);\n          streamingContentData.addEventListener(\n              TextUtils.StreamingContentData.Events.CHUNK_ADDED, ({data: {chunk}}) => {\n                this.#lastDataReceivedTime = request.pseudoWallTime(request.endTime);\n                void this.#parser?.addBase64Chunk(chunk);\n              });\n        }\n      });\n    }\n  }\n\n  get eventSourceMessages(): readonly EventSourceMessage[] {\n    return this.#eventSourceMessages;\n  }\n\n  /** Forwarded Network.eventSourceMessage received */\n  onProtocolEventSourceMessageReceived(eventName: string, data: string, eventId: string, time: number): void {\n    this.#recordMessageAndDispatchEvent({\n      eventName,\n      eventId,\n      data,\n      time,\n    });\n  }\n\n  #onParserEvent(eventName: string, data: string, eventId: string): void {\n    this.#recordMessageAndDispatchEvent({\n      eventName,\n      eventId,\n      data,\n      time: this.#lastDataReceivedTime,\n    });\n  }\n\n  #recordMessageAndDispatchEvent(message: EventSourceMessage): void {\n    this.#eventSourceMessages.push(message);\n    this.#request.dispatchEventToListeners(Events.EVENT_SOURCE_MESSAGE_ADDED, message);\n  }\n}\n"]}