{"version":3,"file":"SourceMapFunctionRanges.js","sourceRoot":"","sources":["../../../../../../front_end/core/sdk/SourceMapFunctionRanges.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2025 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as ScopesCodec from '../../third_party/source-map-scopes-codec/source-map-scopes-codec.js';\n\nimport {TokenIterator} from './SourceMap.js';\n\nexport interface NamedFunctionRange {\n  start: ScopesCodec.Position;\n  end: ScopesCodec.Position;\n  name: string;\n}\n\n/**\n * Turns a list of {@link NamedFunctionRange}s into a single {@link OriginalScope} tree nested\n * according to the start/end position. Each range is turned into a OriginalScope with the `isStackFrame`\n * bit set to denote it as a function and a generic \"Function\" label.\n *\n * We nest all these function scopes underneath a single global scope that always starts at (0, 0) and\n * reaches to the largest end position.\n *\n * `ranges` can be unsorted but will be sorted in-place.\n *\n * @throws if the ranges are not nested properly. Concretely: start < end for each range, and no\n * \"straddling\" (i.e. partially overlapping ranges).\n */\nexport function buildOriginalScopes(ranges: NamedFunctionRange[]): ScopesCodec.OriginalScope {\n  validateStartBeforeEnd(ranges);\n\n  // 1. Sort ranges by ascending start position.\n  //    If two ranges have the same start position, we sort the one\n  //    with the higher end position first, because it's the parent.\n  ranges.sort((a, b) => comparePositions(a.start, b.start) || comparePositions(b.end, a.end));\n\n  const root: ScopesCodec.OriginalScope = {\n    start: {line: 0, column: 0},\n    end: {line: Number.POSITIVE_INFINITY, column: Number.POSITIVE_INFINITY},\n    kind: 'Global',\n    isStackFrame: false,\n    children: [],\n    variables: [],\n  };\n\n  // 2. Build the tree from the ranges.\n  const stack: ScopesCodec.OriginalScope[] = [root];\n  for (const range of ranges) {\n    // Pop all scopes that precede the current entry (to find the right parent).\n    let stackTop = stack.at(-1) as ScopesCodec.OriginalScope;\n    while (true) {\n      if (comparePositions(stackTop.end, range.start) <= 0) {\n        stack.pop();\n        stackTop = stack.at(-1) as ScopesCodec.OriginalScope;\n      } else {\n        break;\n      }\n    }\n\n    /*\n     * Check for partially overlapping ranges:\n     *\n     * --- A\n     *  |  --- B\n     * ---  |\n     *     ---\n     *\n     *i.e.: B.start < A.end < B.end\n     */\n    if (comparePositions(range.start, stackTop.end) < 0 && comparePositions(stackTop.end, range.end) < 0) {\n      throw new Error(`Range ${JSON.stringify(range)} and ${JSON.stringify(stackTop)} partially overlap.`);\n    }\n\n    const scope = createScopeFrom(range);\n    stackTop.children.push(scope);\n    stack.push(scope);\n  }\n\n  // 3. Update root.end.\n  const lastChild = root.children.at(-1);\n  if (lastChild) {\n    root.end = lastChild.end;\n  }\n\n  return root;\n}\n\nfunction validateStartBeforeEnd(ranges: NamedFunctionRange[]): void {\n  for (const range of ranges) {\n    if (comparePositions(range.start, range.end) >= 0) {\n      throw new Error(`Invalid range. End before start: ${JSON.stringify(range)}`);\n    }\n  }\n}\n\nfunction createScopeFrom(range: NamedFunctionRange): ScopesCodec.OriginalScope {\n  return {\n    ...range,\n    kind: 'Function',\n    isStackFrame: true,\n    children: [],\n    variables: [],\n  };\n}\n\n/**\n * Implements decoding of the pasta source map specification.\n *\n * See https://github.com/bloomberg/pasta-sourcemaps/blob/main/spec.md\n */\nexport function decodePastaRanges(encodedRanges: string, names: string[]): NamedFunctionRange[] {\n  const result: NamedFunctionRange[] = [];\n\n  let nameIndex = 0;\n  let startLineNumber = 0;\n  let startColumnNumber = 0;\n  let endLineNumber = 0;\n  let endColumnNumber = 0;\n\n  const tokenIter = new TokenIterator(encodedRanges);\n  let atStart = true;\n  while (tokenIter.hasNext()) {\n    if (atStart) {\n      atStart = false;\n    } else if (tokenIter.peek() === ',') {\n      tokenIter.next();\n    } else {\n      // Unexpected character. Return what we have up until now.\n      break;\n    }\n\n    nameIndex += tokenIter.nextVLQ();\n    startLineNumber = endLineNumber + tokenIter.nextVLQ();\n    startColumnNumber += tokenIter.nextVLQ();\n    endLineNumber = startLineNumber + tokenIter.nextVLQ();\n    endColumnNumber += tokenIter.nextVLQ();\n\n    const name = names[nameIndex];\n    if (name === undefined) {\n      // If the range doesn't have a valid name, ignore it.\n      continue;\n    }\n\n    result.push({\n      start: {line: startLineNumber, column: startColumnNumber},\n      end: {line: endLineNumber, column: endColumnNumber},\n      name,\n    });\n  }\n\n  return result;\n}\n\n/** @returns 0 if both positions are equal, a negative number if a < b and a positive number if a > b */\nfunction comparePositions(a: ScopesCodec.Position, b: ScopesCodec.Position): number {\n  return a.line - b.line || a.column - b.column;\n}\n"]}