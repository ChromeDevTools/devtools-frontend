{"version":3,"file":"SourceMapScopesInfo.js","sourceRoot":"","sources":["../../../../../../front_end/core/sdk/SourceMapScopesInfo.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Protocol from '../../generated/protocol.js';\nimport * as Formatter from '../../models/formatter/formatter.js';\nimport type * as TextUtils from '../../models/text_utils/text_utils.js';\nimport type * as ScopesCodec from '../../third_party/source-map-scopes-codec/source-map-scopes-codec.js';\nimport type * as Platform from '../platform/platform.js';\n\nimport type {CallFrame, ScopeChainEntry} from './DebuggerModel.js';\nimport type {SourceMap} from './SourceMap.js';\nimport {SourceMapScopeChainEntry} from './SourceMapScopeChainEntry.js';\n\nexport class SourceMapScopesInfo {\n  readonly #sourceMap: SourceMap;\n  readonly #originalScopes: Array<ScopesCodec.OriginalScope|null>;\n  readonly #generatedRanges: ScopesCodec.GeneratedRange[];\n\n  #cachedVariablesAndBindingsPresent: boolean|null = null;\n\n  constructor(sourceMap: SourceMap, scopeInfo: ScopesCodec.ScopeInfo) {\n    this.#sourceMap = sourceMap;\n    this.#originalScopes = scopeInfo.scopes;\n    this.#generatedRanges = scopeInfo.ranges;\n  }\n\n  /**\n   * If the source map does not contain any scopes information, this factory function attempts to create bare bones scope information\n   * via the script's AST combined with the mappings.\n   *\n   * We create the generated ranges from the scope tree and for each range we create an original scope that matches the bounds 1:1.\n   * We don't map the bounds via mappings as mappings are often iffy and it's not strictly required to translate stack traces where we\n   * map call-sites separately.\n   */\n  static createFromAst(\n      sourceMap: SourceMap, scopeTree: Formatter.FormatterWorkerPool.ScopeTreeNode,\n      text: TextUtils.Text.Text): SourceMapScopesInfo {\n    const {scope, range} = convertScope(scopeTree, undefined, undefined);\n    return new SourceMapScopesInfo(sourceMap, {scopes: [scope], ranges: [range]});\n\n    function convertScope(\n        node: Formatter.FormatterWorkerPool.ScopeTreeNode, parentScope: ScopesCodec.OriginalScope|undefined,\n        parentRange: ScopesCodec.GeneratedRange|\n        undefined): {scope: ScopesCodec.OriginalScope, range: ScopesCodec.GeneratedRange} {\n      const start = positionFromOffset(node.start);\n      const end = positionFromOffset(node.end);\n      const isStackFrame = node.kind === Formatter.FormatterWorkerPool.ScopeKind.FUNCTION;\n\n      const scope: ScopesCodec.OriginalScope = {\n        start,\n        end,\n        name: sourceMap.findEntry(start.line, start.column, 0)?.name,\n        isStackFrame,\n        variables: [],\n        children: [],\n      };\n\n      const range: ScopesCodec.GeneratedRange = {\n        start,\n        end,\n        originalScope: scope,\n        isStackFrame,\n        isHidden: false,\n        values: [],\n        children: [],\n      };\n\n      parentRange?.children.push(range);\n      parentScope?.children.push(scope);\n\n      node.children.forEach(child => convertScope(child, scope, range));\n\n      return {scope, range};\n    }\n\n    function positionFromOffset(offset: number): ScopesCodec.Position {\n      const location = text.positionFromOffset(offset);\n      return {line: location.lineNumber, column: location.columnNumber};\n    }\n  }\n\n  addOriginalScopes(scopes: Array<ScopesCodec.OriginalScope|null>): void {\n    for (const scope of scopes) {\n      this.#originalScopes.push(scope);\n    }\n  }\n\n  addGeneratedRanges(ranges: ScopesCodec.GeneratedRange[]): void {\n    for (const range of ranges) {\n      this.#generatedRanges.push(range);\n    }\n  }\n\n  hasOriginalScopes(sourceIdx: number): boolean {\n    return Boolean(this.#originalScopes[sourceIdx]);\n  }\n\n  isEmpty(): boolean {\n    return !this.#originalScopes.length && !this.#generatedRanges.length;\n  }\n\n  addOriginalScopesAtIndex(sourceIdx: number, scope: ScopesCodec.OriginalScope): void {\n    if (!this.#originalScopes[sourceIdx]) {\n      this.#originalScopes[sourceIdx] = scope;\n    } else {\n      throw new Error(`Trying to re-augment existing scopes for source at index: ${sourceIdx}`);\n    }\n  }\n\n  /**\n   * @returns true, iff the function surrounding the provided position is marked as \"hidden\".\n   */\n  isOutlinedFrame(generatedLine: number, generatedColumn: number): boolean {\n    const rangeChain = this.#findGeneratedRangeChain(generatedLine, generatedColumn);\n    return this.#isOutlinedFrame(rangeChain);\n  }\n\n  #isOutlinedFrame(rangeChain: ScopesCodec.GeneratedRange[]): boolean {\n    for (let i = rangeChain.length - 1; i >= 0; --i) {\n      if (rangeChain[i].isStackFrame) {\n        return rangeChain[i].isHidden;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @returns true, iff the range surrounding the provided position contains multiple\n   * inlined original functions.\n   */\n  hasInlinedFrames(generatedLine: number, generatedColumn: number): boolean {\n    const rangeChain = this.#findGeneratedRangeChain(generatedLine, generatedColumn);\n    for (let i = rangeChain.length - 1; i >= 0; --i) {\n      if (rangeChain[i].isStackFrame) {\n        // We stop looking for inlined original functions once we reach the current frame.\n        return false;\n      }\n      if (rangeChain[i].callSite) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Given a generated position, returns the original name of the surrounding function as well as\n   * all the original function names that got inlined into the surrounding generated function and their\n   * respective callsites in the original code (ordered from inner to outer).\n   *\n   * @returns a list with inlined functions. Every entry in the list has a callsite in the orignal code,\n   * except the last function (since the last function didn't get inlined).\n   */\n  findInlinedFunctions(generatedLine: number, generatedColumn: number): InlineInfo {\n    const rangeChain = this.#findGeneratedRangeChain(generatedLine, generatedColumn);\n    const result: InlineInfo = {\n      inlinedFunctions: [],\n      originalFunctionName: '',\n    };\n\n    // Walk the generated ranges from the innermost containing range outwards as long as we don't\n    // encounter a range that is a scope in the generated code and a function scope originally.\n    for (let i = rangeChain.length - 1; i >= 0; --i) {\n      const range = rangeChain[i];\n\n      if (range.callSite) {\n        // Record the name and call-site if the range corresponds to an inlined function.\n        result.inlinedFunctions.push({\n          name: range.originalScope?.name ?? '',\n          callsite: {...range.callSite, sourceURL: this.#sourceMap.sourceURLForSourceIndex(range.callSite.sourceIndex)}\n        });\n      }\n      if (range.isStackFrame) {\n        // We arrived at an actual generated JS function, don't go further.\n        // The corresponding original scope could not actually be a function\n        // (e.g. a block scope transpiled down to a JS function), but we'll\n        // filter that out later.\n        result.originalFunctionName = range.originalScope?.name ?? '';\n        break;\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Takes a V8 provided call frame and expands any inlined frames into virtual call frames.\n   *\n   * For call frames where nothing was inlined, the result contains only a single element,\n   * the provided frame but with the original name.\n   *\n   * For call frames where we are paused in inlined code, this function returns a list of\n   * call frames from \"inner to outer\". This is the call frame at index 0\n   * signifies the top of this stack trace fragment.\n   *\n   * The rest are \"virtual\" call frames and will have an \"inlineFrameIndex\" set in ascending\n   * order, so the condition `result[index] === result[index].inlineFrameIndex` always holds.\n   */\n  expandCallFrame(callFrame: CallFrame): CallFrame[] {\n    const {originalFunctionName, inlinedFunctions} =\n        this.findInlinedFunctions(callFrame.location().lineNumber, callFrame.location().columnNumber);\n    const result: CallFrame[] = [];\n    for (const [index, fn] of inlinedFunctions.entries()) {\n      result.push(callFrame.createVirtualCallFrame(index, fn.name));\n    }\n    result.push(callFrame.createVirtualCallFrame(result.length, originalFunctionName));\n    return result;\n  }\n\n  /**\n   * Given a generated position, this returns all the surrounding generated ranges from outer\n   * to inner.\n   */\n  #findGeneratedRangeChain(line: number, column: number): ScopesCodec.GeneratedRange[] {\n    const result: ScopesCodec.GeneratedRange[] = [];\n\n    (function walkRanges(ranges: ScopesCodec.GeneratedRange[]) {\n      for (const range of ranges) {\n        if (!contains(range, line, column)) {\n          continue;\n        }\n        result.push(range);\n        walkRanges(range.children);\n      }\n    })(this.#generatedRanges);\n\n    return result;\n  }\n\n  /**\n   * @returns true if we have enough info (i.e. variable and binding expressions) to build\n   * a scope view.\n   */\n  hasVariablesAndBindings(): boolean {\n    if (this.#cachedVariablesAndBindingsPresent === null) {\n      this.#cachedVariablesAndBindingsPresent = this.#areVariablesAndBindingsPresent();\n    }\n    return this.#cachedVariablesAndBindingsPresent;\n  }\n\n  #areVariablesAndBindingsPresent(): boolean {\n    // We check whether any original scope has a non-empty list of variables, and\n    // generated ranges with a non-empty binding list.\n\n    function walkTree(nodes: Array<ScopesCodec.OriginalScope|null>|ScopesCodec.GeneratedRange[]): boolean {\n      for (const node of nodes) {\n        if (!node) {\n          continue;\n        }\n\n        if ('variables' in node && node.variables.length > 0) {\n          return true;\n        }\n\n        if ('values' in node && node.values.some(v => v !== null)) {\n          return true;\n        }\n\n        if (walkTree(node.children)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    return walkTree(this.#originalScopes) && walkTree(this.#generatedRanges);\n  }\n\n  /**\n   * Constructs a scope chain based on the CallFrame's paused position.\n   *\n   * The algorithm to obtain the original scope chain is straight-forward:\n   *\n   *   1) Find the inner-most generated range that contains the CallFrame's\n   *      paused position.\n   *\n   *   2) Does the found range have an associated original scope?\n   *\n   *      2a) If no, return null. This is a \"hidden\" range and technically\n   *          we shouldn't be pausing here in the first place. This code doesn't\n   *          correspond to anything in the authored code.\n   *\n   *      2b) If yes, the associated original scope is the inner-most\n   *          original scope in the resulting scope chain.\n   *\n   *   3) Walk the parent chain of the found original scope outwards. This is\n   *      our scope view. For each original scope we also try to find a\n   *      corresponding generated range that contains the CallFrame's\n   *      paused position. We need the generated range to resolve variable\n   *      values.\n   */\n  resolveMappedScopeChain(callFrame: CallFrame): ScopeChainEntry[]|null {\n    const rangeChain = this.#findGeneratedRangeChainForFrame(callFrame);\n    const innerMostOriginalScope = rangeChain.at(-1)?.originalScope;\n    if (innerMostOriginalScope === undefined) {\n      return null;\n    }\n\n    // TODO(crbug.com/40277685): Add a sanity check here where we map the paused position using\n    //         the source map's mappings, find the inner-most original scope with that mapped paused\n    //         position and compare that result with `innerMostOriginalScope`. If they don't match we\n    //         should emit a warning about the broken source map as mappings and scopes are inconsistent\n    //         w.r.t. each other.\n\n    let seenFunctionScope = false;\n    const result: SourceMapScopeChainEntry[] = [];\n    // Walk the original scope chain outwards and try to find the corresponding generated range along the way.\n    for (let originalScope = rangeChain.at(-1)?.originalScope; originalScope; originalScope = originalScope.parent) {\n      const range = rangeChain.findLast(r => r.originalScope === originalScope);\n      const isFunctionScope = originalScope.kind === 'function';\n      const isInnerMostFunction = isFunctionScope && !seenFunctionScope;\n      const returnValue = isInnerMostFunction ? callFrame.returnValue() : null;\n      result.push(\n          new SourceMapScopeChainEntry(callFrame, originalScope, range, isInnerMostFunction, returnValue ?? undefined));\n      seenFunctionScope ||= isFunctionScope;\n    }\n\n    // If we are paused on a return statement, we need to drop inner block scopes. This is because V8 only emits a\n    // single return bytecode and \"gotos\" at the functions' end, where we are now paused.\n    if (callFrame.returnValue() !== null) {\n      while (result.length && result[0].type() !== Protocol.Debugger.ScopeType.Local) {\n        result.shift();\n      }\n    }\n\n    return result;\n  }\n\n  /** Similar to #findGeneratedRangeChain, but takes inlineFrameIndex of virtual call frames into account */\n  #findGeneratedRangeChainForFrame(callFrame: CallFrame): ScopesCodec.GeneratedRange[] {\n    const rangeChain =\n        this.#findGeneratedRangeChain(callFrame.location().lineNumber, callFrame.location().columnNumber);\n    if (callFrame.inlineFrameIndex === 0) {\n      return rangeChain;\n    }\n\n    // Drop ranges in the chain until we reach our desired inlined range.\n    for (let inlineIndex = 0; inlineIndex < callFrame.inlineFrameIndex;) {\n      const range = rangeChain.pop();\n      if (range?.callSite) {\n        ++inlineIndex;\n      }\n    }\n\n    return rangeChain;\n  }\n\n  /**\n   * Returns the authored function name of the function containing the provided generated position.\n   */\n  findOriginalFunctionName({line, column}: ScopesCodec.Position): string|null {\n    // There are 2 approaches:\n    //   1) Find the inner-most generated range containing the provided generated position\n    //      and use it's OriginalScope (then walk it outwards until we hit a function).\n    //   2) Use the mappings to turn the generated position into an original position.\n    //      Then find the inner-most original scope containing that original position.\n    //      Then walk it outwards until we hit a function.\n    //\n    // Both approaches should yield the same result (assuming the mappings are spec compliant\n    // w.r.t. generated ranges). But in the case of \"pasta\" scopes and extension provided\n    // scope info, we only have the OriginalScope parts and mappings without GeneratedRanges.\n\n    let originalInnerMostScope: ScopesCodec.OriginalScope|undefined;\n\n    if (this.#generatedRanges.length > 0) {\n      const rangeChain = this.#findGeneratedRangeChain(line, column);\n      originalInnerMostScope = rangeChain.at(-1)?.originalScope;\n    } else {\n      // No GeneratedRanges. Try to use mappings.\n      const entry = this.#sourceMap.findEntry(line, column);\n      if (entry?.sourceIndex === undefined) {\n        return null;\n      }\n      originalInnerMostScope =\n          this.#findOriginalScopeChain(\n                  {sourceIndex: entry.sourceIndex, line: entry.sourceLineNumber, column: entry.sourceColumnNumber})\n              .at(-1);\n    }\n\n    return this.#findFunctionNameInOriginalScopeChain(originalInnerMostScope) ?? null;\n  }\n\n  /**\n   * Given an original position, this returns all the surrounding original scopes from outer\n   * to inner.\n   */\n  #findOriginalScopeChain({sourceIndex, line, column}: ScopesCodec.OriginalPosition): ScopesCodec.OriginalScope[] {\n    const scope = this.#originalScopes[sourceIndex];\n    if (!scope) {\n      return [];\n    }\n\n    const result: ScopesCodec.OriginalScope[] = [];\n    (function walkScopes(scopes: ScopesCodec.OriginalScope[]) {\n      for (const scope of scopes) {\n        if (!contains(scope, line, column)) {\n          continue;\n        }\n        result.push(scope);\n        walkScopes(scope.children);\n      }\n    })([scope]);\n\n    return result;\n  }\n\n  #findFunctionNameInOriginalScopeChain(innerOriginalScope: ScopesCodec.OriginalScope|undefined): string|null {\n    for (let originalScope = innerOriginalScope; originalScope; originalScope = originalScope.parent) {\n      if (originalScope.isStackFrame) {\n        return originalScope.name ?? '';\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Returns one or more original stack frames for this single \"raw frame\" or call-site.\n   *\n   * @returns An empty array if no mapping at the call-site was found, or the resulting frames\n   * in top-to-bottom order in case of inlining.\n   * @throws If this range is marked \"hidden\". Outlining needs to be handled externally as\n   * outlined function segments in stack traces can span across bundles.\n   */\n  translateCallSite(generatedLine: number, generatedColumn: number): TranslatedFrame[] {\n    const rangeChain = this.#findGeneratedRangeChain(generatedLine, generatedColumn);\n    if (this.#isOutlinedFrame(rangeChain)) {\n      throw new Error('SourceMapScopesInfo is unable to translate an outlined function by itself');\n    }\n\n    const mapping = this.#sourceMap.findEntry(generatedLine, generatedColumn);\n    if (mapping?.sourceIndex === undefined) {\n      return [];\n    }\n\n    // The top-most frame is translated the same even if we have inlined functions.\n    const result: TranslatedFrame[] = [{\n      line: mapping.sourceLineNumber,\n      column: mapping.sourceColumnNumber,\n      name: this.findOriginalFunctionName({line: generatedLine, column: generatedColumn}) ?? undefined,\n      url: mapping.sourceURL,\n    }];\n\n    // Walk the range chain inside out until we find a generated function and for each inlined function add a frame.\n    for (let i = rangeChain.length - 1; i >= 0 && !rangeChain[i].isStackFrame; --i) {\n      const range = rangeChain[i];\n      if (!range.callSite) {\n        continue;\n      }\n\n      const originalScopeChain = this.#findOriginalScopeChain(range.callSite);\n      result.push({\n        line: range.callSite.line,\n        column: range.callSite.column,\n        name: this.#findFunctionNameInOriginalScopeChain(originalScopeChain.at(-1)) ?? undefined,\n        url: this.#sourceMap.sourceURLForSourceIndex(range.callSite.sourceIndex),\n      });\n    }\n\n    return result;\n  }\n}\n\n/**\n * Represents a stack frame in original terms. It closely aligns with StackTrace.StackTrace.Frame,\n * but since we can't import that type here we mirror it here somewhat.\n *\n * Equivalent to Pick<StackTrace.StackTrace.Frame, 'line'|'column'|'name'|'url'>.\n */\nexport interface TranslatedFrame {\n  line: number;\n  column: number;\n  name?: string;\n  url?: Platform.DevToolsPath.UrlString;\n}\n\n/**\n * Represents the inlining information for a given generated position.\n *\n * It contains a list of all the inlined original functions at the generated position\n * as well as the original function name of the generated position's surrounding\n * function.\n *\n * The inlined functions are sorted from inner to outer (or top to bottom on the stack).\n */\nexport interface InlineInfo {\n  inlinedFunctions: Array<{\n    name: string,\n    callsite: {\n      line: number,\n      column: number,\n      sourceIndex: number,\n      sourceURL?: Platform.DevToolsPath.UrlString,\n    },\n  }>;\n  originalFunctionName: string;\n}\n\nexport function contains(\n    range: Pick<ScopesCodec.GeneratedRange, 'start'|'end'>, line: number, column: number): boolean {\n  if (range.start.line > line || (range.start.line === line && range.start.column > column)) {\n    return false;\n  }\n\n  if (range.end.line < line || (range.end.line === line && range.end.column <= column)) {\n    return false;\n  }\n\n  return true;\n}\n"]}