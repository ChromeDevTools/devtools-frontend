{"version":3,"file":"SourceMapScopesInfo.js","sourceRoot":"","sources":["../../../../../../front_end/core/sdk/SourceMapScopesInfo.ts"],"names":[],"mappings":"AAAA,sCAAsC;AACtC,yEAAyE;AACzE,6BAA6B;AAG7B,OAAO,KAAK,SAAS,MAAM,qCAAqC,CAAC;AAOjE,OAAO,EAAC,wBAAwB,EAAC,MAAM,+BAA+B,CAAC;AAEvE,MAAM,OAAO,mBAAmB;IACrB,UAAU,CAAY;IACtB,eAAe,CAAwC;IACvD,gBAAgB,CAA+B;IAExD,kCAAkC,GAAiB,IAAI,CAAC;IAExD,YAAY,SAAoB,EAAE,SAAgC;QAChE,IAAI,CAAC,UAAU,GAAG,SAAS,CAAC;QAC5B,IAAI,CAAC,eAAe,GAAG,SAAS,CAAC,MAAM,CAAC;QACxC,IAAI,CAAC,gBAAgB,GAAG,SAAS,CAAC,MAAM,CAAC;IAC3C,CAAC;IAED;;;;;OAKG;IACH,MAAM,CAAC,aAAa,CAChB,SAAoB,EAAE,SAAsD,EAC5E,IAAyB;QAC3B,MAAM,aAAa,GAAG,SAAS,CAAC,UAAU,EAAE,CAAC,MAAM,CAAC;QACpD,MAAM,gBAAgB,GAAgC,EAAE,CAAC;QACzD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,aAAa,EAAE,CAAC,EAAE,EAAE,CAAC;YACvC,MAAM,KAAK,GAA8B;gBACvC,KAAK,EAAE,EAAC,IAAI,EAAE,CAAC,EAAE,MAAM,EAAE,CAAC,EAAC;gBAC3B,GAAG,EAAE,EAAC,IAAI,EAAE,MAAM,CAAC,iBAAiB,EAAE,MAAM,EAAE,MAAM,CAAC,iBAAiB,EAAC;gBACvE,YAAY,EAAE,KAAK;gBACnB,SAAS,EAAE,EAAE;gBACb,QAAQ,EAAE,EAAE;aACb,CAAC;YACF,gBAAgB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAC/B,CAAC;QAED,kFAAkF;QAClF,qEAAqE;QACrE,MAAM,EAAC,KAAK,EAAC,GAAG,YAAY,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC;QACnD,OAAO,IAAI,mBAAmB,CAAC,SAAS,EAAE,EAAC,MAAM,EAAE,gBAAgB,EAAE,MAAM,EAAE,CAAC,KAAK,CAAC,EAAC,CAAC,CAAC;QAEvF;;;WAGG;QACH,SAAS,aAAa,CAAC,MAAiC,EAAE,QAAmC;YAC3F,2EAA2E;YAC3E,KAAK,MAAM,KAAK,IAAI,MAAM,CAAC,QAAQ,EAAE,CAAC;gBACpC,IAAI,QAAQ,CAAC,KAAK,EAAE,QAAQ,CAAC,EAAE,CAAC;oBAC9B,aAAa,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;oBAC/B,OAAO;gBACT,CAAC;YACH,CAAC;YAED,kDAAkD;YAClD,4EAA4E;YAC5E,2EAA2E;YAC3E,kCAAkC;YAClC,MAAM,cAAc,GAAgC,EAAE,CAAC;YACvD,KAAK,MAAM,KAAK,IAAI,MAAM,CAAC,QAAQ,EAAE,CAAC;gBACpC,IAAI,QAAQ,CAAC,QAAQ,EAAE,KAAK,CAAC,EAAE,CAAC;oBAC9B,sDAAsD;oBACtD,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;oBAC9B,KAAK,CAAC,MAAM,GAAG,QAAQ,CAAC;gBAC1B,CAAC;qBAAM,CAAC;oBACN,cAAc,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBAC7B,CAAC;YACH,CAAC;YAED,uEAAuE;YACvE,+DAA+D;YAC/D,MAAM,WAAW,GAAG,cAAc,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE,CAAC,aAAa,CAAC,QAAQ,EAAE,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;YAC1F,IAAI,WAAW,KAAK,CAAC,CAAC,EAAE,CAAC;gBACvB,gDAAgD;gBAChD,cAAc,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAChC,CAAC;iBAAM,CAAC;gBACN,cAAc,CAAC,MAAM,CAAC,WAAW,EAAE,CAAC,EAAE,QAAQ,CAAC,CAAC;YAClD,CAAC;YAED,8EAA8E;YAC9E,MAAM,CAAC,QAAQ,GAAG,cAAc,CAAC;YACjC,QAAQ,CAAC,MAAM,GAAG,MAAM,CAAC;QAC3B,CAAC;QAED,SAAS,QAAQ,CAAC,KAAgC,EAAE,KAAgC;YAClF,OAAO,gBAAgB,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,gBAAgB,CAAC,KAAK,CAAC,GAAG,EAAE,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QACxG,CAAC;QAED,SAAS,aAAa,CAAC,CAA4B,EAAE,CAA4B;YAC/E,OAAO,gBAAgB,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC;QAC5C,CAAC;QAED,SAAS,gBAAgB,CAAC,CAAuB,EAAE,CAAuB;YACxE,IAAI,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,IAAI,EAAE,CAAC;gBACtB,OAAO,CAAC,CAAC,IAAI,GAAG,CAAC,CAAC,IAAI,CAAC;YACzB,CAAC;YACD,OAAO,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,MAAM,CAAC;QAC7B,CAAC;QAED,SAAS,YAAY,CACjB,IAAiD,EACjD,WAAiD;YACnD,MAAM,KAAK,GAAG,kBAAkB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YAC7C,MAAM,GAAG,GAAG,kBAAkB,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;YACzC,MAAM,UAAU,GAAG,SAAS,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC;YACjE,MAAM,QAAQ,GAAG,SAAS,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,MAAM,CAAC,CAAC;YAC3D,MAAM,WAAW,GAAG,UAAU,EAAE,WAAW,CAAC;YAC5C,MAAM,sBAAsB,GAAG,UAAU,IAAI,QAAQ,IAAI,WAAW,KAAK,SAAS;gBAC9E,UAAU,CAAC,WAAW,KAAK,QAAQ,CAAC,WAAW,IAAI,UAAU,CAAC,WAAW,KAAK,SAAS,IAAI,WAAW,IAAI,CAAC;gBAC3G,WAAW,GAAG,aAAa,CAAC;YAChC,MAAM,YAAY,GAAG,IAAI,CAAC,IAAI,6DAAqD;gBAC/E,IAAI,CAAC,IAAI,mEAA2D,CAAC;YACzE,qIAAqI;YACrI,mIAAmI;YACnI,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,6DAAqD,CAAC,CAAC,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC,CAAC,SAAS,CAAC;YAE3G,IAAI,KAA0C,CAAC;YAC/C,IAAI,sBAAsB,EAAE,CAAC;gBAC3B,KAAK,GAAG;oBACN,KAAK,EAAE,EAAC,IAAI,EAAE,UAAU,CAAC,gBAAgB,EAAE,MAAM,EAAE,UAAU,CAAC,kBAAkB,EAAC;oBACjF,GAAG,EAAE,EAAC,IAAI,EAAE,QAAQ,CAAC,gBAAgB,EAAE,MAAM,EAAE,QAAQ,CAAC,kBAAkB,EAAC;oBAC3E,IAAI;oBACJ,YAAY;oBACZ,SAAS,EAAE,EAAE;oBACb,QAAQ,EAAE,EAAE;iBACb,CAAC;YACJ,CAAC;YAED,MAAM,KAAK,GAA+B;gBACxC,KAAK;gBACL,GAAG;gBACH,aAAa,EAAE,KAAK;gBACpB,YAAY;gBACZ,QAAQ,EAAE,KAAK;gBACf,MAAM,EAAE,EAAE;gBACV,QAAQ,EAAE,EAAE;aACb,CAAC;YAEF,WAAW,EAAE,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YAClC,IAAI,sBAAsB,IAAI,KAAK,EAAE,CAAC;gBACpC,MAAM,SAAS,GAAG,gBAAgB,CAAC,WAAW,CAAC,CAAC;gBAChD,aAAa,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC;YAClC,CAAC;YAED,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,YAAY,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC;YAE3D,OAAO,EAAC,KAAK,EAAC,CAAC;QACjB,CAAC;QAED,SAAS,kBAAkB,CAAC,MAAc;YACxC,MAAM,QAAQ,GAAG,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,CAAC;YACjD,OAAO,EAAC,IAAI,EAAE,QAAQ,CAAC,UAAU,EAAE,MAAM,EAAE,QAAQ,CAAC,YAAY,EAAC,CAAC;QACpE,CAAC;IACH,CAAC;IAED,iBAAiB,CAAC,MAA6C;QAC7D,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE,CAAC;YAC3B,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACnC,CAAC;IACH,CAAC;IAED,kBAAkB,CAAC,MAAoC;QACrD,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE,CAAC;YAC3B,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACpC,CAAC;IACH,CAAC;IAED,iBAAiB,CAAC,SAAiB;QACjC,OAAO,OAAO,CAAC,IAAI,CAAC,eAAe,CAAC,SAAS,CAAC,CAAC,CAAC;IAClD,CAAC;IAED,OAAO;QACL,OAAO,CAAC,IAAI,CAAC,eAAe,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC;IACvE,CAAC;IAED,wBAAwB,CAAC,SAAiB,EAAE,KAAgC;QAC1E,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,SAAS,CAAC,EAAE,CAAC;YACrC,IAAI,CAAC,eAAe,CAAC,SAAS,CAAC,GAAG,KAAK,CAAC;QAC1C,CAAC;aAAM,CAAC;YACN,MAAM,IAAI,KAAK,CAAC,6DAA6D,SAAS,EAAE,CAAC,CAAC;QAC5F,CAAC;IACH,CAAC;IAED;;OAEG;IACH,eAAe,CAAC,aAAqB,EAAE,eAAuB;QAC5D,MAAM,UAAU,GAAG,IAAI,CAAC,wBAAwB,CAAC,aAAa,EAAE,eAAe,CAAC,CAAC;QACjF,OAAO,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC;IAC3C,CAAC;IAED,gBAAgB,CAAC,UAAwC;QACvD,KAAK,IAAI,CAAC,GAAG,UAAU,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC;YAChD,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC,YAAY,EAAE,CAAC;gBAC/B,OAAO,UAAU,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC;YAChC,CAAC;QACH,CAAC;QACD,OAAO,KAAK,CAAC;IACf,CAAC;IAED;;;OAGG;IACH,gBAAgB,CAAC,aAAqB,EAAE,eAAuB;QAC7D,MAAM,UAAU,GAAG,IAAI,CAAC,wBAAwB,CAAC,aAAa,EAAE,eAAe,CAAC,CAAC;QACjF,KAAK,IAAI,CAAC,GAAG,UAAU,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC;YAChD,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC,YAAY,EAAE,CAAC;gBAC/B,kFAAkF;gBAClF,OAAO,KAAK,CAAC;YACf,CAAC;YACD,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC;gBAC3B,OAAO,IAAI,CAAC;YACd,CAAC;QACH,CAAC;QACD,OAAO,KAAK,CAAC;IACf,CAAC;IAED;;;;;;;OAOG;IACH,oBAAoB,CAAC,aAAqB,EAAE,eAAuB;QACjE,MAAM,UAAU,GAAG,IAAI,CAAC,wBAAwB,CAAC,aAAa,EAAE,eAAe,CAAC,CAAC;QACjF,MAAM,MAAM,GAAe;YACzB,gBAAgB,EAAE,EAAE;YACpB,oBAAoB,EAAE,EAAE;SACzB,CAAC;QAEF,6FAA6F;QAC7F,2FAA2F;QAC3F,KAAK,IAAI,CAAC,GAAG,UAAU,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC;YAChD,MAAM,KAAK,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;YAE5B,IAAI,KAAK,CAAC,QAAQ,EAAE,CAAC;gBACnB,iFAAiF;gBACjF,MAAM,CAAC,gBAAgB,CAAC,IAAI,CAAC;oBAC3B,IAAI,EAAE,KAAK,CAAC,aAAa,EAAE,IAAI,IAAI,EAAE;oBACrC,QAAQ,EAAE,EAAC,GAAG,KAAK,CAAC,QAAQ,EAAE,SAAS,EAAE,IAAI,CAAC,UAAU,CAAC,uBAAuB,CAAC,KAAK,CAAC,QAAQ,CAAC,WAAW,CAAC,EAAC;iBAC9G,CAAC,CAAC;YACL,CAAC;YACD,IAAI,KAAK,CAAC,YAAY,EAAE,CAAC;gBACvB,mEAAmE;gBACnE,oEAAoE;gBACpE,mEAAmE;gBACnE,yBAAyB;gBACzB,MAAM,CAAC,oBAAoB,GAAG,KAAK,CAAC,aAAa,EAAE,IAAI,IAAI,EAAE,CAAC;gBAC9D,MAAM;YACR,CAAC;QACH,CAAC;QAED,OAAO,MAAM,CAAC;IAChB,CAAC;IAED;;;;;;;;;;;;OAYG;IACH,eAAe,CAAC,SAAoB;QAClC,MAAM,EAAC,oBAAoB,EAAE,gBAAgB,EAAC,GAC1C,IAAI,CAAC,oBAAoB,CAAC,SAAS,CAAC,QAAQ,EAAE,CAAC,UAAU,EAAE,SAAS,CAAC,QAAQ,EAAE,CAAC,YAAY,CAAC,CAAC;QAClG,MAAM,MAAM,GAAgB,EAAE,CAAC;QAC/B,KAAK,MAAM,CAAC,KAAK,EAAE,EAAE,CAAC,IAAI,gBAAgB,CAAC,OAAO,EAAE,EAAE,CAAC;YACrD,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,sBAAsB,CAAC,KAAK,EAAE,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC;QAChE,CAAC;QACD,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,sBAAsB,CAAC,MAAM,CAAC,MAAM,EAAE,oBAAoB,CAAC,CAAC,CAAC;QACnF,OAAO,MAAM,CAAC;IAChB,CAAC;IAED;;;OAGG;IACH,wBAAwB,CAAC,IAAY,EAAE,MAAc;QACnD,MAAM,MAAM,GAAiC,EAAE,CAAC;QAEhD,CAAC,SAAS,UAAU,CAAC,MAAoC;YACvD,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE,CAAC;gBAC3B,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,IAAI,EAAE,MAAM,CAAC,EAAE,CAAC;oBACnC,SAAS;gBACX,CAAC;gBACD,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBACnB,UAAU,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;YAC7B,CAAC;QACH,CAAC,CAAC,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;QAE1B,OAAO,MAAM,CAAC;IAChB,CAAC;IAED;;;OAGG;IACH,uBAAuB;QACrB,IAAI,IAAI,CAAC,kCAAkC,KAAK,IAAI,EAAE,CAAC;YACrD,IAAI,CAAC,kCAAkC,GAAG,IAAI,CAAC,+BAA+B,EAAE,CAAC;QACnF,CAAC;QACD,OAAO,IAAI,CAAC,kCAAkC,CAAC;IACjD,CAAC;IAED,+BAA+B;QAC7B,6EAA6E;QAC7E,kDAAkD;QAElD,SAAS,QAAQ,CAAC,KAAyE;YACzF,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE,CAAC;gBACzB,IAAI,CAAC,IAAI,EAAE,CAAC;oBACV,SAAS;gBACX,CAAC;gBAED,IAAI,WAAW,IAAI,IAAI,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;oBACrD,OAAO,IAAI,CAAC;gBACd,CAAC;gBAED,IAAI,QAAQ,IAAI,IAAI,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,IAAI,CAAC,EAAE,CAAC;oBAC1D,OAAO,IAAI,CAAC;gBACd,CAAC;gBAED,IAAI,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC;oBAC5B,OAAO,IAAI,CAAC;gBACd,CAAC;YACH,CAAC;YACD,OAAO,KAAK,CAAC;QACf,CAAC;QACD,OAAO,QAAQ,CAAC,IAAI,CAAC,eAAe,CAAC,IAAI,QAAQ,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;IAC3E,CAAC;IAED;;;;;;;;;;;;;;;;;;;;;;OAsBG;IACH,uBAAuB,CAAC,SAAoB;QAC1C,MAAM,UAAU,GAAG,IAAI,CAAC,gCAAgC,CAAC,SAAS,CAAC,CAAC;QACpE,MAAM,sBAAsB,GAAG,UAAU,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,aAAa,CAAC;QAChE,IAAI,sBAAsB,KAAK,SAAS,EAAE,CAAC;YACzC,OAAO,IAAI,CAAC;QACd,CAAC;QAED,2FAA2F;QAC3F,gGAAgG;QAChG,iGAAiG;QACjG,oGAAoG;QACpG,6BAA6B;QAE7B,IAAI,iBAAiB,GAAG,KAAK,CAAC;QAC9B,MAAM,MAAM,GAA+B,EAAE,CAAC;QAC9C,0GAA0G;QAC1G,KAAK,IAAI,aAAa,GAAG,UAAU,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,aAAa,EAAE,aAAa,EAAE,aAAa,GAAG,aAAa,CAAC,MAAM,EAAE,CAAC;YAC/G,MAAM,KAAK,GAAG,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,aAAa,KAAK,aAAa,CAAC,CAAC;YAC1E,MAAM,eAAe,GAAG,aAAa,CAAC,IAAI,KAAK,UAAU,CAAC;YAC1D,MAAM,mBAAmB,GAAG,eAAe,IAAI,CAAC,iBAAiB,CAAC;YAClE,MAAM,WAAW,GAAG,mBAAmB,CAAC,CAAC,CAAC,SAAS,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC;YACzE,MAAM,CAAC,IAAI,CACP,IAAI,wBAAwB,CAAC,SAAS,EAAE,aAAa,EAAE,KAAK,EAAE,mBAAmB,EAAE,WAAW,IAAI,SAAS,CAAC,CAAC,CAAC;YAClH,iBAAiB,KAAK,eAAe,CAAC;QACxC,CAAC;QAED,8GAA8G;QAC9G,qFAAqF;QACrF,IAAI,SAAS,CAAC,WAAW,EAAE,KAAK,IAAI,EAAE,CAAC;YACrC,OAAO,MAAM,CAAC,MAAM,IAAI,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,oDAAsC,EAAE,CAAC;gBAC/E,MAAM,CAAC,KAAK,EAAE,CAAC;YACjB,CAAC;QACH,CAAC;QAED,OAAO,MAAM,CAAC;IAChB,CAAC;IAED,0GAA0G;IAC1G,gCAAgC,CAAC,SAAoB;QACnD,MAAM,UAAU,GACZ,IAAI,CAAC,wBAAwB,CAAC,SAAS,CAAC,QAAQ,EAAE,CAAC,UAAU,EAAE,SAAS,CAAC,QAAQ,EAAE,CAAC,YAAY,CAAC,CAAC;QACtG,IAAI,SAAS,CAAC,gBAAgB,KAAK,CAAC,EAAE,CAAC;YACrC,OAAO,UAAU,CAAC;QACpB,CAAC;QAED,qEAAqE;QACrE,KAAK,IAAI,WAAW,GAAG,CAAC,EAAE,WAAW,GAAG,SAAS,CAAC,gBAAgB,GAAG,CAAC;YACpE,MAAM,KAAK,GAAG,UAAU,CAAC,GAAG,EAAE,CAAC;YAC/B,IAAI,KAAK,EAAE,QAAQ,EAAE,CAAC;gBACpB,EAAE,WAAW,CAAC;YAChB,CAAC;QACH,CAAC;QAED,OAAO,UAAU,CAAC;IACpB,CAAC;IAED;;OAEG;IACH,wBAAwB,CAAC,QAA8B;QACrD,MAAM,sBAAsB,GAAG,IAAI,CAAC,yBAAyB,CAAC,QAAQ,CAAC,EAAE,KAAK,IAAI,SAAS,CAAC;QAC5F,OAAO,IAAI,CAAC,qCAAqC,CAAC,sBAAsB,CAAC,CAAC;IAC5E,CAAC;IAED;;OAEG;IACH,yBAAyB,CAAC,EAAC,IAAI,EAAE,MAAM,EAAuB;QAE5D,0BAA0B;QAC1B,sFAAsF;QACtF,mFAAmF;QACnF,kFAAkF;QAClF,kFAAkF;QAClF,sDAAsD;QACtD,EAAE;QACF,yFAAyF;QACzF,qFAAqF;QACrF,yFAAyF;QAEzF,IAAI,sBAA2D,CAAC;QAEhE,IAAI,IAAI,CAAC,gBAAgB,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YACrC,MAAM,UAAU,GAAG,IAAI,CAAC,wBAAwB,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;YAC/D,sBAAsB,GAAG,UAAU,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,aAAa,CAAC;QAC5D,CAAC;aAAM,CAAC;YACN,2CAA2C;YAC3C,MAAM,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;YACtD,IAAI,KAAK,EAAE,WAAW,KAAK,SAAS,EAAE,CAAC;gBACrC,OAAO,IAAI,CAAC;YACd,CAAC;YACD,sBAAsB;gBAClB,IAAI,CAAC,uBAAuB,CACpB,EAAC,WAAW,EAAE,KAAK,CAAC,WAAW,EAAE,IAAI,EAAE,KAAK,CAAC,gBAAgB,EAAE,MAAM,EAAE,KAAK,CAAC,kBAAkB,EAAC,CAAC;qBACpG,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;QAClB,CAAC;QAED,IAAI,CAAC,sBAAsB,EAAE,CAAC;YAC5B,OAAO,IAAI,CAAC;QACd,CAAC;QAED,MAAM,aAAa,GAAG,IAAI,CAAC,sCAAsC,CAAC,sBAAsB,CAAC,CAAC;QAC1F,IAAI,CAAC,aAAa,EAAE,CAAC;YACnB,OAAO,IAAI,CAAC;QACd,CAAC;QAED,6EAA6E;QAC7E,IAAI,SAAS,GAA8B,aAAa,CAAC;QACzD,OAAO,SAAS,CAAC,MAAM,EAAE,CAAC;YACxB,SAAS,GAAG,SAAS,CAAC,MAAM,CAAC;QAC/B,CAAC;QACD,MAAM,WAAW,GAAG,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;QAC5D,MAAM,GAAG,GAAG,WAAW,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,uBAAuB,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;QAElG,OAAO,aAAa,CAAC,CAAC,CAAC,EAAC,KAAK,EAAE,aAAa,EAAE,GAAG,EAAC,CAAC,CAAC,CAAC,IAAI,CAAC;IAC5D,CAAC;IAED;;;OAGG;IACH,uBAAuB,CAAC,EAAC,WAAW,EAAE,IAAI,EAAE,MAAM,EAA+B;QAC/E,MAAM,KAAK,GAAG,IAAI,CAAC,eAAe,CAAC,WAAW,CAAC,CAAC;QAChD,IAAI,CAAC,KAAK,EAAE,CAAC;YACX,OAAO,EAAE,CAAC;QACZ,CAAC;QAED,MAAM,MAAM,GAAgC,EAAE,CAAC;QAC/C,CAAC,SAAS,UAAU,CAAC,MAAmC;YACtD,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE,CAAC;gBAC3B,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,IAAI,EAAE,MAAM,CAAC,EAAE,CAAC;oBACnC,SAAS;gBACX,CAAC;gBACD,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBACnB,UAAU,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;YAC7B,CAAC;QACH,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;QAEZ,OAAO,MAAM,CAAC;IAChB,CAAC;IAED,sCAAsC,CAAC,kBAAuD;QAE5F,KAAK,IAAI,aAAa,GAAG,kBAAkB,EAAE,aAAa,EAAE,aAAa,GAAG,aAAa,CAAC,MAAM,EAAE,CAAC;YACjG,IAAI,aAAa,CAAC,YAAY,EAAE,CAAC;gBAC/B,OAAO,aAAa,CAAC;YACvB,CAAC;QACH,CAAC;QACD,OAAO,IAAI,CAAC;IACd,CAAC;IAED,qCAAqC,CAAC,kBAAuD;QAC3F,MAAM,aAAa,GAAG,IAAI,CAAC,sCAAsC,CAAC,kBAAkB,CAAC,CAAC;QACtF,IAAI,CAAC,aAAa,EAAE,CAAC;YACnB,OAAO,IAAI,CAAC;QACd,CAAC;QAED,OAAO,aAAa,CAAC,IAAI,IAAI,EAAE,CAAC;IAClC,CAAC;IAED;;;;;;;OAOG;IACH,iBAAiB,CAAC,aAAqB,EAAE,eAAuB;QAC9D,MAAM,UAAU,GAAG,IAAI,CAAC,wBAAwB,CAAC,aAAa,EAAE,eAAe,CAAC,CAAC;QACjF,IAAI,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,EAAE,CAAC;YACtC,MAAM,IAAI,KAAK,CAAC,2EAA2E,CAAC,CAAC;QAC/F,CAAC;QAED,MAAM,OAAO,GAAG,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,aAAa,EAAE,eAAe,CAAC,CAAC;QAC1E,IAAI,OAAO,EAAE,WAAW,KAAK,SAAS,EAAE,CAAC;YACvC,OAAO,EAAE,CAAC;QACZ,CAAC;QAED,+EAA+E;QAC/E,MAAM,MAAM,GAAsB,CAAC;gBACjC,IAAI,EAAE,OAAO,CAAC,gBAAgB;gBAC9B,MAAM,EAAE,OAAO,CAAC,kBAAkB;gBAClC,IAAI,EAAE,IAAI,CAAC,wBAAwB,CAAC,EAAC,IAAI,EAAE,aAAa,EAAE,MAAM,EAAE,eAAe,EAAC,CAAC,IAAI,SAAS;gBAChG,GAAG,EAAE,OAAO,CAAC,SAAS;aACvB,CAAC,CAAC;QAEH,gHAAgH;QAChH,KAAK,IAAI,CAAC,GAAG,UAAU,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,YAAY,EAAE,EAAE,CAAC,EAAE,CAAC;YAC/E,MAAM,KAAK,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;YAC5B,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC;gBACpB,SAAS;YACX,CAAC;YAED,MAAM,kBAAkB,GAAG,IAAI,CAAC,uBAAuB,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;YACxE,MAAM,CAAC,IAAI,CAAC;gBACV,IAAI,EAAE,KAAK,CAAC,QAAQ,CAAC,IAAI;gBACzB,MAAM,EAAE,KAAK,CAAC,QAAQ,CAAC,MAAM;gBAC7B,IAAI,EAAE,IAAI,CAAC,qCAAqC,CAAC,kBAAkB,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,SAAS;gBACxF,GAAG,EAAE,IAAI,CAAC,UAAU,CAAC,uBAAuB,CAAC,KAAK,CAAC,QAAQ,CAAC,WAAW,CAAC;aACzE,CAAC,CAAC;QACL,CAAC;QAED,OAAO,MAAM,CAAC;IAChB,CAAC;CACF;AAqCD,MAAM,UAAU,QAAQ,CACpB,KAAsD,EAAE,IAAY,EAAE,MAAc;IACtF,IAAI,KAAK,CAAC,KAAK,CAAC,IAAI,GAAG,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,KAAK,IAAI,IAAI,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,MAAM,CAAC,EAAE,CAAC;QAC1F,OAAO,KAAK,CAAC;IACf,CAAC;IAED,IAAI,KAAK,CAAC,GAAG,CAAC,IAAI,GAAG,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,KAAK,IAAI,IAAI,KAAK,CAAC,GAAG,CAAC,MAAM,IAAI,MAAM,CAAC,EAAE,CAAC;QACrF,OAAO,KAAK,CAAC;IACf,CAAC;IAED,OAAO,IAAI,CAAC;AACd,CAAC","sourcesContent":["// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Protocol from '../../generated/protocol.js';\nimport * as Formatter from '../../models/formatter/formatter.js';\nimport type * as TextUtils from '../../models/text_utils/text_utils.js';\nimport type * as ScopesCodec from '../../third_party/source-map-scopes-codec/source-map-scopes-codec.js';\nimport type * as Platform from '../platform/platform.js';\n\nimport type {CallFrame, ScopeChainEntry} from './DebuggerModel.js';\nimport type {SourceMap} from './SourceMap.js';\nimport {SourceMapScopeChainEntry} from './SourceMapScopeChainEntry.js';\n\nexport class SourceMapScopesInfo {\n  readonly #sourceMap: SourceMap;\n  readonly #originalScopes: Array<ScopesCodec.OriginalScope|null>;\n  readonly #generatedRanges: ScopesCodec.GeneratedRange[];\n\n  #cachedVariablesAndBindingsPresent: boolean|null = null;\n\n  constructor(sourceMap: SourceMap, scopeInfo: ScopesCodec.ScopeInfo) {\n    this.#sourceMap = sourceMap;\n    this.#originalScopes = scopeInfo.scopes;\n    this.#generatedRanges = scopeInfo.ranges;\n  }\n\n  /**\n   * If the source map does not contain any scopes information, this factory function attempts to create scope information\n   * via the script's AST combined with the mappings.\n   *\n   * We create the generated ranges from the scope tree and for each range we create an original scope that matches the bounds 1:1.\n   */\n  static createFromAst(\n      sourceMap: SourceMap, scopeTree: Formatter.FormatterWorkerPool.ScopeTreeNode,\n      text: TextUtils.Text.Text): SourceMapScopesInfo {\n    const numSourceUrls = sourceMap.sourceURLs().length;\n    const scopeBySourceUrl: ScopesCodec.OriginalScope[] = [];\n    for (let i = 0; i < numSourceUrls; i++) {\n      const scope: ScopesCodec.OriginalScope = {\n        start: {line: 0, column: 0},\n        end: {line: Number.POSITIVE_INFINITY, column: Number.POSITIVE_INFINITY},\n        isStackFrame: false,\n        variables: [],\n        children: [],\n      };\n      scopeBySourceUrl.push(scope);\n    }\n\n    // Convert the entire scopeTree. Returns a root range that encompasses everything,\n    // and inserts scopes by sourceIndex into the above scopeBySourceUrl.\n    const {range} = convertScope(scopeTree, undefined);\n    return new SourceMapScopesInfo(sourceMap, {scopes: scopeBySourceUrl, ranges: [range]});\n\n    /**\n     * Recursively finds the correct place in the tree to insert the new scope.\n     * Maintains the invariant that children are sorted and contained by their parent.\n     */\n    function insertInScope(parent: ScopesCodec.OriginalScope, newScope: ScopesCodec.OriginalScope): void {\n      // Check if the newScope fits strictly inside any of the existing children.\n      for (const child of parent.children) {\n        if (contains(child, newScope)) {\n          insertInScope(child, newScope);\n          return;\n        }\n      }\n\n      // When here, newScope belongs directly in parent.\n      // However, newScope might encompass some of parent's existing children (due\n      // to compiler transform quirks or arbitrary insertion order). We must move\n      // those children inside newScope.\n      const childrenToKeep: ScopesCodec.OriginalScope[] = [];\n      for (const child of parent.children) {\n        if (contains(newScope, child)) {\n          // child is actually inside newScope, so re-parent it.\n          newScope.children.push(child);\n          child.parent = newScope;\n        } else {\n          childrenToKeep.push(child);\n        }\n      }\n\n      // Find the correct index in the remaining children to insert newScope.\n      // We look for the first child that starts after the new scope.\n      const insertIndex = childrenToKeep.findIndex(child => compareScopes(newScope, child) < 0);\n      if (insertIndex === -1) {\n        // If no child starts after, it goes at the end.\n        childrenToKeep.push(newScope);\n      } else {\n        childrenToKeep.splice(insertIndex, 0, newScope);\n      }\n\n      // Update parent's children to only be the ones that don't belong to newScope.\n      parent.children = childrenToKeep;\n      newScope.parent = parent;\n    }\n\n    function contains(outer: ScopesCodec.OriginalScope, inner: ScopesCodec.OriginalScope): boolean {\n      return comparePositions(outer.start, inner.start) <= 0 && comparePositions(outer.end, inner.end) >= 0;\n    }\n\n    function compareScopes(a: ScopesCodec.OriginalScope, b: ScopesCodec.OriginalScope): number {\n      return comparePositions(a.start, b.start);\n    }\n\n    function comparePositions(a: ScopesCodec.Position, b: ScopesCodec.Position): number {\n      if (a.line !== b.line) {\n        return a.line - b.line;\n      }\n      return a.column - b.column;\n    }\n\n    function convertScope(\n        node: Formatter.FormatterWorkerPool.ScopeTreeNode,\n        parentRange: ScopesCodec.GeneratedRange|undefined): {range: ScopesCodec.GeneratedRange} {\n      const start = positionFromOffset(node.start);\n      const end = positionFromOffset(node.end);\n      const startEntry = sourceMap.findEntry(start.line, start.column);\n      const endEntry = sourceMap.findEntry(end.line, end.column);\n      const sourceIndex = startEntry?.sourceIndex;\n      const canMapOriginalPosition = startEntry && endEntry && sourceIndex !== undefined &&\n          startEntry.sourceIndex === endEntry.sourceIndex && startEntry.sourceIndex !== undefined && sourceIndex >= 0 &&\n          sourceIndex < numSourceUrls;\n      const isStackFrame = node.kind === Formatter.FormatterWorkerPool.ScopeKind.FUNCTION ||\n          node.kind === Formatter.FormatterWorkerPool.ScopeKind.ARROW_FUNCTION;\n      // TODO(crbug.com/368222773): Instead of mapping `start`, we should report a number of candidates. e.g. for arrow functions we should\n      //     follow the spec and map the `=>` as the spec says that is where the original name (if any) for arrow functions can be found.\n      const name = node.kind === Formatter.FormatterWorkerPool.ScopeKind.FUNCTION ? startEntry?.name : undefined;\n\n      let scope: ScopesCodec.OriginalScope|undefined;\n      if (canMapOriginalPosition) {\n        scope = {\n          start: {line: startEntry.sourceLineNumber, column: startEntry.sourceColumnNumber},\n          end: {line: endEntry.sourceLineNumber, column: endEntry.sourceColumnNumber},\n          name,\n          isStackFrame,\n          variables: [],\n          children: [],\n        };\n      }\n\n      const range: ScopesCodec.GeneratedRange = {\n        start,\n        end,\n        originalScope: scope,\n        isStackFrame,\n        isHidden: false,\n        values: [],\n        children: [],\n      };\n\n      parentRange?.children.push(range);\n      if (canMapOriginalPosition && scope) {\n        const rootScope = scopeBySourceUrl[sourceIndex];\n        insertInScope(rootScope, scope);\n      }\n\n      node.children.forEach(child => convertScope(child, range));\n\n      return {range};\n    }\n\n    function positionFromOffset(offset: number): ScopesCodec.Position {\n      const location = text.positionFromOffset(offset);\n      return {line: location.lineNumber, column: location.columnNumber};\n    }\n  }\n\n  addOriginalScopes(scopes: Array<ScopesCodec.OriginalScope|null>): void {\n    for (const scope of scopes) {\n      this.#originalScopes.push(scope);\n    }\n  }\n\n  addGeneratedRanges(ranges: ScopesCodec.GeneratedRange[]): void {\n    for (const range of ranges) {\n      this.#generatedRanges.push(range);\n    }\n  }\n\n  hasOriginalScopes(sourceIdx: number): boolean {\n    return Boolean(this.#originalScopes[sourceIdx]);\n  }\n\n  isEmpty(): boolean {\n    return !this.#originalScopes.length && !this.#generatedRanges.length;\n  }\n\n  addOriginalScopesAtIndex(sourceIdx: number, scope: ScopesCodec.OriginalScope): void {\n    if (!this.#originalScopes[sourceIdx]) {\n      this.#originalScopes[sourceIdx] = scope;\n    } else {\n      throw new Error(`Trying to re-augment existing scopes for source at index: ${sourceIdx}`);\n    }\n  }\n\n  /**\n   * @returns true, iff the function surrounding the provided position is marked as \"hidden\".\n   */\n  isOutlinedFrame(generatedLine: number, generatedColumn: number): boolean {\n    const rangeChain = this.#findGeneratedRangeChain(generatedLine, generatedColumn);\n    return this.#isOutlinedFrame(rangeChain);\n  }\n\n  #isOutlinedFrame(rangeChain: ScopesCodec.GeneratedRange[]): boolean {\n    for (let i = rangeChain.length - 1; i >= 0; --i) {\n      if (rangeChain[i].isStackFrame) {\n        return rangeChain[i].isHidden;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @returns true, iff the range surrounding the provided position contains multiple\n   * inlined original functions.\n   */\n  hasInlinedFrames(generatedLine: number, generatedColumn: number): boolean {\n    const rangeChain = this.#findGeneratedRangeChain(generatedLine, generatedColumn);\n    for (let i = rangeChain.length - 1; i >= 0; --i) {\n      if (rangeChain[i].isStackFrame) {\n        // We stop looking for inlined original functions once we reach the current frame.\n        return false;\n      }\n      if (rangeChain[i].callSite) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Given a generated position, returns the original name of the surrounding function as well as\n   * all the original function names that got inlined into the surrounding generated function and their\n   * respective callsites in the original code (ordered from inner to outer).\n   *\n   * @returns a list with inlined functions. Every entry in the list has a callsite in the orignal code,\n   * except the last function (since the last function didn't get inlined).\n   */\n  findInlinedFunctions(generatedLine: number, generatedColumn: number): InlineInfo {\n    const rangeChain = this.#findGeneratedRangeChain(generatedLine, generatedColumn);\n    const result: InlineInfo = {\n      inlinedFunctions: [],\n      originalFunctionName: '',\n    };\n\n    // Walk the generated ranges from the innermost containing range outwards as long as we don't\n    // encounter a range that is a scope in the generated code and a function scope originally.\n    for (let i = rangeChain.length - 1; i >= 0; --i) {\n      const range = rangeChain[i];\n\n      if (range.callSite) {\n        // Record the name and call-site if the range corresponds to an inlined function.\n        result.inlinedFunctions.push({\n          name: range.originalScope?.name ?? '',\n          callsite: {...range.callSite, sourceURL: this.#sourceMap.sourceURLForSourceIndex(range.callSite.sourceIndex)}\n        });\n      }\n      if (range.isStackFrame) {\n        // We arrived at an actual generated JS function, don't go further.\n        // The corresponding original scope could not actually be a function\n        // (e.g. a block scope transpiled down to a JS function), but we'll\n        // filter that out later.\n        result.originalFunctionName = range.originalScope?.name ?? '';\n        break;\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Takes a V8 provided call frame and expands any inlined frames into virtual call frames.\n   *\n   * For call frames where nothing was inlined, the result contains only a single element,\n   * the provided frame but with the original name.\n   *\n   * For call frames where we are paused in inlined code, this function returns a list of\n   * call frames from \"inner to outer\". This is the call frame at index 0\n   * signifies the top of this stack trace fragment.\n   *\n   * The rest are \"virtual\" call frames and will have an \"inlineFrameIndex\" set in ascending\n   * order, so the condition `result[index] === result[index].inlineFrameIndex` always holds.\n   */\n  expandCallFrame(callFrame: CallFrame): CallFrame[] {\n    const {originalFunctionName, inlinedFunctions} =\n        this.findInlinedFunctions(callFrame.location().lineNumber, callFrame.location().columnNumber);\n    const result: CallFrame[] = [];\n    for (const [index, fn] of inlinedFunctions.entries()) {\n      result.push(callFrame.createVirtualCallFrame(index, fn.name));\n    }\n    result.push(callFrame.createVirtualCallFrame(result.length, originalFunctionName));\n    return result;\n  }\n\n  /**\n   * Given a generated position, this returns all the surrounding generated ranges from outer\n   * to inner.\n   */\n  #findGeneratedRangeChain(line: number, column: number): ScopesCodec.GeneratedRange[] {\n    const result: ScopesCodec.GeneratedRange[] = [];\n\n    (function walkRanges(ranges: ScopesCodec.GeneratedRange[]) {\n      for (const range of ranges) {\n        if (!contains(range, line, column)) {\n          continue;\n        }\n        result.push(range);\n        walkRanges(range.children);\n      }\n    })(this.#generatedRanges);\n\n    return result;\n  }\n\n  /**\n   * @returns true if we have enough info (i.e. variable and binding expressions) to build\n   * a scope view.\n   */\n  hasVariablesAndBindings(): boolean {\n    if (this.#cachedVariablesAndBindingsPresent === null) {\n      this.#cachedVariablesAndBindingsPresent = this.#areVariablesAndBindingsPresent();\n    }\n    return this.#cachedVariablesAndBindingsPresent;\n  }\n\n  #areVariablesAndBindingsPresent(): boolean {\n    // We check whether any original scope has a non-empty list of variables, and\n    // generated ranges with a non-empty binding list.\n\n    function walkTree(nodes: Array<ScopesCodec.OriginalScope|null>|ScopesCodec.GeneratedRange[]): boolean {\n      for (const node of nodes) {\n        if (!node) {\n          continue;\n        }\n\n        if ('variables' in node && node.variables.length > 0) {\n          return true;\n        }\n\n        if ('values' in node && node.values.some(v => v !== null)) {\n          return true;\n        }\n\n        if (walkTree(node.children)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    return walkTree(this.#originalScopes) && walkTree(this.#generatedRanges);\n  }\n\n  /**\n   * Constructs a scope chain based on the CallFrame's paused position.\n   *\n   * The algorithm to obtain the original scope chain is straight-forward:\n   *\n   *   1) Find the inner-most generated range that contains the CallFrame's\n   *      paused position.\n   *\n   *   2) Does the found range have an associated original scope?\n   *\n   *      2a) If no, return null. This is a \"hidden\" range and technically\n   *          we shouldn't be pausing here in the first place. This code doesn't\n   *          correspond to anything in the authored code.\n   *\n   *      2b) If yes, the associated original scope is the inner-most\n   *          original scope in the resulting scope chain.\n   *\n   *   3) Walk the parent chain of the found original scope outwards. This is\n   *      our scope view. For each original scope we also try to find a\n   *      corresponding generated range that contains the CallFrame's\n   *      paused position. We need the generated range to resolve variable\n   *      values.\n   */\n  resolveMappedScopeChain(callFrame: CallFrame): ScopeChainEntry[]|null {\n    const rangeChain = this.#findGeneratedRangeChainForFrame(callFrame);\n    const innerMostOriginalScope = rangeChain.at(-1)?.originalScope;\n    if (innerMostOriginalScope === undefined) {\n      return null;\n    }\n\n    // TODO(crbug.com/40277685): Add a sanity check here where we map the paused position using\n    //         the source map's mappings, find the inner-most original scope with that mapped paused\n    //         position and compare that result with `innerMostOriginalScope`. If they don't match we\n    //         should emit a warning about the broken source map as mappings and scopes are inconsistent\n    //         w.r.t. each other.\n\n    let seenFunctionScope = false;\n    const result: SourceMapScopeChainEntry[] = [];\n    // Walk the original scope chain outwards and try to find the corresponding generated range along the way.\n    for (let originalScope = rangeChain.at(-1)?.originalScope; originalScope; originalScope = originalScope.parent) {\n      const range = rangeChain.findLast(r => r.originalScope === originalScope);\n      const isFunctionScope = originalScope.kind === 'function';\n      const isInnerMostFunction = isFunctionScope && !seenFunctionScope;\n      const returnValue = isInnerMostFunction ? callFrame.returnValue() : null;\n      result.push(\n          new SourceMapScopeChainEntry(callFrame, originalScope, range, isInnerMostFunction, returnValue ?? undefined));\n      seenFunctionScope ||= isFunctionScope;\n    }\n\n    // If we are paused on a return statement, we need to drop inner block scopes. This is because V8 only emits a\n    // single return bytecode and \"gotos\" at the functions' end, where we are now paused.\n    if (callFrame.returnValue() !== null) {\n      while (result.length && result[0].type() !== Protocol.Debugger.ScopeType.Local) {\n        result.shift();\n      }\n    }\n\n    return result;\n  }\n\n  /** Similar to #findGeneratedRangeChain, but takes inlineFrameIndex of virtual call frames into account */\n  #findGeneratedRangeChainForFrame(callFrame: CallFrame): ScopesCodec.GeneratedRange[] {\n    const rangeChain =\n        this.#findGeneratedRangeChain(callFrame.location().lineNumber, callFrame.location().columnNumber);\n    if (callFrame.inlineFrameIndex === 0) {\n      return rangeChain;\n    }\n\n    // Drop ranges in the chain until we reach our desired inlined range.\n    for (let inlineIndex = 0; inlineIndex < callFrame.inlineFrameIndex;) {\n      const range = rangeChain.pop();\n      if (range?.callSite) {\n        ++inlineIndex;\n      }\n    }\n\n    return rangeChain;\n  }\n\n  /**\n   * Returns the authored function name of the function containing the provided generated position.\n   */\n  findOriginalFunctionName(position: ScopesCodec.Position): string|null {\n    const originalInnerMostScope = this.findOriginalFunctionScope(position)?.scope ?? undefined;\n    return this.#findFunctionNameInOriginalScopeChain(originalInnerMostScope);\n  }\n\n  /**\n   * Returns the authored function scope of the function containing the provided generated position.\n   */\n  findOriginalFunctionScope({line, column}: ScopesCodec.Position):\n      {scope: ScopesCodec.OriginalScope, url?: Platform.DevToolsPath.UrlString}|null {\n    // There are 2 approaches:\n    //   1) Find the inner-most generated range containing the provided generated position\n    //      and use it's OriginalScope (then walk it outwards until we hit a function).\n    //   2) Use the mappings to turn the generated position into an original position.\n    //      Then find the inner-most original scope containing that original position.\n    //      Then walk it outwards until we hit a function.\n    //\n    // Both approaches should yield the same result (assuming the mappings are spec compliant\n    // w.r.t. generated ranges). But in the case of \"pasta\" scopes and extension provided\n    // scope info, we only have the OriginalScope parts and mappings without GeneratedRanges.\n\n    let originalInnerMostScope: ScopesCodec.OriginalScope|undefined;\n\n    if (this.#generatedRanges.length > 0) {\n      const rangeChain = this.#findGeneratedRangeChain(line, column);\n      originalInnerMostScope = rangeChain.at(-1)?.originalScope;\n    } else {\n      // No GeneratedRanges. Try to use mappings.\n      const entry = this.#sourceMap.findEntry(line, column);\n      if (entry?.sourceIndex === undefined) {\n        return null;\n      }\n      originalInnerMostScope =\n          this.#findOriginalScopeChain(\n                  {sourceIndex: entry.sourceIndex, line: entry.sourceLineNumber, column: entry.sourceColumnNumber})\n              .at(-1);\n    }\n\n    if (!originalInnerMostScope) {\n      return null;\n    }\n\n    const functionScope = this.#findFunctionScopeInOriginalScopeChain(originalInnerMostScope);\n    if (!functionScope) {\n      return null;\n    }\n\n    // Find the root scope for some given original source, to get the source url.\n    let rootScope: ScopesCodec.OriginalScope = functionScope;\n    while (rootScope.parent) {\n      rootScope = rootScope.parent;\n    }\n    const sourceIndex = this.#originalScopes.indexOf(rootScope);\n    const url = sourceIndex !== -1 ? this.#sourceMap.sourceURLForSourceIndex(sourceIndex) : undefined;\n\n    return functionScope ? {scope: functionScope, url} : null;\n  }\n\n  /**\n   * Given an original position, this returns all the surrounding original scopes from outer\n   * to inner.\n   */\n  #findOriginalScopeChain({sourceIndex, line, column}: ScopesCodec.OriginalPosition): ScopesCodec.OriginalScope[] {\n    const scope = this.#originalScopes[sourceIndex];\n    if (!scope) {\n      return [];\n    }\n\n    const result: ScopesCodec.OriginalScope[] = [];\n    (function walkScopes(scopes: ScopesCodec.OriginalScope[]) {\n      for (const scope of scopes) {\n        if (!contains(scope, line, column)) {\n          continue;\n        }\n        result.push(scope);\n        walkScopes(scope.children);\n      }\n    })([scope]);\n\n    return result;\n  }\n\n  #findFunctionScopeInOriginalScopeChain(innerOriginalScope: ScopesCodec.OriginalScope|undefined):\n      ScopesCodec.OriginalScope|null {\n    for (let originalScope = innerOriginalScope; originalScope; originalScope = originalScope.parent) {\n      if (originalScope.isStackFrame) {\n        return originalScope;\n      }\n    }\n    return null;\n  }\n\n  #findFunctionNameInOriginalScopeChain(innerOriginalScope: ScopesCodec.OriginalScope|undefined): string|null {\n    const functionScope = this.#findFunctionScopeInOriginalScopeChain(innerOriginalScope);\n    if (!functionScope) {\n      return null;\n    }\n\n    return functionScope.name ?? '';\n  }\n\n  /**\n   * Returns one or more original stack frames for this single \"raw frame\" or call-site.\n   *\n   * @returns An empty array if no mapping at the call-site was found, or the resulting frames\n   * in top-to-bottom order in case of inlining.\n   * @throws If this range is marked \"hidden\". Outlining needs to be handled externally as\n   * outlined function segments in stack traces can span across bundles.\n   */\n  translateCallSite(generatedLine: number, generatedColumn: number): TranslatedFrame[] {\n    const rangeChain = this.#findGeneratedRangeChain(generatedLine, generatedColumn);\n    if (this.#isOutlinedFrame(rangeChain)) {\n      throw new Error('SourceMapScopesInfo is unable to translate an outlined function by itself');\n    }\n\n    const mapping = this.#sourceMap.findEntry(generatedLine, generatedColumn);\n    if (mapping?.sourceIndex === undefined) {\n      return [];\n    }\n\n    // The top-most frame is translated the same even if we have inlined functions.\n    const result: TranslatedFrame[] = [{\n      line: mapping.sourceLineNumber,\n      column: mapping.sourceColumnNumber,\n      name: this.findOriginalFunctionName({line: generatedLine, column: generatedColumn}) ?? undefined,\n      url: mapping.sourceURL,\n    }];\n\n    // Walk the range chain inside out until we find a generated function and for each inlined function add a frame.\n    for (let i = rangeChain.length - 1; i >= 0 && !rangeChain[i].isStackFrame; --i) {\n      const range = rangeChain[i];\n      if (!range.callSite) {\n        continue;\n      }\n\n      const originalScopeChain = this.#findOriginalScopeChain(range.callSite);\n      result.push({\n        line: range.callSite.line,\n        column: range.callSite.column,\n        name: this.#findFunctionNameInOriginalScopeChain(originalScopeChain.at(-1)) ?? undefined,\n        url: this.#sourceMap.sourceURLForSourceIndex(range.callSite.sourceIndex),\n      });\n    }\n\n    return result;\n  }\n}\n\n/**\n * Represents a stack frame in original terms. It closely aligns with StackTrace.StackTrace.Frame,\n * but since we can't import that type here we mirror it here somewhat.\n *\n * Equivalent to Pick<StackTrace.StackTrace.Frame, 'line'|'column'|'name'|'url'>.\n */\nexport interface TranslatedFrame {\n  line: number;\n  column: number;\n  name?: string;\n  url?: Platform.DevToolsPath.UrlString;\n}\n\n/**\n * Represents the inlining information for a given generated position.\n *\n * It contains a list of all the inlined original functions at the generated position\n * as well as the original function name of the generated position's surrounding\n * function.\n *\n * The inlined functions are sorted from inner to outer (or top to bottom on the stack).\n */\nexport interface InlineInfo {\n  inlinedFunctions: Array<{\n    name: string,\n    callsite: {\n      line: number,\n      column: number,\n      sourceIndex: number,\n      sourceURL?: Platform.DevToolsPath.UrlString,\n    },\n  }>;\n  originalFunctionName: string;\n}\n\nexport function contains(\n    range: Pick<ScopesCodec.GeneratedRange, 'start'|'end'>, line: number, column: number): boolean {\n  if (range.start.line > line || (range.start.line === line && range.start.column > column)) {\n    return false;\n  }\n\n  if (range.end.line < line || (range.end.line === line && range.end.column <= column)) {\n    return false;\n  }\n\n  return true;\n}\n"]}