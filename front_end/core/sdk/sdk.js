var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// gen/front_end/core/sdk/SDKModel.js
var SDKModel_exports = {};
__export(SDKModel_exports, {
  SDKModel: () => SDKModel
});
import * as Common from "./../common/common.js";
var registeredModels = /* @__PURE__ */ new Map();
var SDKModel = class extends Common.ObjectWrapper.ObjectWrapper {
  #target;
  constructor(target) {
    super();
    this.#target = target;
  }
  target() {
    return this.#target;
  }
  /**
   * Override this method to perform tasks that are required to suspend the
   * model and that still need other models in an unsuspended state.
   */
  async preSuspendModel(_reason) {
  }
  async suspendModel(_reason) {
  }
  async resumeModel() {
  }
  /**
   * Override this method to perform tasks that are required to after resuming
   * the model and that require all models already in an unsuspended state.
   */
  async postResumeModel() {
  }
  dispose() {
  }
  static register(modelClass, registrationInfo) {
    if (registrationInfo.early && !registrationInfo.autostart) {
      throw new Error(`Error registering model ${modelClass.name}: early models must be autostarted.`);
    }
    registeredModels.set(modelClass, registrationInfo);
  }
  static get registeredModels() {
    return registeredModels;
  }
};

// gen/front_end/core/sdk/CSSMetadata.js
var CSSMetadata_exports = {};
__export(CSSMetadata_exports, {
  CSSMetadata: () => CSSMetadata,
  CSSWideKeywords: () => CSSWideKeywords,
  CubicBezierKeywordValues: () => CubicBezierKeywordValues,
  CustomVariableRegex: () => CustomVariableRegex,
  GridAreaRowRegex: () => GridAreaRowRegex,
  PositionTryOrderKeywords: () => PositionTryOrderKeywords,
  URLRegex: () => URLRegex,
  VariableNameRegex: () => VariableNameRegex,
  VariableRegex: () => VariableRegex,
  cssMetadata: () => cssMetadata
});

// gen/front_end/generated/SupportedCSSProperties.js
var generatedProperties = [
  {
    "longhands": [
      "max-lines",
      "block-ellipsis",
      "continue"
    ],
    "name": "-alternative-webkit-line-clamp"
  },
  {
    "inherited": true,
    "name": "-webkit-border-horizontal-spacing"
  },
  {
    "name": "-webkit-border-image"
  },
  {
    "inherited": true,
    "name": "-webkit-border-vertical-spacing"
  },
  {
    "keywords": [
      "stretch",
      "start",
      "center",
      "end",
      "baseline"
    ],
    "name": "-webkit-box-align"
  },
  {
    "keywords": [
      "slice",
      "clone"
    ],
    "name": "-webkit-box-decoration-break"
  },
  {
    "keywords": [
      "normal",
      "reverse"
    ],
    "name": "-webkit-box-direction"
  },
  {
    "name": "-webkit-box-flex"
  },
  {
    "name": "-webkit-box-ordinal-group"
  },
  {
    "keywords": [
      "horizontal",
      "vertical"
    ],
    "name": "-webkit-box-orient"
  },
  {
    "keywords": [
      "start",
      "center",
      "end",
      "justify"
    ],
    "name": "-webkit-box-pack"
  },
  {
    "name": "-webkit-box-reflect"
  },
  {
    "longhands": [
      "break-after"
    ],
    "name": "-webkit-column-break-after"
  },
  {
    "longhands": [
      "break-before"
    ],
    "name": "-webkit-column-break-before"
  },
  {
    "longhands": [
      "break-inside"
    ],
    "name": "-webkit-column-break-inside"
  },
  {
    "inherited": true,
    "name": "-webkit-font-smoothing"
  },
  {
    "keywords": [
      "auto",
      "loose",
      "normal",
      "strict",
      "after-white-space"
    ],
    "name": "-webkit-line-break"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "-webkit-line-clamp"
  },
  {
    "inherited": true,
    "name": "-webkit-locale"
  },
  {
    "longhands": [
      "-webkit-mask-box-image-source",
      "-webkit-mask-box-image-slice",
      "-webkit-mask-box-image-width",
      "-webkit-mask-box-image-outset",
      "-webkit-mask-box-image-repeat"
    ],
    "name": "-webkit-mask-box-image"
  },
  {
    "name": "-webkit-mask-box-image-outset"
  },
  {
    "name": "-webkit-mask-box-image-repeat"
  },
  {
    "name": "-webkit-mask-box-image-slice"
  },
  {
    "name": "-webkit-mask-box-image-source"
  },
  {
    "name": "-webkit-mask-box-image-width"
  },
  {
    "name": "-webkit-mask-position-x"
  },
  {
    "name": "-webkit-mask-position-y"
  },
  {
    "name": "-webkit-perspective-origin-x"
  },
  {
    "name": "-webkit-perspective-origin-y"
  },
  {
    "inherited": true,
    "keywords": [
      "logical",
      "visual"
    ],
    "name": "-webkit-rtl-ordering"
  },
  {
    "inherited": true,
    "name": "-webkit-ruby-position"
  },
  {
    "inherited": true,
    "name": "-webkit-tap-highlight-color"
  },
  {
    "inherited": true,
    "name": "-webkit-text-combine"
  },
  {
    "inherited": true,
    "name": "-webkit-text-decorations-in-effect"
  },
  {
    "inherited": true,
    "name": "-webkit-text-fill-color"
  },
  {
    "inherited": true,
    "name": "-webkit-text-orientation"
  },
  {
    "inherited": true,
    "keywords": [
      "none",
      "disc",
      "circle",
      "square"
    ],
    "name": "-webkit-text-security"
  },
  {
    "inherited": true,
    "longhands": [
      "-webkit-text-stroke-width",
      "-webkit-text-stroke-color"
    ],
    "name": "-webkit-text-stroke"
  },
  {
    "inherited": true,
    "name": "-webkit-text-stroke-color"
  },
  {
    "inherited": true,
    "name": "-webkit-text-stroke-width"
  },
  {
    "name": "-webkit-transform-origin-x"
  },
  {
    "name": "-webkit-transform-origin-y"
  },
  {
    "name": "-webkit-transform-origin-z"
  },
  {
    "keywords": [
      "auto",
      "none",
      "element"
    ],
    "name": "-webkit-user-drag"
  },
  {
    "inherited": true,
    "keywords": [
      "read-only",
      "read-write",
      "read-write-plaintext-only"
    ],
    "name": "-webkit-user-modify"
  },
  {
    "inherited": true,
    "name": "-webkit-writing-mode"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "currentcolor"
    ],
    "name": "accent-color"
  },
  {
    "name": "additive-symbols"
  },
  {
    "name": "align-content"
  },
  {
    "name": "align-items"
  },
  {
    "name": "align-self"
  },
  {
    "keywords": [
      "auto",
      "baseline",
      "alphabetic",
      "ideographic",
      "middle",
      "central",
      "mathematical",
      "before-edge",
      "text-before-edge",
      "after-edge",
      "text-after-edge",
      "hanging"
    ],
    "name": "alignment-baseline"
  },
  {
    "longhands": [
      "-webkit-border-horizontal-spacing",
      "-webkit-border-vertical-spacing",
      "-webkit-box-align",
      "-webkit-box-decoration-break",
      "-webkit-box-direction",
      "-webkit-box-flex",
      "-webkit-box-ordinal-group",
      "-webkit-box-orient",
      "-webkit-box-pack",
      "-webkit-box-reflect",
      "-webkit-font-smoothing",
      "-webkit-line-break",
      "-webkit-line-clamp",
      "-webkit-locale",
      "-webkit-mask-box-image-outset",
      "-webkit-mask-box-image-repeat",
      "-webkit-mask-box-image-slice",
      "-webkit-mask-box-image-source",
      "-webkit-mask-box-image-width",
      "-webkit-mask-position-x",
      "-webkit-mask-position-y",
      "-webkit-rtl-ordering",
      "-webkit-ruby-position",
      "-webkit-tap-highlight-color",
      "-webkit-text-combine",
      "-webkit-text-decorations-in-effect",
      "-webkit-text-fill-color",
      "-webkit-text-orientation",
      "-webkit-text-security",
      "-webkit-text-stroke-color",
      "-webkit-text-stroke-width",
      "-webkit-user-drag",
      "-webkit-writing-mode",
      "accent-color",
      "additive-symbols",
      "align-content",
      "align-items",
      "align-self",
      "alignment-baseline",
      "anchor-name",
      "anchor-scope",
      "animation-composition",
      "animation-delay",
      "animation-direction",
      "animation-duration",
      "animation-fill-mode",
      "animation-iteration-count",
      "animation-name",
      "animation-play-state",
      "animation-range-end",
      "animation-range-start",
      "animation-timeline",
      "animation-timing-function",
      "animation-trigger",
      "app-region",
      "appearance",
      "ascent-override",
      "aspect-ratio",
      "backdrop-filter",
      "backface-visibility",
      "background-attachment",
      "background-blend-mode",
      "background-clip",
      "background-color",
      "background-image",
      "background-origin",
      "background-position-x",
      "background-position-y",
      "background-repeat",
      "background-size",
      "base-palette",
      "baseline-shift",
      "baseline-source",
      "block-ellipsis",
      "block-size",
      "border-block-end-color",
      "border-block-end-style",
      "border-block-end-width",
      "border-block-start-color",
      "border-block-start-style",
      "border-block-start-width",
      "border-bottom-color",
      "border-bottom-left-radius",
      "border-bottom-right-radius",
      "border-bottom-style",
      "border-bottom-width",
      "border-collapse",
      "border-end-end-radius",
      "border-end-start-radius",
      "border-image-outset",
      "border-image-repeat",
      "border-image-slice",
      "border-image-source",
      "border-image-width",
      "border-inline-end-color",
      "border-inline-end-style",
      "border-inline-end-width",
      "border-inline-start-color",
      "border-inline-start-style",
      "border-inline-start-width",
      "border-left-color",
      "border-left-style",
      "border-left-width",
      "border-right-color",
      "border-right-style",
      "border-right-width",
      "border-shape",
      "border-start-end-radius",
      "border-start-start-radius",
      "border-top-color",
      "border-top-left-radius",
      "border-top-right-radius",
      "border-top-style",
      "border-top-width",
      "bottom",
      "box-decoration-break",
      "box-shadow",
      "box-sizing",
      "break-after",
      "break-before",
      "break-inside",
      "buffered-rendering",
      "caption-side",
      "caret-animation",
      "caret-color",
      "caret-shape",
      "clear",
      "clip",
      "clip-path",
      "clip-rule",
      "color",
      "color-interpolation",
      "color-interpolation-filters",
      "color-rendering",
      "color-scheme",
      "column-count",
      "column-fill",
      "column-gap",
      "column-height",
      "column-rule-break",
      "column-rule-color",
      "column-rule-outset",
      "column-rule-style",
      "column-rule-visibility-items",
      "column-rule-width",
      "column-span",
      "column-width",
      "column-wrap",
      "contain",
      "contain-intrinsic-block-size",
      "contain-intrinsic-height",
      "contain-intrinsic-inline-size",
      "contain-intrinsic-width",
      "container-name",
      "container-type",
      "content",
      "content-visibility",
      "continue",
      "corner-bottom-left-shape",
      "corner-bottom-right-shape",
      "corner-end-end-shape",
      "corner-end-start-shape",
      "corner-start-end-shape",
      "corner-start-start-shape",
      "corner-top-left-shape",
      "corner-top-right-shape",
      "counter-increment",
      "counter-reset",
      "counter-set",
      "cursor",
      "cx",
      "cy",
      "d",
      "descent-override",
      "display",
      "dominant-baseline",
      "dynamic-range-limit",
      "empty-cells",
      "fallback",
      "field-sizing",
      "fill",
      "fill-opacity",
      "fill-rule",
      "filter",
      "flex-basis",
      "flex-direction",
      "flex-grow",
      "flex-shrink",
      "flex-wrap",
      "float",
      "flood-color",
      "flood-opacity",
      "font-display",
      "font-family",
      "font-feature-settings",
      "font-kerning",
      "font-language-override",
      "font-optical-sizing",
      "font-palette",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-synthesis-small-caps",
      "font-synthesis-style",
      "font-synthesis-weight",
      "font-variant-alternates",
      "font-variant-caps",
      "font-variant-east-asian",
      "font-variant-emoji",
      "font-variant-ligatures",
      "font-variant-numeric",
      "font-variant-position",
      "font-variation-settings",
      "font-weight",
      "forced-color-adjust",
      "gap-rule-overlap",
      "grid-auto-columns",
      "grid-auto-flow",
      "grid-auto-rows",
      "grid-column-end",
      "grid-column-start",
      "grid-row-end",
      "grid-row-start",
      "grid-template-areas",
      "grid-template-columns",
      "grid-template-rows",
      "height",
      "hyphenate-character",
      "hyphenate-limit-chars",
      "hyphens",
      "image-orientation",
      "image-rendering",
      "inherits",
      "initial-letter",
      "initial-value",
      "inline-size",
      "inset-block-end",
      "inset-block-start",
      "inset-inline-end",
      "inset-inline-start",
      "interactivity",
      "interest-delay-end",
      "interest-delay-start",
      "interpolate-size",
      "isolation",
      "item-tolerance",
      "justify-content",
      "justify-items",
      "justify-self",
      "left",
      "letter-spacing",
      "lighting-color",
      "line-break",
      "line-gap-override",
      "line-height",
      "list-style-image",
      "list-style-position",
      "list-style-type",
      "margin-block-end",
      "margin-block-start",
      "margin-bottom",
      "margin-inline-end",
      "margin-inline-start",
      "margin-left",
      "margin-right",
      "margin-top",
      "marker-end",
      "marker-mid",
      "marker-start",
      "mask-clip",
      "mask-composite",
      "mask-image",
      "mask-mode",
      "mask-origin",
      "mask-repeat",
      "mask-size",
      "mask-type",
      "masonry-direction",
      "masonry-fill",
      "math-depth",
      "math-shift",
      "math-style",
      "max-block-size",
      "max-height",
      "max-inline-size",
      "max-lines",
      "max-width",
      "min-block-size",
      "min-height",
      "min-inline-size",
      "min-width",
      "mix-blend-mode",
      "navigation",
      "negative",
      "object-fit",
      "object-position",
      "object-view-box",
      "offset-anchor",
      "offset-distance",
      "offset-path",
      "offset-position",
      "offset-rotate",
      "opacity",
      "order",
      "origin-trial-test-property",
      "orphans",
      "outline-color",
      "outline-offset",
      "outline-style",
      "outline-width",
      "overflow-anchor",
      "overflow-block",
      "overflow-clip-margin",
      "overflow-inline",
      "overflow-wrap",
      "overflow-x",
      "overflow-y",
      "overlay",
      "override-colors",
      "overscroll-area",
      "overscroll-behavior-block",
      "overscroll-behavior-inline",
      "overscroll-behavior-x",
      "overscroll-behavior-y",
      "overscroll-position",
      "pad",
      "padding-block-end",
      "padding-block-start",
      "padding-bottom",
      "padding-inline-end",
      "padding-inline-start",
      "padding-left",
      "padding-right",
      "padding-top",
      "page",
      "page-orientation",
      "paint-order",
      "perspective",
      "perspective-origin",
      "pointer-events",
      "position",
      "position-anchor",
      "position-area",
      "position-try-fallbacks",
      "position-try-order",
      "position-visibility",
      "prefix",
      "print-color-adjust",
      "quotes",
      "r",
      "range",
      "reading-flow",
      "reading-order",
      "resize",
      "result",
      "right",
      "rotate",
      "row-gap",
      "row-rule-break",
      "row-rule-color",
      "row-rule-outset",
      "row-rule-style",
      "row-rule-visibility-items",
      "row-rule-width",
      "ruby-align",
      "ruby-overhang",
      "ruby-position",
      "rx",
      "ry",
      "scale",
      "scroll-behavior",
      "scroll-initial-target",
      "scroll-margin-block-end",
      "scroll-margin-block-start",
      "scroll-margin-bottom",
      "scroll-margin-inline-end",
      "scroll-margin-inline-start",
      "scroll-margin-left",
      "scroll-margin-right",
      "scroll-margin-top",
      "scroll-marker-group",
      "scroll-padding-block-end",
      "scroll-padding-block-start",
      "scroll-padding-bottom",
      "scroll-padding-inline-end",
      "scroll-padding-inline-start",
      "scroll-padding-left",
      "scroll-padding-right",
      "scroll-padding-top",
      "scroll-snap-align",
      "scroll-snap-stop",
      "scroll-snap-type",
      "scroll-start-block",
      "scroll-start-inline",
      "scroll-start-x",
      "scroll-start-y",
      "scroll-target-group",
      "scroll-timeline-axis",
      "scroll-timeline-name",
      "scrollbar-color",
      "scrollbar-gutter",
      "scrollbar-width",
      "shape-image-threshold",
      "shape-margin",
      "shape-outside",
      "shape-rendering",
      "size",
      "size-adjust",
      "speak",
      "speak-as",
      "src",
      "stop-color",
      "stop-opacity",
      "stroke",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "suffix",
      "symbols",
      "syntax",
      "system",
      "tab-size",
      "table-layout",
      "text-align",
      "text-align-last",
      "text-anchor",
      "text-autospace",
      "text-box-edge",
      "text-box-trim",
      "text-combine-upright",
      "text-decoration-color",
      "text-decoration-line",
      "text-decoration-skip-ink",
      "text-decoration-style",
      "text-decoration-thickness",
      "text-emphasis-color",
      "text-emphasis-position",
      "text-emphasis-style",
      "text-grow",
      "text-indent",
      "text-justify",
      "text-orientation",
      "text-overflow",
      "text-rendering",
      "text-shadow",
      "text-shrink",
      "text-size-adjust",
      "text-spacing-trim",
      "text-transform",
      "text-underline-offset",
      "text-underline-position",
      "text-wrap-mode",
      "text-wrap-style",
      "timeline-scope",
      "timeline-trigger-exit-range-end",
      "timeline-trigger-exit-range-start",
      "timeline-trigger-name",
      "timeline-trigger-range-end",
      "timeline-trigger-range-start",
      "timeline-trigger-source",
      "top",
      "touch-action",
      "transform",
      "transform-box",
      "transform-origin",
      "transform-style",
      "transition-behavior",
      "transition-delay",
      "transition-duration",
      "transition-property",
      "transition-timing-function",
      "translate",
      "types",
      "unicode-range",
      "user-select",
      "vector-effect",
      "vertical-align",
      "view-timeline-axis",
      "view-timeline-inset",
      "view-timeline-name",
      "view-transition-class",
      "view-transition-group",
      "view-transition-name",
      "visibility",
      "white-space-collapse",
      "widows",
      "width",
      "will-change",
      "word-break",
      "word-spacing",
      "writing-mode",
      "x",
      "y",
      "z-index",
      "zoom"
    ],
    "name": "all"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "anchor-name"
  },
  {
    "keywords": [
      "none",
      "all"
    ],
    "name": "anchor-scope"
  },
  {
    "longhands": [
      "animation-duration",
      "animation-timing-function",
      "animation-delay",
      "animation-iteration-count",
      "animation-direction",
      "animation-fill-mode",
      "animation-play-state",
      "animation-name",
      "animation-timeline",
      "animation-range-start",
      "animation-range-end"
    ],
    "name": "animation"
  },
  {
    "keywords": [
      "replace",
      "add",
      "accumulate"
    ],
    "name": "animation-composition"
  },
  {
    "name": "animation-delay"
  },
  {
    "keywords": [
      "normal",
      "reverse",
      "alternate",
      "alternate-reverse"
    ],
    "name": "animation-direction"
  },
  {
    "name": "animation-duration"
  },
  {
    "keywords": [
      "none",
      "forwards",
      "backwards",
      "both"
    ],
    "name": "animation-fill-mode"
  },
  {
    "keywords": [
      "infinite"
    ],
    "name": "animation-iteration-count"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "animation-name"
  },
  {
    "keywords": [
      "running",
      "paused"
    ],
    "name": "animation-play-state"
  },
  {
    "longhands": [
      "animation-range-start",
      "animation-range-end"
    ],
    "name": "animation-range"
  },
  {
    "name": "animation-range-end"
  },
  {
    "name": "animation-range-start"
  },
  {
    "keywords": [
      "none",
      "auto"
    ],
    "name": "animation-timeline"
  },
  {
    "keywords": [
      "linear",
      "ease",
      "ease-in",
      "ease-out",
      "ease-in-out",
      "jump-both",
      "jump-end",
      "jump-none",
      "jump-start",
      "step-start",
      "step-end"
    ],
    "name": "animation-timing-function"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "animation-trigger"
  },
  {
    "keywords": [
      "none",
      "drag",
      "no-drag"
    ],
    "name": "app-region"
  },
  {
    "name": "appearance"
  },
  {
    "name": "ascent-override"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "aspect-ratio"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "backdrop-filter"
  },
  {
    "keywords": [
      "visible",
      "hidden"
    ],
    "name": "backface-visibility"
  },
  {
    "longhands": [
      "background-image",
      "background-position-x",
      "background-position-y",
      "background-size",
      "background-repeat",
      "background-attachment",
      "background-origin",
      "background-clip",
      "background-color"
    ],
    "name": "background"
  },
  {
    "keywords": [
      "scroll",
      "fixed",
      "local"
    ],
    "name": "background-attachment"
  },
  {
    "keywords": [
      "normal",
      "multiply",
      "screen",
      "overlay",
      "darken",
      "lighten",
      "color-dodge",
      "color-burn",
      "hard-light",
      "soft-light",
      "difference",
      "exclusion",
      "hue",
      "saturation",
      "color",
      "luminosity"
    ],
    "name": "background-blend-mode"
  },
  {
    "keywords": [
      "border-box",
      "padding-box",
      "content-box",
      "text"
    ],
    "name": "background-clip"
  },
  {
    "keywords": [
      "currentcolor"
    ],
    "name": "background-color"
  },
  {
    "keywords": [
      "auto",
      "none"
    ],
    "name": "background-image"
  },
  {
    "keywords": [
      "border-box",
      "padding-box",
      "content-box"
    ],
    "name": "background-origin"
  },
  {
    "longhands": [
      "background-position-x",
      "background-position-y"
    ],
    "name": "background-position"
  },
  {
    "name": "background-position-x"
  },
  {
    "name": "background-position-y"
  },
  {
    "name": "background-repeat"
  },
  {
    "keywords": [
      "auto",
      "cover",
      "contain"
    ],
    "name": "background-size"
  },
  {
    "name": "base-palette"
  },
  {
    "keywords": [
      "baseline",
      "sub",
      "super"
    ],
    "name": "baseline-shift"
  },
  {
    "keywords": [
      "auto",
      "first",
      "last"
    ],
    "name": "baseline-source"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "no-ellipsis"
    ],
    "name": "block-ellipsis"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "block-size"
  },
  {
    "longhands": [
      "border-top-color",
      "border-top-style",
      "border-top-width",
      "border-right-color",
      "border-right-style",
      "border-right-width",
      "border-bottom-color",
      "border-bottom-style",
      "border-bottom-width",
      "border-left-color",
      "border-left-style",
      "border-left-width",
      "border-image-source",
      "border-image-slice",
      "border-image-width",
      "border-image-outset",
      "border-image-repeat"
    ],
    "name": "border"
  },
  {
    "longhands": [
      "border-block-start-color",
      "border-block-start-style",
      "border-block-start-width",
      "border-block-end-color",
      "border-block-end-style",
      "border-block-end-width"
    ],
    "name": "border-block"
  },
  {
    "longhands": [
      "border-block-start-color",
      "border-block-end-color"
    ],
    "name": "border-block-color"
  },
  {
    "longhands": [
      "border-block-end-width",
      "border-block-end-style",
      "border-block-end-color"
    ],
    "name": "border-block-end"
  },
  {
    "name": "border-block-end-color"
  },
  {
    "name": "border-block-end-style"
  },
  {
    "name": "border-block-end-width"
  },
  {
    "longhands": [
      "border-block-start-width",
      "border-block-start-style",
      "border-block-start-color"
    ],
    "name": "border-block-start"
  },
  {
    "name": "border-block-start-color"
  },
  {
    "name": "border-block-start-style"
  },
  {
    "name": "border-block-start-width"
  },
  {
    "longhands": [
      "border-block-start-style",
      "border-block-end-style"
    ],
    "name": "border-block-style"
  },
  {
    "longhands": [
      "border-block-start-width",
      "border-block-end-width"
    ],
    "name": "border-block-width"
  },
  {
    "longhands": [
      "border-bottom-width",
      "border-bottom-style",
      "border-bottom-color"
    ],
    "name": "border-bottom"
  },
  {
    "keywords": [
      "currentcolor"
    ],
    "name": "border-bottom-color"
  },
  {
    "name": "border-bottom-left-radius"
  },
  {
    "name": "border-bottom-right-radius"
  },
  {
    "keywords": [
      "none",
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double"
    ],
    "name": "border-bottom-style"
  },
  {
    "keywords": [
      "thin",
      "medium",
      "thick"
    ],
    "name": "border-bottom-width"
  },
  {
    "inherited": true,
    "keywords": [
      "separate",
      "collapse"
    ],
    "name": "border-collapse"
  },
  {
    "longhands": [
      "border-top-color",
      "border-right-color",
      "border-bottom-color",
      "border-left-color"
    ],
    "name": "border-color"
  },
  {
    "name": "border-end-end-radius"
  },
  {
    "name": "border-end-start-radius"
  },
  {
    "longhands": [
      "border-image-source",
      "border-image-slice",
      "border-image-width",
      "border-image-outset",
      "border-image-repeat"
    ],
    "name": "border-image"
  },
  {
    "name": "border-image-outset"
  },
  {
    "keywords": [
      "stretch",
      "repeat",
      "round",
      "space"
    ],
    "name": "border-image-repeat"
  },
  {
    "name": "border-image-slice"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "border-image-source"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "border-image-width"
  },
  {
    "longhands": [
      "border-inline-start-color",
      "border-inline-start-style",
      "border-inline-start-width",
      "border-inline-end-color",
      "border-inline-end-style",
      "border-inline-end-width"
    ],
    "name": "border-inline"
  },
  {
    "longhands": [
      "border-inline-start-color",
      "border-inline-end-color"
    ],
    "name": "border-inline-color"
  },
  {
    "longhands": [
      "border-inline-end-width",
      "border-inline-end-style",
      "border-inline-end-color"
    ],
    "name": "border-inline-end"
  },
  {
    "name": "border-inline-end-color"
  },
  {
    "name": "border-inline-end-style"
  },
  {
    "name": "border-inline-end-width"
  },
  {
    "longhands": [
      "border-inline-start-width",
      "border-inline-start-style",
      "border-inline-start-color"
    ],
    "name": "border-inline-start"
  },
  {
    "name": "border-inline-start-color"
  },
  {
    "name": "border-inline-start-style"
  },
  {
    "name": "border-inline-start-width"
  },
  {
    "longhands": [
      "border-inline-start-style",
      "border-inline-end-style"
    ],
    "name": "border-inline-style"
  },
  {
    "longhands": [
      "border-inline-start-width",
      "border-inline-end-width"
    ],
    "name": "border-inline-width"
  },
  {
    "longhands": [
      "border-left-width",
      "border-left-style",
      "border-left-color"
    ],
    "name": "border-left"
  },
  {
    "keywords": [
      "currentcolor"
    ],
    "name": "border-left-color"
  },
  {
    "keywords": [
      "none",
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double"
    ],
    "name": "border-left-style"
  },
  {
    "keywords": [
      "thin",
      "medium",
      "thick"
    ],
    "name": "border-left-width"
  },
  {
    "longhands": [
      "border-top-left-radius",
      "border-top-right-radius",
      "border-bottom-right-radius",
      "border-bottom-left-radius"
    ],
    "name": "border-radius"
  },
  {
    "longhands": [
      "border-right-width",
      "border-right-style",
      "border-right-color"
    ],
    "name": "border-right"
  },
  {
    "keywords": [
      "currentcolor"
    ],
    "name": "border-right-color"
  },
  {
    "keywords": [
      "none",
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double"
    ],
    "name": "border-right-style"
  },
  {
    "keywords": [
      "thin",
      "medium",
      "thick"
    ],
    "name": "border-right-width"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "border-shape"
  },
  {
    "inherited": true,
    "longhands": [
      "-webkit-border-horizontal-spacing",
      "-webkit-border-vertical-spacing"
    ],
    "name": "border-spacing"
  },
  {
    "name": "border-start-end-radius"
  },
  {
    "name": "border-start-start-radius"
  },
  {
    "keywords": [
      "none"
    ],
    "longhands": [
      "border-top-style",
      "border-right-style",
      "border-bottom-style",
      "border-left-style"
    ],
    "name": "border-style"
  },
  {
    "longhands": [
      "border-top-width",
      "border-top-style",
      "border-top-color"
    ],
    "name": "border-top"
  },
  {
    "keywords": [
      "currentcolor"
    ],
    "name": "border-top-color"
  },
  {
    "name": "border-top-left-radius"
  },
  {
    "name": "border-top-right-radius"
  },
  {
    "keywords": [
      "none",
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double"
    ],
    "name": "border-top-style"
  },
  {
    "keywords": [
      "thin",
      "medium",
      "thick"
    ],
    "name": "border-top-width"
  },
  {
    "longhands": [
      "border-top-width",
      "border-right-width",
      "border-bottom-width",
      "border-left-width"
    ],
    "name": "border-width"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "bottom"
  },
  {
    "keywords": [
      "slice",
      "clone"
    ],
    "name": "box-decoration-break"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "box-shadow"
  },
  {
    "keywords": [
      "content-box",
      "border-box"
    ],
    "name": "box-sizing"
  },
  {
    "keywords": [
      "auto",
      "avoid",
      "avoid-column",
      "avoid-page",
      "column",
      "left",
      "page",
      "recto",
      "right",
      "verso"
    ],
    "name": "break-after"
  },
  {
    "keywords": [
      "auto",
      "avoid",
      "avoid-column",
      "avoid-page",
      "column",
      "left",
      "page",
      "recto",
      "right",
      "verso"
    ],
    "name": "break-before"
  },
  {
    "keywords": [
      "auto",
      "avoid",
      "avoid-column",
      "avoid-page"
    ],
    "name": "break-inside"
  },
  {
    "keywords": [
      "auto",
      "dynamic",
      "static"
    ],
    "name": "buffered-rendering"
  },
  {
    "inherited": true,
    "keywords": [
      "top",
      "bottom"
    ],
    "name": "caption-side"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "manual"
    ],
    "name": "caret-animation"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "currentcolor"
    ],
    "name": "caret-color"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "bar",
      "block",
      "underscore"
    ],
    "name": "caret-shape"
  },
  {
    "keywords": [
      "none",
      "left",
      "right",
      "both",
      "inline-start",
      "inline-end"
    ],
    "name": "clear"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "clip"
  },
  {
    "keywords": [
      "border-box",
      "padding-box",
      "content-box",
      "margin-box",
      "fill-box",
      "stroke-box",
      "view-box",
      "none"
    ],
    "name": "clip-path"
  },
  {
    "inherited": true,
    "keywords": [
      "nonzero",
      "evenodd"
    ],
    "name": "clip-rule"
  },
  {
    "inherited": true,
    "keywords": [
      "currentcolor"
    ],
    "name": "color"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "srgb",
      "linearrgb"
    ],
    "name": "color-interpolation"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "srgb",
      "linearrgb"
    ],
    "name": "color-interpolation-filters"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "optimizespeed",
      "optimizequality"
    ],
    "name": "color-rendering"
  },
  {
    "inherited": true,
    "name": "color-scheme"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "column-count"
  },
  {
    "keywords": [
      "balance",
      "auto"
    ],
    "name": "column-fill"
  },
  {
    "keywords": [
      "normal"
    ],
    "name": "column-gap"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "column-height"
  },
  {
    "longhands": [
      "column-rule-width",
      "column-rule-style",
      "column-rule-color"
    ],
    "name": "column-rule"
  },
  {
    "inherited": false,
    "keywords": [
      "none",
      "spanning-item",
      "intersection"
    ],
    "name": "column-rule-break"
  },
  {
    "keywords": [
      "currentcolor"
    ],
    "name": "column-rule-color"
  },
  {
    "inherited": false,
    "name": "column-rule-outset"
  },
  {
    "keywords": [
      "none",
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double"
    ],
    "name": "column-rule-style"
  },
  {
    "inherited": false,
    "keywords": [
      "all",
      "around",
      "between",
      "none"
    ],
    "name": "column-rule-visibility-items"
  },
  {
    "keywords": [
      "thin",
      "medium",
      "thick"
    ],
    "name": "column-rule-width"
  },
  {
    "keywords": [
      "none",
      "all"
    ],
    "name": "column-span"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "column-width"
  },
  {
    "keywords": [
      "auto",
      "nowrap",
      "wrap"
    ],
    "name": "column-wrap"
  },
  {
    "longhands": [
      "column-width",
      "column-count",
      "column-height",
      "column-wrap"
    ],
    "name": "columns"
  },
  {
    "keywords": [
      "none",
      "strict",
      "content",
      "size",
      "layout",
      "style",
      "paint",
      "inline-size",
      "block-size",
      "view-transition"
    ],
    "name": "contain"
  },
  {
    "name": "contain-intrinsic-block-size"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "contain-intrinsic-height"
  },
  {
    "name": "contain-intrinsic-inline-size"
  },
  {
    "longhands": [
      "contain-intrinsic-width",
      "contain-intrinsic-height"
    ],
    "name": "contain-intrinsic-size"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "contain-intrinsic-width"
  },
  {
    "longhands": [
      "container-name",
      "container-type"
    ],
    "name": "container"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "container-name"
  },
  {
    "keywords": [
      "normal",
      "inline-size",
      "size",
      "scroll-state",
      "anchored"
    ],
    "name": "container-type"
  },
  {
    "name": "content"
  },
  {
    "keywords": [
      "visible",
      "auto",
      "hidden"
    ],
    "name": "content-visibility"
  },
  {
    "keywords": [
      "auto",
      "collapse",
      "-webkit-legacy"
    ],
    "name": "continue"
  },
  {
    "longhands": [
      "corner-end-start-shape",
      "corner-end-end-shape"
    ],
    "name": "corner-block-end-shape"
  },
  {
    "longhands": [
      "corner-start-start-shape",
      "corner-start-end-shape"
    ],
    "name": "corner-block-start-shape"
  },
  {
    "keywords": [
      "notch",
      "scoop",
      "bevel",
      "round",
      "squircle",
      "square"
    ],
    "name": "corner-bottom-left-shape"
  },
  {
    "keywords": [
      "notch",
      "scoop",
      "bevel",
      "round",
      "squircle",
      "square"
    ],
    "name": "corner-bottom-right-shape"
  },
  {
    "longhands": [
      "corner-bottom-left-shape",
      "corner-bottom-right-shape"
    ],
    "name": "corner-bottom-shape"
  },
  {
    "name": "corner-end-end-shape"
  },
  {
    "name": "corner-end-start-shape"
  },
  {
    "longhands": [
      "corner-start-end-shape",
      "corner-end-end-shape"
    ],
    "name": "corner-inline-end-shape"
  },
  {
    "longhands": [
      "corner-start-start-shape",
      "corner-end-start-shape"
    ],
    "name": "corner-inline-start-shape"
  },
  {
    "longhands": [
      "corner-top-left-shape",
      "corner-bottom-left-shape"
    ],
    "name": "corner-left-shape"
  },
  {
    "longhands": [
      "corner-top-right-shape",
      "corner-bottom-right-shape"
    ],
    "name": "corner-right-shape"
  },
  {
    "longhands": [
      "corner-top-left-shape",
      "corner-top-right-shape",
      "corner-bottom-right-shape",
      "corner-bottom-left-shape"
    ],
    "name": "corner-shape"
  },
  {
    "name": "corner-start-end-shape"
  },
  {
    "name": "corner-start-start-shape"
  },
  {
    "keywords": [
      "notch",
      "scoop",
      "bevel",
      "round",
      "squircle",
      "square"
    ],
    "name": "corner-top-left-shape"
  },
  {
    "keywords": [
      "notch",
      "scoop",
      "bevel",
      "round",
      "squircle",
      "square"
    ],
    "name": "corner-top-right-shape"
  },
  {
    "longhands": [
      "corner-top-left-shape",
      "corner-top-right-shape"
    ],
    "name": "corner-top-shape"
  },
  {
    "keywords": [
      "normal"
    ],
    "longhands": [
      "border-top-left-radius",
      "corner-top-left-shape",
      "border-top-right-radius",
      "corner-top-right-shape",
      "border-bottom-right-radius",
      "corner-bottom-right-shape",
      "border-bottom-left-radius",
      "corner-bottom-left-shape"
    ],
    "name": "corners"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "counter-increment"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "counter-reset"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "counter-set"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "default",
      "none",
      "context-menu",
      "help",
      "pointer",
      "progress",
      "wait",
      "cell",
      "crosshair",
      "text",
      "vertical-text",
      "alias",
      "copy",
      "move",
      "no-drop",
      "not-allowed",
      "e-resize",
      "n-resize",
      "ne-resize",
      "nw-resize",
      "s-resize",
      "se-resize",
      "sw-resize",
      "w-resize",
      "ew-resize",
      "ns-resize",
      "nesw-resize",
      "nwse-resize",
      "col-resize",
      "row-resize",
      "all-scroll",
      "zoom-in",
      "zoom-out",
      "grab",
      "grabbing"
    ],
    "name": "cursor"
  },
  {
    "name": "cx"
  },
  {
    "name": "cy"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "d"
  },
  {
    "name": "descent-override"
  },
  {
    "inherited": true,
    "keywords": [
      "ltr",
      "rtl"
    ],
    "name": "direction"
  },
  {
    "keywords": [
      "inline",
      "block",
      "list-item",
      "inline-block",
      "table",
      "inline-table",
      "table-row-group",
      "table-header-group",
      "table-footer-group",
      "table-row",
      "table-column-group",
      "table-column",
      "table-cell",
      "table-caption",
      "-webkit-box",
      "-webkit-inline-box",
      "flex",
      "inline-flex",
      "grid",
      "inline-grid",
      "contents",
      "flow-root",
      "none",
      "flow",
      "math",
      "ruby",
      "ruby-text",
      "masonry",
      "inline-masonry"
    ],
    "name": "display"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "alphabetic",
      "ideographic",
      "middle",
      "central",
      "mathematical",
      "hanging",
      "use-script",
      "no-change",
      "reset-size",
      "text-after-edge",
      "text-before-edge"
    ],
    "name": "dominant-baseline"
  },
  {
    "inherited": true,
    "keywords": [
      "standard",
      "no-limit",
      "constrained"
    ],
    "name": "dynamic-range-limit"
  },
  {
    "inherited": true,
    "keywords": [
      "show",
      "hide"
    ],
    "name": "empty-cells"
  },
  {
    "name": "fallback"
  },
  {
    "keywords": [
      "fixed",
      "content"
    ],
    "name": "field-sizing"
  },
  {
    "inherited": true,
    "name": "fill"
  },
  {
    "inherited": true,
    "name": "fill-opacity"
  },
  {
    "inherited": true,
    "keywords": [
      "nonzero",
      "evenodd"
    ],
    "name": "fill-rule"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "filter"
  },
  {
    "longhands": [
      "flex-grow",
      "flex-shrink",
      "flex-basis"
    ],
    "name": "flex"
  },
  {
    "keywords": [
      "auto",
      "fit-content",
      "min-content",
      "max-content",
      "content"
    ],
    "name": "flex-basis"
  },
  {
    "keywords": [
      "row",
      "row-reverse",
      "column",
      "column-reverse"
    ],
    "name": "flex-direction"
  },
  {
    "longhands": [
      "flex-direction",
      "flex-wrap"
    ],
    "name": "flex-flow"
  },
  {
    "name": "flex-grow"
  },
  {
    "name": "flex-shrink"
  },
  {
    "keywords": [
      "nowrap",
      "wrap",
      "wrap-reverse",
      "balance"
    ],
    "name": "flex-wrap"
  },
  {
    "keywords": [
      "none",
      "left",
      "right",
      "inline-start",
      "inline-end"
    ],
    "name": "float"
  },
  {
    "keywords": [
      "currentcolor"
    ],
    "name": "flood-color"
  },
  {
    "name": "flood-opacity"
  },
  {
    "inherited": true,
    "longhands": [
      "font-style",
      "font-variant-ligatures",
      "font-variant-caps",
      "font-variant-numeric",
      "font-variant-east-asian",
      "font-variant-alternates",
      "font-variant-position",
      "font-variant-emoji",
      "font-weight",
      "font-stretch",
      "font-size",
      "line-height",
      "font-family",
      "font-optical-sizing",
      "font-size-adjust",
      "font-kerning",
      "font-feature-settings",
      "font-variation-settings",
      "font-language-override"
    ],
    "name": "font"
  },
  {
    "name": "font-display"
  },
  {
    "inherited": true,
    "name": "font-family"
  },
  {
    "inherited": true,
    "keywords": [
      "normal"
    ],
    "name": "font-feature-settings"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "normal",
      "none"
    ],
    "name": "font-kerning"
  },
  {
    "inherited": true,
    "keywords": [
      "normal"
    ],
    "name": "font-language-override"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "none"
    ],
    "name": "font-optical-sizing"
  },
  {
    "inherited": true,
    "keywords": [
      "normal",
      "light",
      "dark"
    ],
    "name": "font-palette"
  },
  {
    "inherited": true,
    "keywords": [
      "xx-small",
      "x-small",
      "small",
      "medium",
      "large",
      "x-large",
      "xx-large",
      "xxx-large",
      "larger",
      "smaller",
      "-webkit-xxx-large"
    ],
    "name": "font-size"
  },
  {
    "inherited": true,
    "keywords": [
      "none",
      "ex-height",
      "cap-height",
      "ch-width",
      "ic-width",
      "ic-height",
      "from-font"
    ],
    "name": "font-size-adjust"
  },
  {
    "inherited": true,
    "keywords": [
      "normal",
      "ultra-condensed",
      "extra-condensed",
      "condensed",
      "semi-condensed",
      "semi-expanded",
      "expanded",
      "extra-expanded",
      "ultra-expanded"
    ],
    "name": "font-stretch"
  },
  {
    "inherited": true,
    "keywords": [
      "normal",
      "italic",
      "oblique"
    ],
    "name": "font-style"
  },
  {
    "inherited": true,
    "longhands": [
      "font-synthesis-weight",
      "font-synthesis-style",
      "font-synthesis-small-caps"
    ],
    "name": "font-synthesis"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "none"
    ],
    "name": "font-synthesis-small-caps"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "none"
    ],
    "name": "font-synthesis-style"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "none"
    ],
    "name": "font-synthesis-weight"
  },
  {
    "inherited": true,
    "longhands": [
      "font-variant-ligatures",
      "font-variant-caps",
      "font-variant-alternates",
      "font-variant-numeric",
      "font-variant-east-asian",
      "font-variant-position",
      "font-variant-emoji"
    ],
    "name": "font-variant"
  },
  {
    "inherited": true,
    "keywords": [
      "normal"
    ],
    "name": "font-variant-alternates"
  },
  {
    "inherited": true,
    "keywords": [
      "normal",
      "small-caps",
      "all-small-caps",
      "petite-caps",
      "all-petite-caps",
      "unicase",
      "titling-caps"
    ],
    "name": "font-variant-caps"
  },
  {
    "inherited": true,
    "keywords": [
      "normal",
      "jis78",
      "jis83",
      "jis90",
      "jis04",
      "simplified",
      "traditional",
      "full-width",
      "proportional-width",
      "ruby"
    ],
    "name": "font-variant-east-asian"
  },
  {
    "inherited": true,
    "keywords": [
      "normal",
      "text",
      "emoji",
      "unicode"
    ],
    "name": "font-variant-emoji"
  },
  {
    "inherited": true,
    "keywords": [
      "normal",
      "none",
      "common-ligatures",
      "no-common-ligatures",
      "discretionary-ligatures",
      "no-discretionary-ligatures",
      "historical-ligatures",
      "no-historical-ligatures",
      "contextual",
      "no-contextual"
    ],
    "name": "font-variant-ligatures"
  },
  {
    "inherited": true,
    "keywords": [
      "normal",
      "lining-nums",
      "oldstyle-nums",
      "proportional-nums",
      "tabular-nums",
      "diagonal-fractions",
      "stacked-fractions",
      "ordinal",
      "slashed-zero"
    ],
    "name": "font-variant-numeric"
  },
  {
    "inherited": true,
    "keywords": [
      "normal",
      "sub",
      "super"
    ],
    "name": "font-variant-position"
  },
  {
    "inherited": true,
    "keywords": [
      "normal"
    ],
    "name": "font-variation-settings"
  },
  {
    "inherited": true,
    "keywords": [
      "normal",
      "bold",
      "bolder",
      "lighter"
    ],
    "name": "font-weight"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "none",
      "preserve-parent-color"
    ],
    "name": "forced-color-adjust"
  },
  {
    "longhands": [
      "row-gap",
      "column-gap"
    ],
    "name": "gap"
  },
  {
    "inherited": false,
    "keywords": [
      "row-over-column",
      "column-over-row"
    ],
    "name": "gap-rule-overlap"
  },
  {
    "longhands": [
      "grid-template-rows",
      "grid-template-columns",
      "grid-template-areas",
      "grid-auto-flow",
      "grid-auto-rows",
      "grid-auto-columns"
    ],
    "name": "grid"
  },
  {
    "longhands": [
      "grid-row-start",
      "grid-column-start",
      "grid-row-end",
      "grid-column-end"
    ],
    "name": "grid-area"
  },
  {
    "keywords": [
      "auto",
      "min-content",
      "max-content"
    ],
    "name": "grid-auto-columns"
  },
  {
    "keywords": [
      "row",
      "column"
    ],
    "name": "grid-auto-flow"
  },
  {
    "keywords": [
      "auto",
      "min-content",
      "max-content"
    ],
    "name": "grid-auto-rows"
  },
  {
    "longhands": [
      "grid-column-start",
      "grid-column-end"
    ],
    "name": "grid-column"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "grid-column-end"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "grid-column-start"
  },
  {
    "longhands": [
      "grid-row-start",
      "grid-row-end"
    ],
    "name": "grid-row"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "grid-row-end"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "grid-row-start"
  },
  {
    "longhands": [
      "grid-template-rows",
      "grid-template-columns",
      "grid-template-areas"
    ],
    "name": "grid-template"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "grid-template-areas"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "grid-template-columns"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "grid-template-rows"
  },
  {
    "keywords": [
      "auto",
      "fit-content",
      "min-content",
      "max-content"
    ],
    "name": "height"
  },
  {
    "inherited": true,
    "name": "hyphenate-character"
  },
  {
    "inherited": true,
    "keywords": [
      "auto"
    ],
    "name": "hyphenate-limit-chars"
  },
  {
    "inherited": true,
    "keywords": [
      "none",
      "manual",
      "auto"
    ],
    "name": "hyphens"
  },
  {
    "inherited": true,
    "name": "image-orientation"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "optimizespeed",
      "optimizequality",
      "-webkit-optimize-contrast",
      "pixelated"
    ],
    "name": "image-rendering"
  },
  {
    "name": "inherits"
  },
  {
    "inherited": false,
    "keywords": [
      "drop",
      "normal",
      "raise"
    ],
    "name": "initial-letter"
  },
  {
    "name": "initial-value"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "inline-size"
  },
  {
    "longhands": [
      "top",
      "right",
      "bottom",
      "left"
    ],
    "name": "inset"
  },
  {
    "longhands": [
      "inset-block-start",
      "inset-block-end"
    ],
    "name": "inset-block"
  },
  {
    "name": "inset-block-end"
  },
  {
    "name": "inset-block-start"
  },
  {
    "longhands": [
      "inset-inline-start",
      "inset-inline-end"
    ],
    "name": "inset-inline"
  },
  {
    "name": "inset-inline-end"
  },
  {
    "name": "inset-inline-start"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "inert"
    ],
    "name": "interactivity"
  },
  {
    "longhands": [
      "interest-delay-start",
      "interest-delay-end"
    ],
    "name": "interest-delay"
  },
  {
    "name": "interest-delay-end"
  },
  {
    "name": "interest-delay-start"
  },
  {
    "inherited": true,
    "keywords": [
      "numeric-only",
      "allow-keywords"
    ],
    "name": "interpolate-size"
  },
  {
    "keywords": [
      "auto",
      "isolate"
    ],
    "name": "isolation"
  },
  {
    "keywords": [
      "normal",
      "infinite"
    ],
    "name": "item-tolerance"
  },
  {
    "name": "justify-content"
  },
  {
    "name": "justify-items"
  },
  {
    "name": "justify-self"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "left"
  },
  {
    "inherited": true,
    "keywords": [
      "normal"
    ],
    "name": "letter-spacing"
  },
  {
    "keywords": [
      "currentcolor"
    ],
    "name": "lighting-color"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "loose",
      "normal",
      "strict",
      "anywhere",
      "after-white-space"
    ],
    "name": "line-break"
  },
  {
    "longhands": [
      "max-lines",
      "block-ellipsis",
      "continue"
    ],
    "name": "line-clamp"
  },
  {
    "name": "line-gap-override"
  },
  {
    "inherited": true,
    "keywords": [
      "normal"
    ],
    "name": "line-height"
  },
  {
    "inherited": true,
    "longhands": [
      "list-style-position",
      "list-style-image",
      "list-style-type"
    ],
    "name": "list-style"
  },
  {
    "inherited": true,
    "keywords": [
      "none"
    ],
    "name": "list-style-image"
  },
  {
    "inherited": true,
    "keywords": [
      "outside",
      "inside"
    ],
    "name": "list-style-position"
  },
  {
    "inherited": true,
    "keywords": [
      "disc",
      "circle",
      "square",
      "disclosure-open",
      "disclosure-closed",
      "decimal",
      "none"
    ],
    "name": "list-style-type"
  },
  {
    "longhands": [
      "margin-top",
      "margin-right",
      "margin-bottom",
      "margin-left"
    ],
    "name": "margin"
  },
  {
    "longhands": [
      "margin-block-start",
      "margin-block-end"
    ],
    "name": "margin-block"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "margin-block-end"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "margin-block-start"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "margin-bottom"
  },
  {
    "longhands": [
      "margin-inline-start",
      "margin-inline-end"
    ],
    "name": "margin-inline"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "margin-inline-end"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "margin-inline-start"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "margin-left"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "margin-right"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "margin-top"
  },
  {
    "inherited": true,
    "longhands": [
      "marker-start",
      "marker-mid",
      "marker-end"
    ],
    "name": "marker"
  },
  {
    "inherited": true,
    "keywords": [
      "none"
    ],
    "name": "marker-end"
  },
  {
    "inherited": true,
    "keywords": [
      "none"
    ],
    "name": "marker-mid"
  },
  {
    "inherited": true,
    "keywords": [
      "none"
    ],
    "name": "marker-start"
  },
  {
    "longhands": [
      "mask-image",
      "-webkit-mask-position-x",
      "-webkit-mask-position-y",
      "mask-size",
      "mask-repeat",
      "mask-origin",
      "mask-clip",
      "mask-composite",
      "mask-mode"
    ],
    "name": "mask"
  },
  {
    "name": "mask-clip"
  },
  {
    "keywords": [
      "add",
      "subtract",
      "intersect",
      "exclude"
    ],
    "name": "mask-composite"
  },
  {
    "name": "mask-image"
  },
  {
    "keywords": [
      "alpha",
      "luminance",
      "match-source"
    ],
    "name": "mask-mode"
  },
  {
    "name": "mask-origin"
  },
  {
    "longhands": [
      "-webkit-mask-position-x",
      "-webkit-mask-position-y"
    ],
    "name": "mask-position"
  },
  {
    "name": "mask-repeat"
  },
  {
    "name": "mask-size"
  },
  {
    "keywords": [
      "luminance",
      "alpha"
    ],
    "name": "mask-type"
  },
  {
    "longhands": [
      "grid-template-areas",
      "grid-template-columns",
      "masonry-direction",
      "masonry-fill"
    ],
    "name": "masonry"
  },
  {
    "keywords": [
      "row",
      "row-reverse",
      "column",
      "column-reverse"
    ],
    "name": "masonry-direction"
  },
  {
    "keywords": [
      "normal",
      "reverse"
    ],
    "name": "masonry-fill"
  },
  {
    "longhands": [
      "masonry-direction",
      "masonry-fill"
    ],
    "name": "masonry-flow"
  },
  {
    "inherited": true,
    "name": "math-depth"
  },
  {
    "inherited": true,
    "keywords": [
      "normal",
      "compact"
    ],
    "name": "math-shift"
  },
  {
    "inherited": true,
    "keywords": [
      "normal",
      "compact"
    ],
    "name": "math-style"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "max-block-size"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "max-height"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "max-inline-size"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "max-lines"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "max-width"
  },
  {
    "name": "min-block-size"
  },
  {
    "name": "min-height"
  },
  {
    "name": "min-inline-size"
  },
  {
    "name": "min-width"
  },
  {
    "keywords": [
      "normal",
      "multiply",
      "screen",
      "overlay",
      "darken",
      "lighten",
      "color-dodge",
      "color-burn",
      "hard-light",
      "soft-light",
      "difference",
      "exclusion",
      "hue",
      "saturation",
      "color",
      "luminosity",
      "plus-lighter"
    ],
    "name": "mix-blend-mode"
  },
  {
    "name": "navigation"
  },
  {
    "name": "negative"
  },
  {
    "keywords": [
      "fill",
      "contain",
      "cover",
      "none",
      "scale-down"
    ],
    "name": "object-fit"
  },
  {
    "name": "object-position"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "object-view-box"
  },
  {
    "longhands": [
      "offset-position",
      "offset-path",
      "offset-distance",
      "offset-rotate",
      "offset-anchor"
    ],
    "name": "offset"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "offset-anchor"
  },
  {
    "name": "offset-distance"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "offset-path"
  },
  {
    "keywords": [
      "auto",
      "normal"
    ],
    "name": "offset-position"
  },
  {
    "keywords": [
      "auto",
      "reverse"
    ],
    "name": "offset-rotate"
  },
  {
    "name": "opacity"
  },
  {
    "name": "order"
  },
  {
    "keywords": [
      "normal",
      "none"
    ],
    "name": "origin-trial-test-property"
  },
  {
    "inherited": true,
    "name": "orphans"
  },
  {
    "longhands": [
      "outline-color",
      "outline-style",
      "outline-width"
    ],
    "name": "outline"
  },
  {
    "keywords": [
      "currentcolor"
    ],
    "name": "outline-color"
  },
  {
    "name": "outline-offset"
  },
  {
    "keywords": [
      "none",
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double"
    ],
    "name": "outline-style"
  },
  {
    "keywords": [
      "thin",
      "medium",
      "thick"
    ],
    "name": "outline-width"
  },
  {
    "longhands": [
      "overflow-x",
      "overflow-y"
    ],
    "name": "overflow"
  },
  {
    "inherited": false,
    "keywords": [
      "visible",
      "none",
      "auto"
    ],
    "name": "overflow-anchor"
  },
  {
    "name": "overflow-block"
  },
  {
    "keywords": [
      "border-box",
      "content-box",
      "padding-box"
    ],
    "name": "overflow-clip-margin"
  },
  {
    "name": "overflow-inline"
  },
  {
    "inherited": true,
    "keywords": [
      "normal",
      "break-word",
      "anywhere"
    ],
    "name": "overflow-wrap"
  },
  {
    "keywords": [
      "visible",
      "hidden",
      "scroll",
      "auto",
      "overlay",
      "clip"
    ],
    "name": "overflow-x"
  },
  {
    "keywords": [
      "visible",
      "hidden",
      "scroll",
      "auto",
      "overlay",
      "clip"
    ],
    "name": "overflow-y"
  },
  {
    "keywords": [
      "none",
      "auto"
    ],
    "name": "overlay"
  },
  {
    "name": "override-colors"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "overscroll-area"
  },
  {
    "longhands": [
      "overscroll-behavior-x",
      "overscroll-behavior-y"
    ],
    "name": "overscroll-behavior"
  },
  {
    "name": "overscroll-behavior-block"
  },
  {
    "name": "overscroll-behavior-inline"
  },
  {
    "keywords": [
      "auto",
      "contain",
      "none"
    ],
    "name": "overscroll-behavior-x"
  },
  {
    "keywords": [
      "auto",
      "contain",
      "none"
    ],
    "name": "overscroll-behavior-y"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "overscroll-position"
  },
  {
    "name": "pad"
  },
  {
    "longhands": [
      "padding-top",
      "padding-right",
      "padding-bottom",
      "padding-left"
    ],
    "name": "padding"
  },
  {
    "longhands": [
      "padding-block-start",
      "padding-block-end"
    ],
    "name": "padding-block"
  },
  {
    "name": "padding-block-end"
  },
  {
    "name": "padding-block-start"
  },
  {
    "name": "padding-bottom"
  },
  {
    "longhands": [
      "padding-inline-start",
      "padding-inline-end"
    ],
    "name": "padding-inline"
  },
  {
    "name": "padding-inline-end"
  },
  {
    "name": "padding-inline-start"
  },
  {
    "name": "padding-left"
  },
  {
    "name": "padding-right"
  },
  {
    "name": "padding-top"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "page"
  },
  {
    "longhands": [
      "break-after"
    ],
    "name": "page-break-after"
  },
  {
    "longhands": [
      "break-before"
    ],
    "name": "page-break-before"
  },
  {
    "longhands": [
      "break-inside"
    ],
    "name": "page-break-inside"
  },
  {
    "name": "page-orientation"
  },
  {
    "inherited": true,
    "keywords": [
      "normal",
      "fill",
      "stroke",
      "markers"
    ],
    "name": "paint-order"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "perspective"
  },
  {
    "name": "perspective-origin"
  },
  {
    "longhands": [
      "align-content",
      "justify-content"
    ],
    "name": "place-content"
  },
  {
    "longhands": [
      "align-items",
      "justify-items"
    ],
    "name": "place-items"
  },
  {
    "longhands": [
      "align-self",
      "justify-self"
    ],
    "name": "place-self"
  },
  {
    "inherited": true,
    "keywords": [
      "none",
      "auto",
      "stroke",
      "fill",
      "painted",
      "visible",
      "visiblestroke",
      "visiblefill",
      "visiblepainted",
      "bounding-box",
      "all"
    ],
    "name": "pointer-events"
  },
  {
    "keywords": [
      "static",
      "relative",
      "absolute",
      "fixed",
      "sticky"
    ],
    "name": "position"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "position-anchor"
  },
  {
    "keywords": [
      "none",
      "top",
      "bottom",
      "center",
      "left",
      "right",
      "x-start",
      "x-end",
      "y-start",
      "y-end",
      "start",
      "end",
      "self-start",
      "self-end",
      "all"
    ],
    "name": "position-area"
  },
  {
    "longhands": [
      "position-try-order",
      "position-try-fallbacks"
    ],
    "name": "position-try"
  },
  {
    "keywords": [
      "none",
      "flip-block",
      "flip-inline",
      "flip-start"
    ],
    "name": "position-try-fallbacks"
  },
  {
    "keywords": [
      "normal",
      "most-width",
      "most-height",
      "most-block-size",
      "most-inline-size"
    ],
    "name": "position-try-order"
  },
  {
    "keywords": [
      "always",
      "anchors-visible",
      "no-overflow"
    ],
    "name": "position-visibility"
  },
  {
    "name": "prefix"
  },
  {
    "inherited": true,
    "keywords": [
      "economy",
      "exact"
    ],
    "name": "print-color-adjust"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "none"
    ],
    "name": "quotes"
  },
  {
    "name": "r"
  },
  {
    "name": "range"
  },
  {
    "keywords": [
      "normal",
      "flex-visual",
      "flex-flow",
      "grid-rows",
      "grid-columns",
      "grid-order",
      "source-order"
    ],
    "name": "reading-flow"
  },
  {
    "name": "reading-order"
  },
  {
    "keywords": [
      "none",
      "both",
      "horizontal",
      "vertical",
      "block",
      "inline"
    ],
    "name": "resize"
  },
  {
    "name": "result"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "right"
  },
  {
    "name": "rotate"
  },
  {
    "keywords": [
      "normal"
    ],
    "name": "row-gap"
  },
  {
    "longhands": [
      "row-rule-width",
      "row-rule-style",
      "row-rule-color"
    ],
    "name": "row-rule"
  },
  {
    "inherited": false,
    "keywords": [
      "none",
      "spanning-item",
      "intersection"
    ],
    "name": "row-rule-break"
  },
  {
    "keywords": [
      "currentcolor"
    ],
    "name": "row-rule-color"
  },
  {
    "inherited": false,
    "name": "row-rule-outset"
  },
  {
    "keywords": [
      "none",
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double"
    ],
    "name": "row-rule-style"
  },
  {
    "inherited": false,
    "keywords": [
      "all",
      "around",
      "between",
      "none"
    ],
    "name": "row-rule-visibility-items"
  },
  {
    "keywords": [
      "thin",
      "medium",
      "thick"
    ],
    "name": "row-rule-width"
  },
  {
    "inherited": true,
    "keywords": [
      "space-around",
      "start",
      "center",
      "space-between"
    ],
    "name": "ruby-align"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "none"
    ],
    "name": "ruby-overhang"
  },
  {
    "inherited": true,
    "keywords": [
      "over",
      "under"
    ],
    "name": "ruby-position"
  },
  {
    "longhands": [
      "column-rule-width",
      "column-rule-style",
      "column-rule-color",
      "row-rule-width",
      "row-rule-style",
      "row-rule-color"
    ],
    "name": "rule"
  },
  {
    "longhands": [
      "row-rule-break",
      "column-rule-break"
    ],
    "name": "rule-break"
  },
  {
    "longhands": [
      "column-rule-color",
      "row-rule-color"
    ],
    "name": "rule-color"
  },
  {
    "longhands": [
      "row-rule-outset",
      "column-rule-outset"
    ],
    "name": "rule-outset"
  },
  {
    "longhands": [
      "column-rule-style",
      "row-rule-style"
    ],
    "name": "rule-style"
  },
  {
    "longhands": [
      "column-rule-width",
      "row-rule-width"
    ],
    "name": "rule-width"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "rx"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "ry"
  },
  {
    "name": "scale"
  },
  {
    "keywords": [
      "auto",
      "smooth"
    ],
    "name": "scroll-behavior"
  },
  {
    "keywords": [
      "none",
      "nearest"
    ],
    "name": "scroll-initial-target"
  },
  {
    "longhands": [
      "scroll-margin-top",
      "scroll-margin-right",
      "scroll-margin-bottom",
      "scroll-margin-left"
    ],
    "name": "scroll-margin"
  },
  {
    "longhands": [
      "scroll-margin-block-start",
      "scroll-margin-block-end"
    ],
    "name": "scroll-margin-block"
  },
  {
    "name": "scroll-margin-block-end"
  },
  {
    "name": "scroll-margin-block-start"
  },
  {
    "name": "scroll-margin-bottom"
  },
  {
    "longhands": [
      "scroll-margin-inline-start",
      "scroll-margin-inline-end"
    ],
    "name": "scroll-margin-inline"
  },
  {
    "name": "scroll-margin-inline-end"
  },
  {
    "name": "scroll-margin-inline-start"
  },
  {
    "name": "scroll-margin-left"
  },
  {
    "name": "scroll-margin-right"
  },
  {
    "name": "scroll-margin-top"
  },
  {
    "name": "scroll-marker-group"
  },
  {
    "longhands": [
      "scroll-padding-top",
      "scroll-padding-right",
      "scroll-padding-bottom",
      "scroll-padding-left"
    ],
    "name": "scroll-padding"
  },
  {
    "longhands": [
      "scroll-padding-block-start",
      "scroll-padding-block-end"
    ],
    "name": "scroll-padding-block"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "scroll-padding-block-end"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "scroll-padding-block-start"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "scroll-padding-bottom"
  },
  {
    "longhands": [
      "scroll-padding-inline-start",
      "scroll-padding-inline-end"
    ],
    "name": "scroll-padding-inline"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "scroll-padding-inline-end"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "scroll-padding-inline-start"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "scroll-padding-left"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "scroll-padding-right"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "scroll-padding-top"
  },
  {
    "keywords": [
      "none",
      "start",
      "end",
      "center"
    ],
    "name": "scroll-snap-align"
  },
  {
    "keywords": [
      "normal",
      "always"
    ],
    "name": "scroll-snap-stop"
  },
  {
    "keywords": [
      "none",
      "x",
      "y",
      "block",
      "inline",
      "both",
      "mandatory",
      "proximity"
    ],
    "name": "scroll-snap-type"
  },
  {
    "longhands": [
      "scroll-start-block",
      "scroll-start-inline"
    ],
    "name": "scroll-start"
  },
  {
    "name": "scroll-start-block"
  },
  {
    "name": "scroll-start-inline"
  },
  {
    "name": "scroll-start-x"
  },
  {
    "name": "scroll-start-y"
  },
  {
    "keywords": [
      "none",
      "auto"
    ],
    "name": "scroll-target-group"
  },
  {
    "longhands": [
      "scroll-timeline-name",
      "scroll-timeline-axis"
    ],
    "name": "scroll-timeline"
  },
  {
    "name": "scroll-timeline-axis"
  },
  {
    "name": "scroll-timeline-name"
  },
  {
    "inherited": true,
    "keywords": [
      "auto"
    ],
    "name": "scrollbar-color"
  },
  {
    "inherited": false,
    "keywords": [
      "auto",
      "stable",
      "both-edges"
    ],
    "name": "scrollbar-gutter"
  },
  {
    "inherited": false,
    "keywords": [
      "auto",
      "thin",
      "none"
    ],
    "name": "scrollbar-width"
  },
  {
    "name": "shape-image-threshold"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "shape-margin"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "shape-outside"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "optimizespeed",
      "crispedges",
      "geometricprecision"
    ],
    "name": "shape-rendering"
  },
  {
    "name": "size"
  },
  {
    "name": "size-adjust"
  },
  {
    "inherited": true,
    "keywords": [
      "none",
      "normal",
      "spell-out",
      "digits",
      "literal-punctuation",
      "no-punctuation"
    ],
    "name": "speak"
  },
  {
    "name": "speak-as"
  },
  {
    "name": "src"
  },
  {
    "keywords": [
      "currentcolor"
    ],
    "name": "stop-color"
  },
  {
    "name": "stop-opacity"
  },
  {
    "inherited": true,
    "name": "stroke"
  },
  {
    "inherited": true,
    "keywords": [
      "none"
    ],
    "name": "stroke-dasharray"
  },
  {
    "inherited": true,
    "name": "stroke-dashoffset"
  },
  {
    "inherited": true,
    "keywords": [
      "butt",
      "round",
      "square"
    ],
    "name": "stroke-linecap"
  },
  {
    "inherited": true,
    "keywords": [
      "miter",
      "bevel",
      "round"
    ],
    "name": "stroke-linejoin"
  },
  {
    "inherited": true,
    "name": "stroke-miterlimit"
  },
  {
    "inherited": true,
    "name": "stroke-opacity"
  },
  {
    "inherited": true,
    "name": "stroke-width"
  },
  {
    "name": "suffix"
  },
  {
    "name": "symbols"
  },
  {
    "name": "syntax"
  },
  {
    "name": "system"
  },
  {
    "inherited": true,
    "name": "tab-size"
  },
  {
    "keywords": [
      "auto",
      "fixed"
    ],
    "name": "table-layout"
  },
  {
    "inherited": true,
    "keywords": [
      "left",
      "right",
      "center",
      "justify",
      "-webkit-left",
      "-webkit-right",
      "-webkit-center",
      "start",
      "end",
      "match-parent"
    ],
    "name": "text-align"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "start",
      "end",
      "left",
      "right",
      "center",
      "justify",
      "match-parent"
    ],
    "name": "text-align-last"
  },
  {
    "inherited": true,
    "keywords": [
      "start",
      "middle",
      "end"
    ],
    "name": "text-anchor"
  },
  {
    "inherited": true,
    "keywords": [
      "no-autospace",
      "normal"
    ],
    "name": "text-autospace"
  },
  {
    "longhands": [
      "text-box-trim",
      "text-box-edge"
    ],
    "name": "text-box"
  },
  {
    "inherited": true,
    "name": "text-box-edge"
  },
  {
    "keywords": [
      "none",
      "trim-start",
      "trim-end",
      "trim-both"
    ],
    "name": "text-box-trim"
  },
  {
    "inherited": true,
    "keywords": [
      "none",
      "all"
    ],
    "name": "text-combine-upright"
  },
  {
    "longhands": [
      "text-decoration-line",
      "text-decoration-thickness",
      "text-decoration-style",
      "text-decoration-color"
    ],
    "name": "text-decoration"
  },
  {
    "keywords": [
      "currentcolor"
    ],
    "name": "text-decoration-color"
  },
  {
    "keywords": [
      "none",
      "underline",
      "overline",
      "line-through",
      "blink",
      "spelling-error",
      "grammar-error"
    ],
    "name": "text-decoration-line"
  },
  {
    "inherited": true,
    "keywords": [
      "none",
      "auto"
    ],
    "name": "text-decoration-skip-ink"
  },
  {
    "keywords": [
      "solid",
      "double",
      "dotted",
      "dashed",
      "wavy"
    ],
    "name": "text-decoration-style"
  },
  {
    "inherited": false,
    "keywords": [
      "auto",
      "from-font"
    ],
    "name": "text-decoration-thickness"
  },
  {
    "inherited": true,
    "longhands": [
      "text-emphasis-style",
      "text-emphasis-color"
    ],
    "name": "text-emphasis"
  },
  {
    "inherited": true,
    "keywords": [
      "currentcolor"
    ],
    "name": "text-emphasis-color"
  },
  {
    "inherited": true,
    "name": "text-emphasis-position"
  },
  {
    "inherited": true,
    "name": "text-emphasis-style"
  },
  {
    "name": "text-grow"
  },
  {
    "inherited": true,
    "name": "text-indent"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "none",
      "inter-word",
      "inter-character"
    ],
    "name": "text-justify"
  },
  {
    "inherited": true,
    "keywords": [
      "sideways",
      "mixed",
      "upright"
    ],
    "name": "text-orientation"
  },
  {
    "keywords": [
      "clip",
      "ellipsis"
    ],
    "name": "text-overflow"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "optimizespeed",
      "optimizelegibility",
      "geometricprecision"
    ],
    "name": "text-rendering"
  },
  {
    "inherited": true,
    "keywords": [
      "none"
    ],
    "name": "text-shadow"
  },
  {
    "name": "text-shrink"
  },
  {
    "inherited": true,
    "keywords": [
      "none",
      "auto"
    ],
    "name": "text-size-adjust"
  },
  {
    "inherited": true,
    "longhands": [
      "text-autospace",
      "text-spacing-trim"
    ],
    "name": "text-spacing"
  },
  {
    "inherited": true,
    "keywords": [
      "normal",
      "space-all",
      "space-first",
      "trim-start"
    ],
    "name": "text-spacing-trim"
  },
  {
    "inherited": true,
    "keywords": [
      "capitalize",
      "uppercase",
      "lowercase",
      "full-width",
      "none",
      "math-auto"
    ],
    "name": "text-transform"
  },
  {
    "inherited": true,
    "keywords": [
      "auto"
    ],
    "name": "text-underline-offset"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "from-font",
      "under",
      "left",
      "right"
    ],
    "name": "text-underline-position"
  },
  {
    "inherited": true,
    "longhands": [
      "text-wrap-mode",
      "text-wrap-style"
    ],
    "name": "text-wrap"
  },
  {
    "inherited": true,
    "keywords": [
      "wrap",
      "nowrap"
    ],
    "name": "text-wrap-mode"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "balance",
      "pretty",
      "stable"
    ],
    "name": "text-wrap-style"
  },
  {
    "name": "timeline-scope"
  },
  {
    "longhands": [
      "timeline-trigger-name",
      "timeline-trigger-source",
      "timeline-trigger-range-start",
      "timeline-trigger-range-end",
      "timeline-trigger-exit-range-start",
      "timeline-trigger-exit-range-end"
    ],
    "name": "timeline-trigger"
  },
  {
    "name": "timeline-trigger-exit-range-end"
  },
  {
    "name": "timeline-trigger-exit-range-start"
  },
  {
    "name": "timeline-trigger-name"
  },
  {
    "name": "timeline-trigger-range-end"
  },
  {
    "name": "timeline-trigger-range-start"
  },
  {
    "keywords": [
      "none",
      "auto"
    ],
    "name": "timeline-trigger-source"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "top"
  },
  {
    "keywords": [
      "auto",
      "none",
      "pan-x",
      "pan-left",
      "pan-right",
      "pan-y",
      "pan-up",
      "pan-down",
      "pinch-zoom",
      "manipulation"
    ],
    "name": "touch-action"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "transform"
  },
  {
    "keywords": [
      "content-box",
      "border-box",
      "fill-box",
      "stroke-box",
      "view-box"
    ],
    "name": "transform-box"
  },
  {
    "name": "transform-origin"
  },
  {
    "keywords": [
      "flat",
      "preserve-3d"
    ],
    "name": "transform-style"
  },
  {
    "longhands": [
      "transition-property",
      "transition-duration",
      "transition-timing-function",
      "transition-delay",
      "transition-behavior"
    ],
    "name": "transition"
  },
  {
    "keywords": [
      "normal",
      "allow-discrete"
    ],
    "name": "transition-behavior"
  },
  {
    "name": "transition-delay"
  },
  {
    "name": "transition-duration"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "transition-property"
  },
  {
    "keywords": [
      "linear",
      "ease",
      "ease-in",
      "ease-out",
      "ease-in-out",
      "jump-both",
      "jump-end",
      "jump-none",
      "jump-start",
      "step-start",
      "step-end"
    ],
    "name": "transition-timing-function"
  },
  {
    "name": "translate"
  },
  {
    "name": "types"
  },
  {
    "keywords": [
      "normal",
      "embed",
      "bidi-override",
      "isolate",
      "plaintext",
      "isolate-override"
    ],
    "name": "unicode-bidi"
  },
  {
    "name": "unicode-range"
  },
  {
    "inherited": true,
    "keywords": [
      "auto",
      "none",
      "text",
      "all",
      "contain"
    ],
    "name": "user-select"
  },
  {
    "keywords": [
      "none",
      "non-scaling-stroke"
    ],
    "name": "vector-effect"
  },
  {
    "keywords": [
      "baseline",
      "sub",
      "super",
      "text-top",
      "text-bottom",
      "middle"
    ],
    "name": "vertical-align"
  },
  {
    "longhands": [
      "view-timeline-name",
      "view-timeline-axis",
      "view-timeline-inset"
    ],
    "name": "view-timeline"
  },
  {
    "name": "view-timeline-axis"
  },
  {
    "name": "view-timeline-inset"
  },
  {
    "name": "view-timeline-name"
  },
  {
    "keywords": [
      "none"
    ],
    "name": "view-transition-class"
  },
  {
    "keywords": [
      "normal",
      "contain",
      "nearest"
    ],
    "name": "view-transition-group"
  },
  {
    "keywords": [
      "none",
      "auto"
    ],
    "name": "view-transition-name"
  },
  {
    "inherited": true,
    "keywords": [
      "visible",
      "hidden",
      "collapse"
    ],
    "name": "visibility"
  },
  {
    "inherited": true,
    "longhands": [
      "white-space-collapse",
      "text-wrap-mode"
    ],
    "name": "white-space"
  },
  {
    "inherited": true,
    "keywords": [
      "collapse",
      "preserve",
      "preserve-breaks",
      "break-spaces"
    ],
    "name": "white-space-collapse"
  },
  {
    "inherited": true,
    "name": "widows"
  },
  {
    "keywords": [
      "auto",
      "fit-content",
      "min-content",
      "max-content"
    ],
    "name": "width"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "will-change"
  },
  {
    "inherited": true,
    "keywords": [
      "normal",
      "break-all",
      "keep-all",
      "break-word",
      "auto-phrase"
    ],
    "name": "word-break"
  },
  {
    "inherited": true,
    "keywords": [
      "normal"
    ],
    "name": "word-spacing"
  },
  {
    "inherited": true,
    "keywords": [
      "horizontal-tb",
      "vertical-rl",
      "vertical-lr",
      "sideways-rl",
      "sideways-lr"
    ],
    "name": "writing-mode"
  },
  {
    "name": "x"
  },
  {
    "name": "y"
  },
  {
    "keywords": [
      "auto"
    ],
    "name": "z-index"
  },
  {
    "name": "zoom"
  }
];
var generatedPropertyValues = {
  "-webkit-box-align": {
    "values": [
      "stretch",
      "start",
      "center",
      "end",
      "baseline"
    ]
  },
  "-webkit-box-decoration-break": {
    "values": [
      "slice",
      "clone"
    ]
  },
  "-webkit-box-direction": {
    "values": [
      "normal",
      "reverse"
    ]
  },
  "-webkit-box-orient": {
    "values": [
      "horizontal",
      "vertical"
    ]
  },
  "-webkit-box-pack": {
    "values": [
      "start",
      "center",
      "end",
      "justify"
    ]
  },
  "-webkit-line-break": {
    "values": [
      "auto",
      "loose",
      "normal",
      "strict",
      "after-white-space"
    ]
  },
  "-webkit-line-clamp": {
    "values": [
      "none"
    ]
  },
  "-webkit-rtl-ordering": {
    "values": [
      "logical",
      "visual"
    ]
  },
  "-webkit-text-security": {
    "values": [
      "none",
      "disc",
      "circle",
      "square"
    ]
  },
  "-webkit-user-drag": {
    "values": [
      "auto",
      "none",
      "element"
    ]
  },
  "-webkit-user-modify": {
    "values": [
      "read-only",
      "read-write",
      "read-write-plaintext-only"
    ]
  },
  "accent-color": {
    "values": [
      "auto",
      "currentcolor"
    ]
  },
  "alignment-baseline": {
    "values": [
      "auto",
      "baseline",
      "alphabetic",
      "ideographic",
      "middle",
      "central",
      "mathematical",
      "before-edge",
      "text-before-edge",
      "after-edge",
      "text-after-edge",
      "hanging"
    ]
  },
  "anchor-name": {
    "values": [
      "none"
    ]
  },
  "anchor-scope": {
    "values": [
      "none",
      "all"
    ]
  },
  "animation-composition": {
    "values": [
      "replace",
      "add",
      "accumulate"
    ]
  },
  "animation-direction": {
    "values": [
      "normal",
      "reverse",
      "alternate",
      "alternate-reverse"
    ]
  },
  "animation-fill-mode": {
    "values": [
      "none",
      "forwards",
      "backwards",
      "both"
    ]
  },
  "animation-iteration-count": {
    "values": [
      "infinite"
    ]
  },
  "animation-name": {
    "values": [
      "none"
    ]
  },
  "animation-play-state": {
    "values": [
      "running",
      "paused"
    ]
  },
  "animation-timeline": {
    "values": [
      "none",
      "auto"
    ]
  },
  "animation-timing-function": {
    "values": [
      "linear",
      "ease",
      "ease-in",
      "ease-out",
      "ease-in-out",
      "jump-both",
      "jump-end",
      "jump-none",
      "jump-start",
      "step-start",
      "step-end"
    ]
  },
  "animation-trigger": {
    "values": [
      "none"
    ]
  },
  "app-region": {
    "values": [
      "none",
      "drag",
      "no-drag"
    ]
  },
  "aspect-ratio": {
    "values": [
      "auto"
    ]
  },
  "backdrop-filter": {
    "values": [
      "none"
    ]
  },
  "backface-visibility": {
    "values": [
      "visible",
      "hidden"
    ]
  },
  "background-attachment": {
    "values": [
      "scroll",
      "fixed",
      "local"
    ]
  },
  "background-blend-mode": {
    "values": [
      "normal",
      "multiply",
      "screen",
      "overlay",
      "darken",
      "lighten",
      "color-dodge",
      "color-burn",
      "hard-light",
      "soft-light",
      "difference",
      "exclusion",
      "hue",
      "saturation",
      "color",
      "luminosity"
    ]
  },
  "background-clip": {
    "values": [
      "border-box",
      "padding-box",
      "content-box",
      "text"
    ]
  },
  "background-color": {
    "values": [
      "currentcolor"
    ]
  },
  "background-image": {
    "values": [
      "auto",
      "none"
    ]
  },
  "background-origin": {
    "values": [
      "border-box",
      "padding-box",
      "content-box"
    ]
  },
  "background-size": {
    "values": [
      "auto",
      "cover",
      "contain"
    ]
  },
  "baseline-shift": {
    "values": [
      "baseline",
      "sub",
      "super"
    ]
  },
  "baseline-source": {
    "values": [
      "auto",
      "first",
      "last"
    ]
  },
  "block-ellipsis": {
    "values": [
      "auto",
      "no-ellipsis"
    ]
  },
  "block-size": {
    "values": [
      "auto"
    ]
  },
  "border-bottom-color": {
    "values": [
      "currentcolor"
    ]
  },
  "border-bottom-style": {
    "values": [
      "none",
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double"
    ]
  },
  "border-bottom-width": {
    "values": [
      "thin",
      "medium",
      "thick"
    ]
  },
  "border-collapse": {
    "values": [
      "separate",
      "collapse"
    ]
  },
  "border-image-repeat": {
    "values": [
      "stretch",
      "repeat",
      "round",
      "space"
    ]
  },
  "border-image-source": {
    "values": [
      "none"
    ]
  },
  "border-image-width": {
    "values": [
      "auto"
    ]
  },
  "border-left-color": {
    "values": [
      "currentcolor"
    ]
  },
  "border-left-style": {
    "values": [
      "none",
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double"
    ]
  },
  "border-left-width": {
    "values": [
      "thin",
      "medium",
      "thick"
    ]
  },
  "border-right-color": {
    "values": [
      "currentcolor"
    ]
  },
  "border-right-style": {
    "values": [
      "none",
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double"
    ]
  },
  "border-right-width": {
    "values": [
      "thin",
      "medium",
      "thick"
    ]
  },
  "border-shape": {
    "values": [
      "none"
    ]
  },
  "border-style": {
    "values": [
      "none"
    ]
  },
  "border-top-color": {
    "values": [
      "currentcolor"
    ]
  },
  "border-top-style": {
    "values": [
      "none",
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double"
    ]
  },
  "border-top-width": {
    "values": [
      "thin",
      "medium",
      "thick"
    ]
  },
  "bottom": {
    "values": [
      "auto"
    ]
  },
  "box-decoration-break": {
    "values": [
      "slice",
      "clone"
    ]
  },
  "box-shadow": {
    "values": [
      "none"
    ]
  },
  "box-sizing": {
    "values": [
      "content-box",
      "border-box"
    ]
  },
  "break-after": {
    "values": [
      "auto",
      "avoid",
      "avoid-column",
      "avoid-page",
      "column",
      "left",
      "page",
      "recto",
      "right",
      "verso"
    ]
  },
  "break-before": {
    "values": [
      "auto",
      "avoid",
      "avoid-column",
      "avoid-page",
      "column",
      "left",
      "page",
      "recto",
      "right",
      "verso"
    ]
  },
  "break-inside": {
    "values": [
      "auto",
      "avoid",
      "avoid-column",
      "avoid-page"
    ]
  },
  "buffered-rendering": {
    "values": [
      "auto",
      "dynamic",
      "static"
    ]
  },
  "caption-side": {
    "values": [
      "top",
      "bottom"
    ]
  },
  "caret-animation": {
    "values": [
      "auto",
      "manual"
    ]
  },
  "caret-color": {
    "values": [
      "auto",
      "currentcolor"
    ]
  },
  "caret-shape": {
    "values": [
      "auto",
      "bar",
      "block",
      "underscore"
    ]
  },
  "clear": {
    "values": [
      "none",
      "left",
      "right",
      "both",
      "inline-start",
      "inline-end"
    ]
  },
  "clip": {
    "values": [
      "auto"
    ]
  },
  "clip-path": {
    "values": [
      "border-box",
      "padding-box",
      "content-box",
      "margin-box",
      "fill-box",
      "stroke-box",
      "view-box",
      "none"
    ]
  },
  "clip-rule": {
    "values": [
      "nonzero",
      "evenodd"
    ]
  },
  "color": {
    "values": [
      "currentcolor"
    ]
  },
  "color-interpolation": {
    "values": [
      "auto",
      "srgb",
      "linearrgb"
    ]
  },
  "color-interpolation-filters": {
    "values": [
      "auto",
      "srgb",
      "linearrgb"
    ]
  },
  "color-rendering": {
    "values": [
      "auto",
      "optimizespeed",
      "optimizequality"
    ]
  },
  "column-count": {
    "values": [
      "auto"
    ]
  },
  "column-fill": {
    "values": [
      "balance",
      "auto"
    ]
  },
  "column-gap": {
    "values": [
      "normal"
    ]
  },
  "column-height": {
    "values": [
      "auto"
    ]
  },
  "column-rule-break": {
    "values": [
      "none",
      "spanning-item",
      "intersection"
    ]
  },
  "column-rule-color": {
    "values": [
      "currentcolor"
    ]
  },
  "column-rule-style": {
    "values": [
      "none",
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double"
    ]
  },
  "column-rule-visibility-items": {
    "values": [
      "all",
      "around",
      "between",
      "none"
    ]
  },
  "column-rule-width": {
    "values": [
      "thin",
      "medium",
      "thick"
    ]
  },
  "column-span": {
    "values": [
      "none",
      "all"
    ]
  },
  "column-width": {
    "values": [
      "auto"
    ]
  },
  "column-wrap": {
    "values": [
      "auto",
      "nowrap",
      "wrap"
    ]
  },
  "contain": {
    "values": [
      "none",
      "strict",
      "content",
      "size",
      "layout",
      "style",
      "paint",
      "inline-size",
      "block-size",
      "view-transition"
    ]
  },
  "contain-intrinsic-height": {
    "values": [
      "none"
    ]
  },
  "contain-intrinsic-width": {
    "values": [
      "none"
    ]
  },
  "container-name": {
    "values": [
      "none"
    ]
  },
  "container-type": {
    "values": [
      "normal",
      "inline-size",
      "size",
      "scroll-state",
      "anchored"
    ]
  },
  "content-visibility": {
    "values": [
      "visible",
      "auto",
      "hidden"
    ]
  },
  "continue": {
    "values": [
      "auto",
      "collapse",
      "-webkit-legacy"
    ]
  },
  "corner-bottom-left-shape": {
    "values": [
      "notch",
      "scoop",
      "bevel",
      "round",
      "squircle",
      "square"
    ]
  },
  "corner-bottom-right-shape": {
    "values": [
      "notch",
      "scoop",
      "bevel",
      "round",
      "squircle",
      "square"
    ]
  },
  "corner-top-left-shape": {
    "values": [
      "notch",
      "scoop",
      "bevel",
      "round",
      "squircle",
      "square"
    ]
  },
  "corner-top-right-shape": {
    "values": [
      "notch",
      "scoop",
      "bevel",
      "round",
      "squircle",
      "square"
    ]
  },
  "corners": {
    "values": [
      "normal"
    ]
  },
  "counter-increment": {
    "values": [
      "none"
    ]
  },
  "counter-reset": {
    "values": [
      "none"
    ]
  },
  "counter-set": {
    "values": [
      "none"
    ]
  },
  "cursor": {
    "values": [
      "auto",
      "default",
      "none",
      "context-menu",
      "help",
      "pointer",
      "progress",
      "wait",
      "cell",
      "crosshair",
      "text",
      "vertical-text",
      "alias",
      "copy",
      "move",
      "no-drop",
      "not-allowed",
      "e-resize",
      "n-resize",
      "ne-resize",
      "nw-resize",
      "s-resize",
      "se-resize",
      "sw-resize",
      "w-resize",
      "ew-resize",
      "ns-resize",
      "nesw-resize",
      "nwse-resize",
      "col-resize",
      "row-resize",
      "all-scroll",
      "zoom-in",
      "zoom-out",
      "grab",
      "grabbing"
    ]
  },
  "d": {
    "values": [
      "none"
    ]
  },
  "direction": {
    "values": [
      "ltr",
      "rtl"
    ]
  },
  "display": {
    "values": [
      "inline",
      "block",
      "list-item",
      "inline-block",
      "table",
      "inline-table",
      "table-row-group",
      "table-header-group",
      "table-footer-group",
      "table-row",
      "table-column-group",
      "table-column",
      "table-cell",
      "table-caption",
      "-webkit-box",
      "-webkit-inline-box",
      "flex",
      "inline-flex",
      "grid",
      "inline-grid",
      "contents",
      "flow-root",
      "none",
      "flow",
      "math",
      "ruby",
      "ruby-text",
      "masonry",
      "inline-masonry"
    ]
  },
  "dominant-baseline": {
    "values": [
      "auto",
      "alphabetic",
      "ideographic",
      "middle",
      "central",
      "mathematical",
      "hanging",
      "use-script",
      "no-change",
      "reset-size",
      "text-after-edge",
      "text-before-edge"
    ]
  },
  "dynamic-range-limit": {
    "values": [
      "standard",
      "no-limit",
      "constrained"
    ]
  },
  "empty-cells": {
    "values": [
      "show",
      "hide"
    ]
  },
  "field-sizing": {
    "values": [
      "fixed",
      "content"
    ]
  },
  "fill-rule": {
    "values": [
      "nonzero",
      "evenodd"
    ]
  },
  "filter": {
    "values": [
      "none"
    ]
  },
  "flex-basis": {
    "values": [
      "auto",
      "fit-content",
      "min-content",
      "max-content",
      "content"
    ]
  },
  "flex-direction": {
    "values": [
      "row",
      "row-reverse",
      "column",
      "column-reverse"
    ]
  },
  "flex-wrap": {
    "values": [
      "nowrap",
      "wrap",
      "wrap-reverse",
      "balance"
    ]
  },
  "float": {
    "values": [
      "none",
      "left",
      "right",
      "inline-start",
      "inline-end"
    ]
  },
  "flood-color": {
    "values": [
      "currentcolor"
    ]
  },
  "font-feature-settings": {
    "values": [
      "normal"
    ]
  },
  "font-kerning": {
    "values": [
      "auto",
      "normal",
      "none"
    ]
  },
  "font-language-override": {
    "values": [
      "normal"
    ]
  },
  "font-optical-sizing": {
    "values": [
      "auto",
      "none"
    ]
  },
  "font-palette": {
    "values": [
      "normal",
      "light",
      "dark"
    ]
  },
  "font-size": {
    "values": [
      "xx-small",
      "x-small",
      "small",
      "medium",
      "large",
      "x-large",
      "xx-large",
      "xxx-large",
      "larger",
      "smaller",
      "-webkit-xxx-large"
    ]
  },
  "font-size-adjust": {
    "values": [
      "none",
      "ex-height",
      "cap-height",
      "ch-width",
      "ic-width",
      "ic-height",
      "from-font"
    ]
  },
  "font-stretch": {
    "values": [
      "normal",
      "ultra-condensed",
      "extra-condensed",
      "condensed",
      "semi-condensed",
      "semi-expanded",
      "expanded",
      "extra-expanded",
      "ultra-expanded"
    ]
  },
  "font-style": {
    "values": [
      "normal",
      "italic",
      "oblique"
    ]
  },
  "font-synthesis-small-caps": {
    "values": [
      "auto",
      "none"
    ]
  },
  "font-synthesis-style": {
    "values": [
      "auto",
      "none"
    ]
  },
  "font-synthesis-weight": {
    "values": [
      "auto",
      "none"
    ]
  },
  "font-variant-alternates": {
    "values": [
      "normal"
    ]
  },
  "font-variant-caps": {
    "values": [
      "normal",
      "small-caps",
      "all-small-caps",
      "petite-caps",
      "all-petite-caps",
      "unicase",
      "titling-caps"
    ]
  },
  "font-variant-east-asian": {
    "values": [
      "normal",
      "jis78",
      "jis83",
      "jis90",
      "jis04",
      "simplified",
      "traditional",
      "full-width",
      "proportional-width",
      "ruby"
    ]
  },
  "font-variant-emoji": {
    "values": [
      "normal",
      "text",
      "emoji",
      "unicode"
    ]
  },
  "font-variant-ligatures": {
    "values": [
      "normal",
      "none",
      "common-ligatures",
      "no-common-ligatures",
      "discretionary-ligatures",
      "no-discretionary-ligatures",
      "historical-ligatures",
      "no-historical-ligatures",
      "contextual",
      "no-contextual"
    ]
  },
  "font-variant-numeric": {
    "values": [
      "normal",
      "lining-nums",
      "oldstyle-nums",
      "proportional-nums",
      "tabular-nums",
      "diagonal-fractions",
      "stacked-fractions",
      "ordinal",
      "slashed-zero"
    ]
  },
  "font-variant-position": {
    "values": [
      "normal",
      "sub",
      "super"
    ]
  },
  "font-variation-settings": {
    "values": [
      "normal"
    ]
  },
  "font-weight": {
    "values": [
      "normal",
      "bold",
      "bolder",
      "lighter"
    ]
  },
  "forced-color-adjust": {
    "values": [
      "auto",
      "none",
      "preserve-parent-color"
    ]
  },
  "gap-rule-overlap": {
    "values": [
      "row-over-column",
      "column-over-row"
    ]
  },
  "grid-auto-columns": {
    "values": [
      "auto",
      "min-content",
      "max-content"
    ]
  },
  "grid-auto-flow": {
    "values": [
      "row",
      "column"
    ]
  },
  "grid-auto-rows": {
    "values": [
      "auto",
      "min-content",
      "max-content"
    ]
  },
  "grid-column-end": {
    "values": [
      "auto"
    ]
  },
  "grid-column-start": {
    "values": [
      "auto"
    ]
  },
  "grid-row-end": {
    "values": [
      "auto"
    ]
  },
  "grid-row-start": {
    "values": [
      "auto"
    ]
  },
  "grid-template-areas": {
    "values": [
      "none"
    ]
  },
  "grid-template-columns": {
    "values": [
      "none"
    ]
  },
  "grid-template-rows": {
    "values": [
      "none"
    ]
  },
  "height": {
    "values": [
      "auto",
      "fit-content",
      "min-content",
      "max-content"
    ]
  },
  "hyphenate-limit-chars": {
    "values": [
      "auto"
    ]
  },
  "hyphens": {
    "values": [
      "none",
      "manual",
      "auto"
    ]
  },
  "image-rendering": {
    "values": [
      "auto",
      "optimizespeed",
      "optimizequality",
      "-webkit-optimize-contrast",
      "pixelated"
    ]
  },
  "initial-letter": {
    "values": [
      "drop",
      "normal",
      "raise"
    ]
  },
  "inline-size": {
    "values": [
      "auto"
    ]
  },
  "interactivity": {
    "values": [
      "auto",
      "inert"
    ]
  },
  "interpolate-size": {
    "values": [
      "numeric-only",
      "allow-keywords"
    ]
  },
  "isolation": {
    "values": [
      "auto",
      "isolate"
    ]
  },
  "item-tolerance": {
    "values": [
      "normal",
      "infinite"
    ]
  },
  "left": {
    "values": [
      "auto"
    ]
  },
  "letter-spacing": {
    "values": [
      "normal"
    ]
  },
  "lighting-color": {
    "values": [
      "currentcolor"
    ]
  },
  "line-break": {
    "values": [
      "auto",
      "loose",
      "normal",
      "strict",
      "anywhere",
      "after-white-space"
    ]
  },
  "line-height": {
    "values": [
      "normal"
    ]
  },
  "list-style-image": {
    "values": [
      "none"
    ]
  },
  "list-style-position": {
    "values": [
      "outside",
      "inside"
    ]
  },
  "list-style-type": {
    "values": [
      "disc",
      "circle",
      "square",
      "disclosure-open",
      "disclosure-closed",
      "decimal",
      "none"
    ]
  },
  "margin-block-end": {
    "values": [
      "auto"
    ]
  },
  "margin-block-start": {
    "values": [
      "auto"
    ]
  },
  "margin-bottom": {
    "values": [
      "auto"
    ]
  },
  "margin-inline-end": {
    "values": [
      "auto"
    ]
  },
  "margin-inline-start": {
    "values": [
      "auto"
    ]
  },
  "margin-left": {
    "values": [
      "auto"
    ]
  },
  "margin-right": {
    "values": [
      "auto"
    ]
  },
  "margin-top": {
    "values": [
      "auto"
    ]
  },
  "marker-end": {
    "values": [
      "none"
    ]
  },
  "marker-mid": {
    "values": [
      "none"
    ]
  },
  "marker-start": {
    "values": [
      "none"
    ]
  },
  "mask-composite": {
    "values": [
      "add",
      "subtract",
      "intersect",
      "exclude"
    ]
  },
  "mask-mode": {
    "values": [
      "alpha",
      "luminance",
      "match-source"
    ]
  },
  "mask-type": {
    "values": [
      "luminance",
      "alpha"
    ]
  },
  "masonry-direction": {
    "values": [
      "row",
      "row-reverse",
      "column",
      "column-reverse"
    ]
  },
  "masonry-fill": {
    "values": [
      "normal",
      "reverse"
    ]
  },
  "math-shift": {
    "values": [
      "normal",
      "compact"
    ]
  },
  "math-style": {
    "values": [
      "normal",
      "compact"
    ]
  },
  "max-block-size": {
    "values": [
      "none"
    ]
  },
  "max-height": {
    "values": [
      "none"
    ]
  },
  "max-inline-size": {
    "values": [
      "none"
    ]
  },
  "max-lines": {
    "values": [
      "none"
    ]
  },
  "max-width": {
    "values": [
      "none"
    ]
  },
  "mix-blend-mode": {
    "values": [
      "normal",
      "multiply",
      "screen",
      "overlay",
      "darken",
      "lighten",
      "color-dodge",
      "color-burn",
      "hard-light",
      "soft-light",
      "difference",
      "exclusion",
      "hue",
      "saturation",
      "color",
      "luminosity",
      "plus-lighter"
    ]
  },
  "object-fit": {
    "values": [
      "fill",
      "contain",
      "cover",
      "none",
      "scale-down"
    ]
  },
  "object-view-box": {
    "values": [
      "none"
    ]
  },
  "offset-anchor": {
    "values": [
      "auto"
    ]
  },
  "offset-path": {
    "values": [
      "none"
    ]
  },
  "offset-position": {
    "values": [
      "auto",
      "normal"
    ]
  },
  "offset-rotate": {
    "values": [
      "auto",
      "reverse"
    ]
  },
  "origin-trial-test-property": {
    "values": [
      "normal",
      "none"
    ]
  },
  "outline-color": {
    "values": [
      "currentcolor"
    ]
  },
  "outline-style": {
    "values": [
      "none",
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double"
    ]
  },
  "outline-width": {
    "values": [
      "thin",
      "medium",
      "thick"
    ]
  },
  "overflow-anchor": {
    "values": [
      "visible",
      "none",
      "auto"
    ]
  },
  "overflow-clip-margin": {
    "values": [
      "border-box",
      "content-box",
      "padding-box"
    ]
  },
  "overflow-wrap": {
    "values": [
      "normal",
      "break-word",
      "anywhere"
    ]
  },
  "overflow-x": {
    "values": [
      "visible",
      "hidden",
      "scroll",
      "auto",
      "overlay",
      "clip"
    ]
  },
  "overflow-y": {
    "values": [
      "visible",
      "hidden",
      "scroll",
      "auto",
      "overlay",
      "clip"
    ]
  },
  "overlay": {
    "values": [
      "none",
      "auto"
    ]
  },
  "overscroll-area": {
    "values": [
      "none"
    ]
  },
  "overscroll-behavior-x": {
    "values": [
      "auto",
      "contain",
      "none"
    ]
  },
  "overscroll-behavior-y": {
    "values": [
      "auto",
      "contain",
      "none"
    ]
  },
  "overscroll-position": {
    "values": [
      "none"
    ]
  },
  "page": {
    "values": [
      "auto"
    ]
  },
  "paint-order": {
    "values": [
      "normal",
      "fill",
      "stroke",
      "markers"
    ]
  },
  "perspective": {
    "values": [
      "none"
    ]
  },
  "pointer-events": {
    "values": [
      "none",
      "auto",
      "stroke",
      "fill",
      "painted",
      "visible",
      "visiblestroke",
      "visiblefill",
      "visiblepainted",
      "bounding-box",
      "all"
    ]
  },
  "position": {
    "values": [
      "static",
      "relative",
      "absolute",
      "fixed",
      "sticky"
    ]
  },
  "position-anchor": {
    "values": [
      "auto"
    ]
  },
  "position-area": {
    "values": [
      "none",
      "top",
      "bottom",
      "center",
      "left",
      "right",
      "x-start",
      "x-end",
      "y-start",
      "y-end",
      "start",
      "end",
      "self-start",
      "self-end",
      "all"
    ]
  },
  "position-try-fallbacks": {
    "values": [
      "none",
      "flip-block",
      "flip-inline",
      "flip-start"
    ]
  },
  "position-try-order": {
    "values": [
      "normal",
      "most-width",
      "most-height",
      "most-block-size",
      "most-inline-size"
    ]
  },
  "position-visibility": {
    "values": [
      "always",
      "anchors-visible",
      "no-overflow"
    ]
  },
  "print-color-adjust": {
    "values": [
      "economy",
      "exact"
    ]
  },
  "quotes": {
    "values": [
      "auto",
      "none"
    ]
  },
  "reading-flow": {
    "values": [
      "normal",
      "flex-visual",
      "flex-flow",
      "grid-rows",
      "grid-columns",
      "grid-order",
      "source-order"
    ]
  },
  "resize": {
    "values": [
      "none",
      "both",
      "horizontal",
      "vertical",
      "block",
      "inline"
    ]
  },
  "right": {
    "values": [
      "auto"
    ]
  },
  "row-gap": {
    "values": [
      "normal"
    ]
  },
  "row-rule-break": {
    "values": [
      "none",
      "spanning-item",
      "intersection"
    ]
  },
  "row-rule-color": {
    "values": [
      "currentcolor"
    ]
  },
  "row-rule-style": {
    "values": [
      "none",
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double"
    ]
  },
  "row-rule-visibility-items": {
    "values": [
      "all",
      "around",
      "between",
      "none"
    ]
  },
  "row-rule-width": {
    "values": [
      "thin",
      "medium",
      "thick"
    ]
  },
  "ruby-align": {
    "values": [
      "space-around",
      "start",
      "center",
      "space-between"
    ]
  },
  "ruby-overhang": {
    "values": [
      "auto",
      "none"
    ]
  },
  "ruby-position": {
    "values": [
      "over",
      "under"
    ]
  },
  "rx": {
    "values": [
      "auto"
    ]
  },
  "ry": {
    "values": [
      "auto"
    ]
  },
  "scroll-behavior": {
    "values": [
      "auto",
      "smooth"
    ]
  },
  "scroll-initial-target": {
    "values": [
      "none",
      "nearest"
    ]
  },
  "scroll-padding-block-end": {
    "values": [
      "auto"
    ]
  },
  "scroll-padding-block-start": {
    "values": [
      "auto"
    ]
  },
  "scroll-padding-bottom": {
    "values": [
      "auto"
    ]
  },
  "scroll-padding-inline-end": {
    "values": [
      "auto"
    ]
  },
  "scroll-padding-inline-start": {
    "values": [
      "auto"
    ]
  },
  "scroll-padding-left": {
    "values": [
      "auto"
    ]
  },
  "scroll-padding-right": {
    "values": [
      "auto"
    ]
  },
  "scroll-padding-top": {
    "values": [
      "auto"
    ]
  },
  "scroll-snap-align": {
    "values": [
      "none",
      "start",
      "end",
      "center"
    ]
  },
  "scroll-snap-stop": {
    "values": [
      "normal",
      "always"
    ]
  },
  "scroll-snap-type": {
    "values": [
      "none",
      "x",
      "y",
      "block",
      "inline",
      "both",
      "mandatory",
      "proximity"
    ]
  },
  "scroll-target-group": {
    "values": [
      "none",
      "auto"
    ]
  },
  "scrollbar-color": {
    "values": [
      "auto"
    ]
  },
  "scrollbar-gutter": {
    "values": [
      "auto",
      "stable",
      "both-edges"
    ]
  },
  "scrollbar-width": {
    "values": [
      "auto",
      "thin",
      "none"
    ]
  },
  "shape-margin": {
    "values": [
      "none"
    ]
  },
  "shape-outside": {
    "values": [
      "none"
    ]
  },
  "shape-rendering": {
    "values": [
      "auto",
      "optimizespeed",
      "crispedges",
      "geometricprecision"
    ]
  },
  "speak": {
    "values": [
      "none",
      "normal",
      "spell-out",
      "digits",
      "literal-punctuation",
      "no-punctuation"
    ]
  },
  "stop-color": {
    "values": [
      "currentcolor"
    ]
  },
  "stroke-dasharray": {
    "values": [
      "none"
    ]
  },
  "stroke-linecap": {
    "values": [
      "butt",
      "round",
      "square"
    ]
  },
  "stroke-linejoin": {
    "values": [
      "miter",
      "bevel",
      "round"
    ]
  },
  "table-layout": {
    "values": [
      "auto",
      "fixed"
    ]
  },
  "text-align": {
    "values": [
      "left",
      "right",
      "center",
      "justify",
      "-webkit-left",
      "-webkit-right",
      "-webkit-center",
      "start",
      "end",
      "match-parent"
    ]
  },
  "text-align-last": {
    "values": [
      "auto",
      "start",
      "end",
      "left",
      "right",
      "center",
      "justify",
      "match-parent"
    ]
  },
  "text-anchor": {
    "values": [
      "start",
      "middle",
      "end"
    ]
  },
  "text-autospace": {
    "values": [
      "no-autospace",
      "normal"
    ]
  },
  "text-box-trim": {
    "values": [
      "none",
      "trim-start",
      "trim-end",
      "trim-both"
    ]
  },
  "text-combine-upright": {
    "values": [
      "none",
      "all"
    ]
  },
  "text-decoration-color": {
    "values": [
      "currentcolor"
    ]
  },
  "text-decoration-line": {
    "values": [
      "none",
      "underline",
      "overline",
      "line-through",
      "blink",
      "spelling-error",
      "grammar-error"
    ]
  },
  "text-decoration-skip-ink": {
    "values": [
      "none",
      "auto"
    ]
  },
  "text-decoration-style": {
    "values": [
      "solid",
      "double",
      "dotted",
      "dashed",
      "wavy"
    ]
  },
  "text-decoration-thickness": {
    "values": [
      "auto",
      "from-font"
    ]
  },
  "text-emphasis-color": {
    "values": [
      "currentcolor"
    ]
  },
  "text-justify": {
    "values": [
      "auto",
      "none",
      "inter-word",
      "inter-character"
    ]
  },
  "text-orientation": {
    "values": [
      "sideways",
      "mixed",
      "upright"
    ]
  },
  "text-overflow": {
    "values": [
      "clip",
      "ellipsis"
    ]
  },
  "text-rendering": {
    "values": [
      "auto",
      "optimizespeed",
      "optimizelegibility",
      "geometricprecision"
    ]
  },
  "text-shadow": {
    "values": [
      "none"
    ]
  },
  "text-size-adjust": {
    "values": [
      "none",
      "auto"
    ]
  },
  "text-spacing-trim": {
    "values": [
      "normal",
      "space-all",
      "space-first",
      "trim-start"
    ]
  },
  "text-transform": {
    "values": [
      "capitalize",
      "uppercase",
      "lowercase",
      "full-width",
      "none",
      "math-auto"
    ]
  },
  "text-underline-offset": {
    "values": [
      "auto"
    ]
  },
  "text-underline-position": {
    "values": [
      "auto",
      "from-font",
      "under",
      "left",
      "right"
    ]
  },
  "text-wrap-mode": {
    "values": [
      "wrap",
      "nowrap"
    ]
  },
  "text-wrap-style": {
    "values": [
      "auto",
      "balance",
      "pretty",
      "stable"
    ]
  },
  "timeline-trigger-source": {
    "values": [
      "none",
      "auto"
    ]
  },
  "top": {
    "values": [
      "auto"
    ]
  },
  "touch-action": {
    "values": [
      "auto",
      "none",
      "pan-x",
      "pan-left",
      "pan-right",
      "pan-y",
      "pan-up",
      "pan-down",
      "pinch-zoom",
      "manipulation"
    ]
  },
  "transform": {
    "values": [
      "none"
    ]
  },
  "transform-box": {
    "values": [
      "content-box",
      "border-box",
      "fill-box",
      "stroke-box",
      "view-box"
    ]
  },
  "transform-style": {
    "values": [
      "flat",
      "preserve-3d"
    ]
  },
  "transition-behavior": {
    "values": [
      "normal",
      "allow-discrete"
    ]
  },
  "transition-property": {
    "values": [
      "none"
    ]
  },
  "transition-timing-function": {
    "values": [
      "linear",
      "ease",
      "ease-in",
      "ease-out",
      "ease-in-out",
      "jump-both",
      "jump-end",
      "jump-none",
      "jump-start",
      "step-start",
      "step-end"
    ]
  },
  "unicode-bidi": {
    "values": [
      "normal",
      "embed",
      "bidi-override",
      "isolate",
      "plaintext",
      "isolate-override"
    ]
  },
  "user-select": {
    "values": [
      "auto",
      "none",
      "text",
      "all",
      "contain"
    ]
  },
  "vector-effect": {
    "values": [
      "none",
      "non-scaling-stroke"
    ]
  },
  "vertical-align": {
    "values": [
      "baseline",
      "sub",
      "super",
      "text-top",
      "text-bottom",
      "middle"
    ]
  },
  "view-transition-class": {
    "values": [
      "none"
    ]
  },
  "view-transition-group": {
    "values": [
      "normal",
      "contain",
      "nearest"
    ]
  },
  "view-transition-name": {
    "values": [
      "none",
      "auto"
    ]
  },
  "visibility": {
    "values": [
      "visible",
      "hidden",
      "collapse"
    ]
  },
  "white-space-collapse": {
    "values": [
      "collapse",
      "preserve",
      "preserve-breaks",
      "break-spaces"
    ]
  },
  "width": {
    "values": [
      "auto",
      "fit-content",
      "min-content",
      "max-content"
    ]
  },
  "will-change": {
    "values": [
      "auto"
    ]
  },
  "word-break": {
    "values": [
      "normal",
      "break-all",
      "keep-all",
      "break-word",
      "auto-phrase"
    ]
  },
  "word-spacing": {
    "values": [
      "normal"
    ]
  },
  "writing-mode": {
    "values": [
      "horizontal-tb",
      "vertical-rl",
      "vertical-lr",
      "sideways-rl",
      "sideways-lr"
    ]
  },
  "z-index": {
    "values": [
      "auto"
    ]
  }
};
var generatedAliasesFor = /* @__PURE__ */ new Map([
  [
    "-epub-caption-side",
    "caption-side"
  ],
  [
    "-epub-text-combine",
    "-webkit-text-combine"
  ],
  [
    "-epub-text-emphasis",
    "text-emphasis"
  ],
  [
    "-epub-text-emphasis-color",
    "text-emphasis-color"
  ],
  [
    "-epub-text-emphasis-style",
    "text-emphasis-style"
  ],
  [
    "-epub-text-orientation",
    "-webkit-text-orientation"
  ],
  [
    "-epub-text-transform",
    "text-transform"
  ],
  [
    "-epub-word-break",
    "word-break"
  ],
  [
    "-epub-writing-mode",
    "-webkit-writing-mode"
  ],
  [
    "-webkit-align-content",
    "align-content"
  ],
  [
    "-webkit-align-items",
    "align-items"
  ],
  [
    "-webkit-align-self",
    "align-self"
  ],
  [
    "-webkit-animation",
    "animation"
  ],
  [
    "-webkit-animation-delay",
    "animation-delay"
  ],
  [
    "-webkit-animation-direction",
    "animation-direction"
  ],
  [
    "-webkit-animation-duration",
    "animation-duration"
  ],
  [
    "-webkit-animation-fill-mode",
    "animation-fill-mode"
  ],
  [
    "-webkit-animation-iteration-count",
    "animation-iteration-count"
  ],
  [
    "-webkit-animation-name",
    "animation-name"
  ],
  [
    "-webkit-animation-play-state",
    "animation-play-state"
  ],
  [
    "-webkit-animation-timing-function",
    "animation-timing-function"
  ],
  [
    "-webkit-app-region",
    "app-region"
  ],
  [
    "-webkit-appearance",
    "appearance"
  ],
  [
    "-webkit-backface-visibility",
    "backface-visibility"
  ],
  [
    "-webkit-background-clip",
    "background-clip"
  ],
  [
    "-webkit-background-origin",
    "background-origin"
  ],
  [
    "-webkit-background-size",
    "background-size"
  ],
  [
    "-webkit-border-after",
    "border-block-end"
  ],
  [
    "-webkit-border-after-color",
    "border-block-end-color"
  ],
  [
    "-webkit-border-after-style",
    "border-block-end-style"
  ],
  [
    "-webkit-border-after-width",
    "border-block-end-width"
  ],
  [
    "-webkit-border-before",
    "border-block-start"
  ],
  [
    "-webkit-border-before-color",
    "border-block-start-color"
  ],
  [
    "-webkit-border-before-style",
    "border-block-start-style"
  ],
  [
    "-webkit-border-before-width",
    "border-block-start-width"
  ],
  [
    "-webkit-border-bottom-left-radius",
    "border-bottom-left-radius"
  ],
  [
    "-webkit-border-bottom-right-radius",
    "border-bottom-right-radius"
  ],
  [
    "-webkit-border-end",
    "border-inline-end"
  ],
  [
    "-webkit-border-end-color",
    "border-inline-end-color"
  ],
  [
    "-webkit-border-end-style",
    "border-inline-end-style"
  ],
  [
    "-webkit-border-end-width",
    "border-inline-end-width"
  ],
  [
    "-webkit-border-radius",
    "border-radius"
  ],
  [
    "-webkit-border-start",
    "border-inline-start"
  ],
  [
    "-webkit-border-start-color",
    "border-inline-start-color"
  ],
  [
    "-webkit-border-start-style",
    "border-inline-start-style"
  ],
  [
    "-webkit-border-start-width",
    "border-inline-start-width"
  ],
  [
    "-webkit-border-top-left-radius",
    "border-top-left-radius"
  ],
  [
    "-webkit-border-top-right-radius",
    "border-top-right-radius"
  ],
  [
    "-webkit-box-shadow",
    "box-shadow"
  ],
  [
    "-webkit-box-sizing",
    "box-sizing"
  ],
  [
    "-webkit-clip-path",
    "clip-path"
  ],
  [
    "-webkit-column-count",
    "column-count"
  ],
  [
    "-webkit-column-gap",
    "column-gap"
  ],
  [
    "-webkit-column-rule",
    "column-rule"
  ],
  [
    "-webkit-column-rule-color",
    "column-rule-color"
  ],
  [
    "-webkit-column-rule-style",
    "column-rule-style"
  ],
  [
    "-webkit-column-rule-width",
    "column-rule-width"
  ],
  [
    "-webkit-column-span",
    "column-span"
  ],
  [
    "-webkit-column-width",
    "column-width"
  ],
  [
    "-webkit-columns",
    "columns"
  ],
  [
    "-webkit-filter",
    "filter"
  ],
  [
    "-webkit-flex",
    "flex"
  ],
  [
    "-webkit-flex-basis",
    "flex-basis"
  ],
  [
    "-webkit-flex-direction",
    "flex-direction"
  ],
  [
    "-webkit-flex-flow",
    "flex-flow"
  ],
  [
    "-webkit-flex-grow",
    "flex-grow"
  ],
  [
    "-webkit-flex-shrink",
    "flex-shrink"
  ],
  [
    "-webkit-flex-wrap",
    "flex-wrap"
  ],
  [
    "-webkit-font-feature-settings",
    "font-feature-settings"
  ],
  [
    "-webkit-hyphenate-character",
    "hyphenate-character"
  ],
  [
    "-webkit-justify-content",
    "justify-content"
  ],
  [
    "-webkit-logical-height",
    "block-size"
  ],
  [
    "-webkit-logical-width",
    "inline-size"
  ],
  [
    "-webkit-margin-after",
    "margin-block-end"
  ],
  [
    "-webkit-margin-before",
    "margin-block-start"
  ],
  [
    "-webkit-margin-end",
    "margin-inline-end"
  ],
  [
    "-webkit-margin-start",
    "margin-inline-start"
  ],
  [
    "-webkit-mask",
    "mask"
  ],
  [
    "-webkit-mask-clip",
    "mask-clip"
  ],
  [
    "-webkit-mask-composite",
    "mask-composite"
  ],
  [
    "-webkit-mask-image",
    "mask-image"
  ],
  [
    "-webkit-mask-origin",
    "mask-origin"
  ],
  [
    "-webkit-mask-position",
    "mask-position"
  ],
  [
    "-webkit-mask-repeat",
    "mask-repeat"
  ],
  [
    "-webkit-mask-size",
    "mask-size"
  ],
  [
    "-webkit-max-logical-height",
    "max-block-size"
  ],
  [
    "-webkit-max-logical-width",
    "max-inline-size"
  ],
  [
    "-webkit-min-logical-height",
    "min-block-size"
  ],
  [
    "-webkit-min-logical-width",
    "min-inline-size"
  ],
  [
    "-webkit-opacity",
    "opacity"
  ],
  [
    "-webkit-order",
    "order"
  ],
  [
    "-webkit-padding-after",
    "padding-block-end"
  ],
  [
    "-webkit-padding-before",
    "padding-block-start"
  ],
  [
    "-webkit-padding-end",
    "padding-inline-end"
  ],
  [
    "-webkit-padding-start",
    "padding-inline-start"
  ],
  [
    "-webkit-perspective",
    "perspective"
  ],
  [
    "-webkit-perspective-origin",
    "perspective-origin"
  ],
  [
    "-webkit-print-color-adjust",
    "print-color-adjust"
  ],
  [
    "-webkit-shape-image-threshold",
    "shape-image-threshold"
  ],
  [
    "-webkit-shape-margin",
    "shape-margin"
  ],
  [
    "-webkit-shape-outside",
    "shape-outside"
  ],
  [
    "-webkit-text-emphasis",
    "text-emphasis"
  ],
  [
    "-webkit-text-emphasis-color",
    "text-emphasis-color"
  ],
  [
    "-webkit-text-emphasis-position",
    "text-emphasis-position"
  ],
  [
    "-webkit-text-emphasis-style",
    "text-emphasis-style"
  ],
  [
    "-webkit-text-size-adjust",
    "text-size-adjust"
  ],
  [
    "-webkit-transform",
    "transform"
  ],
  [
    "-webkit-transform-origin",
    "transform-origin"
  ],
  [
    "-webkit-transform-style",
    "transform-style"
  ],
  [
    "-webkit-transition",
    "transition"
  ],
  [
    "-webkit-transition-delay",
    "transition-delay"
  ],
  [
    "-webkit-transition-duration",
    "transition-duration"
  ],
  [
    "-webkit-transition-property",
    "transition-property"
  ],
  [
    "-webkit-transition-timing-function",
    "transition-timing-function"
  ],
  [
    "-webkit-user-select",
    "user-select"
  ],
  [
    "grid-column-gap",
    "column-gap"
  ],
  [
    "grid-gap",
    "gap"
  ],
  [
    "grid-row-gap",
    "row-gap"
  ],
  [
    "word-wrap",
    "overflow-wrap"
  ]
]);

// gen/front_end/core/sdk/CSSMetadata.js
import * as Common2 from "./../common/common.js";
var CSSMetadata = class _CSSMetadata {
  #values = [];
  #longhands = /* @__PURE__ */ new Map();
  #shorthands = /* @__PURE__ */ new Map();
  #inherited = /* @__PURE__ */ new Set();
  #svgProperties = /* @__PURE__ */ new Set();
  #propertyValues = /* @__PURE__ */ new Map();
  #aliasesFor = /* @__PURE__ */ new Map();
  #nameValuePresets = [];
  #nameValuePresetsIncludingSVG = [];
  #valuesSet;
  constructor(properties, aliasesFor) {
    this.#aliasesFor = aliasesFor;
    for (let i = 0; i < properties.length; ++i) {
      const property = properties[i];
      const propertyName = property.name;
      if (!CSS.supports(propertyName, "initial")) {
        continue;
      }
      this.#values.push(propertyName);
      if (property.inherited) {
        this.#inherited.add(propertyName);
      }
      if (property.svg) {
        this.#svgProperties.add(propertyName);
      }
      const longhands = properties[i].longhands;
      if (longhands) {
        this.#longhands.set(propertyName, longhands);
        for (let j = 0; j < longhands.length; ++j) {
          const longhandName = longhands[j];
          let shorthands = this.#shorthands.get(longhandName);
          if (!shorthands) {
            shorthands = [];
            this.#shorthands.set(longhandName, shorthands);
          }
          shorthands.push(propertyName);
        }
      }
    }
    this.#values.sort(_CSSMetadata.sortPrefixesAndCSSWideKeywordsToEnd);
    this.#valuesSet = new Set(this.#values);
    const propertyValueSets = /* @__PURE__ */ new Map();
    for (const [propertyName, basisValueObj] of Object.entries(generatedPropertyValues)) {
      propertyValueSets.set(propertyName, new Set(basisValueObj.values));
    }
    for (const [propertyName, extraValues] of extraPropertyValues) {
      const propertyValueSet = propertyValueSets.get(propertyName);
      if (propertyValueSet) {
        propertyValueSets.set(propertyName, propertyValueSet.union(extraValues));
      } else {
        propertyValueSets.set(propertyName, extraValues);
      }
    }
    for (const [propertyName, values] of propertyValueSets) {
      for (const commonKeyword of CommonKeywords) {
        if (!values.has(commonKeyword) && CSS.supports(propertyName, commonKeyword)) {
          values.add(commonKeyword);
        }
      }
      this.#propertyValues.set(propertyName, [...values]);
    }
    for (const name of this.#valuesSet) {
      const values = this.specificPropertyValues(name).filter((value) => CSS.supports(name, value)).sort(_CSSMetadata.sortPrefixesAndCSSWideKeywordsToEnd);
      const presets = values.map((value) => `${name}: ${value}`);
      if (!this.isSVGProperty(name)) {
        this.#nameValuePresets.push(...presets);
      }
      this.#nameValuePresetsIncludingSVG.push(...presets);
    }
  }
  static isCSSWideKeyword(a) {
    return CSSWideKeywords.includes(a);
  }
  static isPositionTryOrderKeyword(a) {
    return PositionTryOrderKeywords.includes(a);
  }
  static sortPrefixesAndCSSWideKeywordsToEnd(a, b) {
    const aIsCSSWideKeyword = _CSSMetadata.isCSSWideKeyword(a);
    const bIsCSSWideKeyword = _CSSMetadata.isCSSWideKeyword(b);
    if (aIsCSSWideKeyword && !bIsCSSWideKeyword) {
      return 1;
    }
    if (!aIsCSSWideKeyword && bIsCSSWideKeyword) {
      return -1;
    }
    const aIsPrefixed = a.startsWith("-webkit-");
    const bIsPrefixed = b.startsWith("-webkit-");
    if (aIsPrefixed && !bIsPrefixed) {
      return 1;
    }
    if (!aIsPrefixed && bIsPrefixed) {
      return -1;
    }
    return a < b ? -1 : a > b ? 1 : 0;
  }
  allProperties() {
    return this.#values;
  }
  aliasesFor() {
    return this.#aliasesFor;
  }
  nameValuePresets(includeSVG) {
    return includeSVG ? this.#nameValuePresetsIncludingSVG : this.#nameValuePresets;
  }
  isSVGProperty(name) {
    name = name.toLowerCase();
    return this.#svgProperties.has(name);
  }
  getLonghands(shorthand) {
    return this.#longhands.get(shorthand) || null;
  }
  getShorthands(longhand) {
    return this.#shorthands.get(longhand) || null;
  }
  isColorAwareProperty(propertyName) {
    return colorAwareProperties.has(propertyName.toLowerCase()) || this.isCustomProperty(propertyName.toLowerCase());
  }
  isFontFamilyProperty(propertyName) {
    return propertyName.toLowerCase() === "font-family";
  }
  isAngleAwareProperty(propertyName) {
    const lowerCasedName = propertyName.toLowerCase();
    return colorAwareProperties.has(lowerCasedName) || angleAwareProperties.has(lowerCasedName);
  }
  isGridAreaDefiningProperty(propertyName) {
    propertyName = propertyName.toLowerCase();
    return propertyName === "grid" || propertyName === "grid-template" || propertyName === "grid-template-areas";
  }
  isGridColumnNameAwareProperty(propertyName) {
    propertyName = propertyName.toLowerCase();
    return ["grid-column", "grid-column-start", "grid-column-end"].includes(propertyName);
  }
  isGridRowNameAwareProperty(propertyName) {
    propertyName = propertyName.toLowerCase();
    return ["grid-row", "grid-row-start", "grid-row-end"].includes(propertyName);
  }
  isGridAreaNameAwareProperty(propertyName) {
    propertyName = propertyName.toLowerCase();
    return propertyName === "grid-area";
  }
  isGridNameAwareProperty(propertyName) {
    return this.isGridAreaNameAwareProperty(propertyName) || this.isGridColumnNameAwareProperty(propertyName) || this.isGridRowNameAwareProperty(propertyName);
  }
  isLengthProperty(propertyName) {
    propertyName = propertyName.toLowerCase();
    if (propertyName === "line-height") {
      return false;
    }
    return distanceProperties.has(propertyName) || propertyName.startsWith("margin") || propertyName.startsWith("padding") || propertyName.indexOf("width") !== -1 || propertyName.indexOf("height") !== -1;
  }
  isBezierAwareProperty(propertyName) {
    propertyName = propertyName.toLowerCase();
    return bezierAwareProperties.has(propertyName) || this.isCustomProperty(propertyName);
  }
  isFontAwareProperty(propertyName) {
    propertyName = propertyName.toLowerCase();
    return fontAwareProperties.has(propertyName) || this.isCustomProperty(propertyName);
  }
  isCustomProperty(propertyName) {
    return propertyName.startsWith("--");
  }
  isShadowProperty(propertyName) {
    propertyName = propertyName.toLowerCase();
    return propertyName === "box-shadow" || propertyName === "text-shadow" || propertyName === "-webkit-box-shadow";
  }
  isStringProperty(propertyName) {
    propertyName = propertyName.toLowerCase();
    return propertyName === "content";
  }
  canonicalPropertyName(name) {
    if (this.isCustomProperty(name)) {
      return name;
    }
    name = name.toLowerCase();
    const aliasFor = this.#aliasesFor.get(name);
    if (aliasFor) {
      return aliasFor;
    }
    if (!name || name.length < 9 || name.charAt(0) !== "-") {
      return name;
    }
    const match = name.match(/(?:-webkit-)(.+)/);
    if (!match || !this.#valuesSet.has(match[1])) {
      return name;
    }
    return match[1];
  }
  isCSSPropertyName(propertyName) {
    propertyName = propertyName.toLowerCase();
    if (propertyName.startsWith("--") && propertyName.length > 2 || propertyName.startsWith("-moz-") || propertyName.startsWith("-ms-") || propertyName.startsWith("-o-") || propertyName.startsWith("-webkit-")) {
      return true;
    }
    return this.#valuesSet.has(propertyName);
  }
  isPropertyInherited(propertyName) {
    propertyName = propertyName.toLowerCase();
    return propertyName.startsWith("--") || this.#inherited.has(this.canonicalPropertyName(propertyName)) || this.#inherited.has(propertyName);
  }
  specificPropertyValues(propertyName) {
    const unprefixedName = propertyName.replace(/^-webkit-/, "");
    const propertyValues = this.#propertyValues;
    let keywords = propertyValues.get(propertyName) || propertyValues.get(unprefixedName);
    if (!keywords) {
      keywords = [];
      for (const commonKeyword of CommonKeywords) {
        if (CSS.supports(propertyName, commonKeyword)) {
          keywords.push(commonKeyword);
        }
      }
      propertyValues.set(propertyName, keywords);
    }
    return keywords;
  }
  getPropertyValues(propertyName) {
    propertyName = propertyName.toLowerCase();
    const acceptedKeywords = [...this.specificPropertyValues(propertyName), ...CSSWideKeywords];
    if (this.isColorAwareProperty(propertyName)) {
      acceptedKeywords.push("currentColor");
      for (const color of Common2.Color.Nicknames.keys()) {
        acceptedKeywords.push(color);
      }
    }
    return acceptedKeywords.sort(_CSSMetadata.sortPrefixesAndCSSWideKeywordsToEnd);
  }
  propertyUsageWeight(property) {
    return Weight.get(property) || Weight.get(this.canonicalPropertyName(property)) || 0;
  }
  getValuePreset(key, value) {
    const values = valuePresets.get(key);
    let text = values ? values.get(value) : null;
    if (!text) {
      return null;
    }
    let startColumn = text.length;
    let endColumn = text.length;
    if (text) {
      startColumn = text.indexOf("|");
      endColumn = text.lastIndexOf("|");
      endColumn = startColumn === endColumn ? endColumn : endColumn - 1;
      text = text.replace(/\|/g, "");
    }
    return { text, startColumn, endColumn };
  }
  isHighlightPseudoType(pseudoType) {
    return pseudoType === "highlight" || pseudoType === "selection" || pseudoType === "target-text" || pseudoType === "grammar-error" || pseudoType === "spelling-error";
  }
};
var CubicBezierKeywordValues = /* @__PURE__ */ new Map([
  ["linear", "cubic-bezier(0, 0, 1, 1)"],
  ["ease", "cubic-bezier(0.25, 0.1, 0.25, 1)"],
  ["ease-in", "cubic-bezier(0.42, 0, 1, 1)"],
  ["ease-in-out", "cubic-bezier(0.42, 0, 0.58, 1)"],
  ["ease-out", "cubic-bezier(0, 0, 0.58, 1)"]
]);
var CSSWideKeywords = [
  "inherit",
  "initial",
  "revert",
  "revert-layer",
  "unset"
];
var PositionTryOrderKeywords = [
  "normal",
  "most-height",
  "most-width",
  "most-block-size",
  "most-inline-size"
];
var VariableNameRegex = /(\s*--.*?)/gs;
var VariableRegex = /(var\(\s*--.*?\))/gs;
var CustomVariableRegex = /(var\(*--[\w\d]+-([\w]+-[\w]+)\))/g;
var URLRegex = /url\(\s*('.+?'|".+?"|[^)]+)\s*\)/g;
var GridAreaRowRegex = /((?:\[[\w\- ]+\]\s*)*(?:"[^"]+"|'[^']+'))[^'"\[]*\[?[^'"\[]*/;
var cssMetadataInstance = null;
function cssMetadata() {
  if (!cssMetadataInstance) {
    const supportedProperties = generatedProperties;
    cssMetadataInstance = new CSSMetadata(supportedProperties, generatedAliasesFor);
  }
  return cssMetadataInstance;
}
var imageValuePresetMap = /* @__PURE__ */ new Map([
  ["linear-gradient", "linear-gradient(|45deg, black, transparent|)"],
  ["radial-gradient", "radial-gradient(|black, transparent|)"],
  ["repeating-linear-gradient", "repeating-linear-gradient(|45deg, black, transparent 100px|)"],
  ["repeating-radial-gradient", "repeating-radial-gradient(|black, transparent 100px|)"],
  ["url", "url(||)"]
]);
var filterValuePresetMap = /* @__PURE__ */ new Map([
  ["blur", "blur(|1px|)"],
  ["brightness", "brightness(|0.5|)"],
  ["contrast", "contrast(|0.5|)"],
  ["drop-shadow", "drop-shadow(|2px 4px 6px black|)"],
  ["grayscale", "grayscale(|1|)"],
  ["hue-rotate", "hue-rotate(|45deg|)"],
  ["invert", "invert(|1|)"],
  ["opacity", "opacity(|0.5|)"],
  ["saturate", "saturate(|0.5|)"],
  ["sepia", "sepia(|1|)"],
  ["url", "url(||)"]
]);
var cornerShapeValuePresetMap = /* @__PURE__ */ new Map([
  ["superellipse(0.5)", "superellipse(|0.5|)"],
  ["superellipse(infinity)", "superellipse(|infinity|)"]
]);
var valuePresets = /* @__PURE__ */ new Map([
  ["filter", filterValuePresetMap],
  ["backdrop-filter", filterValuePresetMap],
  ["background", imageValuePresetMap],
  ["background-image", imageValuePresetMap],
  ["-webkit-mask-image", imageValuePresetMap],
  [
    "transform",
    /* @__PURE__ */ new Map([
      ["scale", "scale(|1.5|)"],
      ["scaleX", "scaleX(|1.5|)"],
      ["scaleY", "scaleY(|1.5|)"],
      ["scale3d", "scale3d(|1.5, 1.5, 1.5|)"],
      ["rotate", "rotate(|45deg|)"],
      ["rotateX", "rotateX(|45deg|)"],
      ["rotateY", "rotateY(|45deg|)"],
      ["rotateZ", "rotateZ(|45deg|)"],
      ["rotate3d", "rotate3d(|1, 1, 1, 45deg|)"],
      ["skew", "skew(|10deg, 10deg|)"],
      ["skewX", "skewX(|10deg|)"],
      ["skewY", "skewY(|10deg|)"],
      ["translate", "translate(|10px, 10px|)"],
      ["translateX", "translateX(|10px|)"],
      ["translateY", "translateY(|10px|)"],
      ["translateZ", "translateZ(|10px|)"],
      ["translate3d", "translate3d(|10px, 10px, 10px|)"],
      ["matrix", "matrix(|1, 0, 0, 1, 0, 0|)"],
      ["matrix3d", "matrix3d(|1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1|)"],
      ["perspective", "perspective(|10px|)"]
    ])
  ],
  ["corner-shape", cornerShapeValuePresetMap]
]);
var distanceProperties = /* @__PURE__ */ new Set([
  "background-position",
  "border-spacing",
  "bottom",
  "font-size",
  "height",
  "left",
  "letter-spacing",
  "max-height",
  "max-width",
  "min-height",
  "min-width",
  "right",
  "text-indent",
  "top",
  "width",
  "word-spacing",
  "grid-row-gap",
  "grid-column-gap",
  "row-gap"
]);
var bezierAwareProperties = /* @__PURE__ */ new Set([
  "animation",
  "animation-timing-function",
  "transition",
  "transition-timing-function",
  "-webkit-animation",
  "-webkit-animation-timing-function",
  "-webkit-transition",
  "-webkit-transition-timing-function"
]);
var fontAwareProperties = /* @__PURE__ */ new Set(["font-size", "line-height", "font-weight", "font-family", "letter-spacing"]);
var colorAwareProperties = /* @__PURE__ */ new Set([
  "accent-color",
  "background",
  "background-color",
  "background-image",
  "border",
  "border-color",
  "border-image",
  "border-image-source",
  "border-bottom",
  "border-bottom-color",
  "border-left",
  "border-left-color",
  "border-right",
  "border-right-color",
  "border-top",
  "border-top-color",
  "border-block",
  "border-block-color",
  "border-block-end",
  "border-block-end-color",
  "border-block-start",
  "border-block-start-color",
  "border-inline",
  "border-inline-color",
  "border-inline-end",
  "border-inline-end-color",
  "border-inline-start",
  "border-inline-start-color",
  "box-shadow",
  "caret-color",
  "color",
  "column-rule",
  "column-rule-color",
  "content",
  "fill",
  "list-style-image",
  "mask",
  "mask-image",
  "mask-border",
  "mask-border-source",
  "outline",
  "outline-color",
  "scrollbar-color",
  "stop-color",
  "stroke",
  "text-decoration-color",
  "text-shadow",
  "text-emphasis",
  "text-emphasis-color",
  "-webkit-border-after",
  "-webkit-border-after-color",
  "-webkit-border-before",
  "-webkit-border-before-color",
  "-webkit-border-end",
  "-webkit-border-end-color",
  "-webkit-border-start",
  "-webkit-border-start-color",
  "-webkit-box-reflect",
  "-webkit-box-shadow",
  "-webkit-column-rule-color",
  "-webkit-mask",
  "-webkit-mask-box-image",
  "-webkit-mask-box-image-source",
  "-webkit-mask-image",
  "-webkit-tap-highlight-color",
  "-webkit-text-emphasis",
  "-webkit-text-emphasis-color",
  "-webkit-text-fill-color",
  "-webkit-text-stroke",
  "-webkit-text-stroke-color",
  // For SVG
  "flood-color",
  "lighting-color",
  "stop-color"
]);
var angleAwareProperties = /* @__PURE__ */ new Set([
  "-webkit-border-image",
  "transform",
  "-webkit-transform",
  "rotate",
  "filter",
  "-webkit-filter",
  "backdrop-filter",
  "offset",
  "offset-rotate",
  "font-style"
]);
var textEmphasisPosition = /* @__PURE__ */ new Set([
  "over",
  "under",
  "over right",
  // Initial value
  "over left",
  "under right",
  "under left"
]);
var textEmphasisStyle = /* @__PURE__ */ new Set([
  "none",
  "dot",
  "circle",
  "double-circle",
  "triangle",
  "sesame",
  "filled",
  "open",
  "dot open",
  "circle open",
  "double-circle open",
  "triangle open",
  "sesame open",
  '"\u2764\uFE0F"'
  // <string>
]);
var extraPropertyValues = /* @__PURE__ */ new Map([
  ["background-repeat", /* @__PURE__ */ new Set(["repeat", "repeat-x", "repeat-y", "no-repeat", "space", "round"])],
  ["content", /* @__PURE__ */ new Set(["normal", "close-quote", "no-close-quote", "no-open-quote", "open-quote"])],
  ["baseline-shift", /* @__PURE__ */ new Set(["baseline"])],
  ["max-height", /* @__PURE__ */ new Set(["min-content", "max-content", "-webkit-fill-available", "fit-content"])],
  ["color", /* @__PURE__ */ new Set(["black"])],
  ["background-color", /* @__PURE__ */ new Set(["white"])],
  ["box-shadow", /* @__PURE__ */ new Set(["inset"])],
  ["text-shadow", /* @__PURE__ */ new Set(["0 0 black"])],
  ["-webkit-writing-mode", /* @__PURE__ */ new Set(["horizontal-tb", "vertical-rl", "vertical-lr"])],
  ["writing-mode", /* @__PURE__ */ new Set(["lr", "rl", "tb", "lr-tb", "rl-tb", "tb-rl"])],
  ["page-break-inside", /* @__PURE__ */ new Set(["avoid"])],
  ["cursor", /* @__PURE__ */ new Set(["-webkit-zoom-in", "-webkit-zoom-out", "-webkit-grab", "-webkit-grabbing"])],
  ["border-width", /* @__PURE__ */ new Set(["medium", "thick", "thin"])],
  ["border-style", /* @__PURE__ */ new Set(["hidden", "inset", "groove", "ridge", "outset", "dotted", "dashed", "solid", "double"])],
  ["size", /* @__PURE__ */ new Set(["a3", "a4", "a5", "b4", "b5", "landscape", "ledger", "legal", "letter", "portrait"])],
  ["overflow", /* @__PURE__ */ new Set(["hidden", "visible", "overlay", "scroll", "clip"])],
  ["overscroll-behavior", /* @__PURE__ */ new Set(["contain"])],
  ["text-rendering", /* @__PURE__ */ new Set(["optimizeSpeed", "optimizeLegibility", "geometricPrecision"])],
  ["text-align", /* @__PURE__ */ new Set(["-webkit-auto", "-webkit-match-parent"])],
  ["clip-path", /* @__PURE__ */ new Set(["circle", "ellipse", "inset", "polygon", "url"])],
  ["color-interpolation", /* @__PURE__ */ new Set(["sRGB", "linearRGB"])],
  ["word-wrap", /* @__PURE__ */ new Set(["normal", "break-word"])],
  ["font-weight", /* @__PURE__ */ new Set(["100", "200", "300", "400", "500", "600", "700", "800", "900"])],
  ["text-emphasis", textEmphasisStyle],
  ["-webkit-text-emphasis", textEmphasisStyle],
  ["color-rendering", /* @__PURE__ */ new Set(["optimizeSpeed", "optimizeQuality"])],
  ["-webkit-text-combine", /* @__PURE__ */ new Set(["horizontal"])],
  ["text-orientation", /* @__PURE__ */ new Set(["sideways-right"])],
  [
    "outline",
    /* @__PURE__ */ new Set(["inset", "groove", "ridge", "outset", "dotted", "dashed", "solid", "double", "medium", "thick", "thin"])
  ],
  [
    "font",
    /* @__PURE__ */ new Set([
      "caption",
      "icon",
      "menu",
      "message-box",
      "small-caption",
      "-webkit-mini-control",
      "-webkit-small-control",
      "-webkit-control",
      "status-bar"
    ])
  ],
  ["dominant-baseline", /* @__PURE__ */ new Set(["text-before-edge", "text-after-edge", "use-script", "no-change", "reset-size"])],
  ["text-emphasis-position", textEmphasisPosition],
  ["-webkit-text-emphasis-position", textEmphasisPosition],
  ["alignment-baseline", /* @__PURE__ */ new Set(["before-edge", "after-edge", "text-before-edge", "text-after-edge", "hanging"])],
  ["page-break-before", /* @__PURE__ */ new Set(["left", "right", "always", "avoid"])],
  ["border-image", /* @__PURE__ */ new Set(["repeat", "stretch", "space", "round"])],
  [
    "text-decoration",
    /* @__PURE__ */ new Set(["blink", "line-through", "overline", "underline", "wavy", "double", "solid", "dashed", "dotted"])
  ],
  // List taken from https://drafts.csswg.org/css-fonts-4/#generic-font-families
  [
    "font-family",
    /* @__PURE__ */ new Set([
      "serif",
      "sans-serif",
      "cursive",
      "fantasy",
      "monospace",
      "system-ui",
      "emoji",
      "math",
      "fangsong",
      "ui-serif",
      "ui-sans-serif",
      "ui-monospace",
      "ui-rounded",
      "-webkit-body"
    ])
  ],
  ["zoom", /* @__PURE__ */ new Set(["normal"])],
  ["max-width", /* @__PURE__ */ new Set(["min-content", "max-content", "-webkit-fill-available", "fit-content"])],
  ["-webkit-font-smoothing", /* @__PURE__ */ new Set(["antialiased", "subpixel-antialiased"])],
  [
    "border",
    /* @__PURE__ */ new Set([
      "hidden",
      "inset",
      "groove",
      "ridge",
      "outset",
      "dotted",
      "dashed",
      "solid",
      "double",
      "medium",
      "thick",
      "thin"
    ])
  ],
  [
    "font-variant",
    /* @__PURE__ */ new Set([
      "small-caps",
      "normal",
      "common-ligatures",
      "no-common-ligatures",
      "discretionary-ligatures",
      "no-discretionary-ligatures",
      "historical-ligatures",
      "no-historical-ligatures",
      "contextual",
      "no-contextual",
      "all-small-caps",
      "petite-caps",
      "all-petite-caps",
      "unicase",
      "titling-caps",
      "lining-nums",
      "oldstyle-nums",
      "proportional-nums",
      "tabular-nums",
      "diagonal-fractions",
      "stacked-fractions",
      "ordinal",
      "slashed-zero",
      "jis78",
      "jis83",
      "jis90",
      "jis04",
      "simplified",
      "traditional",
      "full-width",
      "proportional-width",
      "ruby"
    ])
  ],
  ["vertical-align", /* @__PURE__ */ new Set(["top", "bottom", "-webkit-baseline-middle"])],
  ["page-break-after", /* @__PURE__ */ new Set(["left", "right", "always", "avoid"])],
  ["text-emphasis-style", textEmphasisStyle],
  ["-webkit-text-emphasis-style", textEmphasisStyle],
  [
    "transform",
    /* @__PURE__ */ new Set([
      "scale",
      "scaleX",
      "scaleY",
      "scale3d",
      "rotate",
      "rotateX",
      "rotateY",
      "rotateZ",
      "rotate3d",
      "skew",
      "skewX",
      "skewY",
      "translate",
      "translateX",
      "translateY",
      "translateZ",
      "translate3d",
      "matrix",
      "matrix3d",
      "perspective"
    ])
  ],
  [
    "align-content",
    /* @__PURE__ */ new Set([
      "normal",
      "baseline",
      "space-between",
      "space-around",
      "space-evenly",
      "stretch",
      "center",
      "start",
      "end",
      "flex-start",
      "flex-end"
    ])
  ],
  [
    "justify-content",
    /* @__PURE__ */ new Set([
      "normal",
      "space-between",
      "space-around",
      "space-evenly",
      "stretch",
      "center",
      "start",
      "end",
      "flex-start",
      "flex-end",
      "left",
      "right"
    ])
  ],
  [
    "place-content",
    /* @__PURE__ */ new Set([
      "normal",
      "space-between",
      "space-around",
      "space-evenly",
      "stretch",
      "center",
      "start",
      "end",
      "flex-start",
      "flex-end",
      "baseline"
    ])
  ],
  [
    "align-items",
    /* @__PURE__ */ new Set([
      "normal",
      "stretch",
      "baseline",
      "center",
      "start",
      "end",
      "self-start",
      "self-end",
      "flex-start",
      "flex-end",
      "anchor-center"
    ])
  ],
  [
    "justify-items",
    /* @__PURE__ */ new Set([
      "normal",
      "stretch",
      "baseline",
      "center",
      "start",
      "end",
      "self-start",
      "self-end",
      "flex-start",
      "flex-end",
      "left",
      "right",
      "legacy",
      "anchor-center"
    ])
  ],
  [
    "place-items",
    /* @__PURE__ */ new Set([
      "normal",
      "stretch",
      "baseline",
      "center",
      "start",
      "end",
      "self-start",
      "self-end",
      "flex-start",
      "flex-end",
      "anchor-center"
    ])
  ],
  [
    "align-self",
    /* @__PURE__ */ new Set([
      "normal",
      "stretch",
      "baseline",
      "center",
      "start",
      "end",
      "self-start",
      "self-end",
      "flex-start",
      "flex-end",
      "anchor-center"
    ])
  ],
  [
    "justify-self",
    /* @__PURE__ */ new Set([
      "normal",
      "stretch",
      "baseline",
      "center",
      "start",
      "end",
      "self-start",
      "self-end",
      "flex-start",
      "flex-end",
      "left",
      "right",
      "anchor-center"
    ])
  ],
  [
    "place-self",
    /* @__PURE__ */ new Set([
      "normal",
      "stretch",
      "baseline",
      "center",
      "start",
      "end",
      "self-start",
      "self-end",
      "flex-start",
      "flex-end",
      "anchor-center"
    ])
  ],
  ["perspective-origin", /* @__PURE__ */ new Set(["left", "center", "right", "top", "bottom"])],
  ["transform-origin", /* @__PURE__ */ new Set(["left", "center", "right", "top", "bottom"])],
  ["transition-timing-function", /* @__PURE__ */ new Set(["cubic-bezier", "steps"])],
  ["animation-timing-function", /* @__PURE__ */ new Set(["cubic-bezier", "steps"])],
  ["-webkit-backface-visibility", /* @__PURE__ */ new Set(["visible", "hidden"])],
  ["-webkit-column-break-after", /* @__PURE__ */ new Set(["always", "avoid"])],
  ["-webkit-column-break-before", /* @__PURE__ */ new Set(["always", "avoid"])],
  ["-webkit-column-break-inside", /* @__PURE__ */ new Set(["avoid"])],
  ["-webkit-column-span", /* @__PURE__ */ new Set(["all"])],
  ["-webkit-column-gap", /* @__PURE__ */ new Set(["normal"])],
  [
    "filter",
    /* @__PURE__ */ new Set([
      "url",
      "blur",
      "brightness",
      "contrast",
      "drop-shadow",
      "grayscale",
      "hue-rotate",
      "invert",
      "opacity",
      "saturate",
      "sepia"
    ])
  ],
  [
    "backdrop-filter",
    /* @__PURE__ */ new Set([
      "url",
      "blur",
      "brightness",
      "contrast",
      "drop-shadow",
      "grayscale",
      "hue-rotate",
      "invert",
      "opacity",
      "saturate",
      "sepia"
    ])
  ],
  ["grid-template-columns", /* @__PURE__ */ new Set(["min-content", "max-content"])],
  ["grid-template-rows", /* @__PURE__ */ new Set(["min-content", "max-content"])],
  ["grid-auto-flow", /* @__PURE__ */ new Set(["dense"])],
  [
    "background",
    /* @__PURE__ */ new Set([
      "repeat",
      "repeat-x",
      "repeat-y",
      "no-repeat",
      "top",
      "bottom",
      "left",
      "right",
      "center",
      "fixed",
      "local",
      "scroll",
      "space",
      "round",
      "border-box",
      "content-box",
      "padding-box",
      "linear-gradient",
      "radial-gradient",
      "repeating-linear-gradient",
      "repeating-radial-gradient",
      "url"
    ])
  ],
  [
    "background-image",
    /* @__PURE__ */ new Set(["linear-gradient", "radial-gradient", "repeating-linear-gradient", "repeating-radial-gradient", "url"])
  ],
  ["background-position", /* @__PURE__ */ new Set(["top", "bottom", "left", "right", "center"])],
  ["background-position-x", /* @__PURE__ */ new Set(["left", "right", "center"])],
  ["background-position-y", /* @__PURE__ */ new Set(["top", "bottom", "center"])],
  ["background-repeat-x", /* @__PURE__ */ new Set(["repeat", "no-repeat"])],
  ["background-repeat-y", /* @__PURE__ */ new Set(["repeat", "no-repeat"])],
  [
    "border-bottom",
    /* @__PURE__ */ new Set([
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double",
      "medium",
      "thick",
      "thin"
    ])
  ],
  [
    "border-left",
    /* @__PURE__ */ new Set([
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double",
      "medium",
      "thick",
      "thin"
    ])
  ],
  [
    "border-right",
    /* @__PURE__ */ new Set([
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double",
      "medium",
      "thick",
      "thin"
    ])
  ],
  [
    "border-top",
    /* @__PURE__ */ new Set([
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double",
      "medium",
      "thick",
      "thin"
    ])
  ],
  ["buffered-rendering", /* @__PURE__ */ new Set(["static", "dynamic"])],
  ["color-interpolation-filters", /* @__PURE__ */ new Set(["srgb", "linearrgb"])],
  [
    "column-rule",
    /* @__PURE__ */ new Set([
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double",
      "medium",
      "thick",
      "thin"
    ])
  ],
  ["flex-flow", /* @__PURE__ */ new Set(["nowrap", "row", "row-reverse", "column", "column-reverse", "wrap", "wrap-reverse"])],
  ["height", /* @__PURE__ */ new Set(["-webkit-fill-available"])],
  ["inline-size", /* @__PURE__ */ new Set(["-webkit-fill-available", "min-content", "max-content", "fit-content"])],
  [
    "list-style",
    /* @__PURE__ */ new Set([
      "outside",
      "inside",
      "disc",
      "circle",
      "square",
      "decimal",
      "decimal-leading-zero",
      "arabic-indic",
      "bengali",
      "cambodian",
      "khmer",
      "devanagari",
      "gujarati",
      "gurmukhi",
      "kannada",
      "lao",
      "malayalam",
      "mongolian",
      "myanmar",
      "oriya",
      "persian",
      "urdu",
      "telugu",
      "tibetan",
      "thai",
      "lower-roman",
      "upper-roman",
      "lower-greek",
      "lower-alpha",
      "lower-latin",
      "upper-alpha",
      "upper-latin",
      "cjk-earthly-branch",
      "cjk-heavenly-stem",
      "ethiopic-halehame",
      "ethiopic-halehame-am",
      "ethiopic-halehame-ti-er",
      "ethiopic-halehame-ti-et",
      "hangul",
      "hangul-consonant",
      "korean-hangul-formal",
      "korean-hanja-formal",
      "korean-hanja-informal",
      "hebrew",
      "armenian",
      "lower-armenian",
      "upper-armenian",
      "georgian",
      "cjk-ideographic",
      "simp-chinese-formal",
      "simp-chinese-informal",
      "trad-chinese-formal",
      "trad-chinese-informal",
      "hiragana",
      "katakana",
      "hiragana-iroha",
      "katakana-iroha"
    ])
  ],
  ["max-block-size", /* @__PURE__ */ new Set(["-webkit-fill-available", "min-content", "max-content", "fit-content"])],
  ["max-inline-size", /* @__PURE__ */ new Set(["-webkit-fill-available", "min-content", "max-content", "fit-content"])],
  ["min-block-size", /* @__PURE__ */ new Set(["-webkit-fill-available", "min-content", "max-content", "fit-content"])],
  ["min-height", /* @__PURE__ */ new Set(["-webkit-fill-available", "min-content", "max-content", "fit-content"])],
  ["min-inline-size", /* @__PURE__ */ new Set(["-webkit-fill-available", "min-content", "max-content", "fit-content"])],
  ["min-width", /* @__PURE__ */ new Set(["-webkit-fill-available", "min-content", "max-content", "fit-content"])],
  ["object-position", /* @__PURE__ */ new Set(["top", "bottom", "left", "right", "center"])],
  ["shape-outside", /* @__PURE__ */ new Set(["border-box", "content-box", "padding-box", "margin-box"])],
  [
    "-webkit-appearance",
    /* @__PURE__ */ new Set([
      "checkbox",
      "radio",
      "push-button",
      "square-button",
      "button",
      "inner-spin-button",
      "listbox",
      "media-slider",
      "media-sliderthumb",
      "media-volume-slider",
      "media-volume-sliderthumb",
      "menulist",
      "menulist-button",
      "meter",
      "progress-bar",
      "slider-horizontal",
      "slider-vertical",
      "sliderthumb-horizontal",
      "sliderthumb-vertical",
      "searchfield",
      "searchfield-cancel-button",
      "textfield",
      "textarea"
    ])
  ],
  [
    "-webkit-border-after",
    /* @__PURE__ */ new Set([
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double",
      "medium",
      "thick",
      "thin"
    ])
  ],
  [
    "-webkit-border-after-style",
    /* @__PURE__ */ new Set(["hidden", "inset", "groove", "outset", "ridge", "dotted", "dashed", "solid", "double"])
  ],
  ["-webkit-border-after-width", /* @__PURE__ */ new Set(["medium", "thick", "thin"])],
  [
    "-webkit-border-before",
    /* @__PURE__ */ new Set([
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double",
      "medium",
      "thick",
      "thin"
    ])
  ],
  [
    "-webkit-border-before-style",
    /* @__PURE__ */ new Set(["hidden", "inset", "groove", "outset", "ridge", "dotted", "dashed", "solid", "double"])
  ],
  ["-webkit-border-before-width", /* @__PURE__ */ new Set(["medium", "thick", "thin"])],
  [
    "-webkit-border-end",
    /* @__PURE__ */ new Set([
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double",
      "medium",
      "thick",
      "thin"
    ])
  ],
  [
    "-webkit-border-end-style",
    /* @__PURE__ */ new Set(["hidden", "inset", "groove", "outset", "ridge", "dotted", "dashed", "solid", "double"])
  ],
  ["-webkit-border-end-width", /* @__PURE__ */ new Set(["medium", "thick", "thin"])],
  [
    "-webkit-border-start",
    /* @__PURE__ */ new Set([
      "hidden",
      "inset",
      "groove",
      "outset",
      "ridge",
      "dotted",
      "dashed",
      "solid",
      "double",
      "medium",
      "thick",
      "thin"
    ])
  ],
  [
    "-webkit-border-start-style",
    /* @__PURE__ */ new Set(["hidden", "inset", "groove", "outset", "ridge", "dotted", "dashed", "solid", "double"])
  ],
  ["-webkit-border-start-width", /* @__PURE__ */ new Set(["medium", "thick", "thin"])],
  ["-webkit-logical-height", /* @__PURE__ */ new Set(["-webkit-fill-available", "min-content", "max-content", "fit-content"])],
  ["-webkit-logical-width", /* @__PURE__ */ new Set(["-webkit-fill-available", "min-content", "max-content", "fit-content"])],
  ["-webkit-mask-box-image", /* @__PURE__ */ new Set(["repeat", "stretch", "space", "round"])],
  ["-webkit-mask-box-image-repeat", /* @__PURE__ */ new Set(["repeat", "stretch", "space", "round"])],
  ["-webkit-mask-clip", /* @__PURE__ */ new Set(["text", "border", "border-box", "content", "content-box", "padding", "padding-box"])],
  [
    "-webkit-mask-composite",
    /* @__PURE__ */ new Set([
      "clear",
      "copy",
      "source-over",
      "source-in",
      "source-out",
      "source-atop",
      "destination-over",
      "destination-in",
      "destination-out",
      "destination-atop",
      "xor",
      "plus-lighter"
    ])
  ],
  [
    "-webkit-mask-image",
    /* @__PURE__ */ new Set(["linear-gradient", "radial-gradient", "repeating-linear-gradient", "repeating-radial-gradient", "url"])
  ],
  ["-webkit-mask-origin", /* @__PURE__ */ new Set(["border", "border-box", "content", "content-box", "padding", "padding-box"])],
  ["-webkit-mask-position", /* @__PURE__ */ new Set(["top", "bottom", "left", "right", "center"])],
  ["-webkit-mask-position-x", /* @__PURE__ */ new Set(["left", "right", "center"])],
  ["-webkit-mask-position-y", /* @__PURE__ */ new Set(["top", "bottom", "center"])],
  ["-webkit-mask-repeat", /* @__PURE__ */ new Set(["repeat", "repeat-x", "repeat-y", "no-repeat", "space", "round"])],
  ["-webkit-mask-size", /* @__PURE__ */ new Set(["contain", "cover"])],
  ["-webkit-max-logical-height", /* @__PURE__ */ new Set(["-webkit-fill-available", "min-content", "max-content", "fit-content"])],
  ["-webkit-max-logical-width", /* @__PURE__ */ new Set(["-webkit-fill-available", "min-content", "max-content", "fit-content"])],
  ["-webkit-min-logical-height", /* @__PURE__ */ new Set(["-webkit-fill-available", "min-content", "max-content", "fit-content"])],
  ["-webkit-min-logical-width", /* @__PURE__ */ new Set(["-webkit-fill-available", "min-content", "max-content", "fit-content"])],
  ["-webkit-perspective-origin-x", /* @__PURE__ */ new Set(["left", "right", "center"])],
  ["-webkit-perspective-origin-y", /* @__PURE__ */ new Set(["top", "bottom", "center"])],
  ["-webkit-text-decorations-in-effect", /* @__PURE__ */ new Set(["blink", "line-through", "overline", "underline"])],
  ["-webkit-text-stroke", /* @__PURE__ */ new Set(["medium", "thick", "thin"])],
  ["-webkit-text-stroke-width", /* @__PURE__ */ new Set(["medium", "thick", "thin"])],
  ["-webkit-transform-origin-x", /* @__PURE__ */ new Set(["left", "right", "center"])],
  ["-webkit-transform-origin-y", /* @__PURE__ */ new Set(["top", "bottom", "center"])],
  ["width", /* @__PURE__ */ new Set(["-webkit-fill-available"])],
  ["contain-intrinsic-width", /* @__PURE__ */ new Set(["auto none", "auto 100px"])],
  ["contain-intrinsic-height", /* @__PURE__ */ new Set(["auto none", "auto 100px"])],
  ["contain-intrinsic-size", /* @__PURE__ */ new Set(["auto none", "auto 100px"])],
  ["contain-intrinsic-inline-size", /* @__PURE__ */ new Set(["auto none", "auto 100px"])],
  ["contain-intrinsic-block-size", /* @__PURE__ */ new Set(["auto none", "auto 100px"])],
  // Due to some compatibility issues[1] with Chrome's implementation[2],
  // only a few legacy values are added here.
  // [1]: https://github.com/w3c/csswg-drafts/issues/9102#issuecomment-1807453214
  // [2]: https://chromium-review.googlesource.com/c/chromium/src/+/4232738
  [
    "white-space",
    /* @__PURE__ */ new Set([
      "normal",
      // equal to: `collapse wrap`
      "pre",
      // equal to: `preserve nowrap`
      "pre-wrap",
      // equal to: `preserve wrap`
      "pre-line",
      // equal to: `preserve-breaks wrap`
      "nowrap",
      // equal to: `collapse nowrap`
      "break-spaces"
      // equal to: `break-spaces wrap`, Chrome 76, crbug.com/767634#c28
    ])
  ],
  // https://drafts.csswg.org/css-inline-3/#text-box-edge
  // Now we're going to allow the following rule:
  // auto | [ text | cap | ex ] [ text | alphabetic ]?
  // ideographic and ideographic-ink are not implemented yet.
  // We don't add values like `cap text` because that is equivalent to `text`.
  [
    "text-box-edge",
    /* @__PURE__ */ new Set([
      "auto",
      "text",
      "cap",
      "ex",
      "text alphabetic",
      "cap alphabetic",
      "ex alphabetic"
    ])
  ],
  [
    "corner-shape",
    /* @__PURE__ */ new Set([
      "round",
      "scoop",
      "bevel",
      "notch",
      "square",
      "squircle",
      "superellipse(0.5)",
      "superellipse(infinity)"
    ])
  ]
]);
var Weight = /* @__PURE__ */ new Map([
  ["align-content", 57],
  ["align-items", 129],
  ["align-self", 55],
  ["animation", 175],
  ["animation-delay", 114],
  ["animation-direction", 113],
  ["animation-duration", 137],
  ["animation-fill-mode", 132],
  ["animation-iteration-count", 124],
  ["animation-name", 139],
  ["animation-play-state", 104],
  ["animation-timing-function", 141],
  ["backface-visibility", 123],
  ["background", 260],
  ["background-attachment", 119],
  ["background-clip", 165],
  ["background-color", 259],
  ["background-image", 246],
  ["background-origin", 107],
  ["background-position", 237],
  ["background-position-x", 108],
  ["background-position-y", 93],
  ["background-repeat", 234],
  ["background-size", 203],
  ["border", 263],
  ["border-bottom", 233],
  ["border-bottom-color", 190],
  ["border-bottom-left-radius", 186],
  ["border-bottom-right-radius", 185],
  ["border-bottom-style", 150],
  ["border-bottom-width", 179],
  ["border-collapse", 209],
  ["border-color", 226],
  ["border-image", 89],
  ["border-image-outset", 50],
  ["border-image-repeat", 49],
  ["border-image-slice", 58],
  ["border-image-source", 32],
  ["border-image-width", 52],
  ["border-left", 221],
  ["border-left-color", 174],
  ["border-left-style", 142],
  ["border-left-width", 172],
  ["border-radius", 224],
  ["border-right", 223],
  ["border-right-color", 182],
  ["border-right-style", 130],
  ["border-right-width", 178],
  ["border-spacing", 198],
  ["border-style", 206],
  ["border-top", 231],
  ["border-top-color", 192],
  ["border-top-left-radius", 187],
  ["border-top-right-radius", 189],
  ["border-top-style", 152],
  ["border-top-width", 180],
  ["border-width", 214],
  ["bottom", 227],
  ["box-shadow", 213],
  ["box-sizing", 216],
  ["caption-side", 96],
  ["clear", 229],
  ["clip", 173],
  ["clip-rule", 5],
  ["color", 256],
  ["content", 219],
  ["counter-increment", 111],
  ["counter-reset", 110],
  ["cursor", 250],
  ["direction", 176],
  ["display", 262],
  ["empty-cells", 99],
  ["fill", 140],
  ["fill-opacity", 82],
  ["fill-rule", 22],
  ["filter", 160],
  ["flex", 133],
  ["flex-basis", 66],
  ["flex-direction", 85],
  ["flex-flow", 94],
  ["flex-grow", 112],
  ["flex-shrink", 61],
  ["flex-wrap", 68],
  ["float", 252],
  ["font", 211],
  ["font-family", 254],
  ["font-kerning", 18],
  ["font-size", 264],
  ["font-stretch", 77],
  ["font-style", 220],
  ["font-variant", 161],
  ["font-weight", 257],
  ["height", 266],
  ["image-rendering", 90],
  ["justify-content", 127],
  ["left", 248],
  ["letter-spacing", 188],
  ["line-height", 244],
  ["list-style", 215],
  ["list-style-image", 145],
  ["list-style-position", 149],
  ["list-style-type", 199],
  ["margin", 267],
  ["margin-bottom", 241],
  ["margin-left", 243],
  ["margin-right", 238],
  ["margin-top", 253],
  ["mask", 20],
  ["max-height", 205],
  ["max-width", 225],
  ["min-height", 217],
  ["min-width", 218],
  ["object-fit", 33],
  ["opacity", 251],
  ["order", 117],
  ["orphans", 146],
  ["outline", 222],
  ["outline-color", 153],
  ["outline-offset", 147],
  ["outline-style", 151],
  ["outline-width", 148],
  ["overflow", 255],
  ["overflow-wrap", 105],
  ["overflow-x", 184],
  ["overflow-y", 196],
  ["padding", 265],
  ["padding-bottom", 230],
  ["padding-left", 235],
  ["padding-right", 232],
  ["padding-top", 240],
  ["page", 8],
  ["page-break-after", 120],
  ["page-break-before", 69],
  ["page-break-inside", 121],
  ["perspective", 92],
  ["perspective-origin", 103],
  ["pointer-events", 183],
  ["position", 261],
  ["quotes", 158],
  ["resize", 168],
  ["right", 245],
  ["shape-rendering", 38],
  ["size", 64],
  ["speak", 118],
  ["src", 170],
  ["stop-color", 42],
  ["stop-opacity", 31],
  ["stroke", 98],
  ["stroke-dasharray", 36],
  ["stroke-dashoffset", 3],
  ["stroke-linecap", 30],
  ["stroke-linejoin", 21],
  ["stroke-miterlimit", 12],
  ["stroke-opacity", 34],
  ["stroke-width", 87],
  ["table-layout", 171],
  ["tab-size", 46],
  ["text-align", 260],
  ["text-anchor", 35],
  ["text-decoration", 247],
  ["text-indent", 207],
  ["text-overflow", 204],
  ["text-rendering", 155],
  ["text-shadow", 208],
  ["text-transform", 202],
  ["top", 258],
  ["touch-action", 80],
  ["transform", 181],
  ["transform-origin", 162],
  ["transform-style", 86],
  ["transition", 193],
  ["transition-delay", 134],
  ["transition-duration", 135],
  ["transition-property", 131],
  ["transition-timing-function", 122],
  ["unicode-bidi", 156],
  ["unicode-range", 136],
  ["vertical-align", 236],
  ["visibility", 242],
  ["-webkit-appearance", 191],
  ["-webkit-backface-visibility", 154],
  ["-webkit-background-clip", 164],
  ["-webkit-background-origin", 40],
  ["-webkit-background-size", 163],
  ["-webkit-border-end", 9],
  ["-webkit-border-horizontal-spacing", 81],
  ["-webkit-border-image", 75],
  ["-webkit-border-radius", 212],
  ["-webkit-border-start", 10],
  ["-webkit-border-start-color", 16],
  ["-webkit-border-start-width", 13],
  ["-webkit-border-vertical-spacing", 43],
  ["-webkit-box-align", 101],
  ["-webkit-box-direction", 51],
  ["-webkit-box-flex", 128],
  ["-webkit-box-ordinal-group", 91],
  ["-webkit-box-orient", 144],
  ["-webkit-box-pack", 106],
  ["-webkit-box-reflect", 39],
  ["-webkit-box-shadow", 210],
  ["-webkit-column-break-inside", 60],
  ["-webkit-column-count", 84],
  ["-webkit-column-gap", 76],
  ["-webkit-column-rule", 25],
  ["-webkit-column-rule-color", 23],
  ["-webkit-columns", 44],
  ["-webkit-column-span", 29],
  ["-webkit-column-width", 47],
  ["-webkit-filter", 159],
  ["-webkit-font-feature-settings", 59],
  ["-webkit-font-smoothing", 177],
  ["-webkit-line-break", 45],
  ["-webkit-line-clamp", 126],
  ["-webkit-margin-after", 67],
  ["-webkit-margin-before", 70],
  ["-webkit-margin-collapse", 14],
  ["-webkit-margin-end", 65],
  ["-webkit-margin-start", 100],
  ["-webkit-mask", 19],
  ["-webkit-mask-box-image", 72],
  ["-webkit-mask-image", 88],
  ["-webkit-mask-position", 54],
  ["-webkit-mask-repeat", 63],
  ["-webkit-mask-size", 79],
  ["-webkit-padding-after", 15],
  ["-webkit-padding-before", 28],
  ["-webkit-padding-end", 48],
  ["-webkit-padding-start", 73],
  ["-webkit-print-color-adjust", 83],
  ["-webkit-rtl-ordering", 7],
  ["-webkit-tap-highlight-color", 169],
  ["-webkit-text-emphasis-color", 11],
  ["-webkit-text-fill-color", 71],
  ["-webkit-text-security", 17],
  ["-webkit-text-stroke", 56],
  ["-webkit-text-stroke-color", 37],
  ["-webkit-text-stroke-width", 53],
  ["-webkit-user-drag", 95],
  ["-webkit-user-modify", 62],
  ["-webkit-user-select", 194],
  ["-webkit-writing-mode", 4],
  ["white-space", 228],
  ["widows", 115],
  ["width", 268],
  ["will-change", 74],
  ["word-break", 166],
  ["word-spacing", 157],
  ["word-wrap", 197],
  ["writing-mode", 41],
  ["z-index", 239],
  ["zoom", 200]
]);
var CommonKeywords = ["auto", "none"];

// gen/front_end/core/sdk/NetworkRequest.js
var NetworkRequest_exports = {};
__export(NetworkRequest_exports, {
  DirectSocketChunkType: () => DirectSocketChunkType,
  DirectSocketStatus: () => DirectSocketStatus,
  DirectSocketType: () => DirectSocketType,
  Events: () => Events,
  NetworkRequest: () => NetworkRequest,
  WebSocketFrameType: () => WebSocketFrameType,
  cookieBlockedReasonToAttribute: () => cookieBlockedReasonToAttribute,
  cookieBlockedReasonToUiString: () => cookieBlockedReasonToUiString,
  cookieExemptionReasonToUiString: () => cookieExemptionReasonToUiString,
  setCookieBlockedReasonToAttribute: () => setCookieBlockedReasonToAttribute,
  setCookieBlockedReasonToUiString: () => setCookieBlockedReasonToUiString
});
import * as TextUtils23 from "./../../models/text_utils/text_utils.js";
import * as Common27 from "./../common/common.js";
import * as i18n21 from "./../i18n/i18n.js";
import * as Platform18 from "./../platform/platform.js";

// gen/front_end/core/sdk/CookieModel.js
var CookieModel_exports = {};
__export(CookieModel_exports, {
  CookieModel: () => CookieModel
});
import * as Common25 from "./../common/common.js";
import * as Platform17 from "./../platform/platform.js";
import * as Root9 from "./../root/root.js";

// gen/front_end/core/sdk/Cookie.js
var Cookie_exports = {};
__export(Cookie_exports, {
  Cookie: () => Cookie
});
var OPAQUE_PARTITION_KEY = "<opaque>";
var Cookie = class _Cookie {
  #name;
  #value;
  #type;
  #attributes = /* @__PURE__ */ new Map();
  #size = 0;
  #priority;
  #cookieLine = null;
  #partitionKey;
  constructor(name, value, type, priority, partitionKey) {
    this.#name = name;
    this.#value = value;
    this.#type = type;
    this.#priority = priority || "Medium";
    this.#partitionKey = partitionKey;
  }
  static fromProtocolCookie(protocolCookie) {
    const cookie = new _Cookie(protocolCookie.name, protocolCookie.value, null, protocolCookie.priority);
    cookie.addAttribute("domain", protocolCookie["domain"]);
    cookie.addAttribute("path", protocolCookie["path"]);
    if (protocolCookie["expires"]) {
      cookie.addAttribute("expires", protocolCookie["expires"] * 1e3);
    }
    if (protocolCookie["httpOnly"]) {
      cookie.addAttribute(
        "http-only"
        /* Attribute.HTTP_ONLY */
      );
    }
    if (protocolCookie["secure"]) {
      cookie.addAttribute(
        "secure"
        /* Attribute.SECURE */
      );
    }
    if (protocolCookie["sameSite"]) {
      cookie.addAttribute("same-site", protocolCookie["sameSite"]);
    }
    if ("sourcePort" in protocolCookie) {
      cookie.addAttribute("source-port", protocolCookie.sourcePort);
    }
    if ("sourceScheme" in protocolCookie) {
      cookie.addAttribute("source-scheme", protocolCookie.sourceScheme);
    }
    if ("partitionKey" in protocolCookie) {
      if (protocolCookie.partitionKey) {
        cookie.setPartitionKey(protocolCookie.partitionKey.topLevelSite, protocolCookie.partitionKey.hasCrossSiteAncestor);
      }
    }
    if ("partitionKeyOpaque" in protocolCookie && protocolCookie.partitionKeyOpaque) {
      cookie.addAttribute("partition-key", OPAQUE_PARTITION_KEY);
    }
    cookie.setSize(protocolCookie["size"]);
    return cookie;
  }
  key() {
    return (this.domain() || "-") + " " + this.name() + " " + (this.path() || "-") + " " + (this.partitionKey() ? this.topLevelSite() + " " + (this.hasCrossSiteAncestor() ? "cross_site" : "same_site") : "-");
  }
  name() {
    return this.#name;
  }
  value() {
    return this.#value;
  }
  type() {
    return this.#type;
  }
  httpOnly() {
    return this.#attributes.has(
      "http-only"
      /* Attribute.HTTP_ONLY */
    );
  }
  secure() {
    return this.#attributes.has(
      "secure"
      /* Attribute.SECURE */
    );
  }
  partitioned() {
    return this.#attributes.has(
      "partitioned"
      /* Attribute.PARTITIONED */
    ) || Boolean(this.partitionKey()) || this.partitionKeyOpaque();
  }
  sameSite() {
    return this.#attributes.get(
      "same-site"
      /* Attribute.SAME_SITE */
    );
  }
  partitionKey() {
    return this.#partitionKey;
  }
  setPartitionKey(topLevelSite, hasCrossSiteAncestor) {
    this.#partitionKey = { topLevelSite, hasCrossSiteAncestor };
    if (!this.#attributes.has(
      "partitioned"
      /* Attribute.PARTITIONED */
    )) {
      this.addAttribute(
        "partitioned"
        /* Attribute.PARTITIONED */
      );
    }
  }
  topLevelSite() {
    if (!this.#partitionKey) {
      return "";
    }
    return this.#partitionKey?.topLevelSite;
  }
  setTopLevelSite(topLevelSite, hasCrossSiteAncestor) {
    this.setPartitionKey(topLevelSite, hasCrossSiteAncestor);
  }
  hasCrossSiteAncestor() {
    if (!this.#partitionKey) {
      return false;
    }
    return this.#partitionKey?.hasCrossSiteAncestor;
  }
  setHasCrossSiteAncestor(hasCrossSiteAncestor) {
    if (!this.partitionKey() || !Boolean(this.topLevelSite())) {
      return;
    }
    this.setPartitionKey(this.topLevelSite(), hasCrossSiteAncestor);
  }
  partitionKeyOpaque() {
    if (!this.#partitionKey) {
      return false;
    }
    return this.topLevelSite() === OPAQUE_PARTITION_KEY;
  }
  setPartitionKeyOpaque() {
    this.addAttribute("partition-key", OPAQUE_PARTITION_KEY);
    this.setPartitionKey(OPAQUE_PARTITION_KEY, false);
  }
  priority() {
    return this.#priority;
  }
  session() {
    return !(this.#attributes.has(
      "expires"
      /* Attribute.EXPIRES */
    ) || this.#attributes.has(
      "max-age"
      /* Attribute.MAX_AGE */
    ));
  }
  path() {
    return this.#attributes.get(
      "path"
      /* Attribute.PATH */
    );
  }
  domain() {
    return this.#attributes.get(
      "domain"
      /* Attribute.DOMAIN */
    );
  }
  expires() {
    return this.#attributes.get(
      "expires"
      /* Attribute.EXPIRES */
    );
  }
  maxAge() {
    return this.#attributes.get(
      "max-age"
      /* Attribute.MAX_AGE */
    );
  }
  sourcePort() {
    return this.#attributes.get(
      "source-port"
      /* Attribute.SOURCE_PORT */
    );
  }
  sourceScheme() {
    return this.#attributes.get(
      "source-scheme"
      /* Attribute.SOURCE_SCHEME */
    );
  }
  size() {
    return this.#size;
  }
  /**
   * @deprecated
   */
  url() {
    if (!this.domain() || !this.path()) {
      return null;
    }
    let port = "";
    const sourcePort = this.sourcePort();
    if (sourcePort && sourcePort !== 80 && sourcePort !== 443) {
      port = `:${this.sourcePort()}`;
    }
    return (this.secure() ? "https://" : "http://") + this.domain() + port + this.path();
  }
  setSize(size) {
    this.#size = size;
  }
  expiresDate(requestDate) {
    if (this.maxAge()) {
      return new Date(requestDate.getTime() + 1e3 * this.maxAge());
    }
    if (this.expires()) {
      return new Date(this.expires());
    }
    return null;
  }
  addAttribute(key, value) {
    if (!key) {
      return;
    }
    switch (key) {
      case "priority":
        this.#priority = value;
        break;
      default:
        this.#attributes.set(key, value);
    }
  }
  hasAttribute(key) {
    return this.#attributes.has(key);
  }
  getAttribute(key) {
    return this.#attributes.get(key);
  }
  setCookieLine(cookieLine) {
    this.#cookieLine = cookieLine;
  }
  getCookieLine() {
    return this.#cookieLine;
  }
  matchesSecurityOrigin(securityOrigin) {
    const hostname = new URL(securityOrigin).hostname;
    return _Cookie.isDomainMatch(this.domain(), hostname);
  }
  static isDomainMatch(domain, hostname) {
    if (hostname === domain) {
      return true;
    }
    if (!domain || domain[0] !== ".") {
      return false;
    }
    if (domain.substr(1) === hostname) {
      return true;
    }
    return hostname.length > domain.length && hostname.endsWith(domain);
  }
};

// gen/front_end/core/sdk/NetworkManager.js
var NetworkManager_exports = {};
__export(NetworkManager_exports, {
  BlockingConditions: () => BlockingConditions,
  Events: () => Events2,
  Fast4GConditions: () => Fast4GConditions,
  FetchDispatcher: () => FetchDispatcher,
  InterceptedRequest: () => InterceptedRequest,
  MultitargetNetworkManager: () => MultitargetNetworkManager,
  NetworkDispatcher: () => NetworkDispatcher,
  NetworkManager: () => NetworkManager,
  NoThrottlingConditions: () => NoThrottlingConditions,
  OfflineConditions: () => OfflineConditions,
  RequestCondition: () => RequestCondition,
  RequestConditions: () => RequestConditions,
  RequestURLPattern: () => RequestURLPattern,
  Slow3GConditions: () => Slow3GConditions,
  Slow4GConditions: () => Slow4GConditions,
  THROTTLING_CONDITIONS_LOOKUP: () => THROTTLING_CONDITIONS_LOOKUP,
  activeNetworkThrottlingKeySetting: () => activeNetworkThrottlingKeySetting,
  customUserNetworkConditionsSetting: () => customUserNetworkConditionsSetting,
  getPredefinedCondition: () => getPredefinedCondition,
  getPredefinedOrBlockingCondition: () => getPredefinedOrBlockingCondition,
  getRecommendedNetworkPreset: () => getRecommendedNetworkPreset,
  keyIsCustomUser: () => keyIsCustomUser,
  networkConditionsEqual: () => networkConditionsEqual
});
import * as TextUtils from "./../../models/text_utils/text_utils.js";
import * as Common5 from "./../common/common.js";
import * as Host2 from "./../host/host.js";
import * as i18n from "./../i18n/i18n.js";
import * as Platform3 from "./../platform/platform.js";
import * as Root2 from "./../root/root.js";

// gen/front_end/core/sdk/TargetManager.js
var TargetManager_exports = {};
__export(TargetManager_exports, {
  Observer: () => Observer,
  SDKModelObserver: () => SDKModelObserver,
  TargetManager: () => TargetManager
});
import * as Common4 from "./../common/common.js";
import * as Host from "./../host/host.js";
import * as Platform2 from "./../platform/platform.js";
import { assertNotNullOrUndefined } from "./../platform/platform.js";
import * as Root from "./../root/root.js";

// gen/front_end/core/sdk/Target.js
var Target_exports = {};
__export(Target_exports, {
  Target: () => Target,
  Type: () => Type
});
import * as Common3 from "./../common/common.js";
import * as Platform from "./../platform/platform.js";
import * as ProtocolClient from "./../protocol_client/protocol_client.js";
var Target = class extends ProtocolClient.InspectorBackend.TargetBase {
  #targetManager;
  #name;
  #inspectedURL = Platform.DevToolsPath.EmptyUrlString;
  #inspectedURLName = "";
  #capabilitiesMask;
  #type;
  #parentTarget;
  #id;
  #modelByConstructor = /* @__PURE__ */ new Map();
  #isSuspended;
  /**
   * Generally when a target crashes we don't need to know, with one exception.
   * If a target crashes during the recording of a performance trace, after the
   * trace when we try to resume() it, it will fail because it has crashed. This
   * causes the performance panel to freeze (see crbug.com/333989070). So we
   * mark the target as crashed so we can exit without trying to resume it. In
   * `ChildTargetManager` we will mark a target as "un-crashed" when we get the
   * `targetInfoChanged` event. This helps ensure we can deal with cases where
   * the page crashes, but a reload fixes it and the targets get restored (see
   * crbug.com/387258086).
   */
  #hasCrashed = false;
  #targetInfo;
  #creatingModels;
  constructor(targetManager, id, name, type, parentTarget, sessionId, suspended, connection, targetInfo) {
    const needsNodeJSPatching = type === Type.NODE;
    super(needsNodeJSPatching, parentTarget, sessionId, connection);
    this.#targetManager = targetManager;
    this.#name = name;
    this.#capabilitiesMask = 0;
    switch (type) {
      case Type.FRAME:
        this.#capabilitiesMask = 1 | 8192 | 2 | 4 | 8 | 16 | 32 | 128 | 256 | 1024 | 2048 | 32768 | 65536 | 131072 | 262144 | 524288;
        if (parentTarget?.type() !== Type.FRAME) {
          this.#capabilitiesMask |= 4096 | 64 | 512 | 16384;
          if (Common3.ParsedURL.schemeIs(targetInfo?.url, "chrome-extension:")) {
            this.#capabilitiesMask &= ~512;
          }
        }
        break;
      case Type.ServiceWorker:
        this.#capabilitiesMask = 4 | 8 | 16 | 32 | 2048 | 131072 | 524288;
        if (parentTarget?.type() !== Type.FRAME) {
          this.#capabilitiesMask |= 1 | 8192;
        }
        break;
      case Type.SHARED_WORKER:
        this.#capabilitiesMask = 4 | 8 | 16 | 32 | 131072 | 262144 | 2048 | 524288;
        if (parentTarget?.type() !== Type.FRAME) {
          this.#capabilitiesMask |= 8192;
        }
        break;
      case Type.SHARED_STORAGE_WORKLET:
        this.#capabilitiesMask = 4 | 8 | 2048 | 524288;
        break;
      case Type.Worker:
        this.#capabilitiesMask = 4 | 8 | 16 | 32 | 131072 | 262144 | 256 | 524288;
        if (parentTarget?.type() !== Type.FRAME) {
          this.#capabilitiesMask |= 8192;
        }
        break;
      case Type.WORKLET:
        this.#capabilitiesMask = 4 | 8 | 524288 | 16;
        break;
      case Type.NODE:
        this.#capabilitiesMask = 4 | 16 | 32 | 131072;
        break;
      case Type.AUCTION_WORKLET:
        this.#capabilitiesMask = 4 | 524288;
        break;
      case Type.BROWSER:
        this.#capabilitiesMask = 32 | 131072;
        break;
      case Type.TAB:
        this.#capabilitiesMask = 32 | 128;
        break;
      case Type.NODE_WORKER:
        this.#capabilitiesMask = 4 | 16 | 32 | 131072;
    }
    this.#type = type;
    this.#parentTarget = parentTarget;
    this.#id = id;
    this.#isSuspended = suspended;
    this.#targetInfo = targetInfo;
  }
  createModels(required) {
    this.#creatingModels = true;
    const registeredModels2 = Array.from(SDKModel.registeredModels.entries());
    for (const [modelClass, info] of registeredModels2) {
      if (info.early) {
        this.model(modelClass);
      }
    }
    for (const [modelClass, info] of registeredModels2) {
      if (info.autostart || required.has(modelClass)) {
        this.model(modelClass);
      }
    }
    this.#creatingModels = false;
  }
  id() {
    return this.#id;
  }
  name() {
    return this.#name || this.#inspectedURLName;
  }
  setName(name) {
    if (this.#name === name) {
      return;
    }
    this.#name = name;
    this.#targetManager.onNameChange(this);
  }
  type() {
    return this.#type;
  }
  markAsNodeJSForTest() {
    super.markAsNodeJSForTest();
    this.#type = Type.NODE;
  }
  targetManager() {
    return this.#targetManager;
  }
  hasAllCapabilities(capabilitiesMask) {
    return (this.#capabilitiesMask & capabilitiesMask) === capabilitiesMask;
  }
  decorateLabel(label) {
    return this.#type === Type.Worker || this.#type === Type.ServiceWorker ? "\u2699 " + label : label;
  }
  parentTarget() {
    return this.#parentTarget;
  }
  outermostTarget() {
    let lastTarget = null;
    let currentTarget = this;
    do {
      if (currentTarget.type() !== Type.TAB && currentTarget.type() !== Type.BROWSER) {
        lastTarget = currentTarget;
      }
      currentTarget = currentTarget.parentTarget();
    } while (currentTarget);
    return lastTarget;
  }
  dispose(reason) {
    super.dispose(reason);
    this.#targetManager.removeTarget(this);
    for (const model of this.#modelByConstructor.values()) {
      model.dispose();
    }
  }
  model(modelClass) {
    if (!this.#modelByConstructor.get(modelClass)) {
      const info = SDKModel.registeredModels.get(modelClass);
      if (info === void 0) {
        throw new Error("Model class is not registered");
      }
      if ((this.#capabilitiesMask & info.capabilities) === info.capabilities) {
        const model = new modelClass(this);
        this.#modelByConstructor.set(modelClass, model);
        if (!this.#creatingModels) {
          this.#targetManager.modelAdded(modelClass, model, this.#targetManager.isInScope(this));
        }
      }
    }
    return this.#modelByConstructor.get(modelClass) || null;
  }
  models() {
    return this.#modelByConstructor;
  }
  inspectedURL() {
    return this.#inspectedURL;
  }
  setInspectedURL(inspectedURL) {
    this.#inspectedURL = inspectedURL;
    const parsedURL = Common3.ParsedURL.ParsedURL.fromString(inspectedURL);
    this.#inspectedURLName = parsedURL ? parsedURL.lastPathComponentWithFragment() : "#" + this.#id;
    this.#targetManager.onInspectedURLChange(this);
    if (!this.#name) {
      this.#targetManager.onNameChange(this);
    }
  }
  hasCrashed() {
    return this.#hasCrashed;
  }
  setHasCrashed(isCrashed) {
    const wasCrashed = this.#hasCrashed;
    this.#hasCrashed = isCrashed;
    if (wasCrashed && !isCrashed) {
      void this.resume();
    }
  }
  async suspend(reason) {
    if (this.#isSuspended) {
      return;
    }
    this.#isSuspended = true;
    if (this.#hasCrashed) {
      return;
    }
    await Promise.all(Array.from(this.models().values(), (m) => m.preSuspendModel(reason)));
    await Promise.all(Array.from(this.models().values(), (m) => m.suspendModel(reason)));
  }
  async resume() {
    if (!this.#isSuspended) {
      return;
    }
    this.#isSuspended = false;
    if (this.#hasCrashed) {
      return;
    }
    await Promise.all(Array.from(this.models().values(), (m) => m.resumeModel()));
    await Promise.all(Array.from(this.models().values(), (m) => m.postResumeModel()));
  }
  suspended() {
    return this.#isSuspended;
  }
  updateTargetInfo(targetInfo) {
    this.#targetInfo = targetInfo;
  }
  targetInfo() {
    return this.#targetInfo;
  }
};
var Type;
(function(Type3) {
  Type3["FRAME"] = "frame";
  Type3["ServiceWorker"] = "service-worker";
  Type3["Worker"] = "worker";
  Type3["SHARED_WORKER"] = "shared-worker";
  Type3["SHARED_STORAGE_WORKLET"] = "shared-storage-worklet";
  Type3["NODE"] = "node";
  Type3["BROWSER"] = "browser";
  Type3["AUCTION_WORKLET"] = "auction-worklet";
  Type3["WORKLET"] = "worklet";
  Type3["TAB"] = "tab";
  Type3["NODE_WORKER"] = "node-worker";
})(Type || (Type = {}));

// gen/front_end/core/sdk/TargetManager.js
var targetManagerInstance;
var TargetManager = class _TargetManager extends Common4.ObjectWrapper.ObjectWrapper {
  #targets;
  #observers;
  /* eslint-disable @typescript-eslint/no-explicit-any */
  #modelListeners;
  #modelObservers;
  #scopedObservers;
  /* eslint-enable @typescript-eslint/no-explicit-any */
  #isSuspended;
  #browserTarget;
  #scopeTarget;
  #defaultScopeSet;
  #scopeChangeListeners;
  constructor() {
    super();
    this.#targets = /* @__PURE__ */ new Set();
    this.#observers = /* @__PURE__ */ new Set();
    this.#modelListeners = new Platform2.MapUtilities.Multimap();
    this.#modelObservers = new Platform2.MapUtilities.Multimap();
    this.#isSuspended = false;
    this.#browserTarget = null;
    this.#scopeTarget = null;
    this.#scopedObservers = /* @__PURE__ */ new WeakSet();
    this.#defaultScopeSet = false;
    this.#scopeChangeListeners = /* @__PURE__ */ new Set();
  }
  static instance({ forceNew } = { forceNew: false }) {
    if (!targetManagerInstance || forceNew) {
      targetManagerInstance = new _TargetManager();
    }
    return targetManagerInstance;
  }
  static removeInstance() {
    targetManagerInstance = void 0;
  }
  onInspectedURLChange(target) {
    if (target !== this.#scopeTarget) {
      return;
    }
    Host.InspectorFrontendHost.InspectorFrontendHostInstance.inspectedURLChanged(target.inspectedURL() || Platform2.DevToolsPath.EmptyUrlString);
    this.dispatchEventToListeners("InspectedURLChanged", target);
  }
  onNameChange(target) {
    this.dispatchEventToListeners("NameChanged", target);
  }
  async suspendAllTargets(reason) {
    if (this.#isSuspended) {
      return;
    }
    this.#isSuspended = true;
    this.dispatchEventToListeners(
      "SuspendStateChanged"
      /* Events.SUSPEND_STATE_CHANGED */
    );
    const suspendPromises = Array.from(this.#targets.values(), (target) => target.suspend(reason));
    await Promise.all(suspendPromises);
  }
  async resumeAllTargets() {
    if (!this.#isSuspended) {
      return;
    }
    this.#isSuspended = false;
    this.dispatchEventToListeners(
      "SuspendStateChanged"
      /* Events.SUSPEND_STATE_CHANGED */
    );
    const resumePromises = Array.from(this.#targets.values(), (target) => target.resume());
    await Promise.all(resumePromises);
  }
  allTargetsSuspended() {
    return this.#isSuspended;
  }
  models(modelClass, opts) {
    const result = [];
    for (const target of this.#targets) {
      if (opts?.scoped && !this.isInScope(target)) {
        continue;
      }
      const model = target.model(modelClass);
      if (!model) {
        continue;
      }
      result.push(model);
    }
    return result;
  }
  inspectedURL() {
    const mainTarget = this.primaryPageTarget();
    return mainTarget ? mainTarget.inspectedURL() : "";
  }
  observeModels(modelClass, observer, opts) {
    const models = this.models(modelClass, opts);
    this.#modelObservers.set(modelClass, observer);
    if (opts?.scoped) {
      this.#scopedObservers.add(observer);
    }
    for (const model of models) {
      observer.modelAdded(model);
    }
  }
  unobserveModels(modelClass, observer) {
    this.#modelObservers.delete(modelClass, observer);
    this.#scopedObservers.delete(observer);
  }
  modelAdded(modelClass, model, inScope) {
    for (const observer of this.#modelObservers.get(modelClass).values()) {
      if (!this.#scopedObservers.has(observer) || inScope) {
        observer.modelAdded(model);
      }
    }
  }
  modelRemoved(modelClass, model, inScope) {
    for (const observer of this.#modelObservers.get(modelClass).values()) {
      if (!this.#scopedObservers.has(observer) || inScope) {
        observer.modelRemoved(model);
      }
    }
  }
  addModelListener(modelClass, eventType, listener, thisObject, opts) {
    const wrappedListener = (event) => {
      if (!opts?.scoped || this.isInScope(event)) {
        listener.call(thisObject, event);
      }
    };
    for (const model of this.models(modelClass)) {
      model.addEventListener(eventType, wrappedListener);
    }
    this.#modelListeners.set(eventType, { modelClass, thisObject, listener, wrappedListener });
  }
  removeModelListener(modelClass, eventType, listener, thisObject) {
    if (!this.#modelListeners.has(eventType)) {
      return;
    }
    let wrappedListener = null;
    for (const info of this.#modelListeners.get(eventType)) {
      if (info.modelClass === modelClass && info.listener === listener && info.thisObject === thisObject) {
        wrappedListener = info.wrappedListener;
        this.#modelListeners.delete(eventType, info);
      }
    }
    if (wrappedListener) {
      for (const model of this.models(modelClass)) {
        model.removeEventListener(eventType, wrappedListener);
      }
    }
  }
  observeTargets(targetObserver, opts) {
    if (this.#observers.has(targetObserver)) {
      throw new Error("Observer can only be registered once");
    }
    if (opts?.scoped) {
      this.#scopedObservers.add(targetObserver);
    }
    for (const target of this.#targets) {
      if (!opts?.scoped || this.isInScope(target)) {
        targetObserver.targetAdded(target);
      }
    }
    this.#observers.add(targetObserver);
  }
  unobserveTargets(targetObserver) {
    this.#observers.delete(targetObserver);
    this.#scopedObservers.delete(targetObserver);
  }
  createTarget(id, name, type, parentTarget, sessionId, waitForDebuggerInPage, connection, targetInfo) {
    const target = new Target(this, id, name, type, parentTarget, sessionId || "", this.#isSuspended, connection || null, targetInfo);
    if (waitForDebuggerInPage) {
      void target.pageAgent().invoke_waitForDebugger();
    }
    target.createModels(new Set(this.#modelObservers.keysArray()));
    this.#targets.add(target);
    const inScope = this.isInScope(target);
    for (const observer of [...this.#observers]) {
      if (!this.#scopedObservers.has(observer) || inScope) {
        observer.targetAdded(target);
      }
    }
    for (const [modelClass, model] of target.models().entries()) {
      this.modelAdded(modelClass, model, inScope);
    }
    for (const key of this.#modelListeners.keysArray()) {
      for (const info of this.#modelListeners.get(key)) {
        const model = target.model(info.modelClass);
        if (model) {
          model.addEventListener(key, info.wrappedListener);
        }
      }
    }
    if (target === target.outermostTarget() && (target.type() !== Type.FRAME || target === this.primaryPageTarget()) && !this.#defaultScopeSet) {
      this.setScopeTarget(target);
    }
    return target;
  }
  removeTarget(target) {
    if (!this.#targets.has(target)) {
      return;
    }
    const inScope = this.isInScope(target);
    this.#targets.delete(target);
    for (const modelClass of target.models().keys()) {
      const model = target.models().get(modelClass);
      assertNotNullOrUndefined(model);
      this.modelRemoved(modelClass, model, inScope);
    }
    for (const observer of [...this.#observers]) {
      if (!this.#scopedObservers.has(observer) || inScope) {
        observer.targetRemoved(target);
      }
    }
    for (const key of this.#modelListeners.keysArray()) {
      for (const info of this.#modelListeners.get(key)) {
        const model = target.model(info.modelClass);
        if (model) {
          model.removeEventListener(key, info.wrappedListener);
        }
      }
    }
  }
  targets() {
    return [...this.#targets];
  }
  targetById(id) {
    return this.targets().find((target) => target.id() === id) || null;
  }
  rootTarget() {
    if (this.#targets.size === 0) {
      return null;
    }
    return this.#targets.values().next().value ?? null;
  }
  primaryPageTarget() {
    let target = this.rootTarget();
    if (target?.type() === Type.TAB) {
      target = this.targets().find((t) => t.parentTarget() === target && t.type() === Type.FRAME && !t.targetInfo()?.subtype?.length) || null;
    }
    return target;
  }
  browserTarget() {
    return this.#browserTarget;
  }
  async maybeAttachInitialTarget() {
    if (!Boolean(Root.Runtime.Runtime.queryParam("browserConnection"))) {
      return false;
    }
    if (!this.#browserTarget) {
      this.#browserTarget = new Target(
        this,
        /* #id*/
        "main",
        /* #name*/
        "browser",
        Type.BROWSER,
        /* #parentTarget*/
        null,
        /* #sessionId */
        "",
        /* suspended*/
        false,
        /* #connection*/
        null,
        /* targetInfo*/
        void 0
      );
      this.#browserTarget.createModels(new Set(this.#modelObservers.keysArray()));
    }
    const targetId = await Host.InspectorFrontendHost.InspectorFrontendHostInstance.initialTargetId();
    void this.#browserTarget.targetAgent().invoke_autoAttachRelated({
      targetId,
      waitForDebuggerOnStart: true
    });
    return true;
  }
  clearAllTargetsForTest() {
    this.#targets.clear();
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  isInScope(arg) {
    if (!arg) {
      return false;
    }
    if (isSDKModelEvent(arg)) {
      arg = arg.source;
    }
    if (arg instanceof SDKModel) {
      arg = arg.target();
    }
    while (arg && arg !== this.#scopeTarget) {
      arg = arg.parentTarget();
    }
    return Boolean(arg) && arg === this.#scopeTarget;
  }
  // Sets a root of a scope substree.
  // TargetManager API invoked with `scoped: true` will behave as if targets
  // outside of the scope subtree don't exist. Concretely this means that
  // target observers, model observers and model listeners won't be invoked for targets outside of the
  // scope tree. This method will invoke targetRemoved and modelRemoved for
  // objects in the previous scope, as if they disappear and then will invoke
  // targetAdded and modelAdded as if they just appeared.
  // Note that scopeTarget could be null, which will effectively prevent scoped
  // observes from getting any events.
  setScopeTarget(scopeTarget) {
    if (scopeTarget === this.#scopeTarget) {
      return;
    }
    for (const target of this.targets()) {
      if (!this.isInScope(target)) {
        continue;
      }
      for (const modelClass of this.#modelObservers.keysArray()) {
        const model = target.models().get(modelClass);
        if (!model) {
          continue;
        }
        for (const observer of [...this.#modelObservers.get(modelClass)].filter((o) => this.#scopedObservers.has(o))) {
          observer.modelRemoved(model);
        }
      }
      for (const observer of [...this.#observers].filter((o) => this.#scopedObservers.has(o))) {
        observer.targetRemoved(target);
      }
    }
    this.#scopeTarget = scopeTarget;
    for (const target of this.targets()) {
      if (!this.isInScope(target)) {
        continue;
      }
      for (const observer of [...this.#observers].filter((o) => this.#scopedObservers.has(o))) {
        observer.targetAdded(target);
      }
      for (const [modelClass, model] of target.models().entries()) {
        for (const observer of [...this.#modelObservers.get(modelClass)].filter((o) => this.#scopedObservers.has(o))) {
          observer.modelAdded(model);
        }
      }
    }
    for (const scopeChangeListener of this.#scopeChangeListeners) {
      scopeChangeListener();
    }
    if (scopeTarget?.inspectedURL()) {
      this.onInspectedURLChange(scopeTarget);
    }
  }
  addScopeChangeListener(listener) {
    this.#scopeChangeListeners.add(listener);
  }
  scopeTarget() {
    return this.#scopeTarget;
  }
};
var Observer = class {
  targetAdded(_target) {
  }
  targetRemoved(_target) {
  }
};
var SDKModelObserver = class {
  modelAdded(_model) {
  }
  modelRemoved(_model) {
  }
};
function isSDKModelEvent(arg) {
  return "source" in arg && arg.source instanceof SDKModel;
}

// gen/front_end/core/sdk/NetworkManager.js
var _a;
var UIStrings = {
  /**
   * @description Explanation why no content is shown for WebSocket connection.
   */
  noContentForWebSocket: "Content for WebSockets is currently not supported",
  /**
   * @description Explanation why no content is shown for redirect response.
   */
  noContentForRedirect: "No content available because this request was redirected",
  /**
   * @description Explanation why no content is shown for preflight request.
   */
  noContentForPreflight: "No content available for preflight request",
  /**
   * @description Text to indicate that network throttling is disabled
   */
  noThrottling: "No throttling",
  /**
   * @description Text to indicate the network connectivity is offline
   */
  offline: "Offline",
  /**
   * @description Text in Network Manager representing the "3G" throttling preset.
   */
  slowG: "3G",
  // Named `slowG` for legacy reasons and because this value
  // is serialized locally on the user's machine: if we
  // change it we break their stored throttling settings.
  // (See crrev.com/c/2947255)
  /**
   * @description Text in Network Manager representing the "Slow 4G" throttling preset
   */
  fastG: "Slow 4G",
  // Named `fastG` for legacy reasons and because this value
  // is serialized locally on the user's machine: if we
  // change it we break their stored throttling settings.
  // (See crrev.com/c/2947255)
  /**
   * @description Text in Network Manager representing the "Fast 4G" throttling preset
   */
  fast4G: "Fast 4G",
  /**
   * @description Text in Network Manager representing the "Blocking" throttling preset
   */
  block: "Block",
  /**
   * @description Text in Network Manager
   * @example {https://example.com} PH1
   */
  requestWasBlockedByDevtoolsS: 'Request was blocked by DevTools: "{PH1}"',
  /**
   * @description Message in Network Manager
   * @example {XHR} PH1
   * @example {GET} PH2
   * @example {https://example.com} PH3
   */
  sFailedLoadingSS: '{PH1} failed loading: {PH2} "{PH3}".',
  /**
   * @description Message in Network Manager
   * @example {XHR} PH1
   * @example {GET} PH2
   * @example {https://example.com} PH3
   */
  sFinishedLoadingSS: '{PH1} finished loading: {PH2} "{PH3}".',
  /**
   * @description One of direct socket connection statuses
   */
  directSocketStatusOpening: "Opening",
  /**
   * @description One of direct socket connection statuses
   */
  directSocketStatusOpen: "Open",
  /**
   * @description One of direct socket connection statuses
   */
  directSocketStatusClosed: "Closed",
  /**
   * @description One of direct socket connection statuses
   */
  directSocketStatusAborted: "Aborted"
};
var str_ = i18n.i18n.registerUIStrings("core/sdk/NetworkManager.ts", UIStrings);
var i18nString = i18n.i18n.getLocalizedString.bind(void 0, str_);
var i18nLazyString = i18n.i18n.getLazilyComputedLocalizedString.bind(void 0, str_);
var requestToManagerMap = /* @__PURE__ */ new WeakMap();
var CONNECTION_TYPES = /* @__PURE__ */ new Map([
  [
    "2g",
    "cellular2g"
    /* Protocol.Network.ConnectionType.Cellular2g */
  ],
  [
    "3g",
    "cellular3g"
    /* Protocol.Network.ConnectionType.Cellular3g */
  ],
  [
    "4g",
    "cellular4g"
    /* Protocol.Network.ConnectionType.Cellular4g */
  ],
  [
    "bluetooth",
    "bluetooth"
    /* Protocol.Network.ConnectionType.Bluetooth */
  ],
  [
    "wifi",
    "wifi"
    /* Protocol.Network.ConnectionType.Wifi */
  ],
  [
    "wimax",
    "wimax"
    /* Protocol.Network.ConnectionType.Wimax */
  ]
]);
function customUserNetworkConditionsSetting() {
  return Common5.Settings.Settings.instance().moduleSetting("custom-network-conditions");
}
function activeNetworkThrottlingKeySetting() {
  return Common5.Settings.Settings.instance().createSetting(
    "active-network-condition-key",
    "NO_THROTTLING"
    /* PredefinedThrottlingConditionKey.NO_THROTTLING */
  );
}
var NetworkManager = class _NetworkManager extends SDKModel {
  dispatcher;
  fetchDispatcher;
  #networkAgent;
  #bypassServiceWorkerSetting;
  activeNetworkThrottlingKey = activeNetworkThrottlingKeySetting();
  constructor(target) {
    super(target);
    this.dispatcher = new NetworkDispatcher(this);
    this.fetchDispatcher = new FetchDispatcher(target.fetchAgent(), this);
    this.#networkAgent = target.networkAgent();
    target.registerNetworkDispatcher(this.dispatcher);
    target.registerFetchDispatcher(this.fetchDispatcher);
    if (Common5.Settings.Settings.instance().moduleSetting("cache-disabled").get()) {
      void this.#networkAgent.invoke_setCacheDisabled({ cacheDisabled: true });
    }
    if (Root2.Runtime.hostConfig.devToolsPrivacyUI?.enabled && Root2.Runtime.hostConfig.thirdPartyCookieControls?.managedBlockThirdPartyCookies !== true && (Common5.Settings.Settings.instance().createSetting("cookie-control-override-enabled", void 0).get() || Common5.Settings.Settings.instance().createSetting("grace-period-mitigation-disabled", void 0).get() || Common5.Settings.Settings.instance().createSetting("heuristic-mitigation-disabled", void 0).get())) {
      this.cookieControlFlagsSettingChanged();
    }
    void this.#networkAgent.invoke_enable({
      maxPostDataSize: MAX_EAGER_POST_REQUEST_BODY_LENGTH,
      enableDurableMessages: Root2.Runtime.hostConfig.devToolsEnableDurableMessages?.enabled,
      maxTotalBufferSize: MAX_RESPONSE_BODY_TOTAL_BUFFER_LENGTH,
      reportDirectSocketTraffic: true
    });
    void this.#networkAgent.invoke_setAttachDebugStack({ enabled: true });
    this.#bypassServiceWorkerSetting = Common5.Settings.Settings.instance().createSetting("bypass-service-worker", false);
    if (this.#bypassServiceWorkerSetting.get()) {
      this.bypassServiceWorkerChanged();
    }
    this.#bypassServiceWorkerSetting.addChangeListener(this.bypassServiceWorkerChanged, this);
    Common5.Settings.Settings.instance().moduleSetting("cache-disabled").addChangeListener(this.cacheDisabledSettingChanged, this);
    Common5.Settings.Settings.instance().createSetting("cookie-control-override-enabled", void 0).addChangeListener(this.cookieControlFlagsSettingChanged, this);
    Common5.Settings.Settings.instance().createSetting("grace-period-mitigation-disabled", void 0).addChangeListener(this.cookieControlFlagsSettingChanged, this);
    Common5.Settings.Settings.instance().createSetting("heuristic-mitigation-disabled", void 0).addChangeListener(this.cookieControlFlagsSettingChanged, this);
  }
  static forRequest(request) {
    return requestToManagerMap.get(request) || null;
  }
  static canReplayRequest(request) {
    return Boolean(requestToManagerMap.get(request)) && Boolean(request.backendRequestId()) && !request.isRedirect() && request.resourceType() === Common5.ResourceType.resourceTypes.XHR;
  }
  static replayRequest(request) {
    const manager = requestToManagerMap.get(request);
    const requestId = request.backendRequestId();
    if (!manager || !requestId || request.isRedirect()) {
      return;
    }
    void manager.#networkAgent.invoke_replayXHR({ requestId });
  }
  static async searchInRequest(request, query, caseSensitive, isRegex) {
    const manager = _NetworkManager.forRequest(request);
    const requestId = request.backendRequestId();
    if (!manager || !requestId || request.isRedirect()) {
      return [];
    }
    const response = await manager.#networkAgent.invoke_searchInResponseBody({ requestId, query, caseSensitive, isRegex });
    return TextUtils.TextUtils.performSearchInSearchMatches(response.result || [], query, caseSensitive, isRegex);
  }
  static async requestContentData(request) {
    if (request.resourceType() === Common5.ResourceType.resourceTypes.WebSocket) {
      return { error: i18nString(UIStrings.noContentForWebSocket) };
    }
    if (!request.finished) {
      await request.once(Events.FINISHED_LOADING);
    }
    if (request.isRedirect()) {
      return { error: i18nString(UIStrings.noContentForRedirect) };
    }
    if (request.isPreflightRequest()) {
      return { error: i18nString(UIStrings.noContentForPreflight) };
    }
    const manager = _NetworkManager.forRequest(request);
    if (!manager) {
      return { error: "No network manager for request" };
    }
    const requestId = request.backendRequestId();
    if (!requestId) {
      return { error: "No backend request id for request" };
    }
    const response = await manager.#networkAgent.invoke_getResponseBody({ requestId });
    const error = response.getError();
    if (error) {
      return { error };
    }
    return new TextUtils.ContentData.ContentData(response.body, response.base64Encoded, request.mimeType, request.charset() ?? void 0);
  }
  /**
   * Returns the already received bytes for an in-flight request. After calling this method
   * "dataReceived" events will contain additional data.
   */
  static async streamResponseBody(request) {
    if (request.finished) {
      return { error: "Streaming the response body is only available for in-flight requests." };
    }
    const manager = _NetworkManager.forRequest(request);
    if (!manager) {
      return { error: "No network manager for request" };
    }
    const requestId = request.backendRequestId();
    if (!requestId) {
      return { error: "No backend request id for request" };
    }
    const response = await manager.#networkAgent.invoke_streamResourceContent({ requestId });
    const error = response.getError();
    if (error) {
      return { error };
    }
    await request.waitForResponseReceived();
    return new TextUtils.ContentData.ContentData(
      response.bufferedData,
      /* isBase64=*/
      true,
      request.mimeType,
      request.charset() ?? void 0
    );
  }
  static async requestPostData(request) {
    const manager = _NetworkManager.forRequest(request);
    if (!manager) {
      console.error("No network manager for request");
      return null;
    }
    const requestId = request.backendRequestId();
    if (!requestId) {
      console.error("No backend request id for request");
      return null;
    }
    try {
      const { postData } = await manager.#networkAgent.invoke_getRequestPostData({ requestId });
      return postData;
    } catch (e) {
      return e.message;
    }
  }
  static connectionType(conditions) {
    if (!conditions.download && !conditions.upload) {
      return "none";
    }
    try {
      const title = typeof conditions.title === "function" ? conditions.title().toLowerCase() : conditions.title.toLowerCase();
      for (const [name, protocolType] of CONNECTION_TYPES) {
        if (title.includes(name)) {
          return protocolType;
        }
      }
    } catch {
      return "none";
    }
    return "other";
  }
  static lowercaseHeaders(headers) {
    const newHeaders = {};
    for (const headerName in headers) {
      newHeaders[headerName.toLowerCase()] = headers[headerName];
    }
    return newHeaders;
  }
  requestForURL(url) {
    return this.dispatcher.requestForURL(url);
  }
  requestForId(id) {
    return this.dispatcher.requestForId(id);
  }
  requestForLoaderId(loaderId) {
    return this.dispatcher.requestForLoaderId(loaderId);
  }
  cacheDisabledSettingChanged({ data: enabled }) {
    void this.#networkAgent.invoke_setCacheDisabled({ cacheDisabled: enabled });
  }
  cookieControlFlagsSettingChanged() {
    const overridesEnabled = Boolean(Common5.Settings.Settings.instance().createSetting("cookie-control-override-enabled", void 0).get());
    const gracePeriodEnabled = overridesEnabled ? Boolean(Common5.Settings.Settings.instance().createSetting("grace-period-mitigation-disabled", void 0).get()) : false;
    const heuristicEnabled = overridesEnabled ? Boolean(Common5.Settings.Settings.instance().createSetting("heuristic-mitigation-disabled", void 0).get()) : false;
    void this.#networkAgent.invoke_setCookieControls({
      enableThirdPartyCookieRestriction: overridesEnabled,
      disableThirdPartyCookieMetadata: gracePeriodEnabled,
      disableThirdPartyCookieHeuristics: heuristicEnabled
    });
  }
  dispose() {
    Common5.Settings.Settings.instance().moduleSetting("cache-disabled").removeChangeListener(this.cacheDisabledSettingChanged, this);
  }
  bypassServiceWorkerChanged() {
    void this.#networkAgent.invoke_setBypassServiceWorker({ bypass: this.#bypassServiceWorkerSetting.get() });
  }
  async getSecurityIsolationStatus(frameId) {
    const result = await this.#networkAgent.invoke_getSecurityIsolationStatus({ frameId: frameId ?? void 0 });
    if (result.getError()) {
      return null;
    }
    return result.status;
  }
  async getIpProtectionProxyStatus() {
    const result = await this.#networkAgent.invoke_getIPProtectionProxyStatus();
    if (result.getError()) {
      return null;
    }
    return result.status;
  }
  async enableReportingApi(enable = true) {
    return await this.#networkAgent.invoke_enableReportingApi({ enable });
  }
  async loadNetworkResource(frameId, url, options) {
    const result = await this.#networkAgent.invoke_loadNetworkResource({ frameId: frameId ?? void 0, url, options });
    if (result.getError()) {
      throw new Error(result.getError());
    }
    return result.resource;
  }
  clearRequests() {
    this.dispatcher.clearRequests();
  }
};
var Events2;
(function(Events12) {
  Events12["RequestStarted"] = "RequestStarted";
  Events12["RequestUpdated"] = "RequestUpdated";
  Events12["RequestFinished"] = "RequestFinished";
  Events12["RequestUpdateDropped"] = "RequestUpdateDropped";
  Events12["ResponseReceived"] = "ResponseReceived";
  Events12["MessageGenerated"] = "MessageGenerated";
  Events12["RequestRedirected"] = "RequestRedirected";
  Events12["LoadingFinished"] = "LoadingFinished";
  Events12["ReportingApiReportAdded"] = "ReportingApiReportAdded";
  Events12["ReportingApiReportUpdated"] = "ReportingApiReportUpdated";
  Events12["ReportingApiEndpointsChangedForOrigin"] = "ReportingApiEndpointsChangedForOrigin";
})(Events2 || (Events2 = {}));
var BlockingConditions = {
  key: "BLOCKING",
  block: true,
  title: i18nLazyString(UIStrings.block)
};
var NoThrottlingConditions = {
  key: "NO_THROTTLING",
  title: i18nLazyString(UIStrings.noThrottling),
  i18nTitleKey: UIStrings.noThrottling,
  download: -1,
  upload: -1,
  latency: 0
};
var OfflineConditions = {
  key: "OFFLINE",
  title: i18nLazyString(UIStrings.offline),
  i18nTitleKey: UIStrings.offline,
  download: 0,
  upload: 0,
  latency: 0
};
var slow3GTargetLatency = 400;
var Slow3GConditions = {
  key: "SPEED_3G",
  title: i18nLazyString(UIStrings.slowG),
  i18nTitleKey: UIStrings.slowG,
  // ~500Kbps down
  download: 500 * 1e3 / 8 * 0.8,
  // ~500Kbps up
  upload: 500 * 1e3 / 8 * 0.8,
  // 400ms RTT
  latency: slow3GTargetLatency * 5,
  targetLatency: slow3GTargetLatency
};
var slow4GTargetLatency = 150;
var Slow4GConditions = {
  key: "SPEED_SLOW_4G",
  title: i18nLazyString(UIStrings.fastG),
  i18nTitleKey: UIStrings.fastG,
  // ~1.6 Mbps down
  download: 1.6 * 1e3 * 1e3 / 8 * 0.9,
  // ~0.75 Mbps up
  upload: 750 * 1e3 / 8 * 0.9,
  // 150ms RTT
  latency: slow4GTargetLatency * 3.75,
  targetLatency: slow4GTargetLatency
};
var fast4GTargetLatency = 60;
var Fast4GConditions = {
  key: "SPEED_FAST_4G",
  title: i18nLazyString(UIStrings.fast4G),
  i18nTitleKey: UIStrings.fast4G,
  // 9 Mbps down
  download: 9 * 1e3 * 1e3 / 8 * 0.9,
  // 1.5 Mbps up
  upload: 1.5 * 1e3 * 1e3 / 8 * 0.9,
  // 60ms RTT
  latency: fast4GTargetLatency * 2.75,
  targetLatency: fast4GTargetLatency
};
var MAX_EAGER_POST_REQUEST_BODY_LENGTH = 64 * 1024;
var MAX_RESPONSE_BODY_TOTAL_BUFFER_LENGTH = 250 * 1024 * 1024;
var FetchDispatcher = class {
  #fetchAgent;
  #manager;
  constructor(agent, manager) {
    this.#fetchAgent = agent;
    this.#manager = manager;
  }
  requestPaused({ requestId, request, resourceType, responseStatusCode, responseHeaders, networkId }) {
    const networkRequest = networkId ? this.#manager.requestForId(networkId) : null;
    if (networkRequest?.originalResponseHeaders.length === 0 && responseHeaders) {
      networkRequest.originalResponseHeaders = responseHeaders;
    }
    void MultitargetNetworkManager.instance().requestIntercepted(new InterceptedRequest(this.#fetchAgent, request, resourceType, requestId, networkRequest, responseStatusCode, responseHeaders));
  }
  authRequired({}) {
  }
};
var NetworkDispatcher = class {
  #manager;
  #requestsById = /* @__PURE__ */ new Map();
  #requestsByURL = /* @__PURE__ */ new Map();
  #requestsByLoaderId = /* @__PURE__ */ new Map();
  #requestIdToExtraInfoBuilder = /* @__PURE__ */ new Map();
  /**
   * In case of an early abort or a cache hit, the Trust Token done event is
   * reported before the request itself is created in `requestWillBeSent`.
   * This causes the event to be lost as no `NetworkRequest` instance has been
   * created yet.
   * This map caches the events temporarily and populates the NetworkRequest
   * once it is created in `requestWillBeSent`.
   */
  #requestIdToTrustTokenEvent = /* @__PURE__ */ new Map();
  constructor(manager) {
    this.#manager = manager;
    MultitargetNetworkManager.instance().addEventListener("RequestIntercepted", this.#markAsIntercepted.bind(this));
  }
  #markAsIntercepted(event) {
    const request = this.requestForId(event.data);
    if (request) {
      request.setWasIntercepted(true);
    }
  }
  headersMapToHeadersArray(headersMap) {
    const result = [];
    for (const name in headersMap) {
      const values = headersMap[name].split("\n");
      for (let i = 0; i < values.length; ++i) {
        result.push({ name, value: values[i] });
      }
    }
    return result;
  }
  updateNetworkRequestWithRequest(networkRequest, request) {
    networkRequest.requestMethod = request.method;
    networkRequest.setRequestHeaders(this.headersMapToHeadersArray(request.headers));
    networkRequest.setRequestFormData(Boolean(request.hasPostData), request.postData || null);
    networkRequest.setInitialPriority(request.initialPriority);
    networkRequest.mixedContentType = request.mixedContentType || "none";
    networkRequest.setReferrerPolicy(request.referrerPolicy);
    networkRequest.setIsSameSite(request.isSameSite || false);
    networkRequest.setIsAdRelated(request.isAdRelated || false);
  }
  updateNetworkRequestWithResponse(networkRequest, response) {
    if (response.url && networkRequest.url() !== response.url) {
      networkRequest.setUrl(response.url);
    }
    networkRequest.mimeType = response.mimeType;
    networkRequest.setCharset(response.charset);
    if (!networkRequest.statusCode || networkRequest.wasIntercepted()) {
      networkRequest.statusCode = response.status;
    }
    if (!networkRequest.statusText || networkRequest.wasIntercepted()) {
      networkRequest.statusText = response.statusText;
    }
    if (!networkRequest.hasExtraResponseInfo() || networkRequest.wasIntercepted()) {
      networkRequest.responseHeaders = this.headersMapToHeadersArray(response.headers);
    }
    if (response.encodedDataLength >= 0) {
      networkRequest.setTransferSize(response.encodedDataLength);
    }
    if (response.requestHeaders && !networkRequest.hasExtraRequestInfo()) {
      networkRequest.setRequestHeaders(this.headersMapToHeadersArray(response.requestHeaders));
      networkRequest.setRequestHeadersText(response.requestHeadersText || "");
    }
    networkRequest.connectionReused = response.connectionReused;
    networkRequest.connectionId = String(response.connectionId);
    if (response.remoteIPAddress) {
      networkRequest.setRemoteAddress(response.remoteIPAddress, response.remotePort || -1);
    }
    if (response.fromServiceWorker) {
      networkRequest.fetchedViaServiceWorker = true;
    }
    if (response.fromDiskCache) {
      networkRequest.setFromDiskCache();
    }
    if (response.fromPrefetchCache) {
      networkRequest.setFromPrefetchCache();
    }
    if (response.fromEarlyHints) {
      networkRequest.setFromEarlyHints();
    }
    if (response.cacheStorageCacheName) {
      networkRequest.setResponseCacheStorageCacheName(response.cacheStorageCacheName);
    }
    if (response.serviceWorkerRouterInfo) {
      networkRequest.serviceWorkerRouterInfo = response.serviceWorkerRouterInfo;
    }
    if (response.responseTime) {
      networkRequest.setResponseRetrievalTime(new Date(response.responseTime));
    }
    networkRequest.timing = response.timing;
    networkRequest.protocol = response.protocol || "";
    networkRequest.alternateProtocolUsage = response.alternateProtocolUsage;
    if (response.serviceWorkerResponseSource) {
      networkRequest.setServiceWorkerResponseSource(response.serviceWorkerResponseSource);
    }
    networkRequest.setSecurityState(response.securityState);
    if (response.securityDetails) {
      networkRequest.setSecurityDetails(response.securityDetails);
    }
    if (Root2.Runtime.hostConfig.devToolsIpProtectionInDevTools?.enabled) {
      if (response.isIpProtectionUsed) {
        networkRequest.setIsIpProtectionUsed(response.isIpProtectionUsed);
      }
    }
    const newResourceType = Common5.ResourceType.ResourceType.fromMimeTypeOverride(networkRequest.mimeType);
    if (newResourceType) {
      networkRequest.setResourceType(newResourceType);
    }
    if (networkRequest.responseReceivedPromiseResolve) {
      networkRequest.responseReceivedPromiseResolve();
    } else {
      networkRequest.responseReceivedPromise = Promise.resolve();
    }
  }
  requestForId(id) {
    return this.#requestsById.get(id) || null;
  }
  requestForURL(url) {
    return this.#requestsByURL.get(url) || null;
  }
  requestForLoaderId(loaderId) {
    return this.#requestsByLoaderId.get(loaderId) || null;
  }
  resourceChangedPriority({ requestId, newPriority }) {
    const networkRequest = this.#requestsById.get(requestId);
    if (networkRequest) {
      networkRequest.setPriority(newPriority);
    }
  }
  signedExchangeReceived({ requestId, info }) {
    let networkRequest = this.#requestsById.get(requestId);
    if (!networkRequest) {
      networkRequest = this.#requestsByURL.get(info.outerResponse.url);
      if (!networkRequest) {
        return;
      }
      const backendRequestId = networkRequest.backendRequestId() || requestId;
      requestId = backendRequestId;
    }
    networkRequest.setSignedExchangeInfo(info);
    networkRequest.setResourceType(Common5.ResourceType.resourceTypes.SignedExchange);
    this.updateNetworkRequestWithResponse(networkRequest, info.outerResponse);
    this.updateNetworkRequest(networkRequest);
    this.getExtraInfoBuilder(requestId).addHasExtraInfo(info.hasExtraInfo);
    this.#manager.dispatchEventToListeners(Events2.ResponseReceived, { request: networkRequest, response: info.outerResponse });
  }
  requestWillBeSent({ requestId, loaderId, documentURL, request, timestamp, wallTime, initiator, redirectHasExtraInfo, redirectResponse, type, frameId, hasUserGesture }) {
    let networkRequest = this.#requestsById.get(requestId);
    if (networkRequest) {
      if (!redirectResponse) {
        return;
      }
      if (!networkRequest.signedExchangeInfo()) {
        this.responseReceived({
          requestId,
          loaderId,
          timestamp,
          type: type || "Other",
          response: redirectResponse,
          hasExtraInfo: redirectHasExtraInfo,
          frameId
        });
      }
      networkRequest = this.appendRedirect(requestId, timestamp, request.url);
      this.#manager.dispatchEventToListeners(Events2.RequestRedirected, networkRequest);
    } else {
      networkRequest = NetworkRequest.create(requestId, request.url, documentURL, frameId ?? null, loaderId, initiator, hasUserGesture);
      requestToManagerMap.set(networkRequest, this.#manager);
    }
    networkRequest.hasNetworkData = true;
    this.updateNetworkRequestWithRequest(networkRequest, request);
    networkRequest.setIssueTime(timestamp, wallTime);
    networkRequest.setResourceType(type ? Common5.ResourceType.resourceTypes[type] : Common5.ResourceType.resourceTypes.Other);
    if (request.trustTokenParams) {
      networkRequest.setTrustTokenParams(request.trustTokenParams);
    }
    const maybeTrustTokenEvent = this.#requestIdToTrustTokenEvent.get(requestId);
    if (maybeTrustTokenEvent) {
      networkRequest.setTrustTokenOperationDoneEvent(maybeTrustTokenEvent);
      this.#requestIdToTrustTokenEvent.delete(requestId);
    }
    this.getExtraInfoBuilder(requestId).addRequest(networkRequest);
    this.startNetworkRequest(networkRequest, request);
  }
  requestServedFromCache({ requestId }) {
    const networkRequest = this.#requestsById.get(requestId);
    if (!networkRequest) {
      return;
    }
    networkRequest.setFromMemoryCache();
  }
  responseReceived({ requestId, loaderId, timestamp, type, response, hasExtraInfo, frameId }) {
    const networkRequest = this.#requestsById.get(requestId);
    const lowercaseHeaders = NetworkManager.lowercaseHeaders(response.headers);
    if (!networkRequest) {
      const lastModifiedHeader = lowercaseHeaders["last-modified"];
      const eventData = {
        url: response.url,
        frameId: frameId ?? null,
        loaderId,
        resourceType: type,
        mimeType: response.mimeType,
        lastModified: lastModifiedHeader ? new Date(lastModifiedHeader) : null
      };
      this.#manager.dispatchEventToListeners(Events2.RequestUpdateDropped, eventData);
      return;
    }
    networkRequest.responseReceivedTime = timestamp;
    networkRequest.setResourceType(Common5.ResourceType.resourceTypes[type]);
    this.updateNetworkRequestWithResponse(networkRequest, response);
    this.updateNetworkRequest(networkRequest);
    this.getExtraInfoBuilder(requestId).addHasExtraInfo(hasExtraInfo);
    this.#manager.dispatchEventToListeners(Events2.ResponseReceived, { request: networkRequest, response });
  }
  dataReceived(event) {
    let networkRequest = this.#requestsById.get(event.requestId);
    if (!networkRequest) {
      networkRequest = this.maybeAdoptMainResourceRequest(event.requestId);
    }
    if (!networkRequest) {
      return;
    }
    networkRequest.addDataReceivedEvent(event);
    this.updateNetworkRequest(networkRequest);
  }
  loadingFinished({ requestId, timestamp: finishTime, encodedDataLength }) {
    let networkRequest = this.#requestsById.get(requestId);
    if (!networkRequest) {
      networkRequest = this.maybeAdoptMainResourceRequest(requestId);
    }
    if (!networkRequest) {
      return;
    }
    this.getExtraInfoBuilder(requestId).finished();
    this.finishNetworkRequest(networkRequest, finishTime, encodedDataLength);
    this.#manager.dispatchEventToListeners(Events2.LoadingFinished, networkRequest);
  }
  loadingFailed({ requestId, timestamp: time, type: resourceType, errorText: localizedDescription, canceled, blockedReason, corsErrorStatus }) {
    const networkRequest = this.#requestsById.get(requestId);
    if (!networkRequest) {
      return;
    }
    networkRequest.failed = true;
    networkRequest.setResourceType(Common5.ResourceType.resourceTypes[resourceType]);
    networkRequest.canceled = Boolean(canceled);
    if (blockedReason) {
      networkRequest.setBlockedReason(blockedReason);
      if (blockedReason === "inspector") {
        const message = i18nString(UIStrings.requestWasBlockedByDevtoolsS, { PH1: networkRequest.url() });
        this.#manager.dispatchEventToListeners(Events2.MessageGenerated, { message, requestId, warning: true });
      }
    }
    if (corsErrorStatus) {
      networkRequest.setCorsErrorStatus(corsErrorStatus);
    }
    networkRequest.localizedFailDescription = localizedDescription;
    this.getExtraInfoBuilder(requestId).finished();
    this.finishNetworkRequest(networkRequest, time, -1);
  }
  webSocketCreated({ requestId, url: requestURL, initiator }) {
    const networkRequest = NetworkRequest.createForSocket(requestId, requestURL, initiator);
    requestToManagerMap.set(networkRequest, this.#manager);
    networkRequest.setResourceType(Common5.ResourceType.resourceTypes.WebSocket);
    this.startNetworkRequest(networkRequest, null);
  }
  webSocketWillSendHandshakeRequest({ requestId, timestamp: time, wallTime, request }) {
    const networkRequest = this.#requestsById.get(requestId);
    if (!networkRequest) {
      return;
    }
    networkRequest.requestMethod = "GET";
    networkRequest.setRequestHeaders(this.headersMapToHeadersArray(request.headers));
    networkRequest.setIssueTime(time, wallTime);
    this.updateNetworkRequest(networkRequest);
  }
  webSocketHandshakeResponseReceived({ requestId, timestamp: time, response }) {
    const networkRequest = this.#requestsById.get(requestId);
    if (!networkRequest) {
      return;
    }
    networkRequest.statusCode = response.status;
    networkRequest.statusText = response.statusText;
    networkRequest.responseHeaders = this.headersMapToHeadersArray(response.headers);
    networkRequest.responseHeadersText = response.headersText || "";
    if (response.requestHeaders) {
      networkRequest.setRequestHeaders(this.headersMapToHeadersArray(response.requestHeaders));
    }
    if (response.requestHeadersText) {
      networkRequest.setRequestHeadersText(response.requestHeadersText);
    }
    networkRequest.responseReceivedTime = time;
    networkRequest.protocol = "websocket";
    this.updateNetworkRequest(networkRequest);
  }
  webSocketFrameReceived({ requestId, timestamp: time, response }) {
    const networkRequest = this.#requestsById.get(requestId);
    if (!networkRequest) {
      return;
    }
    networkRequest.addProtocolFrame(response, time, false);
    networkRequest.responseReceivedTime = time;
    this.updateNetworkRequest(networkRequest);
  }
  webSocketFrameSent({ requestId, timestamp: time, response }) {
    const networkRequest = this.#requestsById.get(requestId);
    if (!networkRequest) {
      return;
    }
    networkRequest.addProtocolFrame(response, time, true);
    networkRequest.responseReceivedTime = time;
    this.updateNetworkRequest(networkRequest);
  }
  webSocketFrameError({ requestId, timestamp: time, errorMessage }) {
    const networkRequest = this.#requestsById.get(requestId);
    if (!networkRequest) {
      return;
    }
    networkRequest.addProtocolFrameError(errorMessage, time);
    networkRequest.responseReceivedTime = time;
    this.updateNetworkRequest(networkRequest);
  }
  webSocketClosed({ requestId, timestamp: time }) {
    const networkRequest = this.#requestsById.get(requestId);
    if (!networkRequest) {
      return;
    }
    this.finishNetworkRequest(networkRequest, time, -1);
  }
  eventSourceMessageReceived({ requestId, timestamp: time, eventName, eventId, data }) {
    const networkRequest = this.#requestsById.get(requestId);
    if (!networkRequest) {
      return;
    }
    networkRequest.addEventSourceMessage(time, eventName, eventId, data);
  }
  requestIntercepted({}) {
  }
  requestWillBeSentExtraInfo({ requestId, associatedCookies, headers, clientSecurityState, connectTiming, siteHasCookieInOtherPartition, appliedNetworkConditionsId }) {
    const blockedRequestCookies = [];
    const includedRequestCookies = [];
    for (const { blockedReasons, exemptionReason, cookie } of associatedCookies) {
      if (blockedReasons.length === 0) {
        includedRequestCookies.push({ exemptionReason, cookie: Cookie.fromProtocolCookie(cookie) });
      } else {
        blockedRequestCookies.push({ blockedReasons, cookie: Cookie.fromProtocolCookie(cookie) });
      }
    }
    const extraRequestInfo = {
      blockedRequestCookies,
      includedRequestCookies,
      requestHeaders: this.headersMapToHeadersArray(headers),
      clientSecurityState,
      connectTiming,
      siteHasCookieInOtherPartition,
      appliedNetworkConditionsId
    };
    this.getExtraInfoBuilder(requestId).addRequestExtraInfo(extraRequestInfo);
  }
  responseReceivedEarlyHints({ requestId, headers }) {
    this.getExtraInfoBuilder(requestId).setEarlyHintsHeaders(this.headersMapToHeadersArray(headers));
  }
  responseReceivedExtraInfo({ requestId, blockedCookies, headers, headersText, resourceIPAddressSpace, statusCode, cookiePartitionKey, cookiePartitionKeyOpaque, exemptedCookies }) {
    const extraResponseInfo = {
      blockedResponseCookies: blockedCookies.map((blockedCookie) => ({
        blockedReasons: blockedCookie.blockedReasons,
        cookieLine: blockedCookie.cookieLine,
        cookie: blockedCookie.cookie ? Cookie.fromProtocolCookie(blockedCookie.cookie) : null
      })),
      responseHeaders: this.headersMapToHeadersArray(headers),
      responseHeadersText: headersText,
      resourceIPAddressSpace,
      statusCode,
      cookiePartitionKey,
      cookiePartitionKeyOpaque,
      exemptedResponseCookies: exemptedCookies?.map((exemptedCookie) => ({
        cookie: Cookie.fromProtocolCookie(exemptedCookie.cookie),
        cookieLine: exemptedCookie.cookieLine,
        exemptionReason: exemptedCookie.exemptionReason
      }))
    };
    this.getExtraInfoBuilder(requestId).addResponseExtraInfo(extraResponseInfo);
  }
  getExtraInfoBuilder(requestId) {
    let builder;
    if (!this.#requestIdToExtraInfoBuilder.has(requestId)) {
      builder = new ExtraInfoBuilder();
      this.#requestIdToExtraInfoBuilder.set(requestId, builder);
    } else {
      builder = this.#requestIdToExtraInfoBuilder.get(requestId);
    }
    return builder;
  }
  appendRedirect(requestId, time, redirectURL) {
    const originalNetworkRequest = this.#requestsById.get(requestId);
    if (!originalNetworkRequest) {
      throw new Error(`Could not find original network request for ${requestId}`);
    }
    let redirectCount = 0;
    for (let redirect = originalNetworkRequest.redirectSource(); redirect; redirect = redirect.redirectSource()) {
      redirectCount++;
    }
    originalNetworkRequest.markAsRedirect(redirectCount);
    this.finishNetworkRequest(originalNetworkRequest, time, -1);
    const newNetworkRequest = NetworkRequest.create(requestId, redirectURL, originalNetworkRequest.documentURL, originalNetworkRequest.frameId, originalNetworkRequest.loaderId, originalNetworkRequest.initiator(), originalNetworkRequest.hasUserGesture() ?? void 0);
    requestToManagerMap.set(newNetworkRequest, this.#manager);
    newNetworkRequest.setRedirectSource(originalNetworkRequest);
    originalNetworkRequest.setRedirectDestination(newNetworkRequest);
    return newNetworkRequest;
  }
  maybeAdoptMainResourceRequest(requestId) {
    const request = MultitargetNetworkManager.instance().inflightMainResourceRequests.get(requestId);
    if (!request) {
      return null;
    }
    const oldDispatcher = NetworkManager.forRequest(request).dispatcher;
    oldDispatcher.#requestsById.delete(requestId);
    oldDispatcher.#requestsByURL.delete(request.url());
    const loaderId = request.loaderId;
    if (loaderId) {
      oldDispatcher.#requestsByLoaderId.delete(loaderId);
    }
    const builder = oldDispatcher.#requestIdToExtraInfoBuilder.get(requestId);
    oldDispatcher.#requestIdToExtraInfoBuilder.delete(requestId);
    this.#requestsById.set(requestId, request);
    this.#requestsByURL.set(request.url(), request);
    if (loaderId) {
      this.#requestsByLoaderId.set(loaderId, request);
    }
    if (builder) {
      this.#requestIdToExtraInfoBuilder.set(requestId, builder);
    }
    requestToManagerMap.set(request, this.#manager);
    return request;
  }
  startNetworkRequest(networkRequest, originalRequest) {
    this.#requestsById.set(networkRequest.requestId(), networkRequest);
    this.#requestsByURL.set(networkRequest.url(), networkRequest);
    const loaderId = networkRequest.loaderId;
    if (loaderId) {
      this.#requestsByLoaderId.set(loaderId, networkRequest);
    }
    if (networkRequest.loaderId === networkRequest.requestId() || networkRequest.loaderId === "") {
      MultitargetNetworkManager.instance().inflightMainResourceRequests.set(networkRequest.requestId(), networkRequest);
    }
    this.#manager.dispatchEventToListeners(Events2.RequestStarted, { request: networkRequest, originalRequest });
  }
  updateNetworkRequest(networkRequest) {
    this.#manager.dispatchEventToListeners(Events2.RequestUpdated, networkRequest);
  }
  finishNetworkRequest(networkRequest, finishTime, encodedDataLength) {
    networkRequest.endTime = finishTime;
    networkRequest.finished = true;
    if (encodedDataLength >= 0) {
      const redirectSource = networkRequest.redirectSource();
      if (redirectSource?.signedExchangeInfo()) {
        networkRequest.setTransferSize(0);
        redirectSource.setTransferSize(encodedDataLength);
        this.updateNetworkRequest(redirectSource);
      } else {
        networkRequest.setTransferSize(encodedDataLength);
      }
    }
    this.#manager.dispatchEventToListeners(Events2.RequestFinished, networkRequest);
    MultitargetNetworkManager.instance().inflightMainResourceRequests.delete(networkRequest.requestId());
    if (Common5.Settings.Settings.instance().moduleSetting("monitoring-xhr-enabled").get() && networkRequest.resourceType().category() === Common5.ResourceType.resourceCategories.XHR) {
      let message;
      const failedToLoad = networkRequest.failed || networkRequest.hasErrorStatusCode();
      if (failedToLoad) {
        message = i18nString(UIStrings.sFailedLoadingSS, { PH1: networkRequest.resourceType().title(), PH2: networkRequest.requestMethod, PH3: networkRequest.url() });
      } else {
        message = i18nString(UIStrings.sFinishedLoadingSS, { PH1: networkRequest.resourceType().title(), PH2: networkRequest.requestMethod, PH3: networkRequest.url() });
      }
      this.#manager.dispatchEventToListeners(Events2.MessageGenerated, { message, requestId: networkRequest.requestId(), warning: false });
    }
  }
  clearRequests() {
    for (const [requestId, request] of this.#requestsById) {
      if (request.finished) {
        this.#requestsById.delete(requestId);
      }
    }
    for (const [requestURL, request] of this.#requestsByURL) {
      if (request.finished) {
        this.#requestsByURL.delete(requestURL);
      }
    }
    for (const [requestLoaderId, request] of this.#requestsByLoaderId) {
      if (request.finished) {
        this.#requestsByLoaderId.delete(requestLoaderId);
      }
    }
    for (const [requestId, builder] of this.#requestIdToExtraInfoBuilder) {
      if (builder.isFinished()) {
        this.#requestIdToExtraInfoBuilder.delete(requestId);
      }
    }
  }
  webTransportCreated({ transportId, url: requestURL, timestamp: time, initiator }) {
    const networkRequest = NetworkRequest.createForSocket(transportId, requestURL, initiator);
    networkRequest.hasNetworkData = true;
    requestToManagerMap.set(networkRequest, this.#manager);
    networkRequest.setResourceType(Common5.ResourceType.resourceTypes.WebTransport);
    networkRequest.setIssueTime(time, 0);
    this.startNetworkRequest(networkRequest, null);
  }
  webTransportConnectionEstablished({ transportId, timestamp: time }) {
    const networkRequest = this.#requestsById.get(transportId);
    if (!networkRequest) {
      return;
    }
    networkRequest.responseReceivedTime = time;
    networkRequest.endTime = time + 1e-3;
    this.updateNetworkRequest(networkRequest);
  }
  webTransportClosed({ transportId, timestamp: time }) {
    const networkRequest = this.#requestsById.get(transportId);
    if (!networkRequest) {
      return;
    }
    networkRequest.endTime = time;
    this.finishNetworkRequest(networkRequest, time, 0);
  }
  directTCPSocketCreated(event) {
    const requestURL = this.concatHostPort(event.remoteAddr, event.remotePort);
    const networkRequest = NetworkRequest.createForSocket(event.identifier, requestURL, event.initiator);
    networkRequest.hasNetworkData = true;
    networkRequest.setRemoteAddress(event.remoteAddr, event.remotePort);
    networkRequest.protocol = i18n.i18n.lockedString("tcp");
    networkRequest.statusText = i18nString(UIStrings.directSocketStatusOpening);
    networkRequest.directSocketInfo = {
      type: DirectSocketType.TCP,
      status: DirectSocketStatus.OPENING,
      createOptions: {
        remoteAddr: event.remoteAddr,
        remotePort: event.remotePort,
        noDelay: event.options.noDelay,
        keepAliveDelay: event.options.keepAliveDelay,
        sendBufferSize: event.options.sendBufferSize,
        receiveBufferSize: event.options.receiveBufferSize,
        dnsQueryType: event.options.dnsQueryType
      }
    };
    networkRequest.setResourceType(Common5.ResourceType.resourceTypes.DirectSocket);
    networkRequest.setIssueTime(event.timestamp, event.timestamp);
    requestToManagerMap.set(networkRequest, this.#manager);
    this.startNetworkRequest(networkRequest, null);
  }
  directTCPSocketOpened(event) {
    const networkRequest = this.#requestsById.get(event.identifier);
    if (!networkRequest?.directSocketInfo) {
      return;
    }
    networkRequest.responseReceivedTime = event.timestamp;
    networkRequest.directSocketInfo.status = DirectSocketStatus.OPEN;
    networkRequest.statusText = i18nString(UIStrings.directSocketStatusOpen);
    networkRequest.directSocketInfo.openInfo = {
      remoteAddr: event.remoteAddr,
      remotePort: event.remotePort,
      localAddr: event.localAddr,
      localPort: event.localPort
    };
    networkRequest.setRemoteAddress(event.remoteAddr, event.remotePort);
    const requestURL = this.concatHostPort(event.remoteAddr, event.remotePort);
    networkRequest.setUrl(requestURL);
    this.updateNetworkRequest(networkRequest);
  }
  directTCPSocketAborted(event) {
    const networkRequest = this.#requestsById.get(event.identifier);
    if (!networkRequest?.directSocketInfo) {
      return;
    }
    networkRequest.failed = true;
    networkRequest.directSocketInfo.status = DirectSocketStatus.ABORTED;
    networkRequest.statusText = i18nString(UIStrings.directSocketStatusAborted);
    networkRequest.directSocketInfo.errorMessage = event.errorMessage;
    this.finishNetworkRequest(networkRequest, event.timestamp, 0);
  }
  directTCPSocketClosed(event) {
    const networkRequest = this.#requestsById.get(event.identifier);
    if (!networkRequest?.directSocketInfo) {
      return;
    }
    networkRequest.statusText = i18nString(UIStrings.directSocketStatusClosed);
    networkRequest.directSocketInfo.status = DirectSocketStatus.CLOSED;
    this.finishNetworkRequest(networkRequest, event.timestamp, 0);
  }
  directTCPSocketChunkSent(event) {
    const networkRequest = this.#requestsById.get(event.identifier);
    if (!networkRequest) {
      return;
    }
    networkRequest.addDirectSocketChunk({
      data: event.data,
      type: DirectSocketChunkType.SEND,
      timestamp: event.timestamp
    });
    networkRequest.responseReceivedTime = event.timestamp;
    this.updateNetworkRequest(networkRequest);
  }
  directTCPSocketChunkReceived(event) {
    const networkRequest = this.#requestsById.get(event.identifier);
    if (!networkRequest) {
      return;
    }
    networkRequest.addDirectSocketChunk({
      data: event.data,
      type: DirectSocketChunkType.RECEIVE,
      timestamp: event.timestamp
    });
    networkRequest.responseReceivedTime = event.timestamp;
    this.updateNetworkRequest(networkRequest);
  }
  directUDPSocketCreated(event) {
    let requestURL = "";
    let type;
    if (event.options.remoteAddr && event.options.remotePort) {
      requestURL = this.concatHostPort(event.options.remoteAddr, event.options.remotePort);
      type = DirectSocketType.UDP_CONNECTED;
    } else if (event.options.localAddr) {
      requestURL = this.concatHostPort(event.options.localAddr, event.options.localPort);
      type = DirectSocketType.UDP_BOUND;
    } else {
      return;
    }
    const networkRequest = NetworkRequest.createForSocket(event.identifier, requestURL, event.initiator);
    networkRequest.hasNetworkData = true;
    if (event.options.remoteAddr && event.options.remotePort) {
      networkRequest.setRemoteAddress(event.options.remoteAddr, event.options.remotePort);
    }
    networkRequest.protocol = i18n.i18n.lockedString("udp");
    networkRequest.statusText = i18nString(UIStrings.directSocketStatusOpening);
    networkRequest.directSocketInfo = {
      type,
      status: DirectSocketStatus.OPENING,
      createOptions: {
        remoteAddr: event.options.remoteAddr,
        remotePort: event.options.remotePort,
        localAddr: event.options.localAddr,
        localPort: event.options.localPort,
        sendBufferSize: event.options.sendBufferSize,
        receiveBufferSize: event.options.receiveBufferSize,
        dnsQueryType: event.options.dnsQueryType
      }
    };
    networkRequest.setResourceType(Common5.ResourceType.resourceTypes.DirectSocket);
    networkRequest.setIssueTime(event.timestamp, event.timestamp);
    requestToManagerMap.set(networkRequest, this.#manager);
    this.startNetworkRequest(networkRequest, null);
  }
  directUDPSocketOpened(event) {
    const networkRequest = this.#requestsById.get(event.identifier);
    if (!networkRequest?.directSocketInfo) {
      return;
    }
    let requestURL;
    if (networkRequest.directSocketInfo.type === DirectSocketType.UDP_CONNECTED) {
      if (!event.remoteAddr || !event.remotePort) {
        return;
      }
      networkRequest.setRemoteAddress(event.remoteAddr, event.remotePort);
      requestURL = this.concatHostPort(event.remoteAddr, event.remotePort);
    } else {
      requestURL = this.concatHostPort(event.localAddr, event.localPort);
    }
    networkRequest.setUrl(requestURL);
    networkRequest.responseReceivedTime = event.timestamp;
    networkRequest.directSocketInfo.status = DirectSocketStatus.OPEN;
    networkRequest.statusText = i18nString(UIStrings.directSocketStatusOpen);
    networkRequest.directSocketInfo.openInfo = {
      remoteAddr: event.remoteAddr,
      remotePort: event.remotePort,
      localAddr: event.localAddr,
      localPort: event.localPort
    };
    this.updateNetworkRequest(networkRequest);
  }
  directUDPSocketAborted(event) {
    const networkRequest = this.#requestsById.get(event.identifier);
    if (!networkRequest?.directSocketInfo) {
      return;
    }
    networkRequest.failed = true;
    networkRequest.directSocketInfo.status = DirectSocketStatus.ABORTED;
    networkRequest.statusText = i18nString(UIStrings.directSocketStatusAborted);
    networkRequest.directSocketInfo.errorMessage = event.errorMessage;
    this.finishNetworkRequest(networkRequest, event.timestamp, 0);
  }
  directUDPSocketClosed(event) {
    const networkRequest = this.#requestsById.get(event.identifier);
    if (!networkRequest?.directSocketInfo) {
      return;
    }
    networkRequest.statusText = i18nString(UIStrings.directSocketStatusClosed);
    networkRequest.directSocketInfo.status = DirectSocketStatus.CLOSED;
    this.finishNetworkRequest(networkRequest, event.timestamp, 0);
  }
  directUDPSocketChunkSent(event) {
    const networkRequest = this.#requestsById.get(event.identifier);
    if (!networkRequest) {
      return;
    }
    networkRequest.addDirectSocketChunk({
      data: event.message.data,
      type: DirectSocketChunkType.SEND,
      timestamp: event.timestamp,
      remoteAddress: event.message.remoteAddr,
      remotePort: event.message.remotePort
    });
    networkRequest.responseReceivedTime = event.timestamp;
    this.updateNetworkRequest(networkRequest);
  }
  directUDPSocketChunkReceived(event) {
    const networkRequest = this.#requestsById.get(event.identifier);
    if (!networkRequest) {
      return;
    }
    networkRequest.addDirectSocketChunk({
      data: event.message.data,
      type: DirectSocketChunkType.RECEIVE,
      timestamp: event.timestamp,
      remoteAddress: event.message.remoteAddr,
      remotePort: event.message.remotePort
    });
    networkRequest.responseReceivedTime = event.timestamp;
    this.updateNetworkRequest(networkRequest);
  }
  trustTokenOperationDone(event) {
    const request = this.#requestsById.get(event.requestId);
    if (!request) {
      this.#requestIdToTrustTokenEvent.set(event.requestId, event);
      return;
    }
    request.setTrustTokenOperationDoneEvent(event);
  }
  reportingApiReportAdded(data) {
    this.#manager.dispatchEventToListeners(Events2.ReportingApiReportAdded, data.report);
  }
  reportingApiReportUpdated(data) {
    this.#manager.dispatchEventToListeners(Events2.ReportingApiReportUpdated, data.report);
  }
  reportingApiEndpointsChangedForOrigin(data) {
    this.#manager.dispatchEventToListeners(Events2.ReportingApiEndpointsChangedForOrigin, data);
  }
  policyUpdated() {
  }
  /**
   * @deprecated
   * This method is only kept for usage in a web test.
   */
  createNetworkRequest(requestId, frameId, loaderId, url, documentURL, initiator) {
    const request = NetworkRequest.create(requestId, url, documentURL, frameId, loaderId, initiator);
    requestToManagerMap.set(request, this.#manager);
    return request;
  }
  concatHostPort(host, port) {
    if (!port || port === 0) {
      return host;
    }
    return `${host}:${port}`;
  }
};
var RequestURLPattern = class _RequestURLPattern {
  constructorString;
  pattern;
  constructor(constructorString, pattern) {
    this.constructorString = constructorString;
    this.pattern = pattern;
    if (pattern.hasRegExpGroups) {
      throw new Error("RegExp groups are not allowed");
    }
  }
  static isValidPattern(pattern) {
    try {
      const urlPattern = new URLPattern(pattern);
      return urlPattern.hasRegExpGroups ? "has-regexp-groups" : "valid";
    } catch {
      return "failed-to-parse";
    }
  }
  static create(constructorString) {
    try {
      const urlPattern = new URLPattern(constructorString);
      return urlPattern.hasRegExpGroups ? null : new _RequestURLPattern(constructorString, urlPattern);
    } catch {
      return null;
    }
  }
  static upgradeFromWildcard(pattern) {
    const tryCreate = (constructorString) => {
      const result = this.create(constructorString);
      if (result?.pattern.protocol === "localhost" && result?.pattern.hostname === "") {
        return tryCreate(`*://${constructorString}`);
      }
      return result;
    };
    return tryCreate(pattern) ?? // Try to upgrade patterns created from the network panel, which either blocks the full url (sans
    // protocol) or just the domain name. In both cases the wildcard patterns had implicit wildcards at the end.
    // We explicitly add that here, which will match both domain names without path (implicitly setting pathname
    // to '*') and urls with path (appending * to the pathname).
    tryCreate(`*://${pattern}*`);
  }
};
var RequestCondition = class extends Common5.ObjectWrapper.ObjectWrapper {
  #pattern;
  #enabled;
  #conditions;
  #ruleIds = /* @__PURE__ */ new Set();
  static createFromSetting(setting) {
    if ("urlPattern" in setting) {
      const pattern2 = RequestURLPattern.create(setting.urlPattern) ?? {
        wildcardURL: setting.urlPattern,
        upgradedPattern: RequestURLPattern.upgradeFromWildcard(setting.urlPattern) ?? void 0
      };
      const conditions = getPredefinedOrBlockingCondition(setting.conditions) ?? customUserNetworkConditionsSetting().get().find((condition) => condition.key === setting.conditions) ?? NoThrottlingConditions;
      return new this(pattern2, setting.enabled, conditions);
    }
    const pattern = {
      wildcardURL: setting.url,
      upgradedPattern: RequestURLPattern.upgradeFromWildcard(setting.url) ?? void 0
    };
    return new this(pattern, setting.enabled, BlockingConditions);
  }
  static create(pattern, conditions) {
    return new this(
      pattern,
      /* enabled=*/
      true,
      conditions
    );
  }
  constructor(pattern, enabled, conditions) {
    super();
    this.#pattern = pattern;
    this.#enabled = enabled;
    this.#conditions = conditions;
  }
  get isBlocking() {
    return this.conditions === BlockingConditions;
  }
  get ruleIds() {
    return this.#ruleIds;
  }
  get constructorString() {
    return this.#pattern instanceof RequestURLPattern ? this.#pattern.constructorString : this.#pattern.upgradedPattern?.constructorString;
  }
  get wildcardURL() {
    return "wildcardURL" in this.#pattern ? this.#pattern.wildcardURL : void 0;
  }
  get constructorStringOrWildcardURL() {
    return this.#pattern instanceof RequestURLPattern ? this.#pattern.constructorString : this.#pattern.upgradedPattern?.constructorString ?? this.#pattern.wildcardURL;
  }
  set pattern(pattern) {
    if (typeof pattern === "string") {
      if (Root2.Runtime.hostConfig.devToolsIndividualRequestThrottling?.enabled) {
        throw new Error("Should not use wildcard urls");
      }
      this.#pattern = {
        wildcardURL: pattern,
        upgradedPattern: RequestURLPattern.upgradeFromWildcard(pattern) ?? void 0
      };
    } else {
      this.#pattern = pattern;
    }
    this.dispatchEventToListeners(
      "request-condition-changed"
      /* RequestCondition.Events.REQUEST_CONDITION_CHANGED */
    );
  }
  get enabled() {
    return this.#enabled;
  }
  set enabled(enabled) {
    this.#enabled = enabled;
    this.dispatchEventToListeners(
      "request-condition-changed"
      /* RequestCondition.Events.REQUEST_CONDITION_CHANGED */
    );
  }
  get conditions() {
    return this.#conditions;
  }
  set conditions(conditions) {
    this.#conditions = conditions;
    this.#ruleIds = /* @__PURE__ */ new Set();
    this.dispatchEventToListeners(
      "request-condition-changed"
      /* RequestCondition.Events.REQUEST_CONDITION_CHANGED */
    );
  }
  toSetting() {
    const enabled = this.enabled;
    if (this.#pattern instanceof RequestURLPattern) {
      return { enabled, urlPattern: this.#pattern.constructorString, conditions: this.#conditions.key };
    }
    if (this.#conditions !== BlockingConditions && this.#pattern.upgradedPattern) {
      return { enabled, urlPattern: this.#pattern.upgradedPattern.constructorString, conditions: this.#conditions.key };
    }
    return { enabled, url: this.#pattern.wildcardURL };
  }
  get originalOrUpgradedURLPattern() {
    return this.#pattern instanceof RequestURLPattern ? this.#pattern.pattern : this.#pattern.upgradedPattern?.pattern;
  }
};
var RequestConditions = class extends Common5.ObjectWrapper.ObjectWrapper {
  #setting = Common5.Settings.Settings.instance().createSetting("network-blocked-patterns", []);
  #conditionsEnabledSetting = Common5.Settings.Settings.instance().moduleSetting("request-blocking-enabled");
  #conditions = [];
  #requestConditionsById = /* @__PURE__ */ new Map();
  #conditionsAppliedForTestPromise = Promise.resolve();
  constructor() {
    super();
    for (const condition of this.#setting.get()) {
      try {
        this.#conditions.push(RequestCondition.createFromSetting(condition));
      } catch (e) {
        console.error("Error loading throttling settings: ", e);
      }
    }
    for (const condition of this.#conditions) {
      condition.addEventListener("request-condition-changed", this.#conditionsChanged, this);
    }
    this.#conditionsEnabledSetting.addChangeListener(() => this.dispatchEventToListeners(
      "request-conditions-changed"
      /* RequestConditions.Events.REQUEST_CONDITIONS_CHANGED */
    ));
  }
  get count() {
    return this.#conditions.length;
  }
  get conditionsEnabled() {
    return this.#conditionsEnabledSetting.get();
  }
  set conditionsEnabled(enabled) {
    if (this.#conditionsEnabledSetting.get() === enabled) {
      return;
    }
    this.#conditionsEnabledSetting.set(enabled);
  }
  findCondition(pattern) {
    if (Root2.Runtime.hostConfig.devToolsIndividualRequestThrottling?.enabled) {
      return this.#conditions.find((condition) => condition.constructorString === pattern);
    }
    return this.#conditions.find((condition) => condition.wildcardURL === pattern);
  }
  has(url) {
    return Boolean(this.findCondition(url));
  }
  add(...conditions) {
    this.#conditions.push(...conditions);
    for (const condition of conditions) {
      condition.addEventListener("request-condition-changed", this.#conditionsChanged, this);
    }
    this.#conditionsChanged();
  }
  decreasePriority(condition) {
    const index = this.#conditions.indexOf(condition);
    if (index < 0 || index >= this.#conditions.length - 1) {
      return;
    }
    Platform3.ArrayUtilities.swap(this.#conditions, index, index + 1);
    this.dispatchEventToListeners(
      "request-conditions-changed"
      /* RequestConditions.Events.REQUEST_CONDITIONS_CHANGED */
    );
  }
  increasePriority(condition) {
    const index = this.#conditions.indexOf(condition);
    if (index <= 0) {
      return;
    }
    Platform3.ArrayUtilities.swap(this.#conditions, index - 1, index);
    this.dispatchEventToListeners(
      "request-conditions-changed"
      /* RequestConditions.Events.REQUEST_CONDITIONS_CHANGED */
    );
  }
  delete(condition) {
    const index = this.#conditions.indexOf(condition);
    if (index < 0) {
      return;
    }
    condition.removeEventListener("request-condition-changed", this.#conditionsChanged, this);
    this.#conditions.splice(index, 1);
    this.#conditionsChanged();
  }
  clear() {
    this.#conditions.splice(0);
    this.#conditionsChanged();
    for (const condition of this.#conditions) {
      condition.removeEventListener("request-condition-changed", this.#conditionsChanged, this);
    }
  }
  #conditionsChanged() {
    this.#setting.set(this.#conditions.map((condition) => condition.toSetting()));
    this.dispatchEventToListeners(
      "request-conditions-changed"
      /* RequestConditions.Events.REQUEST_CONDITIONS_CHANGED */
    );
  }
  get conditions() {
    return this.#conditions.values();
  }
  applyConditions(offline, globalConditions, ...agents) {
    function isNonBlockingCondition(condition) {
      return !("block" in condition);
    }
    if (Root2.Runtime.hostConfig.devToolsIndividualRequestThrottling?.enabled) {
      const urlPatterns = [];
      const matchedNetworkConditions = [];
      if (this.conditionsEnabled) {
        for (const condition of this.#conditions) {
          const urlPattern = condition.constructorString;
          const conditions = condition.conditions;
          if (!condition.enabled || !urlPattern || conditions === NoThrottlingConditions) {
            continue;
          }
          const block = !isNonBlockingCondition(conditions);
          urlPatterns.push({ urlPattern, block });
          if (!block) {
            const { ruleIds } = condition;
            matchedNetworkConditions.push({ ruleIds, urlPattern, conditions });
          }
        }
        if (globalConditions) {
          matchedNetworkConditions.push({ conditions: globalConditions });
        }
      }
      const promises = [];
      for (const agent of agents) {
        promises.push(agent.invoke_setBlockedURLs({ urlPatterns }));
        promises.push(agent.invoke_emulateNetworkConditionsByRule({
          offline,
          matchedNetworkConditions: matchedNetworkConditions.map(({ urlPattern, conditions }) => ({
            urlPattern: urlPattern ?? "",
            latency: conditions.latency,
            downloadThroughput: conditions.download < 0 ? 0 : conditions.download,
            uploadThroughput: conditions.upload < 0 ? 0 : conditions.upload,
            packetLoss: (conditions.packetLoss ?? 0) < 0 ? 0 : conditions.packetLoss,
            packetQueueLength: conditions.packetQueueLength,
            packetReordering: conditions.packetReordering,
            connectionType: NetworkManager.connectionType(conditions)
          }))
        }).then((response) => {
          if (!response.getError()) {
            for (let i = 0; i < response.ruleIds.length; ++i) {
              const ruleId = response.ruleIds[i];
              const { ruleIds, conditions, urlPattern } = matchedNetworkConditions[i];
              if (ruleIds) {
                this.#requestConditionsById.set(ruleId, { urlPattern, conditions });
                matchedNetworkConditions[i].ruleIds?.add(ruleId);
              }
            }
          }
        }));
        promises.push(agent.invoke_overrideNetworkState({
          offline,
          latency: globalConditions?.latency ?? 0,
          downloadThroughput: !globalConditions || globalConditions.download < 0 ? 0 : globalConditions.download,
          uploadThroughput: !globalConditions || globalConditions.upload < 0 ? 0 : globalConditions.upload
        }));
      }
      this.#conditionsAppliedForTestPromise = this.#conditionsAppliedForTestPromise.then(() => Promise.all(promises));
      return urlPatterns.length > 0;
    }
    const urls = this.conditionsEnabled ? this.#conditions.filter((condition) => condition.enabled && condition.wildcardURL).map((condition) => condition.wildcardURL) : [];
    for (const agent of agents) {
      void agent.invoke_setBlockedURLs({ urls });
    }
    return urls.length > 0;
  }
  conditionsAppliedForTest() {
    return this.#conditionsAppliedForTestPromise;
  }
  conditionsForId(appliedNetworkConditionsId) {
    return this.#requestConditionsById.get(appliedNetworkConditionsId);
  }
};
_a = RequestConditions;
var multiTargetNetworkManagerInstance;
var MultitargetNetworkManager = class _MultitargetNetworkManager extends Common5.ObjectWrapper.ObjectWrapper {
  #userAgentOverride = "";
  #userAgentMetadataOverride = null;
  #customAcceptedEncodings = null;
  #networkAgents = /* @__PURE__ */ new Set();
  #fetchAgents = /* @__PURE__ */ new Set();
  inflightMainResourceRequests = /* @__PURE__ */ new Map();
  #networkConditions = NoThrottlingConditions;
  #updatingInterceptionPatternsPromise = null;
  #requestConditions = new RequestConditions();
  #urlsForRequestInterceptor = new Platform3.MapUtilities.Multimap();
  #extraHeaders;
  #customUserAgent;
  #isBlocking = false;
  constructor() {
    super();
    const blockedPatternChanged = () => {
      this.updateBlockedPatterns();
      this.dispatchEventToListeners(
        "BlockedPatternsChanged"
        /* MultitargetNetworkManager.Events.BLOCKED_PATTERNS_CHANGED */
      );
    };
    this.#requestConditions.addEventListener("request-conditions-changed", blockedPatternChanged);
    this.updateBlockedPatterns();
    TargetManager.instance().observeModels(NetworkManager, this);
  }
  static instance(opts = { forceNew: null }) {
    const { forceNew } = opts;
    if (!multiTargetNetworkManagerInstance || forceNew) {
      multiTargetNetworkManagerInstance = new _MultitargetNetworkManager();
    }
    return multiTargetNetworkManagerInstance;
  }
  static dispose() {
    multiTargetNetworkManagerInstance = null;
  }
  static patchUserAgentWithChromeVersion(uaString) {
    const chromeVersion = Root2.Runtime.getChromeVersion();
    if (chromeVersion.length > 0) {
      const additionalAppVersion = chromeVersion.split(".", 1)[0] + ".0.100.0";
      return Platform3.StringUtilities.sprintf(uaString, chromeVersion, additionalAppVersion);
    }
    return uaString;
  }
  static patchUserAgentMetadataWithChromeVersion(userAgentMetadata) {
    if (!userAgentMetadata.brands) {
      return;
    }
    const chromeVersion = Root2.Runtime.getChromeVersion();
    if (chromeVersion.length === 0) {
      return;
    }
    const majorVersion = chromeVersion.split(".", 1)[0];
    for (const brand of userAgentMetadata.brands) {
      if (brand.version.includes("%s")) {
        brand.version = Platform3.StringUtilities.sprintf(brand.version, majorVersion);
      }
    }
    if (userAgentMetadata.fullVersion) {
      if (userAgentMetadata.fullVersion.includes("%s")) {
        userAgentMetadata.fullVersion = Platform3.StringUtilities.sprintf(userAgentMetadata.fullVersion, chromeVersion);
      }
    }
  }
  modelAdded(networkManager) {
    const networkAgent = networkManager.target().networkAgent();
    const fetchAgent = networkManager.target().fetchAgent();
    if (this.#extraHeaders) {
      void networkAgent.invoke_setExtraHTTPHeaders({ headers: this.#extraHeaders });
    }
    if (this.currentUserAgent()) {
      void networkAgent.invoke_setUserAgentOverride({ userAgent: this.currentUserAgent(), userAgentMetadata: this.#userAgentMetadataOverride || void 0 });
    }
    this.#requestConditions.applyConditions(this.isOffline(), this.isThrottling() ? this.#networkConditions : null, networkAgent);
    if (this.isIntercepting()) {
      void fetchAgent.invoke_enable({ patterns: this.#urlsForRequestInterceptor.valuesArray() });
    }
    if (this.#customAcceptedEncodings === null) {
      void networkAgent.invoke_clearAcceptedEncodingsOverride();
    } else {
      void networkAgent.invoke_setAcceptedEncodings({ encodings: this.#customAcceptedEncodings });
    }
    this.#networkAgents.add(networkAgent);
    this.#fetchAgents.add(fetchAgent);
    if (this.isThrottling() && !Root2.Runtime.hostConfig.devToolsIndividualRequestThrottling?.enabled) {
      this.updateNetworkConditions(networkAgent);
    }
  }
  modelRemoved(networkManager) {
    for (const entry of this.inflightMainResourceRequests) {
      const manager = NetworkManager.forRequest(entry[1]);
      if (manager !== networkManager) {
        continue;
      }
      this.inflightMainResourceRequests.delete(entry[0]);
    }
    this.#networkAgents.delete(networkManager.target().networkAgent());
    this.#fetchAgents.delete(networkManager.target().fetchAgent());
  }
  isThrottling() {
    return this.#networkConditions.download >= 0 || this.#networkConditions.upload >= 0 || this.#networkConditions.latency > 0;
  }
  isOffline() {
    return !this.#networkConditions.download && !this.#networkConditions.upload;
  }
  setNetworkConditions(conditions) {
    this.#networkConditions = conditions;
    if (Root2.Runtime.hostConfig.devToolsIndividualRequestThrottling?.enabled) {
      this.#requestConditions.applyConditions(this.isOffline(), this.isThrottling() ? this.#networkConditions : null, ...this.#networkAgents);
    } else {
      for (const agent of this.#networkAgents) {
        this.updateNetworkConditions(agent);
      }
    }
    this.dispatchEventToListeners(
      "ConditionsChanged"
      /* MultitargetNetworkManager.Events.CONDITIONS_CHANGED */
    );
  }
  networkConditions() {
    return this.#networkConditions;
  }
  updateNetworkConditions(networkAgent) {
    const conditions = this.#networkConditions;
    if (!this.isThrottling()) {
      void networkAgent.invoke_emulateNetworkConditions({
        offline: false,
        latency: 0,
        downloadThroughput: 0,
        uploadThroughput: 0
      });
    } else {
      void networkAgent.invoke_emulateNetworkConditions({
        offline: this.isOffline(),
        latency: conditions.latency,
        downloadThroughput: conditions.download < 0 ? 0 : conditions.download,
        uploadThroughput: conditions.upload < 0 ? 0 : conditions.upload,
        packetLoss: (conditions.packetLoss ?? 0) < 0 ? 0 : conditions.packetLoss,
        packetQueueLength: conditions.packetQueueLength,
        packetReordering: conditions.packetReordering,
        connectionType: NetworkManager.connectionType(conditions)
      });
    }
  }
  setExtraHTTPHeaders(headers) {
    this.#extraHeaders = headers;
    for (const agent of this.#networkAgents) {
      void agent.invoke_setExtraHTTPHeaders({ headers: this.#extraHeaders });
    }
  }
  currentUserAgent() {
    return this.#customUserAgent ? this.#customUserAgent : this.#userAgentOverride;
  }
  updateUserAgentOverride() {
    const userAgent = this.currentUserAgent();
    for (const agent of this.#networkAgents) {
      void agent.invoke_setUserAgentOverride({ userAgent, userAgentMetadata: this.#userAgentMetadataOverride || void 0 });
    }
  }
  setUserAgentOverride(userAgent, userAgentMetadataOverride) {
    const uaChanged = this.#userAgentOverride !== userAgent;
    this.#userAgentOverride = userAgent;
    if (!this.#customUserAgent) {
      this.#userAgentMetadataOverride = userAgentMetadataOverride;
      this.updateUserAgentOverride();
    } else {
      this.#userAgentMetadataOverride = null;
    }
    if (uaChanged) {
      this.dispatchEventToListeners(
        "UserAgentChanged"
        /* MultitargetNetworkManager.Events.USER_AGENT_CHANGED */
      );
    }
  }
  setCustomUserAgentOverride(userAgent, userAgentMetadataOverride = null) {
    this.#customUserAgent = userAgent;
    this.#userAgentMetadataOverride = userAgentMetadataOverride;
    this.updateUserAgentOverride();
  }
  setCustomAcceptedEncodingsOverride(acceptedEncodings) {
    this.#customAcceptedEncodings = acceptedEncodings;
    this.updateAcceptedEncodingsOverride();
    this.dispatchEventToListeners(
      "AcceptedEncodingsChanged"
      /* MultitargetNetworkManager.Events.ACCEPTED_ENCODINGS_CHANGED */
    );
  }
  clearCustomAcceptedEncodingsOverride() {
    this.#customAcceptedEncodings = null;
    this.updateAcceptedEncodingsOverride();
    this.dispatchEventToListeners(
      "AcceptedEncodingsChanged"
      /* MultitargetNetworkManager.Events.ACCEPTED_ENCODINGS_CHANGED */
    );
  }
  isAcceptedEncodingOverrideSet() {
    return this.#customAcceptedEncodings !== null;
  }
  updateAcceptedEncodingsOverride() {
    const customAcceptedEncodings = this.#customAcceptedEncodings;
    for (const agent of this.#networkAgents) {
      if (customAcceptedEncodings === null) {
        void agent.invoke_clearAcceptedEncodingsOverride();
      } else {
        void agent.invoke_setAcceptedEncodings({ encodings: customAcceptedEncodings });
      }
    }
  }
  get requestConditions() {
    return this.#requestConditions;
  }
  isBlocking() {
    return this.#isBlocking && this.requestConditions.conditionsEnabled;
  }
  /**
   * @deprecated Kept for layout tests
   * TODO(pfaffe) remove
   */
  setBlockingEnabled(enabled) {
    this.requestConditions.conditionsEnabled = enabled;
  }
  /**
   * @deprecated Kept for layout tests
   * TODO(pfaffe) remove
   */
  setBlockedPatterns(patterns) {
    this.requestConditions.clear();
    this.requestConditions.add(...patterns.map((pattern) => RequestCondition.createFromSetting(pattern)));
  }
  updateBlockedPatterns() {
    this.#isBlocking = this.#requestConditions.applyConditions(this.isOffline(), this.isThrottling() ? this.#networkConditions : null, ...this.#networkAgents);
  }
  isIntercepting() {
    return Boolean(this.#urlsForRequestInterceptor.size);
  }
  setInterceptionHandlerForPatterns(patterns, requestInterceptor) {
    this.#urlsForRequestInterceptor.deleteAll(requestInterceptor);
    for (const newPattern of patterns) {
      this.#urlsForRequestInterceptor.set(requestInterceptor, newPattern);
    }
    return this.updateInterceptionPatternsOnNextTick();
  }
  updateInterceptionPatternsOnNextTick() {
    if (!this.#updatingInterceptionPatternsPromise) {
      this.#updatingInterceptionPatternsPromise = Promise.resolve().then(this.updateInterceptionPatterns.bind(this));
    }
    return this.#updatingInterceptionPatternsPromise;
  }
  async updateInterceptionPatterns() {
    if (!Common5.Settings.Settings.instance().moduleSetting("cache-disabled").get()) {
      Common5.Settings.Settings.instance().moduleSetting("cache-disabled").set(true);
    }
    this.#updatingInterceptionPatternsPromise = null;
    const promises = [];
    for (const agent of this.#fetchAgents) {
      promises.push(agent.invoke_enable({ patterns: this.#urlsForRequestInterceptor.valuesArray() }));
    }
    this.dispatchEventToListeners(
      "InterceptorsChanged"
      /* MultitargetNetworkManager.Events.INTERCEPTORS_CHANGED */
    );
    await Promise.all(promises);
  }
  async requestIntercepted(interceptedRequest) {
    for (const requestInterceptor of this.#urlsForRequestInterceptor.keysArray()) {
      await requestInterceptor(interceptedRequest);
      if (interceptedRequest.hasResponded() && interceptedRequest.networkRequest) {
        this.dispatchEventToListeners("RequestIntercepted", interceptedRequest.networkRequest.requestId());
        return;
      }
    }
    if (!interceptedRequest.hasResponded()) {
      interceptedRequest.continueRequestWithoutChange();
    }
  }
  clearBrowserCache() {
    for (const agent of this.#networkAgents) {
      void agent.invoke_clearBrowserCache();
    }
  }
  clearBrowserCookies() {
    for (const agent of this.#networkAgents) {
      void agent.invoke_clearBrowserCookies();
    }
  }
  async getCertificate(origin) {
    const target = TargetManager.instance().primaryPageTarget();
    if (!target) {
      return [];
    }
    const certificate = await target.networkAgent().invoke_getCertificate({ origin });
    if (!certificate) {
      return [];
    }
    return certificate.tableNames;
  }
  async loadResource(url) {
    const headers = {};
    const currentUserAgent = this.currentUserAgent();
    if (currentUserAgent) {
      headers["User-Agent"] = currentUserAgent;
    }
    if (Common5.Settings.Settings.instance().moduleSetting("cache-disabled").get()) {
      headers["Cache-Control"] = "no-cache";
    }
    const allowRemoteFilePaths = Common5.Settings.Settings.instance().moduleSetting("network.enable-remote-file-loading").get();
    return await new Promise((resolve) => Host2.ResourceLoader.load(url, headers, (success, _responseHeaders, content, errorDescription) => {
      resolve({ success, content, errorDescription });
    }, allowRemoteFilePaths));
  }
  appliedRequestConditions(requestInternal) {
    if (!requestInternal.appliedNetworkConditionsId) {
      return void 0;
    }
    return this.requestConditions.conditionsForId(requestInternal.appliedNetworkConditionsId);
  }
};
var InterceptedRequest = class _InterceptedRequest {
  #fetchAgent;
  #hasResponded = false;
  request;
  resourceType;
  responseStatusCode;
  responseHeaders;
  requestId;
  networkRequest;
  constructor(fetchAgent, request, resourceType, requestId, networkRequest, responseStatusCode, responseHeaders) {
    this.#fetchAgent = fetchAgent;
    this.request = request;
    this.resourceType = resourceType;
    this.responseStatusCode = responseStatusCode;
    this.responseHeaders = responseHeaders;
    this.requestId = requestId;
    this.networkRequest = networkRequest;
  }
  hasResponded() {
    return this.#hasResponded;
  }
  static mergeSetCookieHeaders(originalSetCookieHeaders, setCookieHeadersFromOverrides) {
    const generateHeaderMap = (headers) => {
      const result = /* @__PURE__ */ new Map();
      for (const header of headers) {
        const match = header.value.match(/^([a-zA-Z0-9!#$%&'*+.^_`|~-]+=)(.*)$/);
        if (match) {
          if (result.has(match[1])) {
            result.get(match[1])?.push(header.value);
          } else {
            result.set(match[1], [header.value]);
          }
        } else if (result.has(header.value)) {
          result.get(header.value)?.push(header.value);
        } else {
          result.set(header.value, [header.value]);
        }
      }
      return result;
    };
    const originalHeadersMap = generateHeaderMap(originalSetCookieHeaders);
    const overridesHeaderMap = generateHeaderMap(setCookieHeadersFromOverrides);
    const mergedHeaders = [];
    for (const [key, headerValues] of originalHeadersMap) {
      if (overridesHeaderMap.has(key)) {
        for (const headerValue of overridesHeaderMap.get(key) || []) {
          mergedHeaders.push({ name: "set-cookie", value: headerValue });
        }
      } else {
        for (const headerValue of headerValues) {
          mergedHeaders.push({ name: "set-cookie", value: headerValue });
        }
      }
    }
    for (const [key, headerValues] of overridesHeaderMap) {
      if (originalHeadersMap.has(key)) {
        continue;
      }
      for (const headerValue of headerValues) {
        mergedHeaders.push({ name: "set-cookie", value: headerValue });
      }
    }
    return mergedHeaders;
  }
  async continueRequestWithContent(contentBlob, encoded, responseHeaders, isBodyOverridden) {
    this.#hasResponded = true;
    const body = encoded ? await contentBlob.text() : await Common5.Base64.encode(contentBlob).catch((err) => {
      console.error(err);
      return "";
    });
    const responseCode = isBodyOverridden ? 200 : this.responseStatusCode || 200;
    if (this.networkRequest) {
      const originalSetCookieHeaders = this.networkRequest?.originalResponseHeaders.filter((header) => header.name === "set-cookie") || [];
      const setCookieHeadersFromOverrides = responseHeaders.filter((header) => header.name === "set-cookie");
      this.networkRequest.setCookieHeaders = _InterceptedRequest.mergeSetCookieHeaders(originalSetCookieHeaders, setCookieHeadersFromOverrides);
      this.networkRequest.hasOverriddenContent = isBodyOverridden;
    }
    void this.#fetchAgent.invoke_fulfillRequest({ requestId: this.requestId, responseCode, body, responseHeaders });
    MultitargetNetworkManager.instance().dispatchEventToListeners("RequestFulfilled", this.request.url);
  }
  continueRequestWithoutChange() {
    console.assert(!this.#hasResponded);
    this.#hasResponded = true;
    void this.#fetchAgent.invoke_continueRequest({ requestId: this.requestId });
  }
  async responseBody() {
    const response = await this.#fetchAgent.invoke_getResponseBody({ requestId: this.requestId });
    const error = response.getError();
    if (error) {
      return { error };
    }
    const { mimeType, charset } = this.getMimeTypeAndCharset();
    return new TextUtils.ContentData.ContentData(response.body, response.base64Encoded, mimeType ?? "application/octet-stream", charset ?? void 0);
  }
  isRedirect() {
    return this.responseStatusCode !== void 0 && this.responseStatusCode >= 300 && this.responseStatusCode < 400;
  }
  /**
   * Tries to determine the MIME type and charset for this intercepted request.
   * Looks at the intercepted response headers first (for Content-Type header), then
   * checks the `NetworkRequest` if we have one.
   */
  getMimeTypeAndCharset() {
    for (const header of this.responseHeaders ?? []) {
      if (header.name.toLowerCase() === "content-type") {
        return Platform3.MimeType.parseContentType(header.value);
      }
    }
    const mimeType = this.networkRequest?.mimeType ?? null;
    const charset = this.networkRequest?.charset() ?? null;
    return { mimeType, charset };
  }
};
var ExtraInfoBuilder = class {
  #requests = [];
  #responseExtraInfoFlag = [];
  #requestExtraInfos = [];
  #responseExtraInfos = [];
  #responseEarlyHintsHeaders = [];
  #finished = false;
  addRequest(req) {
    this.#requests.push(req);
    this.sync(this.#requests.length - 1);
  }
  addHasExtraInfo(hasExtraInfo) {
    this.#responseExtraInfoFlag.push(hasExtraInfo);
    console.assert(this.#requests.length === this.#responseExtraInfoFlag.length, "request/response count mismatch");
    if (!hasExtraInfo) {
      this.#requestExtraInfos.splice(this.#requests.length - 1, 0, null);
      this.#responseExtraInfos.splice(this.#requests.length - 1, 0, null);
    }
    this.sync(this.#requests.length - 1);
  }
  addRequestExtraInfo(info) {
    this.#requestExtraInfos.push(info);
    this.sync(this.#requestExtraInfos.length - 1);
  }
  addResponseExtraInfo(info) {
    this.#responseExtraInfos.push(info);
    this.sync(this.#responseExtraInfos.length - 1);
  }
  setEarlyHintsHeaders(earlyHintsHeaders) {
    this.#responseEarlyHintsHeaders = earlyHintsHeaders;
    this.updateFinalRequest();
  }
  finished() {
    this.#finished = true;
    if (this.#responseExtraInfoFlag.length < this.#requests.length) {
      this.#responseExtraInfoFlag.push(true);
      this.sync(this.#responseExtraInfoFlag.length - 1);
    }
    console.assert(this.#requests.length === this.#responseExtraInfoFlag.length, "request/response count mismatch when request finished");
    this.updateFinalRequest();
  }
  isFinished() {
    return this.#finished;
  }
  sync(index) {
    const req = this.#requests[index];
    if (!req) {
      return;
    }
    if (index >= this.#responseExtraInfoFlag.length) {
      return;
    }
    if (!this.#responseExtraInfoFlag[index]) {
      return;
    }
    const requestExtraInfo = this.#requestExtraInfos[index];
    if (requestExtraInfo) {
      req.addExtraRequestInfo(requestExtraInfo);
      this.#requestExtraInfos[index] = null;
    }
    const responseExtraInfo = this.#responseExtraInfos[index];
    if (responseExtraInfo) {
      req.addExtraResponseInfo(responseExtraInfo);
      this.#responseExtraInfos[index] = null;
    }
  }
  finalRequest() {
    if (!this.#finished) {
      return null;
    }
    return this.#requests[this.#requests.length - 1] || null;
  }
  updateFinalRequest() {
    if (!this.#finished) {
      return;
    }
    const finalRequest = this.finalRequest();
    finalRequest?.setEarlyHintsHeaders(this.#responseEarlyHintsHeaders);
  }
};
SDKModel.register(NetworkManager, { capabilities: 16, autostart: true });
function networkConditionsEqual(first, second) {
  if ("block" in first || "block" in second) {
    if ("block" in first && "block" in second) {
      const firstTitle2 = typeof first.title === "function" ? first.title() : first.title;
      const secondTitle2 = typeof second.title === "function" ? second.title() : second.title;
      return firstTitle2 === secondTitle2 && first.block === second.block;
    }
    return false;
  }
  const firstTitle = first.i18nTitleKey || (typeof first.title === "function" ? first.title() : first.title);
  const secondTitle = second.i18nTitleKey || (typeof second.title === "function" ? second.title() : second.title);
  return second.download === first.download && second.upload === first.upload && second.latency === first.latency && first.packetLoss === second.packetLoss && first.packetQueueLength === second.packetQueueLength && first.packetReordering === second.packetReordering && secondTitle === firstTitle;
}
var THROTTLING_CONDITIONS_LOOKUP = /* @__PURE__ */ new Map([
  ["NO_THROTTLING", NoThrottlingConditions],
  ["OFFLINE", OfflineConditions],
  ["SPEED_3G", Slow3GConditions],
  ["SPEED_SLOW_4G", Slow4GConditions],
  ["SPEED_FAST_4G", Fast4GConditions]
]);
function keyIsPredefined(key) {
  return !key.startsWith("USER_CUSTOM_SETTING_");
}
function keyIsCustomUser(key) {
  return key.startsWith("USER_CUSTOM_SETTING_");
}
function getPredefinedCondition(key) {
  if (!keyIsPredefined(key)) {
    return null;
  }
  return THROTTLING_CONDITIONS_LOOKUP.get(key) ?? null;
}
function getPredefinedOrBlockingCondition(key) {
  return key === "BLOCKING" ? BlockingConditions : getPredefinedCondition(key);
}
function getRecommendedNetworkPreset(rtt) {
  const RTT_COMPARISON_THRESHOLD = 200;
  const RTT_MINIMUM = 60;
  if (!Number.isFinite(rtt)) {
    return null;
  }
  if (rtt < RTT_MINIMUM) {
    return null;
  }
  const presets = THROTTLING_CONDITIONS_LOOKUP.values().filter((condition) => {
    return condition !== NoThrottlingConditions;
  }).toArray();
  let closestPreset = null;
  let smallestDiff = Infinity;
  for (const preset of presets) {
    const { targetLatency } = preset;
    if (!targetLatency) {
      continue;
    }
    const diff = Math.abs(targetLatency - rtt);
    if (diff > RTT_COMPARISON_THRESHOLD) {
      continue;
    }
    if (smallestDiff < diff) {
      continue;
    }
    closestPreset = preset;
    smallestDiff = diff;
  }
  return closestPreset;
}

// gen/front_end/core/sdk/ResourceTreeModel.js
var ResourceTreeModel_exports = {};
__export(ResourceTreeModel_exports, {
  Events: () => Events3,
  PageDispatcher: () => PageDispatcher,
  ResourceTreeFrame: () => ResourceTreeFrame,
  ResourceTreeModel: () => ResourceTreeModel
});
import * as Common24 from "./../common/common.js";
import * as i18n15 from "./../i18n/i18n.js";
import * as Platform16 from "./../platform/platform.js";

// gen/front_end/core/sdk/DOMModel.js
var DOMModel_exports = {};
__export(DOMModel_exports, {
  ARIA_ATTRIBUTES: () => ARIA_ATTRIBUTES,
  DOMDocument: () => DOMDocument,
  DOMModel: () => DOMModel,
  DOMModelUndoStack: () => DOMModelUndoStack,
  DOMNode: () => DOMNode,
  DOMNodeShortcut: () => DOMNodeShortcut,
  DeferredDOMNode: () => DeferredDOMNode,
  Events: () => Events8
});
import * as Common21 from "./../common/common.js";
import * as Platform14 from "./../platform/platform.js";
import * as Root8 from "./../root/root.js";

// gen/front_end/core/sdk/CSSModel.js
var CSSModel_exports = {};
__export(CSSModel_exports, {
  CSSLocation: () => CSSLocation,
  CSSModel: () => CSSModel,
  CSSPropertyTracker: () => CSSPropertyTracker,
  Edit: () => Edit,
  Events: () => Events5,
  InlineStyleResult: () => InlineStyleResult
});
import * as TextUtils17 from "./../../models/text_utils/text_utils.js";
import * as Common14 from "./../common/common.js";
import * as Host4 from "./../host/host.js";
import * as Platform10 from "./../platform/platform.js";
import * as Root5 from "./../root/root.js";

// gen/front_end/core/sdk/CSSFontFace.js
var CSSFontFace_exports = {};
__export(CSSFontFace_exports, {
  CSSFontFace: () => CSSFontFace
});
var CSSFontFace = class {
  #fontFamily;
  #fontVariationAxes;
  #fontVariationAxesByTag = /* @__PURE__ */ new Map();
  #src;
  #fontDisplay;
  constructor(payload) {
    this.#fontFamily = payload.fontFamily;
    this.#fontVariationAxes = payload.fontVariationAxes || [];
    this.#src = payload.src;
    this.#fontDisplay = payload.fontDisplay;
    for (const axis of this.#fontVariationAxes) {
      this.#fontVariationAxesByTag.set(axis.tag, axis);
    }
  }
  getFontFamily() {
    return this.#fontFamily;
  }
  getSrc() {
    return this.#src;
  }
  getFontDisplay() {
    return this.#fontDisplay;
  }
  getVariationAxisByTag(tag) {
    return this.#fontVariationAxesByTag.get(tag);
  }
};

// gen/front_end/core/sdk/CSSMatchedStyles.js
var CSSMatchedStyles_exports = {};
__export(CSSMatchedStyles_exports, {
  CSSMatchedStyles: () => CSSMatchedStyles,
  CSSRegisteredProperty: () => CSSRegisteredProperty,
  CSSValueSource: () => CSSValueSource
});
import * as Platform6 from "./../platform/platform.js";

// gen/front_end/core/sdk/CSSProperty.js
var CSSProperty_exports = {};
__export(CSSProperty_exports, {
  CSSProperty: () => CSSProperty
});
import * as TextUtils3 from "./../../models/text_utils/text_utils.js";
import * as Common7 from "./../common/common.js";
import * as HostModule from "./../host/host.js";
import * as Platform4 from "./../platform/platform.js";
import * as Root3 from "./../root/root.js";

// gen/front_end/core/sdk/CSSPropertyParser.js
var CSSPropertyParser_exports = {};
__export(CSSPropertyParser_exports, {
  ASTUtils: () => ASTUtils,
  BottomUpTreeMatching: () => BottomUpTreeMatching,
  CSSControlMap: () => CSSControlMap,
  ComputedText: () => ComputedText,
  SyntaxTree: () => SyntaxTree,
  TreeSearch: () => TreeSearch,
  TreeWalker: () => TreeWalker,
  matchDeclaration: () => matchDeclaration,
  matcherBase: () => matcherBase,
  parseFontFamily: () => parseFontFamily,
  parseFontVariationSettings: () => parseFontVariationSettings,
  requiresSpace: () => requiresSpace,
  splitByComma: () => splitByComma,
  stripComments: () => stripComments,
  tokenizeDeclaration: () => tokenizeDeclaration,
  tokenizePropertyName: () => tokenizePropertyName
});
import * as CodeMirror from "./../../third_party/codemirror.next/codemirror.next.js";

// gen/front_end/core/sdk/CSSPropertyParserMatchers.js
var CSSPropertyParserMatchers_exports = {};
__export(CSSPropertyParserMatchers_exports, {
  AnchorFunctionMatch: () => AnchorFunctionMatch,
  AnchorFunctionMatcher: () => AnchorFunctionMatcher,
  AngleMatch: () => AngleMatch,
  AngleMatcher: () => AngleMatcher,
  AttributeMatch: () => AttributeMatch,
  AttributeMatcher: () => AttributeMatcher,
  AutoBaseMatch: () => AutoBaseMatch,
  AutoBaseMatcher: () => AutoBaseMatcher,
  BaseFunctionMatch: () => BaseFunctionMatch,
  BaseVariableMatch: () => BaseVariableMatch,
  BaseVariableMatcher: () => BaseVariableMatcher,
  BezierMatch: () => BezierMatch,
  BezierMatcher: () => BezierMatcher,
  BinOpMatch: () => BinOpMatch,
  BinOpMatcher: () => BinOpMatcher,
  CSSWideKeywordMatch: () => CSSWideKeywordMatch,
  CSSWideKeywordMatcher: () => CSSWideKeywordMatcher,
  ColorMatch: () => ColorMatch,
  ColorMatcher: () => ColorMatcher,
  ColorMixMatch: () => ColorMixMatch,
  ColorMixMatcher: () => ColorMixMatcher,
  CustomFunctionMatch: () => CustomFunctionMatch,
  CustomFunctionMatcher: () => CustomFunctionMatcher,
  EnvFunctionMatch: () => EnvFunctionMatch,
  EnvFunctionMatcher: () => EnvFunctionMatcher,
  FlexGridMasonryMatch: () => FlexGridMasonryMatch,
  FlexGridMasonryMatcher: () => FlexGridMasonryMatcher,
  FontMatch: () => FontMatch,
  FontMatcher: () => FontMatcher,
  GridTemplateMatch: () => GridTemplateMatch,
  GridTemplateMatcher: () => GridTemplateMatcher,
  LengthMatch: () => LengthMatch,
  LengthMatcher: () => LengthMatcher,
  LightDarkColorMatch: () => LightDarkColorMatch,
  LightDarkColorMatcher: () => LightDarkColorMatcher,
  LinearGradientMatch: () => LinearGradientMatch,
  LinearGradientMatcher: () => LinearGradientMatcher,
  LinkableNameMatch: () => LinkableNameMatch,
  LinkableNameMatcher: () => LinkableNameMatcher,
  MathFunctionMatch: () => MathFunctionMatch,
  MathFunctionMatcher: () => MathFunctionMatcher,
  PositionAnchorMatch: () => PositionAnchorMatch,
  PositionAnchorMatcher: () => PositionAnchorMatcher,
  PositionTryMatch: () => PositionTryMatch,
  PositionTryMatcher: () => PositionTryMatcher,
  RAW_STRING_TYPE: () => RAW_STRING_TYPE,
  RelativeColorChannelMatch: () => RelativeColorChannelMatch,
  RelativeColorChannelMatcher: () => RelativeColorChannelMatcher,
  ShadowMatch: () => ShadowMatch,
  ShadowMatcher: () => ShadowMatcher,
  StringMatch: () => StringMatch,
  StringMatcher: () => StringMatcher,
  TextMatch: () => TextMatch,
  TextMatcher: () => TextMatcher,
  URLMatch: () => URLMatch,
  URLMatcher: () => URLMatcher,
  VariableMatch: () => VariableMatch,
  VariableMatcher: () => VariableMatcher,
  defaultValueForCSSType: () => defaultValueForCSSType,
  isValidCSSType: () => isValidCSSType,
  localEvalCSS: () => localEvalCSS
});
import * as Common6 from "./../common/common.js";
var BaseVariableMatch = class {
  text;
  node;
  name;
  fallback;
  matching;
  computedTextCallback;
  constructor(text, node, name, fallback, matching, computedTextCallback) {
    this.text = text;
    this.node = node;
    this.name = name;
    this.fallback = fallback;
    this.matching = matching;
    this.computedTextCallback = computedTextCallback;
  }
  computedText() {
    return this.computedTextCallback(this, this.matching);
  }
  fallbackValue() {
    if (!this.fallback) {
      return null;
    }
    if (this.fallback.length === 0) {
      return "";
    }
    if (this.matching.hasUnresolvedSubstitutionsRange(this.fallback[0], this.fallback[this.fallback.length - 1])) {
      return null;
    }
    return this.matching.getComputedTextRange(this.fallback[0], this.fallback[this.fallback.length - 1]);
  }
};
var BaseVariableMatcher = class extends matcherBase(BaseVariableMatch) {
  // clang-format on
  #computedTextCallback;
  constructor(computedTextCallback) {
    super();
    this.#computedTextCallback = computedTextCallback;
  }
  matches(node, matching) {
    const callee = node.getChild("Callee");
    if (node.name !== "CallExpression" || !callee || matching.ast.text(callee) !== "var") {
      return null;
    }
    const args = ASTUtils.callArgs(node).map((args2) => Array.from(ASTUtils.stripComments(args2)));
    if (args.length < 1 || args[0].length !== 1) {
      return null;
    }
    const nameNode = args[0][0];
    const fallback = args.length === 2 ? args[1] : void 0;
    if (nameNode?.name !== "VariableName") {
      return null;
    }
    const varName = matching.ast.text(nameNode);
    if (!varName.startsWith("--")) {
      return null;
    }
    return new BaseVariableMatch(matching.ast.text(node), node, varName, fallback, matching, this.#computedTextCallback);
  }
};
var VariableMatch = class extends BaseVariableMatch {
  matchedStyles;
  style;
  constructor(text, node, name, fallback, matching, matchedStyles, style) {
    super(text, node, name, fallback, matching, () => this.resolveVariable()?.value ?? this.fallbackValue());
    this.matchedStyles = matchedStyles;
    this.style = style;
  }
  resolveVariable() {
    return this.matchedStyles.computeCSSVariable(this.style, this.name);
  }
};
var VariableMatcher = class extends matcherBase(VariableMatch) {
  matchedStyles;
  style;
  // clang-format on
  constructor(matchedStyles, style) {
    super();
    this.matchedStyles = matchedStyles;
    this.style = style;
  }
  matches(node, matching) {
    const match = new BaseVariableMatcher(() => null).matches(node, matching);
    return match ? new VariableMatch(match.text, match.node, match.name, match.fallback, match.matching, this.matchedStyles, this.style) : null;
  }
};
var AttributeMatch = class extends BaseVariableMatch {
  type;
  isCSSTokens;
  isValidType;
  rawValue;
  substitutionText;
  matchedStyles;
  style;
  constructor(text, node, name, fallback, matching, type, isCSSTokens, isValidType, rawValue, substitutionText, matchedStyles, style, computedTextCallback) {
    super(text, node, name, fallback, matching, (_, matching2) => computedTextCallback(this, matching2));
    this.type = type;
    this.isCSSTokens = isCSSTokens;
    this.isValidType = isValidType;
    this.rawValue = rawValue;
    this.substitutionText = substitutionText;
    this.matchedStyles = matchedStyles;
    this.style = style;
  }
  rawAttributeValue() {
    return this.rawValue;
  }
  cssType() {
    return this.type ?? RAW_STRING_TYPE;
  }
  resolveAttributeValue() {
    return this.matchedStyles.computeAttribute(this.style, this.name, { type: this.cssType(), isCSSTokens: this.isCSSTokens });
  }
};
var cssEvaluationElement = null;
function getCssEvaluationElement() {
  const id = "css-evaluation-element";
  if (!cssEvaluationElement) {
    cssEvaluationElement = document.getElementById(id);
    if (!cssEvaluationElement) {
      cssEvaluationElement = document.createElement("div");
      cssEvaluationElement.setAttribute("id", id);
      cssEvaluationElement.setAttribute("style", "hidden: true; --evaluation: attr(data-custom-expr type(*))");
      document.body.appendChild(cssEvaluationElement);
    }
  }
  return cssEvaluationElement;
}
function localEvalCSS(value, type) {
  const element = getCssEvaluationElement();
  element.setAttribute("data-value", value);
  element.setAttribute("data-custom-expr", `attr(data-value ${type})`);
  return element.computedStyleMap().get("--evaluation")?.toString() ?? null;
}
function isValidCSSType(type) {
  const element = getCssEvaluationElement();
  element.setAttribute("data-custom-expr", `attr(data-nonexistent ${type}, "good")`);
  return '"good"' === (element.computedStyleMap().get("--evaluation")?.toString() ?? null);
}
function defaultValueForCSSType(type) {
  const element = getCssEvaluationElement();
  element.setAttribute("data-custom-expr", `attr(data-nonexistent ${type ?? ""})`);
  return element.computedStyleMap().get("--evaluation")?.toString() ?? null;
}
var RAW_STRING_TYPE = "raw-string";
var AttributeMatcher = class extends matcherBase(AttributeMatch) {
  matchedStyles;
  style;
  computedTextCallback;
  // clang-format on
  constructor(matchedStyles, style, computedTextCallback) {
    super();
    this.matchedStyles = matchedStyles;
    this.style = style;
    this.computedTextCallback = computedTextCallback;
  }
  matches(node, matching) {
    const callee = node.getChild("Callee");
    if (node.name !== "CallExpression" || !callee || matching.ast.text(callee) !== "attr") {
      return null;
    }
    const args = ASTUtils.callArgs(node).map((args2) => Array.from(ASTUtils.stripComments(args2)));
    if (args.length < 1) {
      return null;
    }
    const nameNode = args[0][0];
    if (args[0].length < 1 || args[0].length > 2 || nameNode?.name !== "ValueName") {
      return null;
    }
    const fallback = args.length === 2 ? args[1] : void 0;
    let type = null;
    let isCSSTokens = false;
    if (args[0].length === 2) {
      const typeNode = args[0][1];
      type = matching.ast.text(typeNode);
      if (typeNode.name === "CallExpression") {
        if (matching.ast.text(typeNode.getChild("Callee")) !== "type") {
          return null;
        }
        isCSSTokens = true;
      } else if (typeNode.name !== "ValueName" && type !== "%") {
        return null;
      }
    }
    const isValidType = type === null || isValidCSSType(type);
    isCSSTokens = isCSSTokens && isValidType;
    const attrName = matching.ast.text(nameNode);
    const rawValue = this.matchedStyles.rawAttributeValueFromStyle(this.style, attrName);
    let substitutionText = null;
    if (rawValue !== null) {
      substitutionText = isCSSTokens ? rawValue : localEvalCSS(rawValue, type ?? RAW_STRING_TYPE);
    } else if (!fallback) {
      substitutionText = defaultValueForCSSType(type);
    }
    return new AttributeMatch(matching.ast.text(node), node, attrName, fallback, matching, type, isCSSTokens, isValidType, rawValue, substitutionText, this.matchedStyles, this.style, this.computedTextCallback ?? defaultComputeText);
    function defaultComputeText(match, _matching) {
      return match.resolveAttributeValue() ?? (isValidType ? match.fallbackValue() : defaultValueForCSSType(match.type));
    }
  }
};
var BinOpMatch = class {
  text;
  node;
  constructor(text, node) {
    this.text = text;
    this.node = node;
  }
};
var BinOpMatcher = class extends matcherBase(BinOpMatch) {
  // clang-format on
  accepts() {
    return true;
  }
  matches(node, matching) {
    return node.name === "BinaryExpression" ? new BinOpMatch(matching.ast.text(node), node) : null;
  }
};
var TextMatch = class {
  text;
  node;
  computedText;
  constructor(text, node) {
    this.text = text;
    this.node = node;
    if (node.name === "Comment") {
      this.computedText = () => "";
    }
  }
  render() {
    const span = document.createElement("span");
    span.appendChild(document.createTextNode(this.text));
    return [span];
  }
};
var TextMatcher = class extends matcherBase(TextMatch) {
  // clang-format on
  accepts() {
    return true;
  }
  matches(node, matching) {
    if (!node.firstChild || node.name === "NumberLiteral") {
      const text = matching.ast.text(node);
      if (text.length) {
        return new TextMatch(text, node);
      }
    }
    return null;
  }
};
var AngleMatch = class {
  text;
  node;
  constructor(text, node) {
    this.text = text;
    this.node = node;
  }
  computedText() {
    return this.text;
  }
};
var AngleMatcher = class extends matcherBase(AngleMatch) {
  // clang-format on
  accepts(propertyName) {
    return cssMetadata().isAngleAwareProperty(propertyName);
  }
  matches(node, matching) {
    if (node.name !== "NumberLiteral") {
      return null;
    }
    const unit = node.getChild("Unit");
    if (!unit || !["deg", "grad", "rad", "turn"].includes(matching.ast.text(unit))) {
      return null;
    }
    return new AngleMatch(matching.ast.text(node), node);
  }
};
function literalToNumber(node, ast) {
  if (node.type.name !== "NumberLiteral") {
    return null;
  }
  const text = ast.text(node);
  return Number(text.substring(0, text.length - ast.text(node.getChild("Unit")).length));
}
var ColorMixMatch = class {
  text;
  node;
  space;
  color1;
  color2;
  constructor(text, node, space, color1, color2) {
    this.text = text;
    this.node = node;
    this.space = space;
    this.color1 = color1;
    this.color2 = color2;
  }
};
var ColorMixMatcher = class extends matcherBase(ColorMixMatch) {
  // clang-format on
  accepts(propertyName) {
    return cssMetadata().isColorAwareProperty(propertyName);
  }
  matches(node, matching) {
    if (node.name !== "CallExpression" || matching.ast.text(node.getChild("Callee")) !== "color-mix") {
      return null;
    }
    const computedValueTree = tokenizeDeclaration("--property", matching.getComputedText(node));
    if (!computedValueTree) {
      return null;
    }
    const value = ASTUtils.declValue(computedValueTree.tree);
    if (!value) {
      return null;
    }
    const computedValueArgs = ASTUtils.callArgs(value);
    if (computedValueArgs.length !== 3) {
      return null;
    }
    const [space, color1, color2] = computedValueArgs;
    if (space.length < 2 || computedValueTree.text(ASTUtils.stripComments(space).next().value) !== "in" || color1.length < 1 || color2.length < 1) {
      return null;
    }
    const p1 = color1.filter((n) => n.type.name === "NumberLiteral" && computedValueTree.text(n.getChild("Unit")) === "%");
    const p2 = color2.filter((n) => n.type.name === "NumberLiteral" && computedValueTree.text(n.getChild("Unit")) === "%");
    if (p1.length > 1 || p2.length > 1) {
      return null;
    }
    if (p1[0] && p2[0] && (literalToNumber(p1[0], computedValueTree) ?? 0) === 0 && (literalToNumber(p2[0], computedValueTree) ?? 0) === 0) {
      return null;
    }
    const args = ASTUtils.callArgs(node);
    if (args.length !== 3) {
      return null;
    }
    return new ColorMixMatch(matching.ast.text(node), node, args[0], args[1], args[2]);
  }
};
var URLMatch = class {
  url;
  text;
  node;
  constructor(url, text, node) {
    this.url = url;
    this.text = text;
    this.node = node;
  }
};
var URLMatcher = class extends matcherBase(URLMatch) {
  // clang-format on
  matches(node, matching) {
    if (node.name !== "CallLiteral") {
      return null;
    }
    const callee = node.getChild("CallTag");
    if (!callee || matching.ast.text(callee) !== "url") {
      return null;
    }
    const [, lparenNode, urlNode, rparenNode] = ASTUtils.siblings(callee);
    if (matching.ast.text(lparenNode) !== "(" || urlNode.name !== "ParenthesizedContent" && urlNode.name !== "StringLiteral" || matching.ast.text(rparenNode) !== ")") {
      return null;
    }
    const text = matching.ast.text(urlNode);
    const url = urlNode.name === "StringLiteral" ? text.substr(1, text.length - 2) : text.trim();
    return new URLMatch(url, matching.ast.text(node), node);
  }
};
var LinearGradientMatch = class {
  text;
  node;
  constructor(text, node) {
    this.text = text;
    this.node = node;
  }
};
var LinearGradientMatcher = class extends matcherBase(LinearGradientMatch) {
  // clang-format on
  matches(node, matching) {
    const text = matching.ast.text(node);
    if (node.name === "CallExpression" && matching.ast.text(node.getChild("Callee")) === "linear-gradient") {
      return new LinearGradientMatch(text, node);
    }
    return null;
  }
  accepts(propertyName) {
    return ["background", "background-image", "-webkit-mask-image"].includes(propertyName);
  }
};
var ColorMatch = class {
  text;
  node;
  currentColorCallback;
  relativeColor;
  computedText;
  constructor(text, node, currentColorCallback, relativeColor) {
    this.text = text;
    this.node = node;
    this.currentColorCallback = currentColorCallback;
    this.relativeColor = relativeColor;
    this.computedText = currentColorCallback;
  }
};
var ColorMatcher = class _ColorMatcher extends matcherBase(ColorMatch) {
  currentColorCallback;
  constructor(currentColorCallback) {
    super();
    this.currentColorCallback = currentColorCallback;
  }
  // clang-format on
  accepts(propertyName) {
    return cssMetadata().isColorAwareProperty(propertyName);
  }
  matches(node, matching) {
    const text = matching.ast.text(node);
    if (node.name === "ColorLiteral") {
      return new ColorMatch(text, node);
    }
    if (node.name === "ValueName") {
      if (Common6.Color.Nicknames.has(text)) {
        return new ColorMatch(text, node);
      }
      if (text.toLowerCase() === "currentcolor" && this.currentColorCallback) {
        const callback = this.currentColorCallback;
        return new ColorMatch(text, node, () => callback() ?? text);
      }
    }
    if (node.name === "CallExpression") {
      const callee = node.getChild("Callee");
      const colorFunc = matching.ast.text(callee).toLowerCase();
      if (callee && colorFunc.match(/^(rgba?|hsla?|hwba?|lab|lch|oklab|oklch|color)$/)) {
        const args = ASTUtils.children(node.getChild("ArgList"));
        const colorText = args.length >= 2 ? matching.getComputedTextRange(args[0], args[args.length - 1]) : "";
        const isRelativeColorSyntax = Boolean(colorText.match(/^[^)]*\(\W*from\W+/) && !matching.hasUnresolvedSubstitutions(node) && CSS.supports("color", colorFunc + colorText));
        if (!isRelativeColorSyntax) {
          return new ColorMatch(text, node);
        }
        const tokenized = matchDeclaration("--color", "--colorFunc" + colorText, [new _ColorMatcher()]);
        if (!tokenized) {
          return null;
        }
        const [colorArgs] = ASTUtils.callArgs(ASTUtils.declValue(tokenized.ast.tree));
        if (colorArgs.length !== (colorFunc === "color" ? 6 : 5)) {
          return null;
        }
        const colorSpace = Common6.Color.getFormat(colorFunc !== "color" ? colorFunc : matching.ast.text(colorArgs[2]));
        if (!colorSpace) {
          return null;
        }
        const baseColor = tokenized.getMatch(colorArgs[1]);
        if (tokenized.ast.text(colorArgs[0]) !== "from" || !(baseColor instanceof ColorMatch)) {
          return null;
        }
        return new ColorMatch(text, node, void 0, { colorSpace, baseColor });
      }
    }
    return null;
  }
};
function isRelativeColorChannelName(channel) {
  const maybeChannel = channel;
  switch (maybeChannel) {
    case "a":
    case "alpha":
    case "b":
    case "c":
    case "g":
    case "h":
    case "l":
    case "r":
    case "s":
    case "w":
    case "x":
    case "y":
    case "z":
      return true;
  }
  const catchFallback = maybeChannel;
  return false;
}
var RelativeColorChannelMatch = class {
  text;
  node;
  constructor(text, node) {
    this.text = text;
    this.node = node;
  }
  getColorChannelValue(relativeColor) {
    const color = Common6.Color.parse(relativeColor.baseColor.text)?.as(relativeColor.colorSpace);
    if (color instanceof Common6.Color.ColorFunction) {
      switch (this.text) {
        case "r":
          return color.isXYZ() ? null : color.p0;
        case "g":
          return color.isXYZ() ? null : color.p1;
        case "b":
          return color.isXYZ() ? null : color.p2;
        case "x":
          return color.isXYZ() ? color.p0 : null;
        case "y":
          return color.isXYZ() ? color.p1 : null;
        case "z":
          return color.isXYZ() ? color.p2 : null;
        case "alpha":
          return color.alpha;
      }
    } else if (color instanceof Common6.Color.Legacy) {
      switch (this.text) {
        case "r":
          return color.rgba()[0];
        case "g":
          return color.rgba()[1];
        case "b":
          return color.rgba()[2];
        case "alpha":
          return color.rgba()[3];
      }
    } else if (color && this.text in color) {
      return color[this.text];
    }
    return null;
  }
  computedText() {
    return this.text;
  }
};
var RelativeColorChannelMatcher = class extends matcherBase(RelativeColorChannelMatch) {
  // clang-format on
  accepts(propertyName) {
    return cssMetadata().isColorAwareProperty(propertyName);
  }
  matches(node, matching) {
    const text = matching.ast.text(node);
    if (node.name === "ValueName" && isRelativeColorChannelName(text)) {
      return new RelativeColorChannelMatch(text, node);
    }
    return null;
  }
};
var LightDarkColorMatch = class {
  text;
  node;
  light;
  dark;
  style;
  constructor(text, node, light, dark, style) {
    this.text = text;
    this.node = node;
    this.light = light;
    this.dark = dark;
    this.style = style;
  }
};
var LightDarkColorMatcher = class extends matcherBase(LightDarkColorMatch) {
  style;
  // clang-format on
  constructor(style) {
    super();
    this.style = style;
  }
  accepts(propertyName) {
    return cssMetadata().isColorAwareProperty(propertyName);
  }
  matches(node, matching) {
    if (node.name !== "CallExpression" || matching.ast.text(node.getChild("Callee")) !== "light-dark") {
      return null;
    }
    const args = ASTUtils.callArgs(node);
    if (args.length !== 2 || args[0].length === 0 || args[1].length === 0) {
      return null;
    }
    return new LightDarkColorMatch(matching.ast.text(node), node, args[0], args[1], this.style);
  }
};
var AutoBaseMatch = class {
  text;
  node;
  auto;
  base;
  constructor(text, node, auto, base) {
    this.text = text;
    this.node = node;
    this.auto = auto;
    this.base = base;
  }
};
var AutoBaseMatcher = class extends matcherBase(AutoBaseMatch) {
  // clang-format on
  matches(node, matching) {
    if (node.name !== "CallExpression" || matching.ast.text(node.getChild("Callee")) !== "-internal-auto-base") {
      return null;
    }
    const args = ASTUtils.callArgs(node);
    if (args.length !== 2 || args[0].length === 0 || args[1].length === 0) {
      return null;
    }
    return new AutoBaseMatch(matching.ast.text(node), node, args[0], args[1]);
  }
};
var LinkableNameMatch = class {
  text;
  node;
  propertyName;
  constructor(text, node, propertyName) {
    this.text = text;
    this.node = node;
    this.propertyName = propertyName;
  }
};
var LinkableNameMatcher = class _LinkableNameMatcher extends matcherBase(LinkableNameMatch) {
  // clang-format on
  static isLinkableNameProperty(propertyName) {
    const names = [
      "animation",
      "animation-name",
      "font-palette",
      "position-try-fallbacks",
      "position-try"
    ];
    return names.includes(propertyName);
  }
  static identifierAnimationLonghandMap = new Map(Object.entries({
    normal: "direction",
    alternate: "direction",
    reverse: "direction",
    "alternate-reverse": "direction",
    none: "fill-mode",
    forwards: "fill-mode",
    backwards: "fill-mode",
    both: "fill-mode",
    running: "play-state",
    paused: "play-state",
    infinite: "iteration-count",
    linear: "easing-function",
    ease: "easing-function",
    "ease-in": "easing-function",
    "ease-out": "easing-function",
    "ease-in-out": "easing-function",
    steps: "easing-function",
    "step-start": "easing-function",
    "step-end": "easing-function"
  }));
  matchAnimationNameInShorthand(node, matching) {
    const text = matching.ast.text(node);
    if (!_LinkableNameMatcher.identifierAnimationLonghandMap.has(text)) {
      return new LinkableNameMatch(
        text,
        node,
        "animation"
        /* LinkableNameProperties.ANIMATION */
      );
    }
    const declarations = ASTUtils.split(ASTUtils.siblings(ASTUtils.declValue(matching.ast.tree)));
    const currentDeclarationNodes = declarations.find((declaration2) => declaration2[0].from <= node.from && declaration2[declaration2.length - 1].to >= node.to);
    if (!currentDeclarationNodes) {
      return null;
    }
    const computedText = matching.getComputedTextRange(currentDeclarationNodes[0], node);
    const tokenized = tokenizeDeclaration("--p", computedText);
    if (!tokenized) {
      return null;
    }
    const identifierCategory = _LinkableNameMatcher.identifierAnimationLonghandMap.get(text);
    for (let itNode = ASTUtils.declValue(tokenized.tree); itNode?.nextSibling; itNode = itNode.nextSibling) {
      if (itNode.name === "ValueName") {
        const categoryValue = _LinkableNameMatcher.identifierAnimationLonghandMap.get(tokenized.text(itNode));
        if (categoryValue && categoryValue === identifierCategory) {
          return new LinkableNameMatch(
            text,
            node,
            "animation"
            /* LinkableNameProperties.ANIMATION */
          );
        }
      }
    }
    return null;
  }
  matches(node, matching) {
    const { propertyName } = matching.ast;
    const text = matching.ast.text(node);
    const parentNode = node.parent;
    if (!parentNode) {
      return null;
    }
    if (!(propertyName && _LinkableNameMatcher.isLinkableNameProperty(propertyName))) {
      return null;
    }
    const isParentADeclaration = parentNode.name === "Declaration";
    const isInsideVarCall = parentNode.name === "ArgList" && parentNode.prevSibling?.name === "Callee" && matching.ast.text(parentNode.prevSibling) === "var";
    const isAParentDeclarationOrVarCall = isParentADeclaration || isInsideVarCall;
    const shouldMatchOnlyVariableName = propertyName === "position-try" || propertyName === "position-try-fallbacks";
    if (!propertyName || node.name !== "ValueName" && node.name !== "VariableName" || !isAParentDeclarationOrVarCall || node.name === "ValueName" && shouldMatchOnlyVariableName) {
      return null;
    }
    if (propertyName === "animation") {
      return this.matchAnimationNameInShorthand(node, matching);
    }
    return new LinkableNameMatch(text, node, propertyName);
  }
};
var BezierMatch = class {
  text;
  node;
  constructor(text, node) {
    this.text = text;
    this.node = node;
  }
};
var BezierMatcher = class extends matcherBase(BezierMatch) {
  // clang-format on
  accepts(propertyName) {
    return cssMetadata().isBezierAwareProperty(propertyName);
  }
  matches(node, matching) {
    const text = matching.ast.text(node);
    const isCubicBezierKeyword = node.name === "ValueName" && CubicBezierKeywordValues.has(text);
    const isCubicBezierOrLinearFunction = node.name === "CallExpression" && ["cubic-bezier", "linear"].includes(matching.ast.text(node.getChild("Callee")));
    if (!isCubicBezierKeyword && !isCubicBezierOrLinearFunction) {
      return null;
    }
    return new BezierMatch(text, node);
  }
};
var StringMatch = class {
  text;
  node;
  constructor(text, node) {
    this.text = text;
    this.node = node;
  }
};
var StringMatcher = class extends matcherBase(StringMatch) {
  // clang-format on
  matches(node, matching) {
    return node.name === "StringLiteral" ? new StringMatch(matching.ast.text(node), node) : null;
  }
};
var ShadowMatch = class {
  text;
  node;
  shadowType;
  constructor(text, node, shadowType) {
    this.text = text;
    this.node = node;
    this.shadowType = shadowType;
  }
};
var ShadowMatcher = class extends matcherBase(ShadowMatch) {
  // clang-format on
  accepts(propertyName) {
    return cssMetadata().isShadowProperty(propertyName);
  }
  matches(node, matching) {
    if (node.name !== "Declaration") {
      return null;
    }
    const valueNodes = ASTUtils.siblings(ASTUtils.declValue(node));
    if (valueNodes.length === 0) {
      return null;
    }
    const valueText = matching.ast.textRange(valueNodes[0], valueNodes[valueNodes.length - 1]);
    return new ShadowMatch(
      valueText,
      node,
      matching.ast.propertyName === "text-shadow" ? "textShadow" : "boxShadow"
      /* ShadowType.BOX_SHADOW */
    );
  }
};
var FontMatch = class {
  text;
  node;
  constructor(text, node) {
    this.text = text;
    this.node = node;
  }
};
var FontMatcher = class extends matcherBase(FontMatch) {
  // clang-format on
  accepts(propertyName) {
    return cssMetadata().isFontAwareProperty(propertyName);
  }
  matches(node, matching) {
    if (node.name !== "Declaration") {
      return null;
    }
    const valueNodes = ASTUtils.siblings(ASTUtils.declValue(node));
    if (valueNodes.length === 0) {
      return null;
    }
    const validNodes = matching.ast.propertyName === "font-family" ? ["ValueName", "StringLiteral", "Comment", ","] : ["Comment", "ValueName", "NumberLiteral"];
    if (valueNodes.some((node2) => !validNodes.includes(node2.name))) {
      return null;
    }
    const valueText = matching.ast.textRange(valueNodes[0], valueNodes[valueNodes.length - 1]);
    return new FontMatch(valueText, node);
  }
};
var LengthMatch = class {
  text;
  node;
  unit;
  constructor(text, node, unit) {
    this.text = text;
    this.node = node;
    this.unit = unit;
  }
};
var LengthMatcher = class _LengthMatcher extends matcherBase(LengthMatch) {
  // clang-format on
  static LENGTH_UNITS = /* @__PURE__ */ new Set([
    "em",
    "ex",
    "ch",
    "cap",
    "ic",
    "lh",
    "rem",
    "rex",
    "rch",
    "rlh",
    "ric",
    "rcap",
    "pt",
    "pc",
    "in",
    "cm",
    "mm",
    "Q",
    "vw",
    "vh",
    "vi",
    "vb",
    "vmin",
    "vmax",
    "dvw",
    "dvh",
    "dvi",
    "dvb",
    "dvmin",
    "dvmax",
    "svw",
    "svh",
    "svi",
    "svb",
    "svmin",
    "svmax",
    "lvw",
    "lvh",
    "lvi",
    "lvb",
    "lvmin",
    "lvmax",
    "cqw",
    "cqh",
    "cqi",
    "cqb",
    "cqmin",
    "cqmax",
    "cqem",
    "cqlh",
    "cqex",
    "cqch",
    "%"
  ]);
  matches(node, matching) {
    if (node.name !== "NumberLiteral") {
      return null;
    }
    const unit = matching.ast.text(node.getChild("Unit"));
    if (!_LengthMatcher.LENGTH_UNITS.has(unit)) {
      return null;
    }
    const text = matching.ast.text(node);
    return new LengthMatch(text, node, unit);
  }
};
var BaseFunctionMatch = class {
  text;
  node;
  func;
  args;
  constructor(text, node, func, args) {
    this.text = text;
    this.node = node;
    this.func = func;
    this.args = args;
  }
};
var MathFunctionMatch = class extends BaseFunctionMatch {
  isArithmeticFunctionCall() {
    const func = this.func;
    switch (func) {
      case "calc":
      case "sibling-count":
      case "sibling-index":
        return true;
    }
    const catchFallback = func;
    return false;
  }
};
var MathFunctionMatcher = class _MathFunctionMatcher extends matcherBase(MathFunctionMatch) {
  // clang-format on
  static getFunctionType(callee) {
    const maybeFunc = callee;
    switch (maybeFunc) {
      case null:
      case "min":
      case "max":
      case "clamp":
      case "calc":
      case "sibling-count":
      case "sibling-index":
        return maybeFunc;
    }
    const catchFallback = maybeFunc;
    return null;
  }
  matches(node, matching) {
    if (node.name !== "CallExpression") {
      return null;
    }
    const callee = _MathFunctionMatcher.getFunctionType(matching.ast.text(node.getChild("Callee")));
    if (!callee) {
      return null;
    }
    const args = ASTUtils.callArgs(node);
    if (args.some((arg) => arg.length === 0 || matching.hasUnresolvedSubstitutionsRange(arg[0], arg[arg.length - 1]))) {
      return null;
    }
    const text = matching.ast.text(node);
    const match = new MathFunctionMatch(text, node, callee, args);
    if (!match.isArithmeticFunctionCall() && args.length === 0) {
      return null;
    }
    return match;
  }
};
var CustomFunctionMatch = class extends BaseFunctionMatch {
};
var CustomFunctionMatcher = class extends matcherBase(CustomFunctionMatch) {
  // clang-format on
  matches(node, matching) {
    if (node.name !== "CallExpression") {
      return null;
    }
    const callee = matching.ast.text(node.getChild("VariableName"));
    if (!callee?.startsWith("--")) {
      return null;
    }
    const args = ASTUtils.callArgs(node);
    if (args.some((arg) => arg.length === 0 || matching.hasUnresolvedSubstitutionsRange(arg[0], arg[arg.length - 1]))) {
      return null;
    }
    const text = matching.ast.text(node);
    return new CustomFunctionMatch(text, node, callee, args);
  }
};
var FlexGridMasonryMatch = class {
  text;
  node;
  layoutType;
  constructor(text, node, layoutType) {
    this.text = text;
    this.node = node;
    this.layoutType = layoutType;
  }
};
var FlexGridMasonryMatcher = class _FlexGridMasonryMatcher extends matcherBase(FlexGridMasonryMatch) {
  // clang-format on
  static FLEX = ["flex", "inline-flex", "block flex", "inline flex"];
  static GRID = ["grid", "inline-grid", "block grid", "inline grid"];
  static MASONRY = ["masonry", "inline-masonry", "block masonry", "inline masonry"];
  accepts(propertyName) {
    return propertyName === "display";
  }
  matches(node, matching) {
    if (node.name !== "Declaration") {
      return null;
    }
    const valueNodes = ASTUtils.siblings(ASTUtils.declValue(node));
    if (valueNodes.length < 1) {
      return null;
    }
    const values = valueNodes.filter((node2) => node2.name !== "Important").map((node2) => matching.getComputedText(node2).trim()).filter((value) => value);
    const text = values.join(" ");
    if (_FlexGridMasonryMatcher.FLEX.includes(text)) {
      return new FlexGridMasonryMatch(
        matching.ast.text(node),
        node,
        "flex"
        /* LayoutType.FLEX */
      );
    }
    if (_FlexGridMasonryMatcher.GRID.includes(text)) {
      return new FlexGridMasonryMatch(
        matching.ast.text(node),
        node,
        "grid"
        /* LayoutType.GRID */
      );
    }
    if (_FlexGridMasonryMatcher.MASONRY.includes(text)) {
      return new FlexGridMasonryMatch(
        matching.ast.text(node),
        node,
        "masonry"
        /* LayoutType.MASONRY */
      );
    }
    return null;
  }
};
var GridTemplateMatch = class {
  text;
  node;
  lines;
  constructor(text, node, lines) {
    this.text = text;
    this.node = node;
    this.lines = lines;
  }
};
var GridTemplateMatcher = class extends matcherBase(GridTemplateMatch) {
  // clang-format on
  accepts(propertyName) {
    return cssMetadata().isGridAreaDefiningProperty(propertyName);
  }
  matches(node, matching) {
    if (node.name !== "Declaration" || matching.hasUnresolvedSubstitutions(node)) {
      return null;
    }
    const lines = [];
    let curLine = [];
    let hasLeadingLineNames = false;
    let needClosingLineNames = false;
    function parseNodes(nodes, varParsingMode = false) {
      for (const curNode of nodes) {
        if (matching.getMatch(curNode) instanceof BaseVariableMatch) {
          const computedValueTree = tokenizeDeclaration("--property", matching.getComputedText(curNode));
          if (!computedValueTree) {
            continue;
          }
          const varNodes = ASTUtils.siblings(ASTUtils.declValue(computedValueTree.tree));
          if (varNodes.length === 0) {
            continue;
          }
          if (varNodes[0].name === "StringLiteral" && !hasLeadingLineNames || varNodes[0].name === "BracketedValue" && !needClosingLineNames) {
            lines.push(curLine);
            curLine = [curNode];
          } else {
            curLine.push(curNode);
          }
          parseNodes(varNodes, true);
        } else if (curNode.name === "BinaryExpression") {
          parseNodes(ASTUtils.siblings(curNode.firstChild));
        } else if (curNode.name === "StringLiteral") {
          if (!varParsingMode) {
            if (hasLeadingLineNames) {
              curLine.push(curNode);
            } else {
              lines.push(curLine);
              curLine = [curNode];
            }
          }
          needClosingLineNames = true;
          hasLeadingLineNames = false;
        } else if (curNode.name === "BracketedValue") {
          if (!varParsingMode) {
            if (needClosingLineNames) {
              curLine.push(curNode);
            } else {
              lines.push(curLine);
              curLine = [curNode];
            }
          }
          hasLeadingLineNames = !needClosingLineNames;
          needClosingLineNames = !needClosingLineNames;
        } else if (!varParsingMode) {
          curLine.push(curNode);
        }
      }
    }
    const valueNodes = ASTUtils.siblings(ASTUtils.declValue(node));
    if (valueNodes.length === 0) {
      return null;
    }
    parseNodes(valueNodes);
    lines.push(curLine);
    const valueText = matching.ast.textRange(valueNodes[0], valueNodes[valueNodes.length - 1]);
    return new GridTemplateMatch(valueText, node, lines.filter((line) => line.length > 0));
  }
};
var AnchorFunctionMatch = class {
  text;
  node;
  functionName;
  constructor(text, node, functionName) {
    this.text = text;
    this.node = node;
    this.functionName = functionName;
  }
};
var AnchorFunctionMatcher = class extends matcherBase(AnchorFunctionMatch) {
  // clang-format on
  anchorFunction(node, matching) {
    if (node.name !== "CallExpression") {
      return null;
    }
    const calleeText = matching.ast.text(node.getChild("Callee"));
    if (calleeText === "anchor" || calleeText === "anchor-size") {
      return calleeText;
    }
    return null;
  }
  matches(node, matching) {
    if (node.name === "VariableName") {
      let parent = node.parent;
      if (!parent || parent.name !== "ArgList") {
        return null;
      }
      parent = parent.parent;
      if (!parent || !this.anchorFunction(parent, matching)) {
        return null;
      }
      return new AnchorFunctionMatch(matching.ast.text(node), node, null);
    }
    const calleeText = this.anchorFunction(node, matching);
    if (!calleeText) {
      return null;
    }
    const args = ASTUtils.children(node.getChild("ArgList"));
    if (calleeText === "anchor" && args.length <= 2) {
      return null;
    }
    if (args.find((arg) => arg.name === "VariableName")) {
      return null;
    }
    return new AnchorFunctionMatch(matching.ast.text(node), node, calleeText);
  }
};
var PositionAnchorMatch = class {
  text;
  matching;
  node;
  constructor(text, matching, node) {
    this.text = text;
    this.matching = matching;
    this.node = node;
  }
};
var PositionAnchorMatcher = class extends matcherBase(PositionAnchorMatch) {
  // clang-format on
  accepts(propertyName) {
    return propertyName === "position-anchor";
  }
  matches(node, matching) {
    if (node.name !== "VariableName") {
      return null;
    }
    const dashedIdentifier = matching.ast.text(node);
    return new PositionAnchorMatch(dashedIdentifier, matching, node);
  }
};
var CSSWideKeywordMatch = class {
  text;
  node;
  property;
  matchedStyles;
  constructor(text, node, property, matchedStyles) {
    this.text = text;
    this.node = node;
    this.property = property;
    this.matchedStyles = matchedStyles;
  }
  resolveProperty() {
    return this.matchedStyles.resolveGlobalKeyword(this.property, this.text);
  }
  computedText() {
    return this.resolveProperty()?.value ?? null;
  }
};
var CSSWideKeywordMatcher = class extends matcherBase(CSSWideKeywordMatch) {
  property;
  matchedStyles;
  // clang-format on
  constructor(property, matchedStyles) {
    super();
    this.property = property;
    this.matchedStyles = matchedStyles;
  }
  matches(node, matching) {
    const parentNode = node.parent;
    if (node.name !== "ValueName" || parentNode?.name !== "Declaration") {
      return null;
    }
    if (Array.from(ASTUtils.stripComments(ASTUtils.siblings(ASTUtils.declValue(parentNode)))).some((child) => !ASTUtils.equals(child, node))) {
      return null;
    }
    const text = matching.ast.text(node);
    if (!CSSMetadata.isCSSWideKeyword(text)) {
      return null;
    }
    return new CSSWideKeywordMatch(text, node, this.property, this.matchedStyles);
  }
};
var PositionTryMatch = class {
  text;
  node;
  preamble;
  fallbacks;
  constructor(text, node, preamble, fallbacks) {
    this.text = text;
    this.node = node;
    this.preamble = preamble;
    this.fallbacks = fallbacks;
  }
};
var PositionTryMatcher = class extends matcherBase(PositionTryMatch) {
  // clang-format on
  accepts(propertyName) {
    return propertyName === "position-try" || propertyName === "position-try-fallbacks";
  }
  matches(node, matching) {
    if (node.name !== "Declaration") {
      return null;
    }
    let preamble = [];
    const valueNodes = ASTUtils.siblings(ASTUtils.declValue(node));
    const fallbacks = ASTUtils.split(valueNodes);
    if (matching.ast.propertyName === "position-try") {
      for (const [i, n] of fallbacks[0].entries()) {
        const computedText = matching.getComputedText(n);
        if (CSSMetadata.isCSSWideKeyword(computedText)) {
          return null;
        }
        if (CSSMetadata.isPositionTryOrderKeyword(computedText)) {
          preamble = fallbacks[0].splice(0, i + 1);
          break;
        }
      }
    }
    const valueText = matching.ast.textRange(valueNodes[0], valueNodes[valueNodes.length - 1]);
    return new PositionTryMatch(valueText, node, preamble, fallbacks);
  }
};
var EnvFunctionMatch = class {
  text;
  node;
  varName;
  value;
  varNameIsValid;
  constructor(text, node, varName, value, varNameIsValid) {
    this.text = text;
    this.node = node;
    this.varName = varName;
    this.value = value;
    this.varNameIsValid = varNameIsValid;
  }
  computedText() {
    return this.value;
  }
};
var EnvFunctionMatcher = class extends matcherBase(EnvFunctionMatch) {
  matchedStyles;
  // clang-format on
  constructor(matchedStyles) {
    super();
    this.matchedStyles = matchedStyles;
  }
  matches(node, matching) {
    if (node.name !== "CallExpression" || matching.ast.text(node.getChild("Callee")) !== "env") {
      return null;
    }
    const [valueNodes, ...fallbackNodes] = ASTUtils.callArgs(node);
    if (!valueNodes?.length) {
      return null;
    }
    const fallbackValue = fallbackNodes.length > 0 ? matching.getComputedTextRange(...ASTUtils.range(fallbackNodes.flat())) : void 0;
    const varName = matching.getComputedTextRange(...ASTUtils.range(valueNodes)).trim();
    const value = this.matchedStyles.environmentVariable(varName);
    return new EnvFunctionMatch(matching.ast.text(node), node, varName, value ?? fallbackValue ?? null, Boolean(value));
  }
};

// gen/front_end/core/sdk/CSSPropertyParser.js
var globalValues = /* @__PURE__ */ new Set(["inherit", "initial", "unset"]);
var tagRegexp = /[\x20-\x7E]{4}/;
var numRegexp = /[+-]?(?:\d*\.)?\d+(?:[eE]\d+)?/;
var fontVariationSettingsRegexp = new RegExp(`(?:'(${tagRegexp.source})')|(?:"(${tagRegexp.source})")\\s+(${numRegexp.source})`);
function parseFontVariationSettings(value) {
  if (globalValues.has(value.trim()) || value.trim() === "normal") {
    return [];
  }
  const results = [];
  for (const setting of splitByComma(stripComments(value))) {
    const match = setting.match(fontVariationSettingsRegexp);
    if (match) {
      results.push({
        tag: match[1] || match[2],
        value: parseFloat(match[3])
      });
    }
  }
  return results;
}
var fontFamilyRegexp = /^"(.+)"|'(.+)'$/;
function parseFontFamily(value) {
  if (globalValues.has(value.trim())) {
    return [];
  }
  const results = [];
  for (const family of splitByComma(stripComments(value))) {
    const match = family.match(fontFamilyRegexp);
    if (match) {
      results.push(match[1] || match[2]);
    } else {
      results.push(family);
    }
  }
  return results;
}
function splitByComma(value) {
  return value.split(",").map((part) => part.trim());
}
function stripComments(value) {
  return value.replaceAll(/(\/\*(?:.|\s)*?\*\/)/g, "");
}
function nodeText(node, text) {
  return nodeTextRange(node, node, text);
}
function nodeTextRange(from, to, text) {
  return text.substring(from.from, to.to);
}
var SyntaxTree = class _SyntaxTree {
  propertyValue;
  rule;
  tree;
  trailingNodes;
  propertyName;
  constructor(propertyValue, rule, tree, propertyName, trailingNodes = []) {
    this.propertyName = propertyName;
    this.propertyValue = propertyValue;
    this.rule = rule;
    this.tree = tree;
    this.trailingNodes = trailingNodes;
  }
  text(node) {
    if (node === null) {
      return "";
    }
    return nodeText(node ?? this.tree, this.rule);
  }
  textRange(from, to) {
    if (!from || !to) {
      return "";
    }
    return nodeTextRange(from, to, this.rule);
  }
  subtree(node) {
    return new _SyntaxTree(this.propertyValue, this.rule, node);
  }
};
var TreeWalker = class {
  ast;
  constructor(ast) {
    this.ast = ast;
  }
  static walkExcludingSuccessors(propertyValue, ...args) {
    const instance = new this(propertyValue, ...args);
    if (propertyValue.tree.name === "Declaration") {
      instance.iterateDeclaration(propertyValue.tree);
    } else {
      instance.iterateExcludingSuccessors(propertyValue.tree);
    }
    return instance;
  }
  static walk(propertyValue, ...args) {
    const instance = new this(propertyValue, ...args);
    if (propertyValue.tree.name === "Declaration") {
      instance.iterateDeclaration(propertyValue.tree);
    } else {
      instance.iterate(propertyValue.tree);
    }
    return instance;
  }
  iterateDeclaration(tree) {
    if (tree.name !== "Declaration") {
      return;
    }
    if (this.enter(tree)) {
      for (const sibling of ASTUtils.siblings(ASTUtils.declValue(tree))) {
        sibling.cursor().iterate(this.enter.bind(this), this.leave.bind(this));
      }
    }
    this.leave(tree);
  }
  iterate(tree) {
    for (const sibling of ASTUtils.siblings(tree)) {
      sibling.cursor().iterate(this.enter.bind(this), this.leave.bind(this));
    }
  }
  iterateExcludingSuccessors(tree) {
    tree.cursor().iterate(this.enter.bind(this), this.leave.bind(this));
  }
  enter(_node) {
    return true;
  }
  leave(_node) {
  }
};
function matcherBase(matchT) {
  class MatcherBase {
    matchType = matchT;
    accepts(_propertyName) {
      return true;
    }
    matches(_node, _matching) {
      return null;
    }
  }
  return MatcherBase;
}
var BottomUpTreeMatching = class extends TreeWalker {
  #matchers = [];
  #matchedNodes = /* @__PURE__ */ new Map();
  computedText;
  #key(node) {
    return `${node.from}:${node.to}`;
  }
  constructor(ast, matchers) {
    super(ast);
    this.computedText = new ComputedText(ast.rule.substring(ast.tree.from));
    this.#matchers.push(...matchers.filter((m) => !ast.propertyName || m.accepts(ast.propertyName)));
    this.#matchers.push(new TextMatcher());
  }
  leave({ node }) {
    for (const matcher of this.#matchers) {
      const match = matcher.matches(node, this);
      if (match) {
        this.computedText.push(match, node.from - this.ast.tree.from);
        this.#matchedNodes.set(this.#key(node), match);
        break;
      }
    }
  }
  matchText(node) {
    const matchers = this.#matchers.splice(0);
    this.#matchers.push(new TextMatcher());
    this.iterateExcludingSuccessors(node);
    this.#matchers.push(...matchers);
  }
  hasMatches(...matchTypes) {
    return Boolean(this.#matchedNodes.values().find((match) => matchTypes.some((matchType) => match instanceof matchType)));
  }
  getMatch(node) {
    return this.#matchedNodes.get(this.#key(node));
  }
  hasUnresolvedSubstitutions(node) {
    return this.hasUnresolvedSubstitutionsRange(node, node);
  }
  hasUnresolvedSubstitutionsRange(from, to) {
    return this.computedText.hasUnresolvedSubstitutions(from.from - this.ast.tree.from, to.to - this.ast.tree.from);
  }
  getComputedText(node, substitutionHook) {
    return this.getComputedTextRange(node, node, substitutionHook);
  }
  getLonghandValuesCount() {
    const [from, to] = ASTUtils.range(ASTUtils.siblings(ASTUtils.declValue(this.ast.tree)));
    if (!from || !to) {
      return 0;
    }
    return this.computedText.countTopLevelValues(from.from - this.ast.tree.from, to.to - this.ast.tree.from);
  }
  getComputedLonghandName(to) {
    const from = ASTUtils.declValue(this.ast.tree) ?? this.ast.tree;
    return this.computedText.countTopLevelValues(from.from - this.ast.tree.from, to.from - this.ast.tree.from);
  }
  getComputedPropertyValueText(substitutionHook) {
    const [from, to] = ASTUtils.range(ASTUtils.siblings(ASTUtils.declValue(this.ast.tree)));
    return this.getComputedTextRange(from ?? this.ast.tree, to ?? this.ast.tree, substitutionHook);
  }
  getComputedTextRange(from, to, substitutionHook) {
    if (!from || !to) {
      return "";
    }
    return this.computedText.get(from.from - this.ast.tree.from, to.to - this.ast.tree.from, substitutionHook);
  }
};
var ComputedTextChunk = class {
  match;
  offset;
  #cachedComputedText = null;
  #topLevelValueCount = null;
  constructor(match, offset) {
    this.match = match;
    this.offset = offset;
  }
  get end() {
    return this.offset + this.length;
  }
  get length() {
    return this.match.text.length;
  }
  get computedText() {
    if (this.#cachedComputedText === null) {
      this.#cachedComputedText = this.match.computedText();
    }
    return this.#cachedComputedText;
  }
  // If the match is top-level, i.e. is an outermost sub-expression in the property value, count the number of outermost
  // sub-expressions after applying any potential substitutions.
  get topLevelValueCount() {
    if (this.match.node.parent?.name !== "Declaration") {
      return 0;
    }
    const computedText = this.computedText;
    if (computedText === "") {
      return 0;
    }
    if (this.#topLevelValueCount === null) {
      this.#topLevelValueCount = ASTUtils.siblings(ASTUtils.declValue(tokenizeDeclaration("--p", computedText ?? this.match.text)?.tree ?? null)).length;
    }
    return this.#topLevelValueCount;
  }
};
var ComputedText = class {
  #chunks = [];
  text;
  #topLevelValueCounts = /* @__PURE__ */ new Map();
  #sorted = true;
  constructor(text) {
    this.text = text;
  }
  clear() {
    this.#chunks.splice(0);
    this.#topLevelValueCounts.clear();
  }
  get chunkCount() {
    return this.#chunks.length;
  }
  #sortIfNecessary() {
    if (this.#sorted) {
      return;
    }
    this.#chunks.sort((a, b) => {
      if (a.offset < b.offset) {
        return -1;
      }
      if (b.offset < a.offset) {
        return 1;
      }
      if (a.end > b.end) {
        return -1;
      }
      if (a.end < b.end) {
        return 1;
      }
      return 0;
    });
    this.#sorted = true;
  }
  // Add another substitutable match. The match will either be appended to the list of existing matches or it will
  // be substituted for the last match(es) if it encompasses them.
  push(match, offset) {
    function hasComputedText(match2) {
      return Boolean(match2.computedText);
    }
    if (!hasComputedText(match) || offset < 0 || offset >= this.text.length) {
      return;
    }
    const chunk = new ComputedTextChunk(match, offset);
    if (chunk.end > this.text.length) {
      return;
    }
    this.#sorted = false;
    this.#chunks.push(chunk);
  }
  *#range(begin, end) {
    this.#sortIfNecessary();
    let i = this.#chunks.findIndex((c) => c.offset >= begin);
    while (i >= 0 && i < this.#chunks.length && this.#chunks[i].end > begin && begin < end) {
      if (this.#chunks[i].end > end) {
        i++;
        continue;
      }
      yield this.#chunks[i];
      begin = this.#chunks[i].end;
      while (begin < end && i < this.#chunks.length && this.#chunks[i].offset < begin) {
        i++;
      }
    }
  }
  hasUnresolvedSubstitutions(begin, end) {
    for (const chunk of this.#range(begin, end)) {
      if (chunk.computedText === null) {
        return true;
      }
    }
    return false;
  }
  *#getPieces(begin, end) {
    for (const chunk of this.#range(begin, end)) {
      const piece = this.text.substring(begin, Math.min(chunk.offset, end));
      yield piece;
      if (end >= chunk.end) {
        yield chunk;
      }
      begin = chunk.end;
    }
    if (begin < end) {
      const piece = this.text.substring(begin, end);
      yield piece;
    }
  }
  // Get a slice of the computed text corresponding to the property text in the range [begin, end). The slice may not
  // start within a substitution chunk, e.g., it's invalid to request the computed text for the property value text
  // slice "1px var(--".
  get(begin, end, substitutionHook) {
    const pieces = [];
    const getText = (piece) => {
      if (typeof piece === "string") {
        return piece;
      }
      const substitution = substitutionHook?.(piece.match) ?? null;
      if (substitution !== null) {
        return getText(substitution);
      }
      return piece.computedText ?? piece.match.text;
    };
    for (const piece of this.#getPieces(begin, end)) {
      const text = getText(piece);
      if (text.length === 0) {
        continue;
      }
      if (pieces.length > 0 && requiresSpace(pieces[pieces.length - 1], text)) {
        pieces.push(" ");
      }
      pieces.push(text);
    }
    return pieces.join("");
  }
  #countTopLevelValuesInStringPiece(piece) {
    let count = this.#topLevelValueCounts.get(piece);
    if (count === void 0) {
      count = ASTUtils.siblings(ASTUtils.declValue(tokenizeDeclaration("--p", piece)?.tree ?? null)).length;
      this.#topLevelValueCounts.set(piece, count);
    }
    return count;
  }
  countTopLevelValues(begin, end) {
    const pieces = Array.from(this.#getPieces(begin, end));
    const counts = pieces.map((chunk) => chunk instanceof ComputedTextChunk ? chunk.topLevelValueCount : this.#countTopLevelValuesInStringPiece(chunk));
    const count = counts.reduce((sum, v) => sum + v, 0);
    return count;
  }
};
function requiresSpace(a, b) {
  const tail = Array.isArray(a) ? a.findLast((node) => node.textContent)?.textContent : a;
  const head = Array.isArray(b) ? b.find((node) => node.textContent)?.textContent : b;
  const trailingChar = tail ? tail[tail.length - 1] : "";
  const leadingChar = head ? head[0] : "";
  const noSpaceAfter = ["", "(", "{", "}", ";", "["];
  const noSpaceBefore = ["", "(", ")", ",", ":", "*", "{", ";", "]"];
  return !/\s/.test(trailingChar) && !/\s/.test(leadingChar) && !noSpaceAfter.includes(trailingChar) && !noSpaceBefore.includes(leadingChar);
}
var CSSControlMap = Map;
var ASTUtils;
(function(ASTUtils2) {
  function siblings(node) {
    const result = [];
    while (node) {
      result.push(node);
      node = node.nextSibling;
    }
    return result;
  }
  ASTUtils2.siblings = siblings;
  function children(node) {
    return siblings(node?.firstChild ?? null);
  }
  ASTUtils2.children = children;
  function range(node) {
    return [node[0], node[node.length - 1]];
  }
  ASTUtils2.range = range;
  function declValue(node) {
    if (node?.name !== "Declaration") {
      return null;
    }
    return children(node).find((node2) => node2.name === ":")?.nextSibling ?? null;
  }
  ASTUtils2.declValue = declValue;
  function* stripComments2(nodes) {
    for (const node of nodes) {
      if (node.type.name !== "Comment") {
        yield node;
      }
    }
  }
  ASTUtils2.stripComments = stripComments2;
  function split(nodes) {
    const result = [];
    let current = [];
    for (const node of nodes) {
      if (node.name === ",") {
        result.push(current);
        current = [];
      } else {
        current.push(node);
      }
    }
    if (nodes.length > 0) {
      result.push(current);
    }
    return result;
  }
  ASTUtils2.split = split;
  function callArgs(node) {
    const args = children(node?.getChild("ArgList") ?? null);
    const openParen = args.splice(0, 1)[0];
    const closingParen = args.pop();
    if (openParen?.name !== "(" || closingParen?.name !== ")") {
      return [];
    }
    return split(args);
  }
  ASTUtils2.callArgs = callArgs;
  function equals(a, b) {
    return a.name === b.name && a.from === b.from && a.to === b.to;
  }
  ASTUtils2.equals = equals;
})(ASTUtils || (ASTUtils = {}));
function declaration(rule) {
  const cssParser = CodeMirror.css.cssLanguage.parser;
  return cssParser.parse(rule).topNode.getChild("RuleSet")?.getChild("Block")?.getChild("Declaration") ?? null;
}
function tokenizeDeclaration(propertyName, propertyValue) {
  const name = tokenizePropertyName(propertyName);
  if (!name) {
    return null;
  }
  const rule = `*{${name}: ${propertyValue};}`;
  const decl = declaration(rule);
  if (!decl || decl.type.isError) {
    return null;
  }
  const childNodes = ASTUtils.children(decl);
  if (childNodes.length < 2) {
    return null;
  }
  const [varName, colon, tree] = childNodes;
  if (!varName || varName.type.isError || !colon || colon.type.isError || tree?.type.isError) {
    return null;
  }
  const trailingNodes = ASTUtils.siblings(decl).slice(1);
  const [semicolon, brace] = trailingNodes.splice(trailingNodes.length - 2, 2);
  if (semicolon?.name !== ";" && brace?.name !== "}") {
    return null;
  }
  const ast = new SyntaxTree(propertyValue, rule, decl, name, trailingNodes);
  if (ast.text(varName) !== name || colon.name !== ":") {
    return null;
  }
  return ast;
}
function tokenizePropertyName(name) {
  const rule = `*{${name}: inherit;}`;
  const decl = declaration(rule);
  if (!decl || decl.type.isError) {
    return null;
  }
  const propertyName = decl.getChild("PropertyName") ?? decl.getChild("VariableName");
  if (!propertyName) {
    return null;
  }
  return nodeText(propertyName, rule);
}
function matchDeclaration(name, value, matchers) {
  const ast = tokenizeDeclaration(name, value);
  const matchedResult = ast && BottomUpTreeMatching.walk(ast, matchers);
  ast?.trailingNodes.forEach((n) => matchedResult?.matchText(n));
  return matchedResult;
}
var TreeSearch = class _TreeSearch extends TreeWalker {
  #found = null;
  #predicate;
  constructor(ast, predicate) {
    super(ast);
    this.#predicate = predicate;
  }
  enter({ node }) {
    if (this.#found) {
      return false;
    }
    if (this.#predicate(node)) {
      this.#found = this.#found ?? node;
      return false;
    }
    return true;
  }
  static find(ast, predicate) {
    return _TreeSearch.walk(ast, predicate).#found;
  }
  static findAll(ast, predicate) {
    const foundNodes = [];
    _TreeSearch.walk(ast, (node) => {
      if (predicate(node)) {
        foundNodes.push(node);
      }
      return false;
    });
    return foundNodes;
  }
};

// gen/front_end/core/sdk/CSSProperty.js
var CSSProperty = class _CSSProperty extends Common7.ObjectWrapper.ObjectWrapper {
  ownerStyle;
  index;
  name;
  value;
  important;
  disabled;
  parsedOk;
  implicit;
  text;
  range;
  #active = true;
  #nameRange = null;
  #valueRange = null;
  #invalidString;
  #longhandProperties = [];
  constructor(ownerStyle, index, name, value, important, disabled, parsedOk, implicit, text, range, longhandProperties) {
    super();
    this.ownerStyle = ownerStyle;
    this.index = index;
    this.name = name;
    this.value = value;
    this.important = important;
    this.disabled = disabled;
    this.parsedOk = parsedOk;
    this.implicit = implicit;
    this.text = text;
    this.range = range ? TextUtils3.TextRange.TextRange.fromObject(range) : null;
    if (longhandProperties && longhandProperties.length > 0) {
      for (const property of longhandProperties) {
        this.#longhandProperties.push(new _CSSProperty(ownerStyle, ++index, property.name, property.value, important, disabled, parsedOk, true));
      }
    } else {
      const longhandNames = cssMetadata().getLonghands(name);
      for (const longhandName of longhandNames || []) {
        this.#longhandProperties.push(new _CSSProperty(ownerStyle, ++index, longhandName, "", important, disabled, parsedOk, true));
      }
    }
  }
  static parsePayload(ownerStyle, index, payload) {
    const result = new _CSSProperty(ownerStyle, index, payload.name, payload.value, payload.important || false, payload.disabled || false, "parsedOk" in payload ? Boolean(payload.parsedOk) : true, Boolean(payload.implicit), payload.text, payload.range, payload.longhandProperties);
    return result;
  }
  parseExpression(expression, matchedStyles, computedStyles) {
    if (!this.parsedOk) {
      return null;
    }
    return matchDeclaration(this.name, expression, this.#matchers(matchedStyles, computedStyles));
  }
  parseValue(matchedStyles, computedStyles) {
    if (!this.parsedOk) {
      return null;
    }
    return matchDeclaration(this.name, this.value, this.#matchers(matchedStyles, computedStyles));
  }
  #matchers(matchedStyles, computedStyles) {
    const matchers = matchedStyles.propertyMatchers(this.ownerStyle, computedStyles);
    matchers.push(new CSSWideKeywordMatcher(this, matchedStyles));
    if (Root3.Runtime.experiments.isEnabled("font-editor")) {
      matchers.push(new FontMatcher());
    }
    return matchers;
  }
  ensureRanges() {
    if (this.#nameRange && this.#valueRange) {
      return;
    }
    const range = this.range;
    const text = this.text ? new TextUtils3.Text.Text(this.text) : null;
    if (!range || !text) {
      return;
    }
    const nameIndex = text.value().indexOf(this.name);
    const valueIndex = text.value().lastIndexOf(this.value);
    if (nameIndex === -1 || valueIndex === -1 || nameIndex > valueIndex) {
      return;
    }
    const nameSourceRange = new TextUtils3.TextRange.SourceRange(nameIndex, this.name.length);
    const valueSourceRange = new TextUtils3.TextRange.SourceRange(valueIndex, this.value.length);
    this.#nameRange = rebase(text.toTextRange(nameSourceRange), range.startLine, range.startColumn);
    this.#valueRange = rebase(text.toTextRange(valueSourceRange), range.startLine, range.startColumn);
    function rebase(oneLineRange, lineOffset, columnOffset) {
      if (oneLineRange.startLine === 0) {
        oneLineRange.startColumn += columnOffset;
        oneLineRange.endColumn += columnOffset;
      }
      oneLineRange.startLine += lineOffset;
      oneLineRange.endLine += lineOffset;
      return oneLineRange;
    }
  }
  nameRange() {
    this.ensureRanges();
    return this.#nameRange;
  }
  valueRange() {
    this.ensureRanges();
    return this.#valueRange;
  }
  rebase(edit) {
    if (this.ownerStyle.styleSheetId !== edit.styleSheetId) {
      return;
    }
    if (this.range) {
      this.range = this.range.rebaseAfterTextEdit(edit.oldRange, edit.newRange);
    }
  }
  setActive(active) {
    this.#active = active;
  }
  get propertyText() {
    if (this.text !== void 0) {
      return this.text;
    }
    if (this.name === "") {
      return "";
    }
    return this.name + ": " + this.value + (this.important ? " !important" : "") + ";";
  }
  activeInStyle() {
    return this.#active;
  }
  async setText(propertyText, majorChange, overwrite) {
    if (!this.ownerStyle) {
      throw new Error("No ownerStyle for property");
    }
    if (!this.ownerStyle.styleSheetId) {
      throw new Error("No owner style id");
    }
    if (!this.range || !this.ownerStyle.range) {
      throw new Error("Style not editable");
    }
    if (majorChange) {
      HostModule.userMetrics.actionTaken(HostModule.UserMetrics.Action.StyleRuleEdited);
      if (this.ownerStyle.parentRule?.isKeyframeRule()) {
        HostModule.userMetrics.actionTaken(HostModule.UserMetrics.Action.StylePropertyInsideKeyframeEdited);
      }
      if (this.name.startsWith("--")) {
        HostModule.userMetrics.actionTaken(HostModule.UserMetrics.Action.CustomPropertyEdited);
      }
    }
    if (overwrite && propertyText === this.propertyText) {
      this.ownerStyle.cssModel().domModel().markUndoableState(!majorChange);
      return true;
    }
    const range = this.range.relativeTo(this.ownerStyle.range.startLine, this.ownerStyle.range.startColumn);
    const indentation = this.ownerStyle.cssText ? this.detectIndentation(this.ownerStyle.cssText) : Common7.Settings.Settings.instance().moduleSetting("text-editor-indent").get();
    const endIndentation = this.ownerStyle.cssText ? indentation.substring(0, this.ownerStyle.range.endColumn) : "";
    const text = new TextUtils3.Text.Text(this.ownerStyle.cssText || "");
    const newStyleText = text.replaceRange(range, Platform4.StringUtilities.sprintf(";%s;", propertyText));
    const styleText = await _CSSProperty.formatStyle(newStyleText, indentation, endIndentation);
    return await this.ownerStyle.setText(styleText, majorChange);
  }
  static async formatStyle(styleText, indentation, endIndentation) {
    const doubleIndent = indentation.substring(endIndentation.length) + indentation;
    if (indentation) {
      indentation = "\n" + indentation;
    }
    let result = "";
    let propertyName = "";
    let propertyText = "";
    let insideProperty = false;
    let needsSemi = false;
    const tokenize = TextUtils3.CodeMirrorUtils.createCssTokenizer();
    await tokenize("*{" + styleText + "}", processToken);
    if (insideProperty) {
      result += propertyText;
    }
    result = result.substring(2, result.length - 1).trimEnd();
    return result + (indentation ? "\n" + endIndentation : "");
    function processToken(token, tokenType) {
      if (!insideProperty) {
        const disabledProperty = tokenType?.includes("comment") && isDisabledProperty(token);
        const isPropertyStart = tokenType?.includes("def") || tokenType?.includes("string") || tokenType?.includes("meta") || tokenType?.includes("property") || tokenType?.includes("variableName") && tokenType !== "variableName.function";
        if (disabledProperty) {
          result = result.trimEnd() + indentation + token;
        } else if (isPropertyStart) {
          insideProperty = true;
          propertyText = token;
        } else if (token !== ";" || needsSemi) {
          result += token;
          if (token.trim() && !tokenType?.includes("comment")) {
            needsSemi = token !== ";";
          }
        }
        if (token === "{" && !tokenType) {
          needsSemi = false;
        }
        return;
      }
      if (token === "}" || token === ";") {
        const trimmedPropertyText = propertyText.trim();
        result = result.trimEnd() + indentation + trimmedPropertyText + (trimmedPropertyText.endsWith(":") ? " " : "") + token;
        needsSemi = false;
        insideProperty = false;
        propertyName = "";
        return;
      }
      if (cssMetadata().isGridAreaDefiningProperty(propertyName)) {
        const rowResult = GridAreaRowRegex.exec(token);
        if (rowResult && rowResult.index === 0 && !propertyText.trimEnd().endsWith("]")) {
          propertyText = propertyText.trimEnd() + "\n" + doubleIndent;
        }
      }
      if (!propertyName && token === ":") {
        propertyName = propertyText;
      }
      propertyText += token;
    }
    function isDisabledProperty(text) {
      const colon = text.indexOf(":");
      if (colon === -1) {
        return false;
      }
      const propertyName2 = text.substring(2, colon).trim();
      return cssMetadata().isCSSPropertyName(propertyName2);
    }
  }
  detectIndentation(text) {
    const lines = text.split("\n");
    if (lines.length < 2) {
      return "";
    }
    return TextUtils3.TextUtils.Utils.lineIndent(lines[1]);
  }
  setValue(newValue, majorChange, overwrite, userCallback) {
    const text = this.name + ": " + newValue + (this.important ? " !important" : "") + ";";
    void this.setText(text, majorChange, overwrite).then(userCallback);
  }
  // Updates the value stored locally and emits an event to signal its update.
  setLocalValue(value) {
    this.value = value;
    this.dispatchEventToListeners(
      "localValueUpdated"
      /* Events.LOCAL_VALUE_UPDATED */
    );
  }
  async setDisabled(disabled) {
    if (!this.ownerStyle) {
      return false;
    }
    if (disabled === this.disabled) {
      return true;
    }
    if (!this.text) {
      return true;
    }
    const propertyText = this.text.trim();
    const appendSemicolonIfMissing = (propertyText2) => propertyText2 + (propertyText2.endsWith(";") ? "" : ";");
    let text;
    if (disabled) {
      text = "/* " + appendSemicolonIfMissing(stripComments(propertyText)) + " */";
    } else {
      text = appendSemicolonIfMissing(this.text.substring(2, propertyText.length - 2).trim());
    }
    return await this.setText(text, true, true);
  }
  /**
   * This stores the warning string when a CSS Property is improperly parsed.
   */
  setDisplayedStringForInvalidProperty(invalidString) {
    this.#invalidString = invalidString;
  }
  /**
   * Retrieve the warning string for a screen reader to announce when editing the property.
   */
  getInvalidStringForInvalidProperty() {
    return this.#invalidString;
  }
  getLonghandProperties() {
    return this.#longhandProperties;
  }
};

// gen/front_end/core/sdk/CSSRule.js
var CSSRule_exports = {};
__export(CSSRule_exports, {
  CSSFontPaletteValuesRule: () => CSSFontPaletteValuesRule,
  CSSFunctionRule: () => CSSFunctionRule,
  CSSKeyframeRule: () => CSSKeyframeRule,
  CSSKeyframesRule: () => CSSKeyframesRule,
  CSSPositionTryRule: () => CSSPositionTryRule,
  CSSPropertyRule: () => CSSPropertyRule,
  CSSRule: () => CSSRule,
  CSSStyleRule: () => CSSStyleRule
});
import * as TextUtils12 from "./../../models/text_utils/text_utils.js";
import * as Platform5 from "./../platform/platform.js";

// gen/front_end/core/sdk/CSSContainerQuery.js
var CSSContainerQuery_exports = {};
__export(CSSContainerQuery_exports, {
  CSSContainerQuery: () => CSSContainerQuery,
  CSSContainerQueryContainer: () => CSSContainerQueryContainer,
  getPhysicalAxisFromQueryAxis: () => getPhysicalAxisFromQueryAxis,
  getQueryAxisFromContainerType: () => getQueryAxisFromContainerType
});
import * as TextUtils5 from "./../../models/text_utils/text_utils.js";

// gen/front_end/core/sdk/CSSQuery.js
var CSSQuery_exports = {};
__export(CSSQuery_exports, {
  CSSQuery: () => CSSQuery
});
var CSSQuery = class {
  text = "";
  range;
  styleSheetId;
  cssModel;
  constructor(cssModel) {
    this.cssModel = cssModel;
  }
  rebase(edit) {
    if (this.styleSheetId !== edit.styleSheetId || !this.range) {
      return;
    }
    if (edit.oldRange.equal(this.range)) {
      this.reinitialize(edit.payload);
    } else {
      this.range = this.range.rebaseAfterTextEdit(edit.oldRange, edit.newRange);
    }
  }
  equal(other) {
    if (!this.styleSheetId || !this.range || !other.range) {
      return false;
    }
    return this.styleSheetId === other.styleSheetId && this.range.equal(other.range);
  }
  lineNumberInSource() {
    if (!this.range) {
      return void 0;
    }
    return this.header()?.lineNumberInSource(this.range.startLine);
  }
  columnNumberInSource() {
    if (!this.range) {
      return void 0;
    }
    return this.header()?.columnNumberInSource(this.range.startLine, this.range.startColumn);
  }
  header() {
    return this.styleSheetId ? this.cssModel.styleSheetHeaderForId(this.styleSheetId) : null;
  }
  rawLocation() {
    const header = this.header();
    if (!header || this.lineNumberInSource() === void 0) {
      return null;
    }
    const lineNumber = Number(this.lineNumberInSource());
    return new CSSLocation(header, lineNumber, this.columnNumberInSource());
  }
};

// gen/front_end/core/sdk/CSSContainerQuery.js
var CSSContainerQuery = class _CSSContainerQuery extends CSSQuery {
  name;
  physicalAxes;
  logicalAxes;
  queriesScrollState;
  queriesAnchored;
  static parseContainerQueriesPayload(cssModel, payload) {
    return payload.map((cq) => new _CSSContainerQuery(cssModel, cq));
  }
  constructor(cssModel, payload) {
    super(cssModel);
    this.reinitialize(payload);
  }
  reinitialize(payload) {
    this.text = payload.text;
    this.range = payload.range ? TextUtils5.TextRange.TextRange.fromObject(payload.range) : null;
    this.styleSheetId = payload.styleSheetId;
    this.name = payload.name;
    this.physicalAxes = payload.physicalAxes;
    this.logicalAxes = payload.logicalAxes;
    this.queriesScrollState = payload.queriesScrollState;
    this.queriesAnchored = payload.queriesAnchored;
  }
  active() {
    return true;
  }
  async getContainerForNode(nodeId) {
    const containerNode = await this.cssModel.domModel().getContainerForNode(nodeId, this.name, this.physicalAxes, this.logicalAxes, this.queriesScrollState, this.queriesAnchored);
    if (!containerNode) {
      return;
    }
    return new CSSContainerQueryContainer(containerNode);
  }
};
var CSSContainerQueryContainer = class {
  containerNode;
  constructor(containerNode) {
    this.containerNode = containerNode;
  }
  async getContainerSizeDetails() {
    const styles = await this.containerNode.domModel().cssModel().getComputedStyle(this.containerNode.id);
    if (!styles) {
      return;
    }
    const containerType = styles.get("container-type");
    const writingMode = styles.get("writing-mode");
    if (!containerType || !writingMode) {
      return;
    }
    const queryAxis = getQueryAxisFromContainerType(`${containerType}`);
    const physicalAxis = getPhysicalAxisFromQueryAxis(queryAxis, writingMode);
    let width, height;
    if (physicalAxis === "Both" || physicalAxis === "Horizontal") {
      width = styles.get("width");
    }
    if (physicalAxis === "Both" || physicalAxis === "Vertical") {
      height = styles.get("height");
    }
    return {
      queryAxis,
      physicalAxis,
      width,
      height
    };
  }
};
var getQueryAxisFromContainerType = (propertyValue) => {
  const segments = propertyValue.split(" ");
  let isInline = false;
  for (const segment of segments) {
    if (segment === "size") {
      return "size";
    }
    isInline = isInline || segment === "inline-size";
  }
  if (isInline) {
    return "inline-size";
  }
  return "";
};
var getPhysicalAxisFromQueryAxis = (queryAxis, writingMode) => {
  const isVerticalWritingMode = writingMode.startsWith("vertical");
  switch (queryAxis) {
    case "":
      return "";
    case "size":
      return "Both";
    case "inline-size":
      return isVerticalWritingMode ? "Vertical" : "Horizontal";
    case "block-size":
      return isVerticalWritingMode ? "Horizontal" : "Vertical";
  }
};

// gen/front_end/core/sdk/CSSLayer.js
var CSSLayer_exports = {};
__export(CSSLayer_exports, {
  CSSLayer: () => CSSLayer
});
import * as TextUtils6 from "./../../models/text_utils/text_utils.js";
var CSSLayer = class _CSSLayer extends CSSQuery {
  static parseLayerPayload(cssModel, payload) {
    return payload.map((supports) => new _CSSLayer(cssModel, supports));
  }
  constructor(cssModel, payload) {
    super(cssModel);
    this.reinitialize(payload);
  }
  reinitialize(payload) {
    this.text = payload.text;
    this.range = payload.range ? TextUtils6.TextRange.TextRange.fromObject(payload.range) : null;
    this.styleSheetId = payload.styleSheetId;
  }
  active() {
    return true;
  }
};

// gen/front_end/core/sdk/CSSMedia.js
var CSSMedia_exports = {};
__export(CSSMedia_exports, {
  CSSMedia: () => CSSMedia,
  CSSMediaQuery: () => CSSMediaQuery,
  CSSMediaQueryExpression: () => CSSMediaQueryExpression,
  Source: () => Source
});
import * as TextUtils7 from "./../../models/text_utils/text_utils.js";
var CSSMediaQuery = class _CSSMediaQuery {
  #active;
  #expressions;
  constructor(payload) {
    this.#active = payload.active;
    this.#expressions = [];
    for (let j = 0; j < payload.expressions.length; ++j) {
      this.#expressions.push(CSSMediaQueryExpression.parsePayload(payload.expressions[j]));
    }
  }
  static parsePayload(payload) {
    return new _CSSMediaQuery(payload);
  }
  active() {
    return this.#active;
  }
  expressions() {
    return this.#expressions;
  }
};
var CSSMediaQueryExpression = class _CSSMediaQueryExpression {
  #value;
  #unit;
  #feature;
  #valueRange;
  #computedLength;
  constructor(payload) {
    this.#value = payload.value;
    this.#unit = payload.unit;
    this.#feature = payload.feature;
    this.#valueRange = payload.valueRange ? TextUtils7.TextRange.TextRange.fromObject(payload.valueRange) : null;
    this.#computedLength = payload.computedLength || null;
  }
  static parsePayload(payload) {
    return new _CSSMediaQueryExpression(payload);
  }
  value() {
    return this.#value;
  }
  unit() {
    return this.#unit;
  }
  feature() {
    return this.#feature;
  }
  valueRange() {
    return this.#valueRange;
  }
  computedLength() {
    return this.#computedLength;
  }
};
var CSSMedia = class _CSSMedia extends CSSQuery {
  source;
  sourceURL;
  mediaList;
  static parseMediaArrayPayload(cssModel, payload) {
    return payload.map((mq) => new _CSSMedia(cssModel, mq));
  }
  constructor(cssModel, payload) {
    super(cssModel);
    this.reinitialize(payload);
  }
  reinitialize(payload) {
    this.text = payload.text;
    this.source = payload.source;
    this.sourceURL = payload.sourceURL || "";
    this.range = payload.range ? TextUtils7.TextRange.TextRange.fromObject(payload.range) : null;
    this.styleSheetId = payload.styleSheetId;
    this.mediaList = null;
    if (payload.mediaList) {
      this.mediaList = [];
      for (let i = 0; i < payload.mediaList.length; ++i) {
        this.mediaList.push(CSSMediaQuery.parsePayload(payload.mediaList[i]));
      }
    }
  }
  active() {
    if (!this.mediaList) {
      return true;
    }
    for (let i = 0; i < this.mediaList.length; ++i) {
      if (this.mediaList[i].active()) {
        return true;
      }
    }
    return false;
  }
};
var Source = {
  LINKED_SHEET: "linkedSheet",
  INLINE_SHEET: "inlineSheet",
  MEDIA_RULE: "mediaRule",
  IMPORT_RULE: "importRule"
};

// gen/front_end/core/sdk/CSSScope.js
var CSSScope_exports = {};
__export(CSSScope_exports, {
  CSSScope: () => CSSScope
});
import * as TextUtils8 from "./../../models/text_utils/text_utils.js";
var CSSScope = class _CSSScope extends CSSQuery {
  static parseScopesPayload(cssModel, payload) {
    return payload.map((scope) => new _CSSScope(cssModel, scope));
  }
  constructor(cssModel, payload) {
    super(cssModel);
    this.reinitialize(payload);
  }
  reinitialize(payload) {
    this.text = payload.text;
    this.range = payload.range ? TextUtils8.TextRange.TextRange.fromObject(payload.range) : null;
    this.styleSheetId = payload.styleSheetId;
  }
  active() {
    return true;
  }
};

// gen/front_end/core/sdk/CSSStartingStyle.js
var CSSStartingStyle_exports = {};
__export(CSSStartingStyle_exports, {
  CSSStartingStyle: () => CSSStartingStyle
});
import * as TextUtils9 from "./../../models/text_utils/text_utils.js";
var CSSStartingStyle = class _CSSStartingStyle extends CSSQuery {
  static parseStartingStylePayload(cssModel, payload) {
    return payload.map((p) => new _CSSStartingStyle(cssModel, p));
  }
  constructor(cssModel, payload) {
    super(cssModel);
    this.reinitialize(payload);
  }
  reinitialize(payload) {
    this.range = payload.range ? TextUtils9.TextRange.TextRange.fromObject(payload.range) : null;
    this.styleSheetId = payload.styleSheetId;
  }
  active() {
    return true;
  }
};

// gen/front_end/core/sdk/CSSStyleDeclaration.js
var CSSStyleDeclaration_exports = {};
__export(CSSStyleDeclaration_exports, {
  CSSStyleDeclaration: () => CSSStyleDeclaration,
  Type: () => Type2
});
import * as TextUtils10 from "./../../models/text_utils/text_utils.js";
var CSSStyleDeclaration = class {
  #cssModel;
  parentRule;
  #allProperties = [];
  styleSheetId;
  range = null;
  cssText;
  #shorthandValues = /* @__PURE__ */ new Map();
  #shorthandIsImportant = /* @__PURE__ */ new Set();
  #activePropertyMap = /* @__PURE__ */ new Map();
  #leadingProperties = null;
  type;
  // For CSSStyles coming from animations,
  // This holds the name of the animation.
  #animationName;
  constructor(cssModel, parentRule, payload, type, animationName) {
    this.#cssModel = cssModel;
    this.parentRule = parentRule;
    this.#reinitialize(payload);
    this.type = type;
    this.#animationName = animationName;
  }
  rebase(edit) {
    if (this.styleSheetId !== edit.styleSheetId || !this.range) {
      return;
    }
    if (edit.oldRange.equal(this.range)) {
      this.#reinitialize(edit.payload);
    } else {
      this.range = this.range.rebaseAfterTextEdit(edit.oldRange, edit.newRange);
      for (let i = 0; i < this.#allProperties.length; ++i) {
        this.#allProperties[i].rebase(edit);
      }
    }
  }
  animationName() {
    return this.#animationName;
  }
  #reinitialize(payload) {
    this.styleSheetId = payload.styleSheetId;
    this.range = payload.range ? TextUtils10.TextRange.TextRange.fromObject(payload.range) : null;
    const shorthandEntries = payload.shorthandEntries;
    this.#shorthandValues = /* @__PURE__ */ new Map();
    this.#shorthandIsImportant = /* @__PURE__ */ new Set();
    for (let i = 0; i < shorthandEntries.length; ++i) {
      this.#shorthandValues.set(shorthandEntries[i].name, shorthandEntries[i].value);
      if (shorthandEntries[i].important) {
        this.#shorthandIsImportant.add(shorthandEntries[i].name);
      }
    }
    this.#allProperties = [];
    if (payload.cssText && this.range) {
      const longhands = [];
      for (const cssProperty of payload.cssProperties) {
        const range = cssProperty.range;
        if (!range) {
          continue;
        }
        const parsedProperty = CSSProperty.parsePayload(this, this.#allProperties.length, cssProperty);
        this.#allProperties.push(parsedProperty);
        for (const longhand of parsedProperty.getLonghandProperties()) {
          longhands.push(longhand);
        }
      }
      for (const longhand of longhands) {
        longhand.index = this.#allProperties.length;
        this.#allProperties.push(longhand);
      }
    } else {
      for (const cssProperty of payload.cssProperties) {
        this.#allProperties.push(CSSProperty.parsePayload(this, this.#allProperties.length, cssProperty));
      }
    }
    this.#generateSyntheticPropertiesIfNeeded();
    this.#computeInactiveProperties();
    this.#activePropertyMap = /* @__PURE__ */ new Map();
    for (const property of this.#allProperties) {
      if (!property.activeInStyle()) {
        continue;
      }
      this.#activePropertyMap.set(property.name, property);
    }
    this.cssText = payload.cssText;
    this.#leadingProperties = null;
  }
  #generateSyntheticPropertiesIfNeeded() {
    if (this.range) {
      return;
    }
    if (!this.#shorthandValues.size) {
      return;
    }
    const propertiesSet = /* @__PURE__ */ new Set();
    for (const property of this.#allProperties) {
      propertiesSet.add(property.name);
    }
    const generatedProperties2 = [];
    for (const property of this.#allProperties) {
      const shorthands = cssMetadata().getShorthands(property.name) || [];
      for (const shorthand of shorthands) {
        if (propertiesSet.has(shorthand)) {
          continue;
        }
        const shorthandValue = this.#shorthandValues.get(shorthand);
        if (!shorthandValue) {
          continue;
        }
        const shorthandImportance = Boolean(this.#shorthandIsImportant.has(shorthand));
        const shorthandProperty = new CSSProperty(this, this.allProperties().length, shorthand, shorthandValue, shorthandImportance, false, true, false);
        generatedProperties2.push(shorthandProperty);
        propertiesSet.add(shorthand);
      }
    }
    this.#allProperties = this.#allProperties.concat(generatedProperties2);
  }
  #computeLeadingProperties() {
    function propertyHasRange(property) {
      return Boolean(property.range);
    }
    if (this.range) {
      return this.#allProperties.filter(propertyHasRange);
    }
    const leadingProperties = [];
    for (const property of this.#allProperties) {
      const shorthands = cssMetadata().getShorthands(property.name) || [];
      let belongToAnyShorthand = false;
      for (const shorthand of shorthands) {
        if (this.#shorthandValues.get(shorthand)) {
          belongToAnyShorthand = true;
          break;
        }
      }
      if (!belongToAnyShorthand) {
        leadingProperties.push(property);
      }
    }
    return leadingProperties;
  }
  leadingProperties() {
    if (!this.#leadingProperties) {
      this.#leadingProperties = this.#computeLeadingProperties();
    }
    return this.#leadingProperties;
  }
  target() {
    return this.#cssModel.target();
  }
  cssModel() {
    return this.#cssModel;
  }
  #computeInactiveProperties() {
    const activeProperties = /* @__PURE__ */ new Map();
    const processedLonghands = /* @__PURE__ */ new Set();
    for (const property of this.#allProperties) {
      const metadata = cssMetadata();
      const canonicalName = metadata.canonicalPropertyName(property.name);
      if (property.disabled || !property.parsedOk) {
        if (!property.disabled && metadata.isCustomProperty(property.name)) {
          activeProperties.get(canonicalName)?.setActive(false);
          activeProperties.delete(canonicalName);
        }
        property.setActive(false);
        continue;
      }
      if (processedLonghands.has(property)) {
        continue;
      }
      for (const longhand of property.getLonghandProperties()) {
        const activeLonghand = activeProperties.get(longhand.name);
        if (!activeLonghand) {
          activeProperties.set(longhand.name, longhand);
        } else if (!activeLonghand.important || longhand.important) {
          activeLonghand.setActive(false);
          activeProperties.set(longhand.name, longhand);
        } else {
          longhand.setActive(false);
        }
        processedLonghands.add(longhand);
      }
      const activeProperty = activeProperties.get(canonicalName);
      if (!activeProperty) {
        activeProperties.set(canonicalName, property);
      } else if (!activeProperty.important || property.important) {
        activeProperty.setActive(false);
        activeProperties.set(canonicalName, property);
      } else {
        property.setActive(false);
      }
    }
  }
  allProperties() {
    return this.#allProperties;
  }
  hasActiveProperty(name) {
    return this.#activePropertyMap.has(name);
  }
  getPropertyValue(name) {
    const property = this.#activePropertyMap.get(name);
    return property ? property.value : "";
  }
  isPropertyImplicit(name) {
    const property = this.#activePropertyMap.get(name);
    return property ? property.implicit : false;
  }
  propertyAt(index) {
    return index < this.allProperties().length ? this.allProperties()[index] : null;
  }
  pastLastSourcePropertyIndex() {
    for (let i = this.allProperties().length - 1; i >= 0; --i) {
      if (this.allProperties()[i].range) {
        return i + 1;
      }
    }
    return 0;
  }
  #insertionRange(index) {
    const property = this.propertyAt(index);
    if (property?.range) {
      return property.range.collapseToStart();
    }
    if (!this.range) {
      throw new Error("CSSStyleDeclaration.range is null");
    }
    return this.range.collapseToEnd();
  }
  newBlankProperty(index) {
    index = typeof index === "undefined" ? this.pastLastSourcePropertyIndex() : index;
    const property = new CSSProperty(this, index, "", "", false, false, true, false, "", this.#insertionRange(index));
    return property;
  }
  setText(text, majorChange) {
    if (!this.range || !this.styleSheetId) {
      return Promise.resolve(false);
    }
    return this.#cssModel.setStyleText(this.styleSheetId, this.range, text, majorChange);
  }
  insertPropertyAt(index, name, value, userCallback) {
    void this.newBlankProperty(index).setText(name + ": " + value + ";", false, true).then(userCallback);
  }
  appendProperty(name, value, userCallback) {
    this.insertPropertyAt(this.allProperties().length, name, value, userCallback);
  }
};
var Type2;
(function(Type3) {
  Type3["Regular"] = "Regular";
  Type3["Inline"] = "Inline";
  Type3["Attributes"] = "Attributes";
  Type3["Pseudo"] = "Pseudo";
  Type3["Transition"] = "Transition";
  Type3["Animation"] = "Animation";
})(Type2 || (Type2 = {}));

// gen/front_end/core/sdk/CSSSupports.js
var CSSSupports_exports = {};
__export(CSSSupports_exports, {
  CSSSupports: () => CSSSupports
});
import * as TextUtils11 from "./../../models/text_utils/text_utils.js";
var CSSSupports = class _CSSSupports extends CSSQuery {
  static parseSupportsPayload(cssModel, payload) {
    return payload.map((supports) => new _CSSSupports(cssModel, supports));
  }
  #active = true;
  constructor(cssModel, payload) {
    super(cssModel);
    this.reinitialize(payload);
  }
  reinitialize(payload) {
    this.text = payload.text;
    this.range = payload.range ? TextUtils11.TextRange.TextRange.fromObject(payload.range) : null;
    this.styleSheetId = payload.styleSheetId;
    this.#active = payload.active;
  }
  active() {
    return this.#active;
  }
};

// gen/front_end/core/sdk/CSSRule.js
function styleSheetHeaderForRule(cssModel, { styleSheetId }) {
  return styleSheetId && cssModel.styleSheetHeaderForId(styleSheetId) || null;
}
var CSSRule = class {
  cssModelInternal;
  origin;
  style;
  header;
  treeScope;
  constructor(cssModel, payload) {
    this.header = payload.header;
    this.cssModelInternal = cssModel;
    this.origin = payload.origin;
    this.treeScope = payload.originTreeScopeNodeId;
    this.style = new CSSStyleDeclaration(this.cssModelInternal, this, payload.style, Type2.Regular);
  }
  get sourceURL() {
    return this.header?.sourceURL;
  }
  rebase(edit) {
    if (this.header?.id !== edit.styleSheetId) {
      return;
    }
    this.style.rebase(edit);
  }
  resourceURL() {
    return this.header?.resourceURL() ?? Platform5.DevToolsPath.EmptyUrlString;
  }
  isUserAgent() {
    return this.origin === "user-agent";
  }
  isInjected() {
    return this.origin === "injected";
  }
  isViaInspector() {
    return this.origin === "inspector";
  }
  isRegular() {
    return this.origin === "regular";
  }
  isKeyframeRule() {
    return false;
  }
  cssModel() {
    return this.cssModelInternal;
  }
};
var CSSValue = class {
  text;
  range;
  specificity;
  constructor(payload) {
    this.text = payload.text;
    if (payload.range) {
      this.range = TextUtils12.TextRange.TextRange.fromObject(payload.range);
    }
    if (payload.specificity) {
      this.specificity = payload.specificity;
    }
  }
  rebase(edit) {
    if (!this.range) {
      return;
    }
    this.range = this.range.rebaseAfterTextEdit(edit.oldRange, edit.newRange);
  }
};
var CSSStyleRule = class _CSSStyleRule extends CSSRule {
  selectors;
  nestingSelectors;
  media;
  containerQueries;
  supports;
  scopes;
  layers;
  ruleTypes;
  startingStyles;
  wasUsed;
  constructor(cssModel, payload, wasUsed) {
    super(cssModel, {
      origin: payload.origin,
      style: payload.style,
      header: styleSheetHeaderForRule(cssModel, payload),
      originTreeScopeNodeId: payload.originTreeScopeNodeId
    });
    this.reinitializeSelectors(payload.selectorList);
    this.nestingSelectors = payload.nestingSelectors;
    this.media = payload.media ? CSSMedia.parseMediaArrayPayload(cssModel, payload.media) : [];
    this.containerQueries = payload.containerQueries ? CSSContainerQuery.parseContainerQueriesPayload(cssModel, payload.containerQueries) : [];
    this.scopes = payload.scopes ? CSSScope.parseScopesPayload(cssModel, payload.scopes) : [];
    this.supports = payload.supports ? CSSSupports.parseSupportsPayload(cssModel, payload.supports) : [];
    this.layers = payload.layers ? CSSLayer.parseLayerPayload(cssModel, payload.layers) : [];
    this.startingStyles = payload.startingStyles ? CSSStartingStyle.parseStartingStylePayload(cssModel, payload.startingStyles) : [];
    this.ruleTypes = payload.ruleTypes || [];
    this.wasUsed = wasUsed || false;
  }
  static createDummyRule(cssModel, selectorText) {
    const dummyPayload = {
      selectorList: {
        text: "",
        selectors: [{ text: selectorText, value: void 0 }]
      },
      style: {
        styleSheetId: "0",
        range: new TextUtils12.TextRange.TextRange(0, 0, 0, 0),
        shorthandEntries: [],
        cssProperties: []
      },
      origin: "inspector"
    };
    return new _CSSStyleRule(cssModel, dummyPayload);
  }
  reinitializeSelectors(selectorList) {
    this.selectors = [];
    for (let i = 0; i < selectorList.selectors.length; ++i) {
      this.selectors.push(new CSSValue(selectorList.selectors[i]));
    }
  }
  setSelectorText(newSelector) {
    const styleSheetId = this.header?.id;
    if (!styleSheetId) {
      throw new Error("No rule stylesheet id");
    }
    const range = this.selectorRange();
    if (!range) {
      throw new Error("Rule selector is not editable");
    }
    return this.cssModelInternal.setSelectorText(styleSheetId, range, newSelector);
  }
  selectorText() {
    return this.selectors.map((selector) => selector.text).join(", ");
  }
  selectorRange() {
    if (this.selectors.length === 0) {
      return null;
    }
    const firstRange = this.selectors[0].range;
    const lastRange = this.selectors[this.selectors.length - 1].range;
    if (!firstRange || !lastRange) {
      return null;
    }
    return new TextUtils12.TextRange.TextRange(firstRange.startLine, firstRange.startColumn, lastRange.endLine, lastRange.endColumn);
  }
  lineNumberInSource(selectorIndex) {
    const selector = this.selectors[selectorIndex];
    if (!selector?.range || !this.header) {
      return 0;
    }
    return this.header.lineNumberInSource(selector.range.startLine);
  }
  columnNumberInSource(selectorIndex) {
    const selector = this.selectors[selectorIndex];
    if (!selector?.range || !this.header) {
      return void 0;
    }
    return this.header.columnNumberInSource(selector.range.startLine, selector.range.startColumn);
  }
  rebase(edit) {
    if (this.header?.id !== edit.styleSheetId) {
      return;
    }
    const range = this.selectorRange();
    if (range?.equal(edit.oldRange)) {
      this.reinitializeSelectors(edit.payload);
    } else {
      for (let i = 0; i < this.selectors.length; ++i) {
        this.selectors[i].rebase(edit);
      }
    }
    this.media.forEach((media) => media.rebase(edit));
    this.containerQueries.forEach((cq) => cq.rebase(edit));
    this.scopes.forEach((scope) => scope.rebase(edit));
    this.supports.forEach((supports) => supports.rebase(edit));
    super.rebase(edit);
  }
};
var CSSPropertyRule = class extends CSSRule {
  #name;
  constructor(cssModel, payload) {
    super(cssModel, {
      origin: payload.origin,
      style: payload.style,
      header: styleSheetHeaderForRule(cssModel, payload),
      originTreeScopeNodeId: void 0
    });
    this.#name = new CSSValue(payload.propertyName);
  }
  propertyName() {
    return this.#name;
  }
  initialValue() {
    return this.style.hasActiveProperty("initial-value") ? this.style.getPropertyValue("initial-value") : null;
  }
  syntax() {
    return this.style.getPropertyValue("syntax");
  }
  inherits() {
    return this.style.getPropertyValue("inherits") === "true";
  }
  setPropertyName(newPropertyName) {
    const styleSheetId = this.header?.id;
    if (!styleSheetId) {
      throw new Error("No rule stylesheet id");
    }
    const range = this.#name.range;
    if (!range) {
      throw new Error("Property name is not editable");
    }
    return this.cssModelInternal.setPropertyRulePropertyName(styleSheetId, range, newPropertyName);
  }
};
var CSSFontPaletteValuesRule = class extends CSSRule {
  #paletteName;
  constructor(cssModel, payload) {
    super(cssModel, {
      origin: payload.origin,
      style: payload.style,
      header: styleSheetHeaderForRule(cssModel, payload),
      originTreeScopeNodeId: void 0
    });
    this.#paletteName = new CSSValue(payload.fontPaletteName);
  }
  name() {
    return this.#paletteName;
  }
};
var CSSKeyframesRule = class {
  #animationName;
  #keyframes;
  constructor(cssModel, payload) {
    this.#animationName = new CSSValue(payload.animationName);
    this.#keyframes = payload.keyframes.map((keyframeRule) => new CSSKeyframeRule(cssModel, keyframeRule, this.#animationName.text));
  }
  name() {
    return this.#animationName;
  }
  keyframes() {
    return this.#keyframes;
  }
};
var CSSKeyframeRule = class extends CSSRule {
  #keyText;
  #parentRuleName;
  constructor(cssModel, payload, parentRuleName) {
    super(cssModel, {
      origin: payload.origin,
      style: payload.style,
      header: styleSheetHeaderForRule(cssModel, payload),
      originTreeScopeNodeId: void 0
    });
    this.reinitializeKey(payload.keyText);
    this.#parentRuleName = parentRuleName;
  }
  parentRuleName() {
    return this.#parentRuleName;
  }
  key() {
    return this.#keyText;
  }
  reinitializeKey(payload) {
    this.#keyText = new CSSValue(payload);
  }
  rebase(edit) {
    if (this.header?.id !== edit.styleSheetId || !this.#keyText.range) {
      return;
    }
    if (edit.oldRange.equal(this.#keyText.range)) {
      this.reinitializeKey(edit.payload);
    } else {
      this.#keyText.rebase(edit);
    }
    super.rebase(edit);
  }
  isKeyframeRule() {
    return true;
  }
  setKeyText(newKeyText) {
    const styleSheetId = this.header?.id;
    if (!styleSheetId) {
      throw new Error("No rule stylesheet id");
    }
    const range = this.#keyText.range;
    if (!range) {
      throw new Error("Keyframe key is not editable");
    }
    return this.cssModelInternal.setKeyframeKey(styleSheetId, range, newKeyText);
  }
};
var CSSPositionTryRule = class extends CSSRule {
  #name;
  #active;
  constructor(cssModel, payload) {
    super(cssModel, {
      origin: payload.origin,
      style: payload.style,
      header: styleSheetHeaderForRule(cssModel, payload),
      originTreeScopeNodeId: void 0
    });
    this.#name = new CSSValue(payload.name);
    this.#active = payload.active;
  }
  name() {
    return this.#name;
  }
  active() {
    return this.#active;
  }
};
var CSSFunctionRule = class extends CSSRule {
  #name;
  #parameters;
  #children;
  constructor(cssModel, payload) {
    super(cssModel, {
      origin: payload.origin,
      style: { cssProperties: [], shorthandEntries: [] },
      header: styleSheetHeaderForRule(cssModel, payload),
      originTreeScopeNodeId: void 0
    });
    this.#name = new CSSValue(payload.name);
    this.#parameters = payload.parameters.map(({ name }) => name);
    this.#children = this.protocolNodesToNestedStyles(payload.children);
  }
  functionName() {
    return this.#name;
  }
  parameters() {
    return this.#parameters;
  }
  children() {
    return this.#children;
  }
  nameWithParameters() {
    return `${this.functionName().text}(${this.parameters().join(", ")})`;
  }
  protocolNodesToNestedStyles(nodes) {
    const result = [];
    for (const node of nodes) {
      const nestedStyle = this.protocolNodeToNestedStyle(node);
      if (nestedStyle) {
        result.push(nestedStyle);
      }
    }
    return result;
  }
  protocolNodeToNestedStyle(node) {
    if (node.style) {
      return { style: new CSSStyleDeclaration(this.cssModelInternal, this, node.style, Type2.Regular) };
    }
    if (node.condition) {
      const children = this.protocolNodesToNestedStyles(node.condition.children);
      if (node.condition.media) {
        return { children, media: new CSSMedia(this.cssModelInternal, node.condition.media) };
      }
      if (node.condition.containerQueries) {
        return {
          children,
          container: new CSSContainerQuery(this.cssModelInternal, node.condition.containerQueries)
        };
      }
      if (node.condition.supports) {
        return {
          children,
          supports: new CSSSupports(this.cssModelInternal, node.condition.supports)
        };
      }
      console.error("A function rule condition must have a media, container, or supports");
      return;
    }
    console.error("A function rule node must have a style or condition");
    return;
  }
};

// gen/front_end/core/sdk/CSSMatchedStyles.js
function containsStyle(styles, query) {
  if (!query.styleSheetId || !query.range) {
    return false;
  }
  for (const style of styles) {
    if (query.styleSheetId === style.styleSheetId && style.range && query.range.equal(style.range)) {
      return true;
    }
  }
  return false;
}
function containsCustomProperties(style) {
  const properties = style.allProperties();
  return properties.some((property) => cssMetadata().isCustomProperty(property.name));
}
function containsInherited(style) {
  const properties = style.allProperties();
  for (let i = 0; i < properties.length; ++i) {
    const property = properties[i];
    if (property.activeInStyle() && cssMetadata().isPropertyInherited(property.name)) {
      return true;
    }
  }
  return false;
}
function cleanUserAgentPayload(payload) {
  for (const ruleMatch of payload) {
    cleanUserAgentSelectors(ruleMatch);
  }
  const cleanMatchedPayload = [];
  for (const ruleMatch of payload) {
    const lastMatch = cleanMatchedPayload[cleanMatchedPayload.length - 1];
    if (!lastMatch || ruleMatch.rule.origin !== "user-agent" || lastMatch.rule.origin !== "user-agent" || ruleMatch.rule.selectorList.text !== lastMatch.rule.selectorList.text || mediaText(ruleMatch) !== mediaText(lastMatch)) {
      cleanMatchedPayload.push(ruleMatch);
      continue;
    }
    mergeRule(ruleMatch, lastMatch);
  }
  return cleanMatchedPayload;
  function mergeRule(from, to) {
    const shorthands = /* @__PURE__ */ new Map();
    const properties = /* @__PURE__ */ new Map();
    for (const entry of to.rule.style.shorthandEntries) {
      shorthands.set(entry.name, entry.value);
    }
    for (const entry of to.rule.style.cssProperties) {
      properties.set(entry.name, entry.value);
    }
    for (const entry of from.rule.style.shorthandEntries) {
      shorthands.set(entry.name, entry.value);
    }
    for (const entry of from.rule.style.cssProperties) {
      properties.set(entry.name, entry.value);
    }
    to.rule.style.shorthandEntries = [...shorthands.entries()].map(([name, value]) => ({ name, value }));
    to.rule.style.cssProperties = [...properties.entries()].map(([name, value]) => ({ name, value }));
  }
  function mediaText(ruleMatch) {
    if (!ruleMatch.rule.media) {
      return null;
    }
    return ruleMatch.rule.media.map((media) => media.text).join(", ");
  }
  function cleanUserAgentSelectors(ruleMatch) {
    const { matchingSelectors, rule } = ruleMatch;
    if (rule.origin !== "user-agent" || !matchingSelectors.length) {
      return;
    }
    rule.selectorList.selectors = rule.selectorList.selectors.filter((_, i) => matchingSelectors.includes(i));
    rule.selectorList.text = rule.selectorList.selectors.map((item) => item.text).join(", ");
    ruleMatch.matchingSelectors = matchingSelectors.map((_, i) => i);
  }
}
function customHighlightNamesToMatchingSelectorIndices(ruleMatch) {
  const highlightNamesToMatchingSelectors = /* @__PURE__ */ new Map();
  for (let i = 0; i < ruleMatch.matchingSelectors.length; i++) {
    const matchingSelectorIndex = ruleMatch.matchingSelectors[i];
    const selectorText = ruleMatch.rule.selectorList.selectors[matchingSelectorIndex].text;
    const highlightNameMatch = selectorText.match(/::highlight\((.*)\)/);
    if (highlightNameMatch) {
      const highlightName = highlightNameMatch[1];
      const selectorsForName = highlightNamesToMatchingSelectors.get(highlightName);
      if (selectorsForName) {
        selectorsForName.push(matchingSelectorIndex);
      } else {
        highlightNamesToMatchingSelectors.set(highlightName, [matchingSelectorIndex]);
      }
    }
  }
  return highlightNamesToMatchingSelectors;
}
function queryMatches(style) {
  if (!style.parentRule) {
    return true;
  }
  const parentRule = style.parentRule;
  const queries = [...parentRule.media, ...parentRule.containerQueries, ...parentRule.supports, ...parentRule.scopes];
  for (const query of queries) {
    if (!query.active()) {
      return false;
    }
  }
  return true;
}
var CSSRegisteredProperty = class {
  #registration;
  #cssModel;
  #style;
  constructor(cssModel, registration) {
    this.#cssModel = cssModel;
    this.#registration = registration;
  }
  propertyName() {
    return this.#registration instanceof CSSPropertyRule ? this.#registration.propertyName().text : this.#registration.propertyName;
  }
  initialValue() {
    return this.#registration instanceof CSSPropertyRule ? this.#registration.initialValue() : this.#registration.initialValue?.text ?? null;
  }
  inherits() {
    return this.#registration instanceof CSSPropertyRule ? this.#registration.inherits() : this.#registration.inherits;
  }
  syntax() {
    return this.#registration instanceof CSSPropertyRule ? this.#registration.syntax() : `"${this.#registration.syntax}"`;
  }
  parseValue(matchedStyles, computedStyles) {
    const value = this.initialValue();
    if (!value) {
      return null;
    }
    return matchDeclaration(this.propertyName(), value, matchedStyles.propertyMatchers(this.style(), computedStyles));
  }
  #asCSSProperties() {
    if (this.#registration instanceof CSSPropertyRule) {
      return [];
    }
    const { inherits, initialValue, syntax } = this.#registration;
    const properties = [
      { name: "inherits", value: `${inherits}` },
      { name: "syntax", value: `"${syntax}"` }
    ];
    if (initialValue !== void 0) {
      properties.push({ name: "initial-value", value: initialValue.text });
    }
    return properties;
  }
  style() {
    if (!this.#style) {
      this.#style = this.#registration instanceof CSSPropertyRule ? this.#registration.style : new CSSStyleDeclaration(this.#cssModel, null, { cssProperties: this.#asCSSProperties(), shorthandEntries: [] }, Type2.Pseudo);
    }
    return this.#style;
  }
};
var CSSMatchedStyles = class _CSSMatchedStyles {
  #cssModel;
  #node;
  #addedStyles = /* @__PURE__ */ new Map();
  #matchingSelectors = /* @__PURE__ */ new Map();
  #keyframes = [];
  #registeredProperties;
  #registeredPropertyMap = /* @__PURE__ */ new Map();
  #nodeForStyle = /* @__PURE__ */ new Map();
  #inheritedStyles = /* @__PURE__ */ new Set();
  #styleToDOMCascade = /* @__PURE__ */ new Map();
  #parentLayoutNodeId;
  #positionTryRules;
  #activePositionFallbackIndex;
  #mainDOMCascade;
  #pseudoDOMCascades;
  #customHighlightPseudoDOMCascades;
  #functionRules;
  #functionRuleMap = /* @__PURE__ */ new Map();
  #fontPaletteValuesRule;
  #environmentVariables = {};
  static async create(payload) {
    const cssMatchedStyles = new _CSSMatchedStyles(payload);
    await cssMatchedStyles.init(payload);
    return cssMatchedStyles;
  }
  constructor({ cssModel, node, animationsPayload, parentLayoutNodeId, positionTryRules, propertyRules, cssPropertyRegistrations, fontPaletteValuesRule, activePositionFallbackIndex, functionRules }) {
    this.#cssModel = cssModel;
    this.#node = node;
    this.#registeredProperties = [
      ...propertyRules.map((rule) => new CSSPropertyRule(cssModel, rule)),
      ...cssPropertyRegistrations
    ].map((r) => new CSSRegisteredProperty(cssModel, r));
    if (animationsPayload) {
      this.#keyframes = animationsPayload.map((rule) => new CSSKeyframesRule(cssModel, rule));
    }
    this.#positionTryRules = positionTryRules.map((rule) => new CSSPositionTryRule(cssModel, rule));
    this.#parentLayoutNodeId = parentLayoutNodeId;
    this.#fontPaletteValuesRule = fontPaletteValuesRule ? new CSSFontPaletteValuesRule(cssModel, fontPaletteValuesRule) : void 0;
    this.#activePositionFallbackIndex = activePositionFallbackIndex;
    this.#functionRules = functionRules.map((rule) => new CSSFunctionRule(cssModel, rule));
  }
  async init({ matchedPayload, inheritedPayload, inlinePayload, attributesPayload, pseudoPayload, inheritedPseudoPayload, animationStylesPayload, transitionsStylePayload, inheritedAnimatedPayload }) {
    matchedPayload = cleanUserAgentPayload(matchedPayload);
    for (const inheritedResult of inheritedPayload) {
      inheritedResult.matchedCSSRules = cleanUserAgentPayload(inheritedResult.matchedCSSRules);
    }
    this.#environmentVariables = await this.cssModel().getEnvironmentVariables();
    this.#mainDOMCascade = await this.buildMainCascade(inlinePayload, attributesPayload, matchedPayload, inheritedPayload, animationStylesPayload, transitionsStylePayload, inheritedAnimatedPayload);
    [this.#pseudoDOMCascades, this.#customHighlightPseudoDOMCascades] = this.buildPseudoCascades(pseudoPayload, inheritedPseudoPayload);
    for (const domCascade of Array.from(this.#customHighlightPseudoDOMCascades.values()).concat(Array.from(this.#pseudoDOMCascades.values())).concat(this.#mainDOMCascade)) {
      for (const style of domCascade.styles()) {
        this.#styleToDOMCascade.set(style, domCascade);
      }
    }
    for (const prop of this.#registeredProperties) {
      this.#registeredPropertyMap.set(prop.propertyName(), prop);
    }
    for (const rule of this.#functionRules) {
      this.#functionRuleMap.set(rule.functionName().text, rule);
    }
  }
  async buildMainCascade(inlinePayload, attributesPayload, matchedPayload, inheritedPayload, animationStylesPayload, transitionsStylePayload, inheritedAnimatedPayload) {
    const nodeCascades = [];
    const nodeStyles = [];
    function addAttributesStyle() {
      if (!attributesPayload) {
        return;
      }
      const style = new CSSStyleDeclaration(this.#cssModel, null, attributesPayload, Type2.Attributes);
      this.#nodeForStyle.set(style, this.#node);
      nodeStyles.push(style);
    }
    if (transitionsStylePayload) {
      const style = new CSSStyleDeclaration(this.#cssModel, null, transitionsStylePayload, Type2.Transition);
      this.#nodeForStyle.set(style, this.#node);
      nodeStyles.push(style);
    }
    for (const animationsStyle of animationStylesPayload) {
      const style = new CSSStyleDeclaration(this.#cssModel, null, animationsStyle.style, Type2.Animation, animationsStyle.name);
      this.#nodeForStyle.set(style, this.#node);
      nodeStyles.push(style);
    }
    if (inlinePayload && this.#node.nodeType() === Node.ELEMENT_NODE) {
      const style = new CSSStyleDeclaration(this.#cssModel, null, inlinePayload, Type2.Inline);
      this.#nodeForStyle.set(style, this.#node);
      nodeStyles.push(style);
    }
    let addedAttributesStyle;
    for (let i = matchedPayload.length - 1; i >= 0; --i) {
      const rule = new CSSStyleRule(this.#cssModel, matchedPayload[i].rule);
      if ((rule.isInjected() || rule.isUserAgent()) && !addedAttributesStyle) {
        addedAttributesStyle = true;
        addAttributesStyle.call(this);
      }
      this.#nodeForStyle.set(rule.style, this.#node);
      nodeStyles.push(rule.style);
      this.addMatchingSelectors(this.#node, rule, matchedPayload[i].matchingSelectors);
    }
    if (!addedAttributesStyle) {
      addAttributesStyle.call(this);
    }
    nodeCascades.push(new NodeCascade(
      this,
      nodeStyles,
      this.#node,
      false
      /* #isInherited */
    ));
    let parentNode = this.#node.parentNode;
    const traverseParentInFlatTree = async (node) => {
      if (node.hasAssignedSlot()) {
        return await node.assignedSlot?.deferredNode.resolvePromise() ?? null;
      }
      return node.parentNode;
    };
    for (let i = 0; parentNode && inheritedPayload && i < inheritedPayload.length; ++i) {
      const inheritedStyles = [];
      const entryPayload = inheritedPayload[i];
      const inheritedAnimatedEntryPayload = inheritedAnimatedPayload[i];
      const inheritedInlineStyle = entryPayload.inlineStyle ? new CSSStyleDeclaration(this.#cssModel, null, entryPayload.inlineStyle, Type2.Inline) : null;
      const inheritedTransitionsStyle = inheritedAnimatedEntryPayload?.transitionsStyle ? new CSSStyleDeclaration(this.#cssModel, null, inheritedAnimatedEntryPayload?.transitionsStyle, Type2.Transition) : null;
      const inheritedAnimationStyles = inheritedAnimatedEntryPayload?.animationStyles?.map((animationStyle) => new CSSStyleDeclaration(this.#cssModel, null, animationStyle.style, Type2.Animation, animationStyle.name)) ?? [];
      if (inheritedTransitionsStyle && containsInherited(inheritedTransitionsStyle)) {
        this.#nodeForStyle.set(inheritedTransitionsStyle, parentNode);
        inheritedStyles.push(inheritedTransitionsStyle);
        this.#inheritedStyles.add(inheritedTransitionsStyle);
      }
      for (const inheritedAnimationsStyle of inheritedAnimationStyles) {
        if (!containsInherited(inheritedAnimationsStyle)) {
          continue;
        }
        this.#nodeForStyle.set(inheritedAnimationsStyle, parentNode);
        inheritedStyles.push(inheritedAnimationsStyle);
        this.#inheritedStyles.add(inheritedAnimationsStyle);
      }
      if (inheritedInlineStyle && containsInherited(inheritedInlineStyle)) {
        this.#nodeForStyle.set(inheritedInlineStyle, parentNode);
        inheritedStyles.push(inheritedInlineStyle);
        this.#inheritedStyles.add(inheritedInlineStyle);
      }
      const inheritedMatchedCSSRules = entryPayload.matchedCSSRules || [];
      for (let j = inheritedMatchedCSSRules.length - 1; j >= 0; --j) {
        const inheritedRule = new CSSStyleRule(this.#cssModel, inheritedMatchedCSSRules[j].rule);
        this.addMatchingSelectors(parentNode, inheritedRule, inheritedMatchedCSSRules[j].matchingSelectors);
        if (!containsInherited(inheritedRule.style)) {
          continue;
        }
        if (!containsCustomProperties(inheritedRule.style)) {
          if (containsStyle(nodeStyles, inheritedRule.style) || containsStyle(this.#inheritedStyles, inheritedRule.style)) {
            continue;
          }
        }
        this.#nodeForStyle.set(inheritedRule.style, parentNode);
        inheritedStyles.push(inheritedRule.style);
        this.#inheritedStyles.add(inheritedRule.style);
      }
      const node = parentNode;
      parentNode = await traverseParentInFlatTree(parentNode);
      nodeCascades.push(new NodeCascade(
        this,
        inheritedStyles,
        node,
        true
        /* #isInherited */
      ));
    }
    return new DOMInheritanceCascade(this, nodeCascades, this.#registeredProperties);
  }
  /**
   * Pseudo rule matches received via the inspector protocol are grouped by pseudo type.
   * For custom highlight pseudos, we need to instead group the rule matches by highlight
   * name in order to produce separate cascades for each highlight name. This is necessary
   * so that styles of ::highlight(foo) are not shown as overriding styles of ::highlight(bar).
   *
   * This helper function takes a list of rule matches and generates separate NodeCascades
   * for each custom highlight name that was matched.
   */
  buildSplitCustomHighlightCascades(rules, node, isInherited, pseudoCascades) {
    const splitHighlightRules = /* @__PURE__ */ new Map();
    for (let j = rules.length - 1; j >= 0; --j) {
      const highlightNamesToMatchingSelectorIndices = customHighlightNamesToMatchingSelectorIndices(rules[j]);
      for (const [highlightName, matchingSelectors] of highlightNamesToMatchingSelectorIndices) {
        const pseudoRule = new CSSStyleRule(this.#cssModel, rules[j].rule);
        this.#nodeForStyle.set(pseudoRule.style, node);
        if (isInherited) {
          this.#inheritedStyles.add(pseudoRule.style);
        }
        this.addMatchingSelectors(node, pseudoRule, matchingSelectors);
        const ruleListForHighlightName = splitHighlightRules.get(highlightName);
        if (ruleListForHighlightName) {
          ruleListForHighlightName.push(pseudoRule.style);
        } else {
          splitHighlightRules.set(highlightName, [pseudoRule.style]);
        }
      }
    }
    for (const [highlightName, highlightStyles] of splitHighlightRules) {
      const nodeCascade = new NodeCascade(
        this,
        highlightStyles,
        node,
        isInherited,
        true
        /* #isHighlightPseudoCascade*/
      );
      const cascadeListForHighlightName = pseudoCascades.get(highlightName);
      if (cascadeListForHighlightName) {
        cascadeListForHighlightName.push(nodeCascade);
      } else {
        pseudoCascades.set(highlightName, [nodeCascade]);
      }
    }
  }
  buildPseudoCascades(pseudoPayload, inheritedPseudoPayload) {
    const pseudoInheritanceCascades = /* @__PURE__ */ new Map();
    const customHighlightPseudoInheritanceCascades = /* @__PURE__ */ new Map();
    if (!pseudoPayload) {
      return [pseudoInheritanceCascades, customHighlightPseudoInheritanceCascades];
    }
    const pseudoCascades = /* @__PURE__ */ new Map();
    const customHighlightPseudoCascades = /* @__PURE__ */ new Map();
    for (let i = 0; i < pseudoPayload.length; ++i) {
      const entryPayload = pseudoPayload[i];
      const pseudoElement = this.#node.pseudoElements().get(entryPayload.pseudoType)?.at(-1) || null;
      const pseudoStyles = [];
      const rules = entryPayload.matches || [];
      if (entryPayload.pseudoType === "highlight") {
        this.buildSplitCustomHighlightCascades(rules, this.#node, false, customHighlightPseudoCascades);
      } else {
        for (let j = rules.length - 1; j >= 0; --j) {
          const pseudoRule = new CSSStyleRule(this.#cssModel, rules[j].rule);
          pseudoStyles.push(pseudoRule.style);
          const nodeForStyle = cssMetadata().isHighlightPseudoType(entryPayload.pseudoType) ? this.#node : pseudoElement;
          this.#nodeForStyle.set(pseudoRule.style, nodeForStyle);
          if (nodeForStyle) {
            this.addMatchingSelectors(nodeForStyle, pseudoRule, rules[j].matchingSelectors);
          }
        }
        const isHighlightPseudoCascade = cssMetadata().isHighlightPseudoType(entryPayload.pseudoType);
        const nodeCascade = new NodeCascade(
          this,
          pseudoStyles,
          this.#node,
          false,
          isHighlightPseudoCascade
          /* #isHighlightPseudoCascade*/
        );
        pseudoCascades.set(entryPayload.pseudoType, [nodeCascade]);
      }
    }
    if (inheritedPseudoPayload) {
      let parentNode = this.#node.parentNode;
      for (let i = 0; parentNode && i < inheritedPseudoPayload.length; ++i) {
        const inheritedPseudoMatches = inheritedPseudoPayload[i].pseudoElements;
        for (let j = 0; j < inheritedPseudoMatches.length; ++j) {
          const inheritedEntryPayload = inheritedPseudoMatches[j];
          const rules = inheritedEntryPayload.matches || [];
          if (inheritedEntryPayload.pseudoType === "highlight") {
            this.buildSplitCustomHighlightCascades(rules, parentNode, true, customHighlightPseudoCascades);
          } else {
            const pseudoStyles = [];
            for (let k = rules.length - 1; k >= 0; --k) {
              const pseudoRule = new CSSStyleRule(this.#cssModel, rules[k].rule);
              pseudoStyles.push(pseudoRule.style);
              this.#nodeForStyle.set(pseudoRule.style, parentNode);
              this.#inheritedStyles.add(pseudoRule.style);
              this.addMatchingSelectors(parentNode, pseudoRule, rules[k].matchingSelectors);
            }
            const isHighlightPseudoCascade = cssMetadata().isHighlightPseudoType(inheritedEntryPayload.pseudoType);
            const nodeCascade = new NodeCascade(
              this,
              pseudoStyles,
              parentNode,
              true,
              isHighlightPseudoCascade
              /* #isHighlightPseudoCascade*/
            );
            const cascadeListForPseudoType = pseudoCascades.get(inheritedEntryPayload.pseudoType);
            if (cascadeListForPseudoType) {
              cascadeListForPseudoType.push(nodeCascade);
            } else {
              pseudoCascades.set(inheritedEntryPayload.pseudoType, [nodeCascade]);
            }
          }
        }
        parentNode = parentNode.parentNode;
      }
    }
    for (const [pseudoType, nodeCascade] of pseudoCascades.entries()) {
      pseudoInheritanceCascades.set(pseudoType, new DOMInheritanceCascade(this, nodeCascade, this.#registeredProperties));
    }
    for (const [highlightName, nodeCascade] of customHighlightPseudoCascades.entries()) {
      customHighlightPseudoInheritanceCascades.set(highlightName, new DOMInheritanceCascade(this, nodeCascade, this.#registeredProperties));
    }
    return [pseudoInheritanceCascades, customHighlightPseudoInheritanceCascades];
  }
  addMatchingSelectors(node, rule, matchingSelectorIndices) {
    for (const matchingSelectorIndex of matchingSelectorIndices) {
      const selector = rule.selectors[matchingSelectorIndex];
      if (selector) {
        this.setSelectorMatches(node, selector.text, true);
      }
    }
  }
  node() {
    return this.#node;
  }
  cssModel() {
    return this.#cssModel;
  }
  hasMatchingSelectors(rule) {
    return (rule.selectors.length === 0 || this.getMatchingSelectors(rule).length > 0) && queryMatches(rule.style);
  }
  getParentLayoutNodeId() {
    return this.#parentLayoutNodeId;
  }
  getMatchingSelectors(rule) {
    const node = this.nodeForStyle(rule.style);
    if (!node || typeof node.id !== "number") {
      return [];
    }
    const map = this.#matchingSelectors.get(node.id);
    if (!map) {
      return [];
    }
    const result = [];
    for (let i = 0; i < rule.selectors.length; ++i) {
      if (map.get(rule.selectors[i].text)) {
        result.push(i);
      }
    }
    return result;
  }
  async recomputeMatchingSelectors(rule) {
    const node = this.nodeForStyle(rule.style);
    if (!node) {
      return;
    }
    const promises = [];
    for (const selector of rule.selectors) {
      promises.push(querySelector.call(this, node, selector.text));
    }
    await Promise.all(promises);
    async function querySelector(node2, selectorText) {
      const ownerDocument = node2.ownerDocument;
      if (!ownerDocument) {
        return;
      }
      if (typeof node2.id === "number") {
        const map = this.#matchingSelectors.get(node2.id);
        if (map?.has(selectorText)) {
          return;
        }
      }
      if (typeof ownerDocument.id !== "number") {
        return;
      }
      const matchingNodeIds = await this.#node.domModel().querySelectorAll(ownerDocument.id, selectorText);
      if (matchingNodeIds) {
        if (typeof node2.id === "number") {
          this.setSelectorMatches(node2, selectorText, matchingNodeIds.indexOf(node2.id) !== -1);
        } else {
          this.setSelectorMatches(node2, selectorText, false);
        }
      }
    }
  }
  addNewRule(rule, node) {
    this.#addedStyles.set(rule.style, node);
    return this.recomputeMatchingSelectors(rule);
  }
  setSelectorMatches(node, selectorText, value) {
    if (typeof node.id !== "number") {
      return;
    }
    let map = this.#matchingSelectors.get(node.id);
    if (!map) {
      map = /* @__PURE__ */ new Map();
      this.#matchingSelectors.set(node.id, map);
    }
    map.set(selectorText, value);
  }
  nodeStyles() {
    Platform6.assertNotNullOrUndefined(this.#mainDOMCascade);
    return this.#mainDOMCascade.styles();
  }
  inheritedStyles() {
    return this.#mainDOMCascade?.styles().filter((style) => this.isInherited(style)) ?? [];
  }
  animationStyles() {
    return this.#mainDOMCascade?.styles().filter((style) => !this.isInherited(style) && style.type === Type2.Animation) ?? [];
  }
  transitionsStyle() {
    return this.#mainDOMCascade?.styles().find((style) => !this.isInherited(style) && style.type === Type2.Transition) ?? null;
  }
  registeredProperties() {
    return this.#registeredProperties;
  }
  getRegisteredProperty(name) {
    return this.#registeredPropertyMap.get(name);
  }
  getRegisteredFunction(name) {
    const functionRule = this.#functionRuleMap.get(name);
    return functionRule ? functionRule.nameWithParameters() : void 0;
  }
  functionRules() {
    return this.#functionRules;
  }
  fontPaletteValuesRule() {
    return this.#fontPaletteValuesRule;
  }
  keyframes() {
    return this.#keyframes;
  }
  positionTryRules() {
    return this.#positionTryRules;
  }
  activePositionFallbackIndex() {
    return this.#activePositionFallbackIndex;
  }
  pseudoStyles(pseudoType) {
    Platform6.assertNotNullOrUndefined(this.#pseudoDOMCascades);
    const domCascade = this.#pseudoDOMCascades.get(pseudoType);
    return domCascade ? domCascade.styles() : [];
  }
  pseudoTypes() {
    Platform6.assertNotNullOrUndefined(this.#pseudoDOMCascades);
    return new Set(this.#pseudoDOMCascades.keys());
  }
  customHighlightPseudoStyles(highlightName) {
    Platform6.assertNotNullOrUndefined(this.#customHighlightPseudoDOMCascades);
    const domCascade = this.#customHighlightPseudoDOMCascades.get(highlightName);
    return domCascade ? domCascade.styles() : [];
  }
  customHighlightPseudoNames() {
    Platform6.assertNotNullOrUndefined(this.#customHighlightPseudoDOMCascades);
    return new Set(this.#customHighlightPseudoDOMCascades.keys());
  }
  nodeForStyle(style) {
    return this.#addedStyles.get(style) || this.#nodeForStyle.get(style) || null;
  }
  availableCSSVariables(style) {
    const domCascade = this.#styleToDOMCascade.get(style);
    return domCascade ? domCascade.findAvailableCSSVariables(style) : [];
  }
  computeCSSVariable(style, variableName) {
    if (style.parentRule instanceof CSSKeyframeRule) {
      const keyframeName = style.parentRule.parentRuleName();
      const activeStyle = this.#mainDOMCascade?.styles().find((searchStyle) => {
        return searchStyle.allProperties().some(
          (property) => property.name === "animation-name" && property.value === keyframeName && this.#mainDOMCascade?.propertyState(property) === "Active"
          /* PropertyState.ACTIVE */
        );
      });
      if (!activeStyle) {
        return null;
      }
      style = activeStyle;
    }
    const domCascade = this.#styleToDOMCascade.get(style);
    return domCascade ? domCascade.computeCSSVariable(style, variableName) : null;
  }
  computeAttribute(style, attributeName, type) {
    const domCascade = this.#styleToDOMCascade.get(style);
    return domCascade ? domCascade.computeAttribute(style, attributeName, type) : null;
  }
  originatingNodeForStyle(style) {
    let node = this.nodeForStyle(style) ?? this.node();
    while (node?.pseudoType()) {
      node = node.parentNode;
    }
    return node;
  }
  rawAttributeValueFromStyle(style, attributeName) {
    const node = this.originatingNodeForStyle(style);
    if (!node) {
      return null;
    }
    return node.getAttribute(attributeName) ?? null;
  }
  resolveProperty(name, ownerStyle) {
    return this.#styleToDOMCascade.get(ownerStyle)?.resolveProperty(name, ownerStyle) ?? null;
  }
  resolveGlobalKeyword(property, keyword) {
    const resolved = this.#styleToDOMCascade.get(property.ownerStyle)?.resolveGlobalKeyword(property, keyword);
    return resolved ? new CSSValueSource(resolved) : null;
  }
  isInherited(style) {
    return this.#inheritedStyles.has(style);
  }
  propertyState(property) {
    const domCascade = this.#styleToDOMCascade.get(property.ownerStyle);
    return domCascade ? domCascade.propertyState(property) : null;
  }
  resetActiveProperties() {
    Platform6.assertNotNullOrUndefined(this.#mainDOMCascade);
    Platform6.assertNotNullOrUndefined(this.#pseudoDOMCascades);
    Platform6.assertNotNullOrUndefined(this.#customHighlightPseudoDOMCascades);
    this.#mainDOMCascade.reset();
    for (const domCascade of this.#pseudoDOMCascades.values()) {
      domCascade.reset();
    }
    for (const domCascade of this.#customHighlightPseudoDOMCascades.values()) {
      domCascade.reset();
    }
  }
  propertyMatchers(style, computedStyles) {
    return [
      new VariableMatcher(this, style),
      new ColorMatcher(() => computedStyles?.get("color") ?? null),
      new ColorMixMatcher(),
      new URLMatcher(),
      new AngleMatcher(),
      new LinkableNameMatcher(),
      new BezierMatcher(),
      new StringMatcher(),
      new ShadowMatcher(),
      new LightDarkColorMatcher(style),
      new GridTemplateMatcher(),
      new LinearGradientMatcher(),
      new AnchorFunctionMatcher(),
      new PositionAnchorMatcher(),
      new FlexGridMasonryMatcher(),
      new PositionTryMatcher(),
      new LengthMatcher(),
      new MathFunctionMatcher(),
      new CustomFunctionMatcher(),
      new AutoBaseMatcher(),
      new BinOpMatcher(),
      new RelativeColorChannelMatcher(),
      new AttributeMatcher(this, style),
      new EnvFunctionMatcher(this)
    ];
  }
  environmentVariable(name) {
    return this.#environmentVariables[name];
  }
};
var NodeCascade = class {
  #matchedStyles;
  styles;
  #isInherited;
  #isHighlightPseudoCascade;
  propertiesState = /* @__PURE__ */ new Map();
  activeProperties = /* @__PURE__ */ new Map();
  #node;
  constructor(matchedStyles, styles, node, isInherited, isHighlightPseudoCascade = false) {
    this.#matchedStyles = matchedStyles;
    this.styles = styles;
    this.#isInherited = isInherited;
    this.#isHighlightPseudoCascade = isHighlightPseudoCascade;
    this.#node = node;
  }
  computeActiveProperties() {
    this.propertiesState.clear();
    this.activeProperties.clear();
    for (let i = this.styles.length - 1; i >= 0; i--) {
      const style = this.styles[i];
      const rule = style.parentRule;
      if (rule && !(rule instanceof CSSStyleRule)) {
        continue;
      }
      if (rule && !this.#matchedStyles.hasMatchingSelectors(rule)) {
        continue;
      }
      for (const property of style.allProperties()) {
        const metadata = cssMetadata();
        if (this.#isInherited && !this.#isHighlightPseudoCascade && !metadata.isPropertyInherited(property.name)) {
          continue;
        }
        if (style.range && !property.range) {
          continue;
        }
        if (!property.activeInStyle()) {
          this.propertiesState.set(
            property,
            "Overloaded"
            /* PropertyState.OVERLOADED */
          );
          continue;
        }
        if (this.#isInherited) {
          const registration = this.#matchedStyles.getRegisteredProperty(property.name);
          if (registration && !registration.inherits()) {
            this.propertiesState.set(
              property,
              "Overloaded"
              /* PropertyState.OVERLOADED */
            );
            continue;
          }
        }
        const canonicalName = metadata.canonicalPropertyName(property.name);
        this.updatePropertyState(property, canonicalName);
        for (const longhand of property.getLonghandProperties()) {
          if (metadata.isCSSPropertyName(longhand.name)) {
            this.updatePropertyState(longhand, longhand.name);
          }
        }
      }
    }
  }
  #treeScopeDistance(property) {
    if (!property.ownerStyle.parentRule && property.ownerStyle.type !== Type2.Inline) {
      return -1;
    }
    const root = this.#node.getTreeRoot();
    const nodeId = property.ownerStyle.parentRule?.treeScope ?? root?.backendNodeId();
    if (nodeId === void 0) {
      return -1;
    }
    let distance = 0;
    for (let ancestor = this.#node; ancestor; ancestor = ancestor.parentNode) {
      if (ancestor.backendNodeId() === nodeId) {
        return distance;
      }
      distance++;
    }
    return -1;
  }
  #needsCascadeContextStep() {
    if (!this.#node.isInShadowTree()) {
      return false;
    }
    if (this.#node.ancestorShadowRoot()?.shadowRootType() === "user-agent") {
      const pseudoElement = this.#node.getAttribute("pseudo");
      return !pseudoElement?.startsWith("-webkit-") && !pseudoElement?.startsWith("-internal-");
    }
    return true;
  }
  updatePropertyState(propertyWithHigherSpecificity, canonicalName) {
    const activeProperty = this.activeProperties.get(canonicalName);
    if (activeProperty?.important && !propertyWithHigherSpecificity.important || activeProperty && this.#needsCascadeContextStep() && this.#treeScopeDistance(activeProperty) > this.#treeScopeDistance(propertyWithHigherSpecificity)) {
      this.propertiesState.set(
        propertyWithHigherSpecificity,
        "Overloaded"
        /* PropertyState.OVERLOADED */
      );
      return;
    }
    if (activeProperty) {
      this.propertiesState.set(
        activeProperty,
        "Overloaded"
        /* PropertyState.OVERLOADED */
      );
    }
    this.propertiesState.set(
      propertyWithHigherSpecificity,
      "Active"
      /* PropertyState.ACTIVE */
    );
    this.activeProperties.set(canonicalName, propertyWithHigherSpecificity);
  }
};
function isRegular(declaration2) {
  return "ownerStyle" in declaration2;
}
var CSSValueSource = class {
  declaration;
  constructor(declaration2) {
    this.declaration = declaration2;
  }
  get value() {
    return isRegular(this.declaration) ? this.declaration.value : this.declaration.initialValue();
  }
  get style() {
    return isRegular(this.declaration) ? this.declaration.ownerStyle : this.declaration.style();
  }
  get name() {
    return isRegular(this.declaration) ? this.declaration.name : this.declaration.propertyName();
  }
};
var SCCRecordEntry = class {
  nodeCascade;
  name;
  discoveryTime;
  rootDiscoveryTime;
  get isRootEntry() {
    return this.rootDiscoveryTime === this.discoveryTime;
  }
  updateRoot(neighbor) {
    this.rootDiscoveryTime = Math.min(this.rootDiscoveryTime, neighbor.rootDiscoveryTime);
  }
  constructor(nodeCascade, name, discoveryTime) {
    this.nodeCascade = nodeCascade;
    this.name = name;
    this.discoveryTime = discoveryTime;
    this.rootDiscoveryTime = discoveryTime;
  }
};
var SCCRecord = class {
  #time = 0;
  #stack = [];
  #entries = /* @__PURE__ */ new Map();
  get(nodeCascade, variable) {
    return this.#entries.get(nodeCascade)?.get(variable);
  }
  add(nodeCascade, variable) {
    const existing = this.get(nodeCascade, variable);
    if (existing) {
      return existing;
    }
    const entry = new SCCRecordEntry(nodeCascade, variable, this.#time++);
    this.#stack.push(entry);
    let map = this.#entries.get(nodeCascade);
    if (!map) {
      map = /* @__PURE__ */ new Map();
      this.#entries.set(nodeCascade, map);
    }
    map.set(variable, entry);
    return entry;
  }
  isInInProgressSCC(childRecord) {
    return this.#stack.includes(childRecord);
  }
  finishSCC(root) {
    const startIndex = this.#stack.lastIndexOf(root);
    console.assert(startIndex >= 0, "Root is not an in-progress scc");
    return this.#stack.splice(startIndex);
  }
};
function* forEach(array, startAfter) {
  const startIdx = startAfter !== void 0 ? array.indexOf(startAfter) + 1 : 0;
  for (let i = startIdx; i < array.length; ++i) {
    yield array[i];
  }
}
var DOMInheritanceCascade = class {
  #propertiesState = /* @__PURE__ */ new Map();
  #availableCSSVariables = /* @__PURE__ */ new Map();
  #computedCSSVariables = /* @__PURE__ */ new Map();
  #styleToNodeCascade = /* @__PURE__ */ new Map();
  #initialized = false;
  #nodeCascades;
  #registeredProperties;
  #matchedStyles;
  constructor(matchedStyles, nodeCascades, registeredProperties) {
    this.#nodeCascades = nodeCascades;
    this.#matchedStyles = matchedStyles;
    this.#registeredProperties = registeredProperties;
    for (const nodeCascade of nodeCascades) {
      for (const style of nodeCascade.styles) {
        this.#styleToNodeCascade.set(style, nodeCascade);
      }
    }
  }
  findAvailableCSSVariables(style) {
    const nodeCascade = this.#styleToNodeCascade.get(style);
    if (!nodeCascade) {
      return [];
    }
    this.ensureInitialized();
    const availableCSSVariables = this.#availableCSSVariables.get(nodeCascade);
    if (!availableCSSVariables) {
      return [];
    }
    return Array.from(availableCSSVariables.keys());
  }
  #findPropertyInPreviousStyle(property, filter) {
    const cascade = this.#styleToNodeCascade.get(property.ownerStyle);
    if (!cascade) {
      return null;
    }
    for (const style of forEach(cascade.styles, property.ownerStyle)) {
      const candidate = style.allProperties().findLast((candidate2) => candidate2.name === property.name && filter(candidate2));
      if (candidate) {
        return candidate;
      }
    }
    return null;
  }
  resolveProperty(name, ownerStyle) {
    const cascade = this.#styleToNodeCascade.get(ownerStyle);
    if (!cascade) {
      return null;
    }
    for (const style of cascade.styles) {
      const candidate = style.allProperties().findLast((candidate2) => candidate2.name === name);
      if (candidate) {
        return candidate;
      }
    }
    return this.#findPropertyInParentCascadeIfInherited({ name, ownerStyle });
  }
  #findPropertyInParentCascade(property) {
    const nodeCascade = this.#styleToNodeCascade.get(property.ownerStyle);
    if (!nodeCascade) {
      return null;
    }
    for (const cascade of forEach(this.#nodeCascades, nodeCascade)) {
      for (const style of cascade.styles) {
        const inheritedProperty = style.allProperties().findLast((inheritedProperty2) => inheritedProperty2.name === property.name);
        if (inheritedProperty) {
          return inheritedProperty;
        }
      }
    }
    return null;
  }
  #findPropertyInParentCascadeIfInherited(property) {
    if (!cssMetadata().isPropertyInherited(property.name) || !(this.#findCustomPropertyRegistration(property.name)?.inherits() ?? true)) {
      return null;
    }
    return this.#findPropertyInParentCascade(property);
  }
  #findCustomPropertyRegistration(property) {
    const registration = this.#registeredProperties.find((registration2) => registration2.propertyName() === property);
    return registration ? registration : null;
  }
  resolveGlobalKeyword(property, keyword) {
    const isPreviousLayer = (other) => {
      if (!(other.ownerStyle.parentRule instanceof CSSStyleRule)) {
        return false;
      }
      if (property.ownerStyle.type === Type2.Inline) {
        return true;
      }
      if (property.ownerStyle.parentRule instanceof CSSStyleRule && other.ownerStyle.parentRule?.origin === "regular") {
        return JSON.stringify(other.ownerStyle.parentRule.layers) !== JSON.stringify(property.ownerStyle.parentRule.layers);
      }
      return false;
    };
    switch (keyword) {
      case "initial":
        return this.#findCustomPropertyRegistration(property.name);
      case "inherit":
        return this.#findPropertyInParentCascade(property) ?? this.#findCustomPropertyRegistration(property.name);
      case "revert":
        return this.#findPropertyInPreviousStyle(property, (other) => other.ownerStyle.parentRule !== null && other.ownerStyle.parentRule.origin !== (property.ownerStyle.parentRule?.origin ?? "regular")) ?? this.resolveGlobalKeyword(
          property,
          "unset"
          /* CSSWideKeyword.UNSET */
        );
      case "revert-layer":
        return this.#findPropertyInPreviousStyle(property, isPreviousLayer) ?? this.resolveGlobalKeyword(
          property,
          "revert"
          /* CSSWideKeyword.REVERT */
        );
      case "unset":
        return this.#findPropertyInParentCascadeIfInherited(property) ?? this.#findCustomPropertyRegistration(property.name);
    }
  }
  computeCSSVariable(style, variableName) {
    this.ensureInitialized();
    const nodeCascade = this.#styleToNodeCascade.get(style);
    if (!nodeCascade) {
      return null;
    }
    return this.#computeCSSVariable(nodeCascade, variableName);
  }
  #computeCSSVariable(nodeCascade, variableName, sccRecord = new SCCRecord()) {
    const availableCSSVariables = this.#availableCSSVariables.get(nodeCascade);
    const computedCSSVariables = this.#computedCSSVariables.get(nodeCascade);
    if (!computedCSSVariables || !availableCSSVariables?.has(variableName)) {
      return null;
    }
    if (computedCSSVariables?.has(variableName)) {
      return computedCSSVariables.get(variableName) || null;
    }
    let definedValue = availableCSSVariables.get(variableName);
    if (definedValue === void 0 || definedValue === null) {
      return null;
    }
    if (definedValue.declaration.declaration instanceof CSSProperty && definedValue.declaration.value && CSSMetadata.isCSSWideKeyword(definedValue.declaration.value)) {
      const resolvedProperty = this.resolveGlobalKeyword(definedValue.declaration.declaration, definedValue.declaration.value);
      if (!resolvedProperty) {
        return definedValue;
      }
      const declaration2 = new CSSValueSource(resolvedProperty);
      const { value } = declaration2;
      if (!value) {
        return definedValue;
      }
      definedValue = { declaration: declaration2, value };
    }
    const ast = tokenizeDeclaration(`--${variableName}`, definedValue.value);
    if (!ast) {
      return null;
    }
    return this.#walkTree(nodeCascade, ast, definedValue.declaration.style, variableName, sccRecord, definedValue.declaration);
  }
  computeAttribute(style, attributeName, type) {
    this.ensureInitialized();
    const nodeCascade = this.#styleToNodeCascade.get(style);
    if (!nodeCascade) {
      return null;
    }
    return this.#computeAttribute(nodeCascade, style, attributeName, type, new SCCRecord());
  }
  attributeValueAsType(style, attributeName, type) {
    const rawValue = this.#matchedStyles.rawAttributeValueFromStyle(style, attributeName);
    if (rawValue === null) {
      return null;
    }
    return localEvalCSS(rawValue, type);
  }
  attributeValueWithSubstitutions(nodeCascade, style, attributeName, sccRecord) {
    const rawValue = this.#matchedStyles.rawAttributeValueFromStyle(style, attributeName);
    if (rawValue === null) {
      return null;
    }
    const ast = tokenizeDeclaration("--property", rawValue);
    if (!ast) {
      return null;
    }
    return this.#walkTree(nodeCascade, ast, style, `attr(${attributeName})`, sccRecord)?.value ?? null;
  }
  #computeAttribute(nodeCascade, style, attributeName, type, sccRecord = new SCCRecord()) {
    if (type.isCSSTokens) {
      const value = this.attributeValueWithSubstitutions(nodeCascade, style, attributeName, sccRecord);
      if (value !== null && localEvalCSS(value, type.type) !== null) {
        return value;
      }
      return null;
    }
    return this.attributeValueAsType(style, attributeName, type.type);
  }
  #walkTree(outerNodeCascade, ast, parentStyle, substitutionName, sccRecord, declaration2) {
    const record = sccRecord.add(outerNodeCascade, substitutionName);
    const computedCSSVariablesMap = this.#computedCSSVariables;
    const innerNodeCascade = this.#styleToNodeCascade.get(parentStyle);
    const matching = BottomUpTreeMatching.walk(ast, [
      new BaseVariableMatcher((match) => {
        const { value, mayFallback } = recurseWithCycleDetection(match.name, (nodeCascade) => this.#computeCSSVariable(nodeCascade, match.name, sccRecord)?.value ?? null);
        if (!mayFallback || value !== null) {
          return value;
        }
        if (!match.fallback) {
          return null;
        }
        return evaluateFallback(match.fallback, match.matching);
      }),
      new EnvFunctionMatcher(this.#matchedStyles),
      new AttributeMatcher(this.#matchedStyles, parentStyle, (match) => {
        const recordName = `attr(${match.name})`;
        let attributeValue = null;
        if (!match.isCSSTokens) {
          const { value, mayFallback } = recurseWithCycleDetection(recordName, () => this.attributeValueAsType(parentStyle, match.name, match.cssType()));
          if (value === null && !mayFallback) {
            return null;
          }
          attributeValue = value;
        } else {
          const { value, mayFallback } = recurseWithCycleDetection(recordName, (nodeCascade) => this.attributeValueWithSubstitutions(nodeCascade, parentStyle, match.name, sccRecord));
          if (value === null && !mayFallback) {
            return null;
          }
          if (value !== null && localEvalCSS(value, match.cssType()) !== null) {
            attributeValue = value;
          }
        }
        if (attributeValue !== null) {
          return attributeValue;
        }
        if (!match.fallback || !match.isValidType) {
          return defaultValueForCSSType(match.type);
        }
        return evaluateFallback(match.fallback, match.matching);
      })
    ]);
    const decl = ASTUtils.siblings(ASTUtils.declValue(matching.ast.tree));
    const declText = decl.length > 0 ? matching.getComputedTextRange(decl[0], decl[decl.length - 1]) : "";
    const hasUnresolvedSubstitutions = decl.length > 0 && matching.hasUnresolvedSubstitutionsRange(decl[0], decl[decl.length - 1]);
    const computedText = hasUnresolvedSubstitutions ? null : declText;
    const outerComputedCSSVariables = computedCSSVariablesMap.get(outerNodeCascade);
    if (!outerComputedCSSVariables) {
      return null;
    }
    if (record.isRootEntry) {
      const scc = sccRecord.finishSCC(record);
      if (scc.length > 1) {
        for (const entry of scc) {
          console.assert(entry.nodeCascade === outerNodeCascade, "Circles should be within the cascade");
          outerComputedCSSVariables.set(entry.name, null);
        }
        return null;
      }
    }
    if (computedText === null) {
      outerComputedCSSVariables.set(substitutionName, null);
      return null;
    }
    const cssVariableValue = { value: computedText, declaration: declaration2 };
    outerComputedCSSVariables.set(substitutionName, cssVariableValue);
    return cssVariableValue;
    function recurseWithCycleDetection(recordName, func) {
      if (!innerNodeCascade) {
        return { value: null, mayFallback: false };
      }
      const childRecord = sccRecord.get(innerNodeCascade, recordName);
      if (childRecord) {
        if (sccRecord.isInInProgressSCC(childRecord)) {
          record.updateRoot(childRecord);
          return { value: null, mayFallback: false };
        }
        return {
          value: computedCSSVariablesMap.get(innerNodeCascade)?.get(recordName)?.value ?? null,
          mayFallback: false
        };
      }
      const value = func(innerNodeCascade);
      const newChildRecord = sccRecord.get(innerNodeCascade, recordName);
      newChildRecord && record.updateRoot(newChildRecord);
      return { value, mayFallback: true };
    }
    function evaluateFallback(fallback, matching2) {
      if (fallback.length === 0) {
        return "";
      }
      if (matching2.hasUnresolvedSubstitutionsRange(fallback[0], fallback[fallback.length - 1])) {
        return null;
      }
      return matching2.getComputedTextRange(fallback[0], fallback[fallback.length - 1]);
    }
  }
  styles() {
    return Array.from(this.#styleToNodeCascade.keys());
  }
  propertyState(property) {
    this.ensureInitialized();
    return this.#propertiesState.get(property) || null;
  }
  reset() {
    this.#initialized = false;
    this.#propertiesState.clear();
    this.#availableCSSVariables.clear();
    this.#computedCSSVariables.clear();
  }
  ensureInitialized() {
    if (this.#initialized) {
      return;
    }
    this.#initialized = true;
    const activeProperties = /* @__PURE__ */ new Map();
    for (const nodeCascade of this.#nodeCascades) {
      nodeCascade.computeActiveProperties();
      for (const [property, state] of nodeCascade.propertiesState) {
        if (state === "Overloaded") {
          this.#propertiesState.set(
            property,
            "Overloaded"
            /* PropertyState.OVERLOADED */
          );
          continue;
        }
        const canonicalName = cssMetadata().canonicalPropertyName(property.name);
        if (activeProperties.has(canonicalName)) {
          this.#propertiesState.set(
            property,
            "Overloaded"
            /* PropertyState.OVERLOADED */
          );
          continue;
        }
        activeProperties.set(canonicalName, property);
        this.#propertiesState.set(
          property,
          "Active"
          /* PropertyState.ACTIVE */
        );
      }
    }
    for (const [canonicalName, shorthandProperty] of activeProperties) {
      const shorthandStyle = shorthandProperty.ownerStyle;
      const longhands = shorthandProperty.getLonghandProperties();
      if (!longhands.length) {
        continue;
      }
      let hasActiveLonghands = false;
      for (const longhand of longhands) {
        const longhandCanonicalName = cssMetadata().canonicalPropertyName(longhand.name);
        const longhandActiveProperty = activeProperties.get(longhandCanonicalName);
        if (!longhandActiveProperty) {
          continue;
        }
        if (longhandActiveProperty.ownerStyle === shorthandStyle) {
          hasActiveLonghands = true;
          break;
        }
      }
      if (hasActiveLonghands) {
        continue;
      }
      activeProperties.delete(canonicalName);
      this.#propertiesState.set(
        shorthandProperty,
        "Overloaded"
        /* PropertyState.OVERLOADED */
      );
    }
    const accumulatedCSSVariables = /* @__PURE__ */ new Map();
    for (const rule of this.#registeredProperties) {
      const initialValue = rule.initialValue();
      accumulatedCSSVariables.set(rule.propertyName(), initialValue !== null ? { value: initialValue, declaration: new CSSValueSource(rule) } : null);
    }
    for (let i = this.#nodeCascades.length - 1; i >= 0; --i) {
      const nodeCascade = this.#nodeCascades[i];
      const variableNames = [];
      for (const entry of nodeCascade.activeProperties.entries()) {
        const propertyName = entry[0];
        const property = entry[1];
        if (propertyName.startsWith("--")) {
          accumulatedCSSVariables.set(propertyName, { value: property.value, declaration: new CSSValueSource(property) });
          variableNames.push(propertyName);
        }
      }
      const availableCSSVariablesMap = new Map(accumulatedCSSVariables);
      const computedVariablesMap = /* @__PURE__ */ new Map();
      this.#availableCSSVariables.set(nodeCascade, availableCSSVariablesMap);
      this.#computedCSSVariables.set(nodeCascade, computedVariablesMap);
      for (const variableName of variableNames) {
        const prevValue = accumulatedCSSVariables.get(variableName);
        accumulatedCSSVariables.delete(variableName);
        const computedValue = this.#computeCSSVariable(nodeCascade, variableName);
        if (prevValue && computedValue?.value === prevValue.value) {
          computedValue.declaration = prevValue.declaration;
        }
        accumulatedCSSVariables.set(variableName, computedValue);
      }
    }
  }
};

// gen/front_end/core/sdk/CSSStyleSheetHeader.js
var CSSStyleSheetHeader_exports = {};
__export(CSSStyleSheetHeader_exports, {
  CSSStyleSheetHeader: () => CSSStyleSheetHeader
});
import * as TextUtils13 from "./../../models/text_utils/text_utils.js";
import * as Common8 from "./../common/common.js";
import * as i18n3 from "./../i18n/i18n.js";
import * as Platform7 from "./../platform/platform.js";
var UIStrings2 = {
  /**
   * @description Error message for when a CSS file can't be loaded
   */
  couldNotFindTheOriginalStyle: "Could not find the original style sheet.",
  /**
   * @description Error message to display when a source CSS file could not be retrieved.
   */
  thereWasAnErrorRetrievingThe: "There was an error retrieving the source styles."
};
var str_2 = i18n3.i18n.registerUIStrings("core/sdk/CSSStyleSheetHeader.ts", UIStrings2);
var i18nString2 = i18n3.i18n.getLocalizedString.bind(void 0, str_2);
var CSSStyleSheetHeader = class {
  #cssModel;
  id;
  frameId;
  sourceURL;
  hasSourceURL;
  origin;
  title;
  disabled;
  isInline;
  isMutable;
  isConstructed;
  startLine;
  startColumn;
  endLine;
  endColumn;
  contentLength;
  ownerNode;
  sourceMapURL;
  loadingFailed;
  #originalContentProvider;
  constructor(cssModel, payload) {
    this.#cssModel = cssModel;
    this.id = payload.styleSheetId;
    this.frameId = payload.frameId;
    this.sourceURL = payload.sourceURL;
    this.hasSourceURL = Boolean(payload.hasSourceURL);
    this.origin = payload.origin;
    this.title = payload.title;
    this.disabled = payload.disabled;
    this.isInline = payload.isInline;
    this.isMutable = payload.isMutable;
    this.isConstructed = payload.isConstructed;
    this.startLine = payload.startLine;
    this.startColumn = payload.startColumn;
    this.endLine = payload.endLine;
    this.endColumn = payload.endColumn;
    this.contentLength = payload.length;
    if (payload.ownerNode) {
      this.ownerNode = new DeferredDOMNode(cssModel.target(), payload.ownerNode);
    }
    this.sourceMapURL = payload.sourceMapURL;
    this.loadingFailed = payload.loadingFailed ?? false;
    this.#originalContentProvider = null;
  }
  originalContentProvider() {
    if (!this.#originalContentProvider) {
      const lazyContent = async () => {
        const originalText = await this.#cssModel.originalStyleSheetText(this);
        if (originalText === null) {
          return { error: i18nString2(UIStrings2.couldNotFindTheOriginalStyle) };
        }
        return new TextUtils13.ContentData.ContentData(
          originalText,
          /* isBase64=*/
          false,
          "text/css"
        );
      };
      this.#originalContentProvider = new TextUtils13.StaticContentProvider.StaticContentProvider(this.contentURL(), this.contentType(), lazyContent);
    }
    return this.#originalContentProvider;
  }
  setSourceMapURL(sourceMapURL) {
    this.sourceMapURL = sourceMapURL;
  }
  cssModel() {
    return this.#cssModel;
  }
  isAnonymousInlineStyleSheet() {
    return !this.resourceURL() && !this.#cssModel.sourceMapManager().sourceMapForClient(this);
  }
  isConstructedByNew() {
    return this.isConstructed && this.sourceURL.length === 0;
  }
  resourceURL() {
    return this.isViaInspector() ? this.viaInspectorResourceURL() : this.sourceURL;
  }
  getFrameURLPath() {
    const model = this.#cssModel.target().model(ResourceTreeModel);
    console.assert(Boolean(model));
    if (!model) {
      return "";
    }
    const frame = model.frameForId(this.frameId);
    if (!frame) {
      return "";
    }
    console.assert(Boolean(frame));
    const parsedURL = new Common8.ParsedURL.ParsedURL(frame.url);
    let urlPath = parsedURL.host;
    if (parsedURL.port) {
      urlPath += ":" + parsedURL.port;
    }
    urlPath += parsedURL.folderPathComponents;
    if (!urlPath.endsWith("/")) {
      urlPath += "/";
    }
    return urlPath;
  }
  viaInspectorResourceURL() {
    return `inspector://${this.getFrameURLPath()}inspector-stylesheet#${this.id}`;
  }
  lineNumberInSource(lineNumberInStyleSheet) {
    return this.startLine + lineNumberInStyleSheet;
  }
  columnNumberInSource(lineNumberInStyleSheet, columnNumberInStyleSheet) {
    return (lineNumberInStyleSheet ? 0 : this.startColumn) + columnNumberInStyleSheet;
  }
  /**
   * Checks whether the position is in this style sheet. Assumes that the
   * position's columnNumber is consistent with line endings.
   */
  containsLocation(lineNumber, columnNumber) {
    const afterStart = lineNumber === this.startLine && columnNumber >= this.startColumn || lineNumber > this.startLine;
    const beforeEnd = lineNumber < this.endLine || lineNumber === this.endLine && columnNumber <= this.endColumn;
    return afterStart && beforeEnd;
  }
  contentURL() {
    return this.resourceURL();
  }
  contentType() {
    return Common8.ResourceType.resourceTypes.Stylesheet;
  }
  async requestContentData() {
    const cssText = await this.#cssModel.getStyleSheetText(this.id);
    if (cssText === null) {
      return { error: i18nString2(UIStrings2.thereWasAnErrorRetrievingThe) };
    }
    return new TextUtils13.ContentData.ContentData(
      cssText,
      /* isBase64=*/
      false,
      "text/css"
    );
  }
  async searchInContent(query, caseSensitive, isRegex) {
    const contentData = await this.requestContentData();
    return TextUtils13.TextUtils.performSearchInContentData(contentData, query, caseSensitive, isRegex);
  }
  isViaInspector() {
    return this.origin === "inspector";
  }
  createPageResourceLoadInitiator() {
    return {
      target: this.#cssModel.target(),
      frameId: this.frameId,
      initiatorUrl: this.hasSourceURL ? Platform7.DevToolsPath.EmptyUrlString : this.sourceURL
    };
  }
  debugId() {
    return null;
  }
};

// gen/front_end/core/sdk/SourceMapManager.js
var SourceMapManager_exports = {};
__export(SourceMapManager_exports, {
  Events: () => Events4,
  SourceMapManager: () => SourceMapManager,
  loadSourceMap: () => loadSourceMap,
  tryLoadSourceMap: () => tryLoadSourceMap
});
import * as Common13 from "./../common/common.js";
import * as Platform9 from "./../platform/platform.js";

// gen/front_end/core/sdk/PageResourceLoader.js
var PageResourceLoader_exports = {};
__export(PageResourceLoader_exports, {
  PageResourceLoader: () => PageResourceLoader,
  ResourceKey: () => ResourceKey,
  getLoadThroughTargetSetting: () => getLoadThroughTargetSetting
});
import * as Common11 from "./../common/common.js";
import * as Host3 from "./../host/host.js";
import * as i18n5 from "./../i18n/i18n.js";

// gen/front_end/core/sdk/FrameManager.js
var FrameManager_exports = {};
__export(FrameManager_exports, {
  FrameManager: () => FrameManager
});
import * as Common9 from "./../common/common.js";
var frameManagerInstance = null;
var FrameManager = class _FrameManager extends Common9.ObjectWrapper.ObjectWrapper {
  #eventListeners = /* @__PURE__ */ new WeakMap();
  // Maps frameIds to #frames and a count of how many ResourceTreeModels contain this frame.
  // (OOPIFs are usually first attached to a new target and then detached from their old target,
  // therefore being contained in 2 models for a short period of time.)
  #frames = /* @__PURE__ */ new Map();
  #framesForTarget = /* @__PURE__ */ new Map();
  #outermostFrame = null;
  #transferringFramesDataCache = /* @__PURE__ */ new Map();
  #awaitedFrames = /* @__PURE__ */ new Map();
  constructor() {
    super();
    TargetManager.instance().observeModels(ResourceTreeModel, this);
  }
  static instance({ forceNew } = { forceNew: false }) {
    if (!frameManagerInstance || forceNew) {
      frameManagerInstance = new _FrameManager();
    }
    return frameManagerInstance;
  }
  static removeInstance() {
    frameManagerInstance = null;
  }
  modelAdded(resourceTreeModel) {
    const addListener = resourceTreeModel.addEventListener(Events3.FrameAdded, this.frameAdded, this);
    const detachListener = resourceTreeModel.addEventListener(Events3.FrameDetached, this.frameDetached, this);
    const navigatedListener = resourceTreeModel.addEventListener(Events3.FrameNavigated, this.frameNavigated, this);
    const resourceAddedListener = resourceTreeModel.addEventListener(Events3.ResourceAdded, this.resourceAdded, this);
    this.#eventListeners.set(resourceTreeModel, [addListener, detachListener, navigatedListener, resourceAddedListener]);
    this.#framesForTarget.set(resourceTreeModel.target().id(), /* @__PURE__ */ new Set());
  }
  modelRemoved(resourceTreeModel) {
    const listeners = this.#eventListeners.get(resourceTreeModel);
    if (listeners) {
      Common9.EventTarget.removeEventListeners(listeners);
    }
    const frameSet = this.#framesForTarget.get(resourceTreeModel.target().id());
    if (frameSet) {
      for (const frameId of frameSet) {
        this.decreaseOrRemoveFrame(frameId);
      }
    }
    this.#framesForTarget.delete(resourceTreeModel.target().id());
  }
  frameAdded(event) {
    const frame = event.data;
    const frameData = this.#frames.get(frame.id);
    if (frameData) {
      frame.setCreationStackTrace(frameData.frame.getCreationStackTraceData());
      this.#frames.set(frame.id, { frame, count: frameData.count + 1 });
    } else {
      const cachedFrameAttributes = this.#transferringFramesDataCache.get(frame.id);
      if (cachedFrameAttributes?.creationStackTrace && cachedFrameAttributes?.creationStackTraceTarget) {
        frame.setCreationStackTrace({
          creationStackTrace: cachedFrameAttributes.creationStackTrace,
          creationStackTraceTarget: cachedFrameAttributes.creationStackTraceTarget
        });
      }
      this.#frames.set(frame.id, { frame, count: 1 });
      this.#transferringFramesDataCache.delete(frame.id);
    }
    this.resetOutermostFrame();
    const frameSet = this.#framesForTarget.get(frame.resourceTreeModel().target().id());
    if (frameSet) {
      frameSet.add(frame.id);
    }
    this.dispatchEventToListeners("FrameAddedToTarget", { frame });
    this.resolveAwaitedFrame(frame);
  }
  frameDetached(event) {
    const { frame, isSwap } = event.data;
    this.decreaseOrRemoveFrame(frame.id);
    if (isSwap && !this.#frames.get(frame.id)) {
      const traceData = frame.getCreationStackTraceData();
      const cachedFrameAttributes = {
        ...traceData.creationStackTrace && { creationStackTrace: traceData.creationStackTrace },
        ...traceData.creationStackTrace && { creationStackTraceTarget: traceData.creationStackTraceTarget }
      };
      this.#transferringFramesDataCache.set(frame.id, cachedFrameAttributes);
    }
    const frameSet = this.#framesForTarget.get(frame.resourceTreeModel().target().id());
    if (frameSet) {
      frameSet.delete(frame.id);
    }
  }
  frameNavigated(event) {
    const frame = event.data;
    this.dispatchEventToListeners("FrameNavigated", { frame });
    if (frame.isOutermostFrame()) {
      this.dispatchEventToListeners("OutermostFrameNavigated", { frame });
    }
  }
  resourceAdded(event) {
    this.dispatchEventToListeners("ResourceAdded", { resource: event.data });
  }
  decreaseOrRemoveFrame(frameId) {
    const frameData = this.#frames.get(frameId);
    if (frameData) {
      if (frameData.count === 1) {
        this.#frames.delete(frameId);
        this.resetOutermostFrame();
        this.dispatchEventToListeners("FrameRemoved", { frameId });
      } else {
        frameData.count--;
      }
    }
  }
  /**
   * Looks for the outermost frame in `#frames` and sets `#outermostFrame` accordingly.
   *
   * Important: This method needs to be called everytime `#frames` is updated.
   */
  resetOutermostFrame() {
    const outermostFrames = this.getAllFrames().filter((frame) => frame.isOutermostFrame());
    this.#outermostFrame = outermostFrames.length > 0 ? outermostFrames[0] : null;
  }
  /**
   * Returns the ResourceTreeFrame with a given frameId.
   * When a frame is being detached a new ResourceTreeFrame but with the same
   * frameId is created. Consequently getFrame() will return a different
   * ResourceTreeFrame after detachment. Callers of getFrame() should therefore
   * immediately use the function return value and not store it for later use.
   */
  getFrame(frameId) {
    const frameData = this.#frames.get(frameId);
    if (frameData) {
      return frameData.frame;
    }
    return null;
  }
  getAllFrames() {
    return Array.from(this.#frames.values(), (frameData) => frameData.frame);
  }
  getOutermostFrame() {
    return this.#outermostFrame;
  }
  async getOrWaitForFrame(frameId, notInTarget) {
    const frame = this.getFrame(frameId);
    if (frame && (!notInTarget || notInTarget !== frame.resourceTreeModel().target())) {
      return frame;
    }
    return await new Promise((resolve) => {
      const waiting = this.#awaitedFrames.get(frameId);
      if (waiting) {
        waiting.push({ notInTarget, resolve });
      } else {
        this.#awaitedFrames.set(frameId, [{ notInTarget, resolve }]);
      }
    });
  }
  resolveAwaitedFrame(frame) {
    const waiting = this.#awaitedFrames.get(frame.id);
    if (!waiting) {
      return;
    }
    const newWaiting = waiting.filter(({ notInTarget, resolve }) => {
      if (!notInTarget || notInTarget !== frame.resourceTreeModel().target()) {
        resolve(frame);
        return false;
      }
      return true;
    });
    if (newWaiting.length > 0) {
      this.#awaitedFrames.set(frame.id, newWaiting);
    } else {
      this.#awaitedFrames.delete(frame.id);
    }
  }
};

// gen/front_end/core/sdk/IOModel.js
var IOModel_exports = {};
__export(IOModel_exports, {
  IOModel: () => IOModel
});
import * as Common10 from "./../common/common.js";

// gen/front_end/core/sdk/RemoteObject.js
var RemoteObject_exports = {};
__export(RemoteObject_exports, {
  LinearMemoryInspectable: () => LinearMemoryInspectable,
  LocalJSONObject: () => LocalJSONObject,
  RemoteArray: () => RemoteArray,
  RemoteArrayBuffer: () => RemoteArrayBuffer,
  RemoteError: () => RemoteError,
  RemoteFunction: () => RemoteFunction,
  RemoteObject: () => RemoteObject,
  RemoteObjectImpl: () => RemoteObjectImpl,
  RemoteObjectProperty: () => RemoteObjectProperty,
  ScopeRef: () => ScopeRef,
  ScopeRemoteObject: () => ScopeRemoteObject
});
var RemoteObject = class _RemoteObject {
  static fromLocalObject(value) {
    return new LocalJSONObject(value);
  }
  static type(remoteObject) {
    if (remoteObject === null) {
      return "null";
    }
    const type = typeof remoteObject;
    if (type !== "object" && type !== "function") {
      return type;
    }
    return remoteObject.type;
  }
  static isNullOrUndefined(remoteObject) {
    if (remoteObject === void 0) {
      return true;
    }
    switch (remoteObject.type) {
      case "object":
        return remoteObject.subtype === "null";
      case "undefined":
        return true;
      default:
        return false;
    }
  }
  static arrayNameFromDescription(description) {
    return description.replace(descriptionLengthParenRegex, "").replace(descriptionLengthSquareRegex, "");
  }
  static arrayLength(object) {
    if (object.subtype !== "array" && object.subtype !== "typedarray") {
      return 0;
    }
    const parenMatches = object.description?.match(descriptionLengthParenRegex);
    const squareMatches = object.description?.match(descriptionLengthSquareRegex);
    return parenMatches ? parseInt(parenMatches[1], 10) : squareMatches ? parseInt(squareMatches[1], 10) : 0;
  }
  static arrayBufferByteLength(object) {
    if (object.subtype !== "arraybuffer") {
      return 0;
    }
    const matches = object.description?.match(descriptionLengthParenRegex);
    return matches ? parseInt(matches[1], 10) : 0;
  }
  static unserializableDescription(object) {
    if (typeof object === "number") {
      const description = String(object);
      if (object === 0 && 1 / object < 0) {
        return "-0";
      }
      if (description === "NaN" || description === "Infinity" || description === "-Infinity") {
        return description;
      }
    }
    if (typeof object === "bigint") {
      return object + "n";
    }
    return null;
  }
  static toCallArgument(object) {
    const type = typeof object;
    if (type === "undefined") {
      return {};
    }
    const unserializableDescription = _RemoteObject.unserializableDescription(object);
    if (type === "number") {
      if (unserializableDescription !== null) {
        return { unserializableValue: unserializableDescription };
      }
      return { value: object };
    }
    if (type === "bigint") {
      return { unserializableValue: unserializableDescription ?? void 0 };
    }
    if (type === "string" || type === "boolean") {
      return { value: object };
    }
    if (!object) {
      return { value: null };
    }
    const objectAsProtocolRemoteObject = object;
    if (object instanceof _RemoteObject) {
      const unserializableValue = object.unserializableValue();
      if (unserializableValue !== void 0) {
        return { unserializableValue };
      }
    } else if (objectAsProtocolRemoteObject.unserializableValue !== void 0) {
      return { unserializableValue: objectAsProtocolRemoteObject.unserializableValue };
    }
    if (typeof objectAsProtocolRemoteObject.objectId !== "undefined") {
      return { objectId: objectAsProtocolRemoteObject.objectId };
    }
    return { value: objectAsProtocolRemoteObject.value };
  }
  static async loadFromObjectPerProto(object, generatePreview, nonIndexedPropertiesOnly = false) {
    const result = await Promise.all([
      object.getAllProperties(true, generatePreview, nonIndexedPropertiesOnly),
      object.getOwnProperties(generatePreview, nonIndexedPropertiesOnly)
    ]);
    const accessorProperties = result[0].properties;
    const ownProperties = result[1].properties;
    const internalProperties = result[1].internalProperties;
    if (!ownProperties || !accessorProperties) {
      return { properties: null, internalProperties: null };
    }
    const propertiesMap = /* @__PURE__ */ new Map();
    const propertySymbols = [];
    for (let i = 0; i < accessorProperties.length; i++) {
      const property = accessorProperties[i];
      if (property.symbol) {
        propertySymbols.push(property);
      } else if (property.isOwn || property.name !== "__proto__") {
        propertiesMap.set(property.name, property);
      }
    }
    for (let i = 0; i < ownProperties.length; i++) {
      const property = ownProperties[i];
      if (property.isAccessorProperty()) {
        continue;
      }
      if (property.private || property.symbol) {
        propertySymbols.push(property);
      } else {
        propertiesMap.set(property.name, property);
      }
    }
    return {
      properties: [...propertiesMap.values()].concat(propertySymbols),
      internalProperties: internalProperties ? internalProperties : null
    };
  }
  customPreview() {
    return null;
  }
  unserializableValue() {
    throw new Error("Not implemented");
  }
  get preview() {
    return void 0;
  }
  get className() {
    return null;
  }
  callFunction(_functionDeclaration, _args) {
    throw new Error("Not implemented");
  }
  callFunctionJSON(_functionDeclaration, _args) {
    throw new Error("Not implemented");
  }
  arrayBufferByteLength() {
    throw new Error("Not implemented");
  }
  deleteProperty(_name) {
    throw new Error("Not implemented");
  }
  setPropertyValue(_name, _value) {
    throw new Error("Not implemented");
  }
  release() {
  }
  debuggerModel() {
    throw new Error("DebuggerModel-less object");
  }
  runtimeModel() {
    throw new Error("RuntimeModel-less object");
  }
  isNode() {
    return false;
  }
  /**
   * Checks whether this object can be inspected with the Linear memory inspector.
   * @returns `true` if this object can be inspected with the Linear memory inspector.
   */
  isLinearMemoryInspectable() {
    return false;
  }
  webIdl;
};
var RemoteObjectImpl = class extends RemoteObject {
  #runtimeModel;
  #runtimeAgent;
  #type;
  #subtype;
  #objectId;
  #description;
  #hasChildren;
  #preview;
  #unserializableValue;
  #value;
  #customPreview;
  #className;
  constructor(runtimeModel, objectId, type, subtype, value, unserializableValue, description, preview, customPreview, className) {
    super();
    this.#runtimeModel = runtimeModel;
    this.#runtimeAgent = runtimeModel.target().runtimeAgent();
    this.#type = type;
    this.#subtype = subtype;
    if (objectId) {
      this.#objectId = objectId;
      this.#description = description;
      this.#hasChildren = type !== "symbol";
      this.#preview = preview;
    } else {
      this.#description = description;
      if (!this.description && unserializableValue) {
        this.#description = unserializableValue;
      }
      if (!this.#description && (typeof value !== "object" || value === null)) {
        this.#description = String(value);
      }
      this.#hasChildren = false;
      if (typeof unserializableValue === "string") {
        this.#unserializableValue = unserializableValue;
        if (unserializableValue === "Infinity" || unserializableValue === "-Infinity" || unserializableValue === "-0" || unserializableValue === "NaN") {
          this.#value = Number(unserializableValue);
        } else if (type === "bigint" && unserializableValue.endsWith("n")) {
          this.#value = BigInt(unserializableValue.substring(0, unserializableValue.length - 1));
        } else {
          this.#value = unserializableValue;
        }
      } else {
        this.#value = value;
      }
    }
    this.#customPreview = customPreview || null;
    this.#className = typeof className === "string" ? className : null;
  }
  customPreview() {
    return this.#customPreview;
  }
  get objectId() {
    return this.#objectId;
  }
  get type() {
    return this.#type;
  }
  get subtype() {
    return this.#subtype;
  }
  get value() {
    return this.#value;
  }
  unserializableValue() {
    return this.#unserializableValue;
  }
  get description() {
    return this.#description;
  }
  set description(description) {
    this.#description = description;
  }
  get hasChildren() {
    return this.#hasChildren;
  }
  get preview() {
    return this.#preview;
  }
  get className() {
    return this.#className;
  }
  getOwnProperties(generatePreview, nonIndexedPropertiesOnly = false) {
    return this.doGetProperties(true, false, nonIndexedPropertiesOnly, generatePreview);
  }
  getAllProperties(accessorPropertiesOnly, generatePreview, nonIndexedPropertiesOnly = false) {
    return this.doGetProperties(false, accessorPropertiesOnly, nonIndexedPropertiesOnly, generatePreview);
  }
  async createRemoteObject(object) {
    return this.#runtimeModel.createRemoteObject(object);
  }
  async doGetProperties(ownProperties, accessorPropertiesOnly, nonIndexedPropertiesOnly, generatePreview) {
    if (!this.#objectId) {
      return { properties: null, internalProperties: null };
    }
    const response = await this.#runtimeAgent.invoke_getProperties({
      objectId: this.#objectId,
      ownProperties,
      accessorPropertiesOnly,
      nonIndexedPropertiesOnly,
      generatePreview
    });
    if (response.getError()) {
      return { properties: null, internalProperties: null };
    }
    if (response.exceptionDetails) {
      this.#runtimeModel.exceptionThrown(Date.now(), response.exceptionDetails);
      return { properties: null, internalProperties: null };
    }
    const { result: properties = [], internalProperties = [], privateProperties = [] } = response;
    const result = [];
    for (const property of properties) {
      const propertyValue = property.value ? await this.createRemoteObject(property.value) : null;
      const propertySymbol = property.symbol ? this.#runtimeModel.createRemoteObject(property.symbol) : null;
      const remoteProperty = new RemoteObjectProperty(property.name, propertyValue, Boolean(property.enumerable), Boolean(property.writable), Boolean(property.isOwn), Boolean(property.wasThrown), propertySymbol);
      if (typeof property.value === "undefined") {
        if (property.get && property.get.type !== "undefined") {
          remoteProperty.getter = this.#runtimeModel.createRemoteObject(property.get);
        }
        if (property.set && property.set.type !== "undefined") {
          remoteProperty.setter = this.#runtimeModel.createRemoteObject(property.set);
        }
      }
      result.push(remoteProperty);
    }
    for (const property of privateProperties) {
      const propertyValue = property.value ? this.#runtimeModel.createRemoteObject(property.value) : null;
      const remoteProperty = new RemoteObjectProperty(property.name, propertyValue, true, true, true, false, void 0, false, void 0, true);
      if (typeof property.value === "undefined") {
        if (property.get && property.get.type !== "undefined") {
          remoteProperty.getter = this.#runtimeModel.createRemoteObject(property.get);
        }
        if (property.set && property.set.type !== "undefined") {
          remoteProperty.setter = this.#runtimeModel.createRemoteObject(property.set);
        }
      }
      result.push(remoteProperty);
    }
    const internalPropertiesResult = [];
    for (const property of internalProperties) {
      if (!property.value) {
        continue;
      }
      const propertyValue = this.#runtimeModel.createRemoteObject(property.value);
      internalPropertiesResult.push(new RemoteObjectProperty(property.name, propertyValue, true, false, void 0, void 0, void 0, true));
    }
    return { properties: result, internalProperties: internalPropertiesResult };
  }
  async setPropertyValue(name, value) {
    if (!this.#objectId) {
      return "Can\u2019t set a property of non-object.";
    }
    const response = await this.#runtimeAgent.invoke_evaluate({ expression: value, silent: true });
    if (response.getError() || response.exceptionDetails) {
      return response.getError() || (response.result.type !== "string" ? response.result.description : response.result.value);
    }
    if (typeof name === "string") {
      name = RemoteObject.toCallArgument(name);
    }
    const resultPromise = this.doSetObjectPropertyValue(response.result, name);
    if (response.result.objectId) {
      void this.#runtimeAgent.invoke_releaseObject({ objectId: response.result.objectId });
    }
    return await resultPromise;
  }
  async doSetObjectPropertyValue(result, name) {
    const setPropertyValueFunction = "function(a, b) { this[a] = b; }";
    const argv = [name, RemoteObject.toCallArgument(result)];
    const response = await this.#runtimeAgent.invoke_callFunctionOn({
      objectId: this.#objectId,
      functionDeclaration: setPropertyValueFunction,
      arguments: argv,
      silent: true
    });
    const error = response.getError();
    return error || response.exceptionDetails ? error || response.result.description : void 0;
  }
  async deleteProperty(name) {
    if (!this.#objectId) {
      return "Can\u2019t delete a property of non-object.";
    }
    const deletePropertyFunction = "function(a) { delete this[a]; return !(a in this); }";
    const response = await this.#runtimeAgent.invoke_callFunctionOn({
      objectId: this.#objectId,
      functionDeclaration: deletePropertyFunction,
      arguments: [name],
      silent: true
    });
    if (response.getError() || response.exceptionDetails) {
      return response.getError() || response.result.description;
    }
    if (!response.result.value) {
      return "Failed to delete property.";
    }
    return void 0;
  }
  async callFunction(functionDeclaration, args) {
    const response = await this.#runtimeAgent.invoke_callFunctionOn({
      objectId: this.#objectId,
      functionDeclaration: functionDeclaration.toString(),
      arguments: args,
      silent: true
    });
    if (response.getError()) {
      return { object: null, wasThrown: false };
    }
    return {
      object: this.#runtimeModel.createRemoteObject(response.result),
      wasThrown: Boolean(response.exceptionDetails)
    };
  }
  async callFunctionJSON(functionDeclaration, args) {
    const response = await this.#runtimeAgent.invoke_callFunctionOn({
      objectId: this.#objectId,
      functionDeclaration: functionDeclaration.toString(),
      arguments: args,
      silent: true,
      returnByValue: true
    });
    if (response.getError() || response.exceptionDetails) {
      return null;
    }
    return response.result.value;
  }
  release() {
    if (!this.#objectId) {
      return;
    }
    void this.#runtimeAgent.invoke_releaseObject({ objectId: this.#objectId });
  }
  arrayLength() {
    return RemoteObject.arrayLength(this);
  }
  arrayBufferByteLength() {
    return RemoteObject.arrayBufferByteLength(this);
  }
  debuggerModel() {
    return this.#runtimeModel.debuggerModel();
  }
  runtimeModel() {
    return this.#runtimeModel;
  }
  isNode() {
    return Boolean(this.#objectId) && this.type === "object" && this.subtype === "node";
  }
  isLinearMemoryInspectable() {
    return this.type === "object" && this.subtype !== void 0 && ["webassemblymemory", "typedarray", "dataview", "arraybuffer"].includes(this.subtype);
  }
};
var ScopeRemoteObject = class extends RemoteObjectImpl {
  #scopeRef;
  #savedScopeProperties;
  constructor(runtimeModel, objectId, scopeRef, type, subtype, value, unserializableValue, description, preview) {
    super(runtimeModel, objectId, type, subtype, value, unserializableValue, description, preview);
    this.#scopeRef = scopeRef;
    this.#savedScopeProperties = void 0;
  }
  async doGetProperties(ownProperties, accessorPropertiesOnly, _generatePreview) {
    if (accessorPropertiesOnly) {
      return { properties: [], internalProperties: [] };
    }
    if (this.#savedScopeProperties) {
      return { properties: this.#savedScopeProperties.slice(), internalProperties: null };
    }
    const allProperties = await super.doGetProperties(
      ownProperties,
      accessorPropertiesOnly,
      false,
      true
      /* generatePreview */
    );
    if (Array.isArray(allProperties.properties)) {
      this.#savedScopeProperties = allProperties.properties.slice();
    }
    return allProperties;
  }
  async doSetObjectPropertyValue(result, argumentName) {
    const name = argumentName.value;
    const error = await this.debuggerModel().setVariableValue(this.#scopeRef.number, name, RemoteObject.toCallArgument(result), this.#scopeRef.callFrameId);
    if (error) {
      return error;
    }
    if (this.#savedScopeProperties) {
      for (const property of this.#savedScopeProperties) {
        if (property.name === name) {
          property.value = this.runtimeModel().createRemoteObject(result);
        }
      }
    }
    return;
  }
};
var ScopeRef = class {
  number;
  callFrameId;
  constructor(number, callFrameId) {
    this.number = number;
    this.callFrameId = callFrameId;
  }
};
var RemoteObjectProperty = class _RemoteObjectProperty {
  name;
  value;
  enumerable;
  writable;
  isOwn;
  wasThrown;
  symbol;
  synthetic;
  syntheticSetter;
  private;
  getter;
  setter;
  webIdl;
  constructor(name, value, enumerable, writable, isOwn, wasThrown, symbol, synthetic, syntheticSetter, isPrivate) {
    this.name = name;
    this.value = value !== null ? value : void 0;
    this.enumerable = typeof enumerable !== "undefined" ? enumerable : true;
    const isNonSyntheticOrSyntheticWritable = !synthetic || Boolean(syntheticSetter);
    this.writable = typeof writable !== "undefined" ? writable : isNonSyntheticOrSyntheticWritable;
    this.isOwn = Boolean(isOwn);
    this.wasThrown = Boolean(wasThrown);
    if (symbol) {
      this.symbol = symbol;
    }
    this.synthetic = Boolean(synthetic);
    if (syntheticSetter) {
      this.syntheticSetter = syntheticSetter;
    }
    this.private = Boolean(isPrivate);
  }
  async setSyntheticValue(expression) {
    if (!this.syntheticSetter) {
      return false;
    }
    const result = await this.syntheticSetter(expression);
    if (result) {
      this.value = result;
    }
    return Boolean(result);
  }
  isAccessorProperty() {
    return Boolean(this.getter || this.setter);
  }
  match({ includeNullOrUndefinedValues, regex }) {
    if (regex !== null) {
      if (!regex.test(this.name) && !regex.test(this.value?.description ?? "")) {
        return false;
      }
    }
    if (!includeNullOrUndefinedValues) {
      if (!this.isAccessorProperty() && RemoteObject.isNullOrUndefined(this.value)) {
        return false;
      }
    }
    return true;
  }
  cloneWithNewName(newName) {
    const property = new _RemoteObjectProperty(newName, this.value ?? null, this.enumerable, this.writable, this.isOwn, this.wasThrown, this.symbol, this.synthetic, this.syntheticSetter, this.private);
    property.getter = this.getter;
    property.setter = this.setter;
    return property;
  }
};
var LocalJSONObject = class extends RemoteObject {
  #value;
  #cachedDescription;
  #cachedChildren;
  constructor(value) {
    super();
    this.#value = value;
  }
  get objectId() {
    return void 0;
  }
  get value() {
    return this.#value;
  }
  unserializableValue() {
    const unserializableDescription = RemoteObject.unserializableDescription(this.#value);
    return unserializableDescription || void 0;
  }
  get description() {
    if (this.#cachedDescription) {
      return this.#cachedDescription;
    }
    function formatArrayItem(property) {
      return this.formatValue(property.value || null);
    }
    function formatObjectItem(property) {
      let name = property.name;
      if (/^\s|\s$|^$|\n/.test(name)) {
        name = '"' + name.replace(/\n/g, "\u21B5") + '"';
      }
      return name + ": " + this.formatValue(property.value || null);
    }
    if (this.type === "object") {
      switch (this.subtype) {
        case "array":
          this.#cachedDescription = this.concatenate("[", "]", formatArrayItem.bind(this));
          break;
        case "date":
          this.#cachedDescription = String(this.#value);
          break;
        case "null":
          this.#cachedDescription = "null";
          break;
        default:
          this.#cachedDescription = this.concatenate("{", "}", formatObjectItem.bind(this));
      }
    } else {
      this.#cachedDescription = String(this.#value);
    }
    return this.#cachedDescription;
  }
  formatValue(value) {
    if (!value) {
      return "undefined";
    }
    const description = value.description || "";
    if (value.type === "string") {
      return '"' + description.replace(/\n/g, "\u21B5") + '"';
    }
    return description;
  }
  concatenate(prefix, suffix, formatProperty) {
    const previewChars = 100;
    let buffer = prefix;
    const children = this.children();
    for (let i = 0; i < children.length; ++i) {
      const itemDescription = formatProperty(children[i]);
      if (buffer.length + itemDescription.length > previewChars) {
        buffer += ",\u2026";
        break;
      }
      if (i) {
        buffer += ", ";
      }
      buffer += itemDescription;
    }
    buffer += suffix;
    return buffer;
  }
  get type() {
    return typeof this.#value;
  }
  get subtype() {
    if (this.#value === null) {
      return "null";
    }
    if (Array.isArray(this.#value)) {
      return "array";
    }
    if (this.#value instanceof Date) {
      return "date";
    }
    return void 0;
  }
  get hasChildren() {
    if (typeof this.#value !== "object" || this.#value === null) {
      return false;
    }
    return Boolean(Object.keys(this.#value).length);
  }
  async getOwnProperties(_generatePreview, nonIndexedPropertiesOnly = false) {
    function isArrayIndex(name) {
      const index = Number(name) >>> 0;
      return String(index) === name;
    }
    let properties = this.children();
    if (nonIndexedPropertiesOnly) {
      properties = properties.filter((property) => !isArrayIndex(property.name));
    }
    return { properties, internalProperties: null };
  }
  async getAllProperties(accessorPropertiesOnly, generatePreview, nonIndexedPropertiesOnly = false) {
    if (accessorPropertiesOnly) {
      return { properties: [], internalProperties: null };
    }
    return await this.getOwnProperties(generatePreview, nonIndexedPropertiesOnly);
  }
  children() {
    if (!this.hasChildren) {
      return [];
    }
    if (!this.#cachedChildren) {
      this.#cachedChildren = Object.entries(this.#value).map(([name, value]) => {
        return new RemoteObjectProperty(name, value instanceof RemoteObject ? value : RemoteObject.fromLocalObject(value));
      });
    }
    return this.#cachedChildren;
  }
  arrayLength() {
    return Array.isArray(this.#value) ? this.#value.length : 0;
  }
  async callFunction(functionDeclaration, args) {
    const target = this.#value;
    const rawArgs = args ? args.map((arg) => arg.value) : [];
    let result;
    let wasThrown = false;
    try {
      result = functionDeclaration.apply(target, rawArgs);
    } catch {
      wasThrown = true;
    }
    const object = RemoteObject.fromLocalObject(result);
    return { object, wasThrown };
  }
  async callFunctionJSON(functionDeclaration, args) {
    const target = this.#value;
    const rawArgs = args ? args.map((arg) => arg.value) : [];
    let result;
    try {
      result = functionDeclaration.apply(target, rawArgs);
    } catch {
      result = null;
    }
    return result;
  }
};
var RemoteArrayBuffer = class {
  #object;
  constructor(object) {
    if (object.type !== "object" || object.subtype !== "arraybuffer") {
      throw new Error("Object is not an arraybuffer");
    }
    this.#object = object;
  }
  byteLength() {
    return this.#object.arrayBufferByteLength();
  }
  async bytes(start = 0, end = this.byteLength()) {
    if (start < 0 || start >= this.byteLength()) {
      throw new RangeError("start is out of range");
    }
    if (end < start || end > this.byteLength()) {
      throw new RangeError("end is out of range");
    }
    return await this.#object.callFunctionJSON(bytes, [{ value: start }, { value: end - start }]);
    function bytes(offset, length) {
      return [...new Uint8Array(this, offset, length)];
    }
  }
  object() {
    return this.#object;
  }
};
var RemoteArray = class _RemoteArray {
  #object;
  constructor(object) {
    this.#object = object;
  }
  static objectAsArray(object) {
    if (!object || object.type !== "object" || object.subtype !== "array" && object.subtype !== "typedarray") {
      throw new Error("Object is empty or not an array");
    }
    return new _RemoteArray(object);
  }
  static async createFromRemoteObjects(objects) {
    if (!objects.length) {
      throw new Error("Input array is empty");
    }
    const result = await objects[0].callFunction(createArray, objects.map(RemoteObject.toCallArgument));
    if (result.wasThrown || !result.object) {
      throw new Error("Call function throws exceptions or returns empty value");
    }
    return _RemoteArray.objectAsArray(result.object);
    function createArray(...args) {
      return args;
    }
  }
  async at(index) {
    if (index < 0 || index > this.#object.arrayLength()) {
      throw new Error("Out of range");
    }
    const result = await this.#object.callFunction(at, [RemoteObject.toCallArgument(index)]);
    if (result.wasThrown || !result.object) {
      throw new Error("Exception in callFunction or result value is empty");
    }
    return result.object;
    function at(index2) {
      return this[index2];
    }
  }
  length() {
    return this.#object.arrayLength();
  }
  map(func) {
    const promises = [];
    for (let i = 0; i < this.length(); ++i) {
      promises.push(this.at(i).then(func));
    }
    return Promise.all(promises);
  }
  object() {
    return this.#object;
  }
};
var RemoteFunction = class _RemoteFunction {
  #object;
  constructor(object) {
    this.#object = object;
  }
  static objectAsFunction(object) {
    if (object.type !== "function") {
      throw new Error("Object is empty or not a function");
    }
    return new _RemoteFunction(object);
  }
  async targetFunction() {
    const ownProperties = await this.#object.getOwnProperties(
      false
      /* generatePreview */
    );
    const targetFunction = ownProperties.internalProperties?.find(({ name }) => name === "[[TargetFunction]]");
    return targetFunction?.value ?? this.#object;
  }
  async targetFunctionDetails() {
    const targetFunction = await this.targetFunction();
    const functionDetails = await targetFunction.debuggerModel().functionDetailsPromise(targetFunction);
    if (this.#object !== targetFunction) {
      targetFunction.release();
    }
    return functionDetails;
  }
};
var RemoteError = class _RemoteError {
  #object;
  #exceptionDetails;
  #cause;
  constructor(object) {
    this.#object = object;
  }
  static objectAsError(object) {
    if (object.subtype !== "error") {
      throw new Error(`Object of type ${object.subtype} is not an error`);
    }
    return new _RemoteError(object);
  }
  get errorStack() {
    return this.#object.description ?? "";
  }
  exceptionDetails() {
    if (!this.#exceptionDetails) {
      this.#exceptionDetails = this.#lookupExceptionDetails();
    }
    return this.#exceptionDetails;
  }
  #lookupExceptionDetails() {
    if (this.#object.objectId) {
      return this.#object.runtimeModel().getExceptionDetails(this.#object.objectId);
    }
    return Promise.resolve(void 0);
  }
  cause() {
    if (!this.#cause) {
      this.#cause = this.#lookupCause();
    }
    return this.#cause;
  }
  async #lookupCause() {
    const allProperties = await this.#object.getAllProperties(
      false,
      false
      /* generatePreview */
    );
    const cause = allProperties.properties?.find((prop) => prop.name === "cause");
    return cause?.value;
  }
};
var descriptionLengthParenRegex = /\(([0-9]+)\)/;
var descriptionLengthSquareRegex = /\[([0-9]+)\]/;
var LinearMemoryInspectable = class {
  /** The linear memory inspectable {@link RemoteObject}. */
  object;
  /** The name of the variable or the field holding the `object`. */
  expression;
  /**
   * Wrap `object` and `expression` into a reveable structure.
   *
   * @param object A linear memory inspectable {@link RemoteObject}.
   * @param expression An optional name of the field or variable holding the `object`.
   */
  constructor(object, expression) {
    if (!object.isLinearMemoryInspectable()) {
      throw new Error("object must be linear memory inspectable");
    }
    this.object = object;
    this.expression = expression;
  }
};

// gen/front_end/core/sdk/IOModel.js
var IOModel = class extends SDKModel {
  async read(handle, size, offset) {
    const result = await this.target().ioAgent().invoke_read({ handle, offset, size });
    if (result.getError()) {
      throw new Error(result.getError());
    }
    if (result.eof) {
      return null;
    }
    if (result.base64Encoded) {
      return Common10.Base64.decode(result.data);
    }
    return result.data;
  }
  async close(handle) {
    const result = await this.target().ioAgent().invoke_close({ handle });
    if (result.getError()) {
      console.error("Could not close stream.");
    }
  }
  async resolveBlob(objectOrObjectId) {
    const objectId = objectOrObjectId instanceof RemoteObject ? objectOrObjectId.objectId : objectOrObjectId;
    if (!objectId) {
      throw new Error("Remote object has undefined objectId");
    }
    const result = await this.target().ioAgent().invoke_resolveBlob({ objectId });
    if (result.getError()) {
      throw new Error(result.getError());
    }
    return `blob:${result.uuid}`;
  }
  async readToString(handle) {
    const strings = [];
    const decoder = new TextDecoder();
    for (; ; ) {
      const data = await this.read(handle, 1024 * 1024);
      if (data === null) {
        strings.push(decoder.decode());
        break;
      }
      if (data instanceof Uint8Array) {
        strings.push(decoder.decode(data, { stream: true }));
      } else {
        strings.push(data);
      }
    }
    return strings.join("");
  }
  async readToBuffer(handle) {
    const items = [];
    for (; ; ) {
      const data = await this.read(handle, 1024 * 1024);
      if (data === null) {
        break;
      }
      if (data instanceof Uint8Array) {
        items.push(data);
      } else {
        throw new Error("Unexpected stream data type: expected binary, got a string");
      }
    }
    let length = 0;
    for (const item of items) {
      length += item.length;
    }
    const result = new Uint8Array(length);
    let offset = 0;
    for (const item of items) {
      result.set(item, offset);
      offset += item.length;
    }
    return result;
  }
};
SDKModel.register(IOModel, { capabilities: 131072, autostart: true });

// gen/front_end/core/sdk/PageResourceLoader.js
var UIStrings3 = {
  /**
   * @description Error message for canceled source map loads
   */
  loadCanceledDueToReloadOf: "Load canceled due to reload of inspected page"
};
var str_3 = i18n5.i18n.registerUIStrings("core/sdk/PageResourceLoader.ts", UIStrings3);
var i18nString3 = i18n5.i18n.getLocalizedString.bind(void 0, str_3);
function isExtensionInitiator(initiator) {
  return "extensionId" in initiator;
}
var ResourceKey = class {
  key;
  constructor(key) {
    this.key = key;
  }
};
var pageResourceLoader = null;
var PageResourceLoader = class _PageResourceLoader extends Common11.ObjectWrapper.ObjectWrapper {
  #currentlyLoading = 0;
  #currentlyLoadingPerTarget = /* @__PURE__ */ new Map();
  #maxConcurrentLoads;
  #pageResources = /* @__PURE__ */ new Map();
  #queuedLoads = [];
  #loadOverride;
  constructor(loadOverride, maxConcurrentLoads) {
    super();
    this.#maxConcurrentLoads = maxConcurrentLoads;
    TargetManager.instance().addModelListener(ResourceTreeModel, Events3.PrimaryPageChanged, this.onPrimaryPageChanged, this);
    this.#loadOverride = loadOverride;
  }
  static instance({ forceNew, loadOverride, maxConcurrentLoads } = {
    forceNew: false,
    loadOverride: null,
    maxConcurrentLoads: 500
  }) {
    if (!pageResourceLoader || forceNew) {
      pageResourceLoader = new _PageResourceLoader(loadOverride, maxConcurrentLoads);
    }
    return pageResourceLoader;
  }
  static removeInstance() {
    pageResourceLoader = null;
  }
  onPrimaryPageChanged(event) {
    const { frame: mainFrame, type } = event.data;
    if (!mainFrame.isOutermostFrame()) {
      return;
    }
    for (const { reject } of this.#queuedLoads) {
      reject(new Error(i18nString3(UIStrings3.loadCanceledDueToReloadOf)));
    }
    this.#queuedLoads = [];
    const mainFrameTarget = mainFrame.resourceTreeModel().target();
    const keptResources = /* @__PURE__ */ new Map();
    for (const [key, pageResource] of this.#pageResources.entries()) {
      if (type === "Activation" && mainFrameTarget === pageResource.initiator.target) {
        keptResources.set(key, pageResource);
      }
    }
    this.#pageResources = keptResources;
    this.dispatchEventToListeners(
      "Update"
      /* Events.UPDATE */
    );
  }
  getResourcesLoaded() {
    return this.#pageResources;
  }
  getScopedResourcesLoaded() {
    return new Map([...this.#pageResources].filter(([_, pageResource]) => TargetManager.instance().isInScope(pageResource.initiator.target) || isExtensionInitiator(pageResource.initiator)));
  }
  /**
   * Loading is the number of currently loading and queued items. Resources is the total number of resources,
   * including loading and queued resources, but not including resources that are still loading but scheduled
   * for cancelation.;
   */
  getNumberOfResources() {
    return { loading: this.#currentlyLoading, queued: this.#queuedLoads.length, resources: this.#pageResources.size };
  }
  getScopedNumberOfResources() {
    const targetManager = TargetManager.instance();
    let loadingCount = 0;
    for (const [targetId, count] of this.#currentlyLoadingPerTarget) {
      const target = targetManager.targetById(targetId);
      if (targetManager.isInScope(target)) {
        loadingCount += count;
      }
    }
    return { loading: loadingCount, resources: this.getScopedResourcesLoaded().size };
  }
  async acquireLoadSlot(target) {
    this.#currentlyLoading++;
    if (target) {
      const currentCount = this.#currentlyLoadingPerTarget.get(target.id()) || 0;
      this.#currentlyLoadingPerTarget.set(target.id(), currentCount + 1);
    }
    if (this.#currentlyLoading > this.#maxConcurrentLoads) {
      const { promise: waitForCapacity, resolve, reject } = Promise.withResolvers();
      this.#queuedLoads.push({ resolve, reject });
      await waitForCapacity;
    }
  }
  releaseLoadSlot(target) {
    this.#currentlyLoading--;
    if (target) {
      const currentCount = this.#currentlyLoadingPerTarget.get(target.id());
      if (currentCount) {
        this.#currentlyLoadingPerTarget.set(target.id(), currentCount - 1);
      }
    }
    const entry = this.#queuedLoads.shift();
    if (entry) {
      entry.resolve();
    }
  }
  static makeExtensionKey(url, initiator) {
    if (isExtensionInitiator(initiator) && initiator.extensionId) {
      return `${url}-${initiator.extensionId}`;
    }
    throw new Error("Invalid initiator");
  }
  static makeKey(url, initiator) {
    if (initiator.frameId) {
      return `${url}-${initiator.frameId}`;
    }
    if (initiator.target) {
      return `${url}-${initiator.target.id()}`;
    }
    throw new Error("Invalid initiator");
  }
  resourceLoadedThroughExtension(pageResource) {
    const key = _PageResourceLoader.makeExtensionKey(pageResource.url, pageResource.initiator);
    this.#pageResources.set(key, pageResource);
    this.dispatchEventToListeners(
      "Update"
      /* Events.UPDATE */
    );
  }
  async loadResource(url, initiator, isBinary = false) {
    if (isExtensionInitiator(initiator)) {
      throw new Error("Invalid initiator");
    }
    const key = _PageResourceLoader.makeKey(url, initiator);
    const pageResource = { success: null, size: null, duration: null, errorMessage: void 0, url, initiator };
    this.#pageResources.set(key, pageResource);
    this.dispatchEventToListeners(
      "Update"
      /* Events.UPDATE */
    );
    const startTime = performance.now();
    try {
      await this.acquireLoadSlot(initiator.target);
      const resultPromise = this.dispatchLoad(url, initiator, isBinary);
      const result = await resultPromise;
      pageResource.errorMessage = result.errorDescription.message;
      pageResource.success = result.success;
      if (result.success) {
        pageResource.size = result.content.length;
        return { content: result.content };
      }
      throw new Error(result.errorDescription.message);
    } catch (e) {
      if (pageResource.errorMessage === void 0) {
        pageResource.errorMessage = e.message;
      }
      if (pageResource.success === null) {
        pageResource.success = false;
      }
      throw e;
    } finally {
      pageResource.duration = performance.now() - startTime;
      this.releaseLoadSlot(initiator.target);
      this.dispatchEventToListeners(
        "Update"
        /* Events.UPDATE */
      );
    }
  }
  async dispatchLoad(url, initiator, isBinary) {
    if (isExtensionInitiator(initiator)) {
      throw new Error("Invalid initiator");
    }
    const failureReason = null;
    if (this.#loadOverride) {
      return await this.#loadOverride(url);
    }
    const parsedURL = new Common11.ParsedURL.ParsedURL(url);
    const eligibleForLoadFromTarget = getLoadThroughTargetSetting().get() && parsedURL && parsedURL.scheme !== "file" && parsedURL.scheme !== "data" && parsedURL.scheme !== "devtools";
    Host3.userMetrics.developerResourceScheme(this.getDeveloperResourceScheme(parsedURL));
    if (eligibleForLoadFromTarget) {
      try {
        if (initiator.target) {
          Host3.userMetrics.developerResourceLoaded(
            0
            /* Host.UserMetrics.DeveloperResourceLoaded.LOAD_THROUGH_PAGE_VIA_TARGET */
          );
          const result2 = await this.loadFromTarget(initiator.target, initiator.frameId, url, isBinary);
          return result2;
        }
        const frame = FrameManager.instance().getFrame(initiator.frameId);
        if (frame) {
          Host3.userMetrics.developerResourceLoaded(
            1
            /* Host.UserMetrics.DeveloperResourceLoaded.LOAD_THROUGH_PAGE_VIA_FRAME */
          );
          const result2 = await this.loadFromTarget(frame.resourceTreeModel().target(), initiator.frameId, url, isBinary);
          return result2;
        }
      } catch (e) {
        if (e instanceof Error) {
          Host3.userMetrics.developerResourceLoaded(
            2
            /* Host.UserMetrics.DeveloperResourceLoaded.LOAD_THROUGH_PAGE_FAILURE */
          );
          if (e.message.includes("CSP violation")) {
            return {
              success: false,
              content: "",
              errorDescription: { statusCode: 0, netError: void 0, netErrorName: void 0, message: e.message, urlValid: void 0 }
            };
          }
        }
      }
      Host3.userMetrics.developerResourceLoaded(
        3
        /* Host.UserMetrics.DeveloperResourceLoaded.LOAD_THROUGH_PAGE_FALLBACK */
      );
    } else {
      const code = getLoadThroughTargetSetting().get() ? 6 : 5;
      Host3.userMetrics.developerResourceLoaded(code);
    }
    const result = await MultitargetNetworkManager.instance().loadResource(url);
    if (eligibleForLoadFromTarget && !result.success) {
      Host3.userMetrics.developerResourceLoaded(
        7
        /* Host.UserMetrics.DeveloperResourceLoaded.FALLBACK_FAILURE */
      );
    }
    if (failureReason) {
      result.errorDescription.message = `Fetch through target failed: ${failureReason}; Fallback: ${result.errorDescription.message}`;
    }
    return result;
  }
  getDeveloperResourceScheme(parsedURL) {
    if (!parsedURL || parsedURL.scheme === "") {
      return 1;
    }
    const isLocalhost = parsedURL.host === "localhost" || parsedURL.host.endsWith(".localhost");
    switch (parsedURL.scheme) {
      case "file":
        return 7;
      case "data":
        return 6;
      case "blob":
        return 8;
      case "http":
        return isLocalhost ? 4 : 2;
      case "https":
        return isLocalhost ? 5 : 3;
    }
    return 0;
  }
  async loadFromTarget(target, frameId, url, isBinary) {
    const networkManager = target.model(NetworkManager);
    const ioModel = target.model(IOModel);
    const disableCache = Common11.Settings.Settings.instance().moduleSetting("cache-disabled").get();
    const resource = await networkManager.loadNetworkResource(frameId, url, { disableCache, includeCredentials: true });
    try {
      const content = resource.stream ? isBinary ? await ioModel.readToBuffer(resource.stream) : await ioModel.readToString(resource.stream) : "";
      return {
        success: resource.success,
        content,
        errorDescription: {
          statusCode: resource.httpStatusCode || 0,
          netError: resource.netError,
          netErrorName: resource.netErrorName,
          message: Host3.ResourceLoader.netErrorToMessage(resource.netError, resource.httpStatusCode, resource.netErrorName) || "",
          urlValid: void 0
        }
      };
    } finally {
      if (resource.stream) {
        void ioModel.close(resource.stream);
      }
    }
  }
};
function getLoadThroughTargetSetting() {
  return Common11.Settings.Settings.instance().createSetting("load-through-target", true);
}

// gen/front_end/core/sdk/SourceMap.js
var SourceMap_exports = {};
__export(SourceMap_exports, {
  SourceMap: () => SourceMap,
  SourceMapEntry: () => SourceMapEntry,
  TokenIterator: () => TokenIterator,
  parseSourceMap: () => parseSourceMap
});
import * as TextUtils16 from "./../../models/text_utils/text_utils.js";
import * as ScopesCodec from "./../../third_party/source-map-scopes-codec/source-map-scopes-codec.js";
import * as Common12 from "./../common/common.js";
import * as Platform8 from "./../platform/platform.js";
import * as Root4 from "./../root/root.js";

// gen/front_end/core/sdk/ScopeTreeCache.js
var ScopeTreeCache_exports = {};
__export(ScopeTreeCache_exports, {
  scopeTreeForScript: () => scopeTreeForScript
});
import * as Formatter from "./../../models/formatter/formatter.js";
import * as TextUtils15 from "./../../models/text_utils/text_utils.js";
var scopeTrees = /* @__PURE__ */ new WeakMap();
function scopeTreeForScript(script) {
  let promise = scopeTrees.get(script);
  if (promise === void 0) {
    promise = script.requestContentData().then((content) => {
      if (TextUtils15.ContentData.ContentData.isError(content)) {
        return null;
      }
      const sourceType = script.isModule ? "module" : "script";
      return Formatter.FormatterWorkerPool.formatterWorkerPool().javaScriptScopeTree(content.text, sourceType).then((scopeTree) => scopeTree ? { scopeTree, text: content.textObj } : null).catch(() => null);
    });
    scopeTrees.set(script, promise);
  }
  return promise;
}

// gen/front_end/core/sdk/SourceMapFunctionRanges.js
var SourceMapFunctionRanges_exports = {};
__export(SourceMapFunctionRanges_exports, {
  buildOriginalScopes: () => buildOriginalScopes,
  decodePastaRanges: () => decodePastaRanges
});
function buildOriginalScopes(ranges) {
  validateStartBeforeEnd(ranges);
  ranges.sort((a, b) => comparePositions(a.start, b.start) || comparePositions(b.end, a.end));
  const root = {
    start: { line: 0, column: 0 },
    end: { line: Number.POSITIVE_INFINITY, column: Number.POSITIVE_INFINITY },
    kind: "Global",
    isStackFrame: false,
    children: [],
    variables: []
  };
  const stack = [root];
  for (const range of ranges) {
    let stackTop = stack.at(-1);
    while (true) {
      if (comparePositions(stackTop.end, range.start) <= 0) {
        stack.pop();
        stackTop = stack.at(-1);
      } else {
        break;
      }
    }
    if (comparePositions(range.start, stackTop.end) < 0 && comparePositions(stackTop.end, range.end) < 0) {
      throw new Error(`Range ${JSON.stringify(range)} and ${JSON.stringify(stackTop)} partially overlap.`);
    }
    const scope = createScopeFrom(range);
    stackTop.children.push(scope);
    stack.push(scope);
  }
  const lastChild = root.children.at(-1);
  if (lastChild) {
    root.end = lastChild.end;
  }
  return root;
}
function validateStartBeforeEnd(ranges) {
  for (const range of ranges) {
    if (comparePositions(range.start, range.end) >= 0) {
      throw new Error(`Invalid range. End before start: ${JSON.stringify(range)}`);
    }
  }
}
function createScopeFrom(range) {
  return {
    ...range,
    kind: "Function",
    isStackFrame: true,
    children: [],
    variables: []
  };
}
function decodePastaRanges(encodedRanges, names) {
  const result = [];
  let nameIndex = 0;
  let startLineNumber = 0;
  let startColumnNumber = 0;
  let endLineNumber = 0;
  let endColumnNumber = 0;
  const tokenIter = new TokenIterator(encodedRanges);
  let atStart = true;
  while (tokenIter.hasNext()) {
    if (atStart) {
      atStart = false;
    } else if (tokenIter.peek() === ",") {
      tokenIter.next();
    } else {
      break;
    }
    nameIndex += tokenIter.nextVLQ();
    startLineNumber = endLineNumber + tokenIter.nextVLQ();
    startColumnNumber += tokenIter.nextVLQ();
    endLineNumber = startLineNumber + tokenIter.nextVLQ();
    endColumnNumber += tokenIter.nextVLQ();
    const name = names[nameIndex];
    if (name === void 0) {
      continue;
    }
    result.push({
      start: { line: startLineNumber, column: startColumnNumber },
      end: { line: endLineNumber, column: endColumnNumber },
      name
    });
  }
  return result;
}
function comparePositions(a, b) {
  return a.line - b.line || a.column - b.column;
}

// gen/front_end/core/sdk/SourceMapScopesInfo.js
var SourceMapScopesInfo_exports = {};
__export(SourceMapScopesInfo_exports, {
  SourceMapScopesInfo: () => SourceMapScopesInfo,
  contains: () => contains
});
import * as Formatter2 from "./../../models/formatter/formatter.js";

// gen/front_end/core/sdk/SourceMapScopeChainEntry.js
var SourceMapScopeChainEntry_exports = {};
__export(SourceMapScopeChainEntry_exports, {
  SourceMapScopeChainEntry: () => SourceMapScopeChainEntry
});
import * as i18n7 from "./../i18n/i18n.js";
var UIStrings4 = {
  /**
   * @description Title of a section in the debugger showing local JavaScript variables.
   */
  local: "Local",
  /**
   * @description Text that refers to closure as a programming term
   */
  closure: "Closure",
  /**
   * @description Noun that represents a section or block of code in the Debugger Model. Shown in the Sources tab, while paused on a breakpoint.
   */
  block: "Block",
  /**
   * @description Title of a section in the debugger showing JavaScript variables from the global scope.
   */
  global: "Global",
  /**
   * @description Text in Scope Chain Sidebar Pane of the Sources panel
   */
  returnValue: "Return value"
};
var str_4 = i18n7.i18n.registerUIStrings("core/sdk/SourceMapScopeChainEntry.ts", UIStrings4);
var i18nString4 = i18n7.i18n.getLocalizedString.bind(void 0, str_4);
var SourceMapScopeChainEntry = class {
  #callFrame;
  #scope;
  #range;
  #isInnerMostFunction;
  #returnValue;
  /**
   * @param isInnerMostFunction If `scope` is the innermost 'function' scope. Only used for labeling as we name the
   * scope of the paused function 'Local', while other outer 'function' scopes are named 'Closure'.
   */
  constructor(callFrame, scope, range, isInnerMostFunction, returnValue) {
    this.#callFrame = callFrame;
    this.#scope = scope;
    this.#range = range;
    this.#isInnerMostFunction = isInnerMostFunction;
    this.#returnValue = returnValue;
  }
  extraProperties() {
    if (this.#returnValue) {
      return [new RemoteObjectProperty(
        i18nString4(UIStrings4.returnValue),
        this.#returnValue,
        void 0,
        void 0,
        void 0,
        void 0,
        void 0,
        /* synthetic */
        true
      )];
    }
    return [];
  }
  callFrame() {
    return this.#callFrame;
  }
  type() {
    switch (this.#scope.kind) {
      case "global":
        return "global";
      case "function":
        return this.#isInnerMostFunction ? "local" : "closure";
      case "block":
        return "block";
    }
    return this.#scope.kind ?? "";
  }
  typeName() {
    switch (this.#scope.kind) {
      case "global":
        return i18nString4(UIStrings4.global);
      case "function":
        return this.#isInnerMostFunction ? i18nString4(UIStrings4.local) : i18nString4(UIStrings4.closure);
      case "block":
        return i18nString4(UIStrings4.block);
    }
    return this.#scope.kind ?? "";
  }
  name() {
    return this.#scope.name;
  }
  range() {
    return null;
  }
  object() {
    return new SourceMapScopeRemoteObject(this.#callFrame, this.#scope, this.#range);
  }
  description() {
    return "";
  }
  icon() {
    return void 0;
  }
};
var SourceMapScopeRemoteObject = class _SourceMapScopeRemoteObject extends RemoteObjectImpl {
  #callFrame;
  #scope;
  #range;
  constructor(callFrame, scope, range) {
    super(
      callFrame.debuggerModel.runtimeModel(),
      /* objectId */
      void 0,
      "object",
      /* sub type */
      void 0,
      /* value */
      null
    );
    this.#callFrame = callFrame;
    this.#scope = scope;
    this.#range = range;
  }
  async doGetProperties(_ownProperties, accessorPropertiesOnly, generatePreview) {
    if (accessorPropertiesOnly) {
      return { properties: [], internalProperties: [] };
    }
    const properties = [];
    for (const [index, variable] of this.#scope.variables.entries()) {
      const expression = this.#findExpression(index);
      if (expression === null) {
        properties.push(_SourceMapScopeRemoteObject.#unavailableProperty(variable));
        continue;
      }
      const result = await this.#callFrame.evaluate({ expression, generatePreview });
      if ("error" in result || result.exceptionDetails) {
        properties.push(_SourceMapScopeRemoteObject.#unavailableProperty(variable));
      } else {
        properties.push(new RemoteObjectProperty(
          variable,
          result.object,
          /* enumerable */
          false,
          /* writable */
          false,
          /* isOwn */
          true,
          /* wasThrown */
          false
        ));
      }
    }
    return { properties, internalProperties: [] };
  }
  /** @returns null if the variable is unavailable at the current paused location */
  #findExpression(index) {
    if (!this.#range) {
      return null;
    }
    const expressionOrSubRanges = this.#range.values[index];
    if (typeof expressionOrSubRanges === "string") {
      return expressionOrSubRanges;
    }
    if (expressionOrSubRanges === null) {
      return null;
    }
    const pausedPosition = this.#callFrame.location();
    for (const range of expressionOrSubRanges) {
      if (contains({ start: range.from, end: range.to }, pausedPosition.lineNumber, pausedPosition.columnNumber)) {
        return range.value ?? null;
      }
    }
    return null;
  }
  static #unavailableProperty(name) {
    return new RemoteObjectProperty(
      name,
      null,
      /* enumerable */
      false,
      /* writeable */
      false,
      /* isOwn */
      true,
      /* wasThrown */
      false
    );
  }
};

// gen/front_end/core/sdk/SourceMapScopesInfo.js
var SourceMapScopesInfo = class _SourceMapScopesInfo {
  #sourceMap;
  #originalScopes;
  #generatedRanges;
  #cachedVariablesAndBindingsPresent = null;
  constructor(sourceMap, scopeInfo) {
    this.#sourceMap = sourceMap;
    this.#originalScopes = scopeInfo.scopes;
    this.#generatedRanges = scopeInfo.ranges;
  }
  /**
   * If the source map does not contain any scopes information, this factory function attempts to create bare bones scope information
   * via the script's AST combined with the mappings.
   *
   * We create the generated ranges from the scope tree and for each range we create an original scope that matches the bounds 1:1.
   * We don't map the bounds via mappings as mappings are often iffy and it's not strictly required to translate stack traces where we
   * map call-sites separately.
   */
  static createFromAst(sourceMap, scopeTree, text) {
    const { scope, range } = convertScope(scopeTree, void 0, void 0);
    return new _SourceMapScopesInfo(sourceMap, { scopes: [scope], ranges: [range] });
    function convertScope(node, parentScope, parentRange) {
      const start = positionFromOffset(node.start);
      const end = positionFromOffset(node.end);
      const isStackFrame = node.kind === 2;
      const scope2 = {
        start,
        end,
        name: sourceMap.findEntry(start.line, start.column, 0)?.name,
        isStackFrame,
        variables: [],
        children: []
      };
      const range2 = {
        start,
        end,
        originalScope: scope2,
        isStackFrame,
        isHidden: false,
        values: [],
        children: []
      };
      parentRange?.children.push(range2);
      parentScope?.children.push(scope2);
      node.children.forEach((child) => convertScope(child, scope2, range2));
      return { scope: scope2, range: range2 };
    }
    function positionFromOffset(offset) {
      const location = text.positionFromOffset(offset);
      return { line: location.lineNumber, column: location.columnNumber };
    }
  }
  addOriginalScopes(scopes) {
    for (const scope of scopes) {
      this.#originalScopes.push(scope);
    }
  }
  addGeneratedRanges(ranges) {
    for (const range of ranges) {
      this.#generatedRanges.push(range);
    }
  }
  hasOriginalScopes(sourceIdx) {
    return Boolean(this.#originalScopes[sourceIdx]);
  }
  isEmpty() {
    return !this.#originalScopes.length && !this.#generatedRanges.length;
  }
  addOriginalScopesAtIndex(sourceIdx, scope) {
    if (!this.#originalScopes[sourceIdx]) {
      this.#originalScopes[sourceIdx] = scope;
    } else {
      throw new Error(`Trying to re-augment existing scopes for source at index: ${sourceIdx}`);
    }
  }
  /**
   * @returns true, iff the function surrounding the provided position is marked as "hidden".
   */
  isOutlinedFrame(generatedLine, generatedColumn) {
    const rangeChain = this.#findGeneratedRangeChain(generatedLine, generatedColumn);
    return this.#isOutlinedFrame(rangeChain);
  }
  #isOutlinedFrame(rangeChain) {
    for (let i = rangeChain.length - 1; i >= 0; --i) {
      if (rangeChain[i].isStackFrame) {
        return rangeChain[i].isHidden;
      }
    }
    return false;
  }
  /**
   * @returns true, iff the range surrounding the provided position contains multiple
   * inlined original functions.
   */
  hasInlinedFrames(generatedLine, generatedColumn) {
    const rangeChain = this.#findGeneratedRangeChain(generatedLine, generatedColumn);
    for (let i = rangeChain.length - 1; i >= 0; --i) {
      if (rangeChain[i].isStackFrame) {
        return false;
      }
      if (rangeChain[i].callSite) {
        return true;
      }
    }
    return false;
  }
  /**
   * Given a generated position, returns the original name of the surrounding function as well as
   * all the original function names that got inlined into the surrounding generated function and their
   * respective callsites in the original code (ordered from inner to outer).
   *
   * @returns a list with inlined functions. Every entry in the list has a callsite in the orignal code,
   * except the last function (since the last function didn't get inlined).
   */
  findInlinedFunctions(generatedLine, generatedColumn) {
    const rangeChain = this.#findGeneratedRangeChain(generatedLine, generatedColumn);
    const result = {
      inlinedFunctions: [],
      originalFunctionName: ""
    };
    for (let i = rangeChain.length - 1; i >= 0; --i) {
      const range = rangeChain[i];
      if (range.callSite) {
        result.inlinedFunctions.push({
          name: range.originalScope?.name ?? "",
          callsite: { ...range.callSite, sourceURL: this.#sourceMap.sourceURLForSourceIndex(range.callSite.sourceIndex) }
        });
      }
      if (range.isStackFrame) {
        result.originalFunctionName = range.originalScope?.name ?? "";
        break;
      }
    }
    return result;
  }
  /**
   * Takes a V8 provided call frame and expands any inlined frames into virtual call frames.
   *
   * For call frames where nothing was inlined, the result contains only a single element,
   * the provided frame but with the original name.
   *
   * For call frames where we are paused in inlined code, this function returns a list of
   * call frames from "inner to outer". This is the call frame at index 0
   * signifies the top of this stack trace fragment.
   *
   * The rest are "virtual" call frames and will have an "inlineFrameIndex" set in ascending
   * order, so the condition `result[index] === result[index].inlineFrameIndex` always holds.
   */
  expandCallFrame(callFrame) {
    const { originalFunctionName, inlinedFunctions } = this.findInlinedFunctions(callFrame.location().lineNumber, callFrame.location().columnNumber);
    const result = [];
    for (const [index, fn] of inlinedFunctions.entries()) {
      result.push(callFrame.createVirtualCallFrame(index, fn.name));
    }
    result.push(callFrame.createVirtualCallFrame(result.length, originalFunctionName));
    return result;
  }
  /**
   * Given a generated position, this returns all the surrounding generated ranges from outer
   * to inner.
   */
  #findGeneratedRangeChain(line, column) {
    const result = [];
    (function walkRanges(ranges) {
      for (const range of ranges) {
        if (!contains(range, line, column)) {
          continue;
        }
        result.push(range);
        walkRanges(range.children);
      }
    })(this.#generatedRanges);
    return result;
  }
  /**
   * @returns true if we have enough info (i.e. variable and binding expressions) to build
   * a scope view.
   */
  hasVariablesAndBindings() {
    if (this.#cachedVariablesAndBindingsPresent === null) {
      this.#cachedVariablesAndBindingsPresent = this.#areVariablesAndBindingsPresent();
    }
    return this.#cachedVariablesAndBindingsPresent;
  }
  #areVariablesAndBindingsPresent() {
    function walkTree(nodes) {
      for (const node of nodes) {
        if (!node) {
          continue;
        }
        if ("variables" in node && node.variables.length > 0) {
          return true;
        }
        if ("values" in node && node.values.some((v) => v !== null)) {
          return true;
        }
        if (walkTree(node.children)) {
          return true;
        }
      }
      return false;
    }
    return walkTree(this.#originalScopes) && walkTree(this.#generatedRanges);
  }
  /**
   * Constructs a scope chain based on the CallFrame's paused position.
   *
   * The algorithm to obtain the original scope chain is straight-forward:
   *
   *   1) Find the inner-most generated range that contains the CallFrame's
   *      paused position.
   *
   *   2) Does the found range have an associated original scope?
   *
   *      2a) If no, return null. This is a "hidden" range and technically
   *          we shouldn't be pausing here in the first place. This code doesn't
   *          correspond to anything in the authored code.
   *
   *      2b) If yes, the associated original scope is the inner-most
   *          original scope in the resulting scope chain.
   *
   *   3) Walk the parent chain of the found original scope outwards. This is
   *      our scope view. For each original scope we also try to find a
   *      corresponding generated range that contains the CallFrame's
   *      paused position. We need the generated range to resolve variable
   *      values.
   */
  resolveMappedScopeChain(callFrame) {
    const rangeChain = this.#findGeneratedRangeChainForFrame(callFrame);
    const innerMostOriginalScope = rangeChain.at(-1)?.originalScope;
    if (innerMostOriginalScope === void 0) {
      return null;
    }
    let seenFunctionScope = false;
    const result = [];
    for (let originalScope = rangeChain.at(-1)?.originalScope; originalScope; originalScope = originalScope.parent) {
      const range = rangeChain.findLast((r) => r.originalScope === originalScope);
      const isFunctionScope = originalScope.kind === "function";
      const isInnerMostFunction = isFunctionScope && !seenFunctionScope;
      const returnValue = isInnerMostFunction ? callFrame.returnValue() : null;
      result.push(new SourceMapScopeChainEntry(callFrame, originalScope, range, isInnerMostFunction, returnValue ?? void 0));
      seenFunctionScope ||= isFunctionScope;
    }
    if (callFrame.returnValue() !== null) {
      while (result.length && result[0].type() !== "local") {
        result.shift();
      }
    }
    return result;
  }
  /** Similar to #findGeneratedRangeChain, but takes inlineFrameIndex of virtual call frames into account */
  #findGeneratedRangeChainForFrame(callFrame) {
    const rangeChain = this.#findGeneratedRangeChain(callFrame.location().lineNumber, callFrame.location().columnNumber);
    if (callFrame.inlineFrameIndex === 0) {
      return rangeChain;
    }
    for (let inlineIndex = 0; inlineIndex < callFrame.inlineFrameIndex; ) {
      const range = rangeChain.pop();
      if (range?.callSite) {
        ++inlineIndex;
      }
    }
    return rangeChain;
  }
  /**
   * Returns the authored function name of the function containing the provided generated position.
   */
  findOriginalFunctionName({ line, column }) {
    let originalInnerMostScope;
    if (this.#generatedRanges.length > 0) {
      const rangeChain = this.#findGeneratedRangeChain(line, column);
      originalInnerMostScope = rangeChain.at(-1)?.originalScope;
    } else {
      const entry = this.#sourceMap.findEntry(line, column);
      if (entry?.sourceIndex === void 0) {
        return null;
      }
      originalInnerMostScope = this.#findOriginalScopeChain({ sourceIndex: entry.sourceIndex, line: entry.sourceLineNumber, column: entry.sourceColumnNumber }).at(-1);
    }
    return this.#findFunctionNameInOriginalScopeChain(originalInnerMostScope) ?? null;
  }
  /**
   * Given an original position, this returns all the surrounding original scopes from outer
   * to inner.
   */
  #findOriginalScopeChain({ sourceIndex, line, column }) {
    const scope = this.#originalScopes[sourceIndex];
    if (!scope) {
      return [];
    }
    const result = [];
    (function walkScopes(scopes) {
      for (const scope2 of scopes) {
        if (!contains(scope2, line, column)) {
          continue;
        }
        result.push(scope2);
        walkScopes(scope2.children);
      }
    })([scope]);
    return result;
  }
  #findFunctionNameInOriginalScopeChain(innerOriginalScope) {
    for (let originalScope = innerOriginalScope; originalScope; originalScope = originalScope.parent) {
      if (originalScope.isStackFrame) {
        return originalScope.name ?? "";
      }
    }
    return null;
  }
  /**
   * Returns one or more original stack frames for this single "raw frame" or call-site.
   *
   * @returns An empty array if no mapping at the call-site was found, or the resulting frames
   * in top-to-bottom order in case of inlining.
   * @throws If this range is marked "hidden". Outlining needs to be handled externally as
   * outlined function segments in stack traces can span across bundles.
   */
  translateCallSite(generatedLine, generatedColumn) {
    const rangeChain = this.#findGeneratedRangeChain(generatedLine, generatedColumn);
    if (this.#isOutlinedFrame(rangeChain)) {
      throw new Error("SourceMapScopesInfo is unable to translate an outlined function by itself");
    }
    const mapping = this.#sourceMap.findEntry(generatedLine, generatedColumn);
    if (mapping?.sourceIndex === void 0) {
      return [];
    }
    const result = [{
      line: mapping.sourceLineNumber,
      column: mapping.sourceColumnNumber,
      name: this.findOriginalFunctionName({ line: generatedLine, column: generatedColumn }) ?? void 0,
      url: mapping.sourceURL
    }];
    for (let i = rangeChain.length - 1; i >= 0 && !rangeChain[i].isStackFrame; --i) {
      const range = rangeChain[i];
      if (!range.callSite) {
        continue;
      }
      const originalScopeChain = this.#findOriginalScopeChain(range.callSite);
      result.push({
        line: range.callSite.line,
        column: range.callSite.column,
        name: this.#findFunctionNameInOriginalScopeChain(originalScopeChain.at(-1)) ?? void 0,
        url: this.#sourceMap.sourceURLForSourceIndex(range.callSite.sourceIndex)
      });
    }
    return result;
  }
};
function contains(range, line, column) {
  if (range.start.line > line || range.start.line === line && range.start.column > column) {
    return false;
  }
  if (range.end.line < line || range.end.line === line && range.end.column <= column) {
    return false;
  }
  return true;
}

// gen/front_end/core/sdk/SourceMap.js
var _a2;
function parseSourceMap(content) {
  if (content.startsWith(")]}")) {
    content = content.substring(content.indexOf("\n"));
  }
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return JSON.parse(content);
}
var SourceMapEntry = class {
  lineNumber;
  columnNumber;
  sourceIndex;
  sourceURL;
  sourceLineNumber;
  sourceColumnNumber;
  name;
  constructor(lineNumber, columnNumber, sourceIndex, sourceURL, sourceLineNumber, sourceColumnNumber, name) {
    this.lineNumber = lineNumber;
    this.columnNumber = columnNumber;
    this.sourceIndex = sourceIndex;
    this.sourceURL = sourceURL;
    this.sourceLineNumber = sourceLineNumber;
    this.sourceColumnNumber = sourceColumnNumber;
    this.name = name;
  }
  static compare(entry1, entry2) {
    if (entry1.lineNumber !== entry2.lineNumber) {
      return entry1.lineNumber - entry2.lineNumber;
    }
    return entry1.columnNumber - entry2.columnNumber;
  }
};
var SourceMap = class {
  static retainRawSourceMaps = false;
  #json;
  #compiledURL;
  #sourceMappingURL;
  #baseURL;
  #mappings = null;
  #sourceInfos = [];
  #sourceInfoByURL = /* @__PURE__ */ new Map();
  #script;
  #scopesInfo = null;
  #debugId;
  scopesFallbackPromiseForTest;
  /**
   * Implements Source Map V3 model. See https://github.com/google/closure-compiler/wiki/Source-Maps
   * for format description.
   */
  constructor(compiledURL, sourceMappingURL, payload, script) {
    this.#json = payload;
    this.#script = script;
    this.#compiledURL = compiledURL;
    this.#sourceMappingURL = sourceMappingURL;
    this.#baseURL = Common12.ParsedURL.schemeIs(sourceMappingURL, "data:") ? compiledURL : sourceMappingURL;
    this.#debugId = "debugId" in payload ? payload.debugId : void 0;
    if ("sections" in this.#json) {
      if (this.#json.sections.find((section) => "url" in section)) {
        Common12.Console.Console.instance().warn(`SourceMap "${sourceMappingURL}" contains unsupported "URL" field in one of its sections.`);
      }
    }
    this.eachSection(this.parseSources.bind(this));
  }
  json() {
    return this.#json;
  }
  augmentWithScopes(scriptUrl, ranges) {
    this.#ensureSourceMapProcessed();
    if (this.#json && this.#json.version > 3) {
      throw new Error("Only support augmenting source maps up to version 3.");
    }
    const sourceIdx = this.#sourceIndex(scriptUrl);
    if (sourceIdx >= 0) {
      if (!this.#scopesInfo) {
        this.#scopesInfo = new SourceMapScopesInfo(this, { scopes: [], ranges: [] });
      }
      if (!this.#scopesInfo.hasOriginalScopes(sourceIdx)) {
        const originalScopes = buildOriginalScopes(ranges);
        this.#scopesInfo.addOriginalScopesAtIndex(sourceIdx, originalScopes);
      }
    } else {
      throw new Error(`Could not find sourceURL ${scriptUrl} in sourceMap`);
    }
  }
  #sourceIndex(sourceURL) {
    return this.#sourceInfos.findIndex((info) => info.sourceURL === sourceURL);
  }
  compiledURL() {
    return this.#compiledURL;
  }
  url() {
    return this.#sourceMappingURL;
  }
  debugId() {
    return this.#debugId ?? null;
  }
  sourceURLForSourceIndex(index) {
    return this.#sourceInfos[index]?.sourceURL;
  }
  sourceURLs() {
    return [...this.#sourceInfoByURL.keys()];
  }
  embeddedContentByURL(sourceURL) {
    const entry = this.#sourceInfoByURL.get(sourceURL);
    if (!entry) {
      return null;
    }
    return entry.content;
  }
  hasScopeInfo() {
    this.#ensureSourceMapProcessed();
    return this.#scopesInfo !== null && !this.#scopesInfo.isEmpty();
  }
  findEntry(lineNumber, columnNumber, inlineFrameIndex) {
    this.#ensureSourceMapProcessed();
    if (inlineFrameIndex && this.#scopesInfo !== null) {
      const { inlinedFunctions } = this.#scopesInfo.findInlinedFunctions(lineNumber, columnNumber);
      const { callsite } = inlinedFunctions[inlineFrameIndex - 1];
      if (!callsite) {
        console.error("Malformed source map. Expected to have a callsite info for index", inlineFrameIndex);
        return null;
      }
      return {
        lineNumber,
        columnNumber,
        sourceIndex: callsite.sourceIndex,
        sourceURL: this.sourceURLs()[callsite.sourceIndex],
        sourceLineNumber: callsite.line,
        sourceColumnNumber: callsite.column,
        name: void 0
      };
    }
    const mappings = this.mappings();
    const index = Platform8.ArrayUtilities.upperBound(mappings, void 0, (_, entry) => lineNumber - entry.lineNumber || columnNumber - entry.columnNumber);
    return index ? mappings[index - 1] : null;
  }
  findEntryRanges(lineNumber, columnNumber) {
    const mappings = this.mappings();
    const endIndex = Platform8.ArrayUtilities.upperBound(mappings, void 0, (_, entry) => lineNumber - entry.lineNumber || columnNumber - entry.columnNumber);
    if (!endIndex) {
      return null;
    }
    const startIndex = endIndex - 1;
    const sourceURL = mappings[startIndex].sourceURL;
    if (!sourceURL) {
      return null;
    }
    const endLine = endIndex < mappings.length ? mappings[endIndex].lineNumber : 2 ** 31 - 1;
    const endColumn = endIndex < mappings.length ? mappings[endIndex].columnNumber : 2 ** 31 - 1;
    const range = new TextUtils16.TextRange.TextRange(mappings[startIndex].lineNumber, mappings[startIndex].columnNumber, endLine, endColumn);
    const reverseMappings = this.reversedMappings(sourceURL);
    const startSourceLine = mappings[startIndex].sourceLineNumber;
    const startSourceColumn = mappings[startIndex].sourceColumnNumber;
    const endReverseIndex = Platform8.ArrayUtilities.upperBound(reverseMappings, void 0, (_, i) => startSourceLine - mappings[i].sourceLineNumber || startSourceColumn - mappings[i].sourceColumnNumber);
    if (!endReverseIndex) {
      return null;
    }
    const endSourceLine = endReverseIndex < reverseMappings.length ? mappings[reverseMappings[endReverseIndex]].sourceLineNumber : 2 ** 31 - 1;
    const endSourceColumn = endReverseIndex < reverseMappings.length ? mappings[reverseMappings[endReverseIndex]].sourceColumnNumber : 2 ** 31 - 1;
    const sourceRange = new TextUtils16.TextRange.TextRange(startSourceLine, startSourceColumn, endSourceLine, endSourceColumn);
    return { range, sourceRange, sourceURL };
  }
  sourceLineMapping(sourceURL, lineNumber, columnNumber) {
    const mappings = this.mappings();
    const reverseMappings = this.reversedMappings(sourceURL);
    const first = Platform8.ArrayUtilities.lowerBound(reverseMappings, lineNumber, lineComparator);
    const last = Platform8.ArrayUtilities.upperBound(reverseMappings, lineNumber, lineComparator);
    if (first >= reverseMappings.length || mappings[reverseMappings[first]].sourceLineNumber !== lineNumber) {
      return null;
    }
    const columnMappings = reverseMappings.slice(first, last);
    if (!columnMappings.length) {
      return null;
    }
    const index = Platform8.ArrayUtilities.lowerBound(columnMappings, columnNumber, (columnNumber2, i) => columnNumber2 - mappings[i].sourceColumnNumber);
    return index >= columnMappings.length ? mappings[columnMappings[columnMappings.length - 1]] : mappings[columnMappings[index]];
    function lineComparator(lineNumber2, i) {
      return lineNumber2 - mappings[i].sourceLineNumber;
    }
  }
  findReverseIndices(sourceURL, lineNumber, columnNumber) {
    const mappings = this.mappings();
    const reverseMappings = this.reversedMappings(sourceURL);
    const endIndex = Platform8.ArrayUtilities.upperBound(reverseMappings, void 0, (_, i) => lineNumber - mappings[i].sourceLineNumber || columnNumber - mappings[i].sourceColumnNumber);
    let startIndex = endIndex;
    while (startIndex > 0 && mappings[reverseMappings[startIndex - 1]].sourceLineNumber === mappings[reverseMappings[endIndex - 1]].sourceLineNumber && mappings[reverseMappings[startIndex - 1]].sourceColumnNumber === mappings[reverseMappings[endIndex - 1]].sourceColumnNumber) {
      --startIndex;
    }
    return reverseMappings.slice(startIndex, endIndex);
  }
  findReverseEntries(sourceURL, lineNumber, columnNumber) {
    const mappings = this.mappings();
    return this.findReverseIndices(sourceURL, lineNumber, columnNumber).map((i) => mappings[i]);
  }
  findReverseRanges(sourceURL, lineNumber, columnNumber) {
    const mappings = this.mappings();
    const indices = this.findReverseIndices(sourceURL, lineNumber, columnNumber);
    const ranges = [];
    for (let i = 0; i < indices.length; ++i) {
      const startIndex = indices[i];
      let endIndex = startIndex + 1;
      while (i + 1 < indices.length && endIndex === indices[i + 1]) {
        ++endIndex;
        ++i;
      }
      const startLine = mappings[startIndex].lineNumber;
      const startColumn = mappings[startIndex].columnNumber;
      const endLine = endIndex < mappings.length ? mappings[endIndex].lineNumber : 2 ** 31 - 1;
      const endColumn = endIndex < mappings.length ? mappings[endIndex].columnNumber : 2 ** 31 - 1;
      ranges.push(new TextUtils16.TextRange.TextRange(startLine, startColumn, endLine, endColumn));
    }
    return ranges;
  }
  mappings() {
    this.#ensureSourceMapProcessed();
    return this.#mappings ?? [];
  }
  /**
   * If the source map does not contain scope information by itself (e.g. "scopes proposal"
   * or "pasta" scopes), then we'll use this getter to calculate basic function name information from
   * the AST and mappings.
   */
  async #buildScopesFallback() {
    const scopeTreeAndText = this.#script ? await scopeTreeForScript(this.#script) : null;
    if (!scopeTreeAndText) {
      return null;
    }
    const { scopeTree, text } = scopeTreeAndText;
    return SourceMapScopesInfo.createFromAst(this, scopeTree, text);
  }
  reversedMappings(sourceURL) {
    this.#ensureSourceMapProcessed();
    return this.#sourceInfoByURL.get(sourceURL)?.reverseMappings ?? [];
  }
  #ensureSourceMapProcessed() {
    if (this.#mappings === null) {
      this.#mappings = [];
      try {
        this.eachSection(this.parseMap.bind(this));
        if (!this.hasScopeInfo()) {
          this.scopesFallbackPromiseForTest = this.#buildScopesFallback().then((info) => {
            this.#scopesInfo = info;
          });
        }
      } catch (e) {
        console.error("Failed to parse source map", e);
        this.#mappings = [];
      }
      this.mappings().sort(SourceMapEntry.compare);
      this.#computeReverseMappings(this.#mappings);
    }
    if (!_a2.retainRawSourceMaps) {
      this.#json = null;
    }
  }
  #computeReverseMappings(mappings) {
    const reverseMappingsPerUrl = /* @__PURE__ */ new Map();
    for (let i = 0; i < mappings.length; i++) {
      const entryUrl = mappings[i]?.sourceURL;
      if (!entryUrl) {
        continue;
      }
      let reverseMap = reverseMappingsPerUrl.get(entryUrl);
      if (!reverseMap) {
        reverseMap = [];
        reverseMappingsPerUrl.set(entryUrl, reverseMap);
      }
      reverseMap.push(i);
    }
    for (const [url, reverseMap] of reverseMappingsPerUrl.entries()) {
      const info = this.#sourceInfoByURL.get(url);
      if (!info) {
        continue;
      }
      reverseMap.sort(sourceMappingComparator);
      info.reverseMappings = reverseMap;
    }
    function sourceMappingComparator(indexA, indexB) {
      const a = mappings[indexA];
      const b = mappings[indexB];
      return a.sourceLineNumber - b.sourceLineNumber || a.sourceColumnNumber - b.sourceColumnNumber || a.lineNumber - b.lineNumber || a.columnNumber - b.columnNumber;
    }
  }
  eachSection(callback) {
    if (!this.#json) {
      return;
    }
    if ("sections" in this.#json) {
      let sourcesIndex = 0;
      for (const section of this.#json.sections) {
        if ("map" in section) {
          callback(section.map, sourcesIndex, section.offset.line, section.offset.column);
          sourcesIndex += section.map.sources.length;
        }
      }
    } else {
      callback(this.#json, 0, 0, 0);
    }
  }
  parseSources(sourceMap) {
    const sourceRoot = sourceMap.sourceRoot ?? "";
    const ignoreList = new Set(sourceMap.ignoreList ?? sourceMap.x_google_ignoreList);
    for (let i = 0; i < sourceMap.sources.length; ++i) {
      let href = sourceMap.sources[i];
      if (Common12.ParsedURL.ParsedURL.isRelativeURL(href)) {
        if (sourceRoot && !sourceRoot.endsWith("/") && href && !href.startsWith("/")) {
          href = sourceRoot.concat("/", href);
        } else {
          href = sourceRoot.concat(href);
        }
      }
      const url = Common12.ParsedURL.ParsedURL.completeURL(this.#baseURL, href) || href;
      const source = sourceMap.sourcesContent?.[i];
      const sourceInfo = {
        sourceURL: url,
        content: source ?? null,
        ignoreListHint: ignoreList.has(i),
        reverseMappings: null
      };
      this.#sourceInfos.push(sourceInfo);
      if (!this.#sourceInfoByURL.has(url)) {
        this.#sourceInfoByURL.set(url, sourceInfo);
      }
    }
  }
  parseMap(map, baseSourceIndex, baseLineNumber, baseColumnNumber) {
    let sourceIndex = baseSourceIndex;
    let lineNumber = baseLineNumber;
    let columnNumber = baseColumnNumber;
    let sourceLineNumber = 0;
    let sourceColumnNumber = 0;
    let nameIndex = 0;
    const names = map.names ?? [];
    const tokenIter = new TokenIterator(map.mappings);
    let sourceURL = this.#sourceInfos[sourceIndex]?.sourceURL;
    while (true) {
      if (tokenIter.peek() === ",") {
        tokenIter.next();
      } else {
        while (tokenIter.peek() === ";") {
          lineNumber += 1;
          columnNumber = 0;
          tokenIter.next();
        }
        if (!tokenIter.hasNext()) {
          break;
        }
      }
      columnNumber += tokenIter.nextVLQ();
      if (!tokenIter.hasNext() || this.isSeparator(tokenIter.peek())) {
        this.mappings().push(new SourceMapEntry(lineNumber, columnNumber));
        continue;
      }
      const sourceIndexDelta = tokenIter.nextVLQ();
      if (sourceIndexDelta) {
        sourceIndex += sourceIndexDelta;
        sourceURL = this.#sourceInfos[sourceIndex]?.sourceURL;
      }
      sourceLineNumber += tokenIter.nextVLQ();
      sourceColumnNumber += tokenIter.nextVLQ();
      if (!tokenIter.hasNext() || this.isSeparator(tokenIter.peek())) {
        this.mappings().push(new SourceMapEntry(lineNumber, columnNumber, sourceIndex, sourceURL, sourceLineNumber, sourceColumnNumber));
        continue;
      }
      nameIndex += tokenIter.nextVLQ();
      this.mappings().push(new SourceMapEntry(lineNumber, columnNumber, sourceIndex, sourceURL, sourceLineNumber, sourceColumnNumber, names[nameIndex]));
    }
    if (Root4.Runtime.experiments.isEnabled(
      "use-source-map-scopes"
      /* Root.Runtime.ExperimentName.USE_SOURCE_MAP_SCOPES */
    )) {
      if (!this.#scopesInfo) {
        this.#scopesInfo = new SourceMapScopesInfo(this, { scopes: [], ranges: [] });
      }
      if (map.scopes) {
        const { scopes, ranges } = ScopesCodec.decode(map, { mode: 2, generatedOffset: { line: baseLineNumber, column: baseColumnNumber } });
        this.#scopesInfo.addOriginalScopes(scopes);
        this.#scopesInfo.addGeneratedRanges(ranges);
      } else if (map.x_com_bloomberg_sourcesFunctionMappings) {
        const originalScopes = this.parseBloombergScopes(map);
        this.#scopesInfo.addOriginalScopes(originalScopes);
      } else {
        this.#scopesInfo.addOriginalScopes(new Array(map.sources.length).fill(null));
      }
    }
  }
  parseBloombergScopes(map) {
    const scopeList = map.x_com_bloomberg_sourcesFunctionMappings;
    if (!scopeList) {
      throw new Error("Cant decode pasta scopes without x_com_bloomberg_sourcesFunctionMappings field");
    } else if (scopeList.length !== map.sources.length) {
      throw new Error(`x_com_bloomberg_sourcesFunctionMappings must have ${map.sources.length} scope trees`);
    }
    const names = map.names ?? [];
    return scopeList.map((rawScopes) => {
      if (!rawScopes) {
        return null;
      }
      const ranges = decodePastaRanges(rawScopes, names);
      return buildOriginalScopes(ranges);
    });
  }
  isSeparator(char) {
    return char === "," || char === ";";
  }
  /**
   * Finds all the reverse mappings that intersect with the given `textRange` within the
   * source entity identified by the `url`. If the `url` does not have any reverse mappings
   * within this source map, an empty array is returned.
   *
   * @param url the URL of the source entity to query.
   * @param textRange the range of text within the entity to check, considered `[start,end[`.
   * @returns the list of ranges in the generated file that map to locations overlapping the
   *          {@link textRange} in the source file identified by the {@link url}, or `[]`
   *          if the {@link url} does not identify an entity in this source map.
   */
  reverseMapTextRanges(url, textRange) {
    const reverseMappings = this.reversedMappings(url);
    const mappings = this.mappings();
    if (reverseMappings.length === 0) {
      return [];
    }
    let startReverseIndex = Platform8.ArrayUtilities.lowerBound(reverseMappings, textRange, ({ startLine, startColumn }, index) => {
      const { sourceLineNumber, sourceColumnNumber } = mappings[index];
      return startLine - sourceLineNumber || startColumn - sourceColumnNumber;
    });
    while (startReverseIndex === reverseMappings.length || startReverseIndex > 0 && (mappings[reverseMappings[startReverseIndex]].sourceLineNumber > textRange.startLine || mappings[reverseMappings[startReverseIndex]].sourceColumnNumber > textRange.startColumn)) {
      startReverseIndex--;
    }
    let endReverseIndex = startReverseIndex + 1;
    for (; endReverseIndex < reverseMappings.length; ++endReverseIndex) {
      const { sourceLineNumber, sourceColumnNumber } = mappings[reverseMappings[endReverseIndex]];
      if (sourceLineNumber < textRange.endLine || sourceLineNumber === textRange.endLine && sourceColumnNumber < textRange.endColumn) {
        continue;
      }
      break;
    }
    const ranges = [];
    for (let reverseIndex = startReverseIndex; reverseIndex < endReverseIndex; ++reverseIndex) {
      const startIndex = reverseMappings[reverseIndex], endIndex = startIndex + 1;
      const range = TextUtils16.TextRange.TextRange.createUnboundedFromLocation(mappings[startIndex].lineNumber, mappings[startIndex].columnNumber);
      if (endIndex < mappings.length) {
        range.endLine = mappings[endIndex].lineNumber;
        range.endColumn = mappings[endIndex].columnNumber;
      }
      ranges.push(range);
    }
    ranges.sort(TextUtils16.TextRange.TextRange.comparator);
    let j = 0;
    for (let i = 1; i < ranges.length; ++i) {
      if (ranges[j].immediatelyPrecedes(ranges[i])) {
        ranges[j].endLine = ranges[i].endLine;
        ranges[j].endColumn = ranges[i].endColumn;
      } else {
        ranges[++j] = ranges[i];
      }
    }
    ranges.length = j + 1;
    return ranges;
  }
  mapsOrigin() {
    const mappings = this.mappings();
    if (mappings.length > 0) {
      const firstEntry = mappings[0];
      return firstEntry?.lineNumber === 0 || firstEntry.columnNumber === 0;
    }
    return false;
  }
  hasIgnoreListHint(sourceURL) {
    return this.#sourceInfoByURL.get(sourceURL)?.ignoreListHint ?? false;
  }
  /**
   * Returns a list of ranges in the generated script for original sources that
   * match a predicate. Each range is a [begin, end) pair, meaning that code at
   * the beginning location, up to but not including the end location, matches
   * the predicate.
   */
  findRanges(predicate, options) {
    const mappings = this.mappings();
    const ranges = [];
    if (!mappings.length) {
      return [];
    }
    let current = null;
    if ((mappings[0].lineNumber !== 0 || mappings[0].columnNumber !== 0) && options?.isStartMatching) {
      current = TextUtils16.TextRange.TextRange.createUnboundedFromLocation(0, 0);
      ranges.push(current);
    }
    for (const { sourceURL, lineNumber, columnNumber } of mappings) {
      const ignoreListHint = sourceURL && predicate(sourceURL);
      if (!current && ignoreListHint) {
        current = TextUtils16.TextRange.TextRange.createUnboundedFromLocation(lineNumber, columnNumber);
        ranges.push(current);
        continue;
      }
      if (current && !ignoreListHint) {
        current.endLine = lineNumber;
        current.endColumn = columnNumber;
        current = null;
      }
    }
    return ranges;
  }
  /**
   * Determines whether this and the {@link other} `SourceMap` agree on content and ignore-list hint
   * with respect to the {@link sourceURL}.
   *
   * @param sourceURL the URL to test for (might not be provided by either of the sourcemaps).
   * @param other the other `SourceMap` to check.
   * @returns `true` if both this and the {@link other} `SourceMap` either both have the ignore-list
   *          hint for {@link sourceURL} or neither, and if both of them either provide the same
   *          content for the {@link sourceURL} inline or both provide no `sourcesContent` entry
   *          for it.
   */
  compatibleForURL(sourceURL, other) {
    return this.embeddedContentByURL(sourceURL) === other.embeddedContentByURL(sourceURL) && this.hasIgnoreListHint(sourceURL) === other.hasIgnoreListHint(sourceURL);
  }
  expandCallFrame(frame) {
    this.#ensureSourceMapProcessed();
    if (this.#scopesInfo === null) {
      return [frame];
    }
    return this.#scopesInfo.expandCallFrame(frame);
  }
  resolveScopeChain(frame) {
    this.#ensureSourceMapProcessed();
    if (this.#scopesInfo === null) {
      return null;
    }
    return this.#scopesInfo.resolveMappedScopeChain(frame);
  }
  findOriginalFunctionName(position) {
    this.#ensureSourceMapProcessed();
    return this.#scopesInfo?.findOriginalFunctionName(position) ?? null;
  }
  isOutlinedFrame(generatedLine, generatedColumn) {
    this.#ensureSourceMapProcessed();
    return this.#scopesInfo?.isOutlinedFrame(generatedLine, generatedColumn) ?? false;
  }
  hasInlinedFrames(generatedLine, generatedColumn) {
    this.#ensureSourceMapProcessed();
    return this.#scopesInfo?.hasInlinedFrames(generatedLine, generatedColumn) ?? false;
  }
  translateCallSite(generatedLine, generatedColumn) {
    this.#ensureSourceMapProcessed();
    return this.#scopesInfo?.translateCallSite(generatedLine, generatedColumn) ?? [];
  }
};
_a2 = SourceMap;
var VLQ_BASE_SHIFT = 5;
var VLQ_BASE_MASK = (1 << 5) - 1;
var VLQ_CONTINUATION_MASK = 1 << 5;
var TokenIterator = class {
  #string;
  #position;
  constructor(string) {
    this.#string = string;
    this.#position = 0;
  }
  next() {
    return this.#string.charAt(this.#position++);
  }
  /** Returns the unicode value of the next character and advances the iterator  */
  nextCharCode() {
    return this.#string.charCodeAt(this.#position++);
  }
  peek() {
    return this.#string.charAt(this.#position);
  }
  hasNext() {
    return this.#position < this.#string.length;
  }
  nextVLQ() {
    let result = 0;
    let shift = 0;
    let digit = VLQ_CONTINUATION_MASK;
    while (digit & VLQ_CONTINUATION_MASK) {
      if (!this.hasNext()) {
        throw new Error("Unexpected end of input while decodling VLQ number!");
      }
      const charCode = this.nextCharCode();
      digit = Common12.Base64.BASE64_CODES[charCode];
      if (charCode !== 65 && digit === 0) {
        throw new Error(`Unexpected char '${String.fromCharCode(charCode)}' encountered while decoding`);
      }
      result += (digit & VLQ_BASE_MASK) << shift;
      shift += VLQ_BASE_SHIFT;
    }
    const negative = result & 1;
    result >>= 1;
    return negative ? -result : result;
  }
  /**
   * @returns the next VLQ number without iterating further. Or returns null if
   * the iterator is at the end or it's not a valid number.
   */
  peekVLQ() {
    const pos = this.#position;
    try {
      return this.nextVLQ();
    } catch {
      return null;
    } finally {
      this.#position = pos;
    }
  }
};

// gen/front_end/core/sdk/SourceMapCache.js
var SourceMapCache_exports = {};
__export(SourceMapCache_exports, {
  SourceMapCache: () => SourceMapCache
});
var SourceMapCache = class _SourceMapCache {
  static #INSTANCE = new _SourceMapCache("devtools-source-map-cache");
  static instance() {
    return this.#INSTANCE;
  }
  static createForTest(name) {
    return new _SourceMapCache(name);
  }
  #name;
  #cachePromise;
  constructor(name) {
    this.#name = name;
  }
  async set(debugId, sourceMap) {
    const cache = await this.#cache();
    await cache.put(_SourceMapCache.#urlForDebugId(debugId), new Response(JSON.stringify(sourceMap)));
  }
  async get(debugId) {
    const cache = await this.#cache();
    const response = await cache.match(_SourceMapCache.#urlForDebugId(debugId));
    return await response?.json() ?? null;
  }
  async #cache() {
    if (this.#cachePromise) {
      return await this.#cachePromise;
    }
    this.#cachePromise = window.caches.open(this.#name);
    return await this.#cachePromise;
  }
  /** The Cache API only allows URL as keys, so we construct a simple one. Given that we have our own cache, we have no risk of conflicting URLs */
  static #urlForDebugId(debugId) {
    return "http://debug.id/" + encodeURIComponent(debugId);
  }
  async disposeForTest() {
    await window.caches.delete(this.#name);
  }
};

// gen/front_end/core/sdk/SourceMapManager.js
var SourceMapManager = class _SourceMapManager extends Common13.ObjectWrapper.ObjectWrapper {
  #target;
  #factory;
  #isEnabled = true;
  #clientData = /* @__PURE__ */ new Map();
  #sourceMaps = /* @__PURE__ */ new Map();
  #attachingClient = null;
  constructor(target, factory) {
    super();
    this.#target = target;
    this.#factory = factory ?? ((compiledURL, sourceMappingURL, payload) => new SourceMap(compiledURL, sourceMappingURL, payload));
  }
  setEnabled(isEnabled) {
    if (isEnabled === this.#isEnabled) {
      return;
    }
    const clientData = [...this.#clientData.entries()];
    for (const [client] of clientData) {
      this.detachSourceMap(client);
    }
    this.#isEnabled = isEnabled;
    for (const [client, { relativeSourceURL, relativeSourceMapURL }] of clientData) {
      this.attachSourceMap(client, relativeSourceURL, relativeSourceMapURL);
    }
  }
  static getBaseUrl(target) {
    while (target && target.type() !== Type.FRAME) {
      target = target.parentTarget();
    }
    return target?.inspectedURL() ?? Platform9.DevToolsPath.EmptyUrlString;
  }
  static resolveRelativeSourceURL(target, url) {
    url = Common13.ParsedURL.ParsedURL.completeURL(_SourceMapManager.getBaseUrl(target), url) ?? url;
    return url;
  }
  sourceMapForClient(client) {
    return this.#clientData.get(client)?.sourceMap;
  }
  // This method actively awaits the source map, if still loading.
  sourceMapForClientPromise(client) {
    const clientData = this.#clientData.get(client);
    if (!clientData) {
      return Promise.resolve(void 0);
    }
    return clientData.sourceMapPromise;
  }
  clientForSourceMap(sourceMap) {
    return this.#sourceMaps.get(sourceMap);
  }
  // TODO(bmeurer): We are lying about the type of |relativeSourceURL| here.
  attachSourceMap(client, relativeSourceURL, relativeSourceMapURL) {
    if (this.#clientData.has(client)) {
      throw new Error("SourceMap is already attached or being attached to client");
    }
    if (!relativeSourceMapURL) {
      return;
    }
    let clientData = {
      relativeSourceURL,
      relativeSourceMapURL,
      sourceMap: void 0,
      sourceMapPromise: Promise.resolve(void 0)
    };
    if (this.#isEnabled) {
      const sourceURL = _SourceMapManager.resolveRelativeSourceURL(this.#target, relativeSourceURL);
      const sourceMapURL = Common13.ParsedURL.ParsedURL.completeURL(sourceURL, relativeSourceMapURL);
      if (sourceMapURL) {
        if (this.#attachingClient) {
          console.error("Attaching source map may cancel previously attaching source map");
        }
        this.#attachingClient = client;
        this.dispatchEventToListeners(Events4.SourceMapWillAttach, { client });
        if (this.#attachingClient === client) {
          this.#attachingClient = null;
          const initiator = client.createPageResourceLoadInitiator();
          clientData.sourceMapPromise = loadSourceMap(sourceMapURL, client.debugId(), initiator).then((payload) => {
            const sourceMap = this.#factory(sourceURL, sourceMapURL, payload, client);
            if (this.#clientData.get(client) === clientData) {
              clientData.sourceMap = sourceMap;
              this.#sourceMaps.set(sourceMap, client);
              this.dispatchEventToListeners(Events4.SourceMapAttached, { client, sourceMap });
            }
            return sourceMap;
          }, () => {
            if (this.#clientData.get(client) === clientData) {
              this.dispatchEventToListeners(Events4.SourceMapFailedToAttach, { client });
            }
            return void 0;
          });
        } else {
          if (this.#attachingClient) {
            console.error("Cancelling source map attach because another source map is attaching");
          }
          clientData = null;
          this.dispatchEventToListeners(Events4.SourceMapFailedToAttach, { client });
        }
      }
    }
    if (clientData) {
      this.#clientData.set(client, clientData);
    }
  }
  cancelAttachSourceMap(client) {
    if (client === this.#attachingClient) {
      this.#attachingClient = null;
    } else if (this.#attachingClient) {
      console.error("cancel attach source map requested but a different source map was being attached");
    } else {
      console.error("cancel attach source map requested but no source map was being attached");
    }
  }
  detachSourceMap(client) {
    const clientData = this.#clientData.get(client);
    if (!clientData) {
      return;
    }
    this.#clientData.delete(client);
    if (!this.#isEnabled) {
      return;
    }
    const { sourceMap } = clientData;
    if (sourceMap) {
      this.#sourceMaps.delete(sourceMap);
      this.dispatchEventToListeners(Events4.SourceMapDetached, { client, sourceMap });
    } else {
      this.dispatchEventToListeners(Events4.SourceMapFailedToAttach, { client });
    }
  }
  waitForSourceMapsProcessedForTest() {
    return Promise.all(this.#sourceMaps.keys().map((sourceMap) => sourceMap.scopesFallbackPromiseForTest));
  }
};
async function loadSourceMap(url, debugId, initiator) {
  try {
    if (debugId) {
      const cachedSourceMap = await SourceMapCache.instance().get(debugId);
      if (cachedSourceMap) {
        return cachedSourceMap;
      }
    }
    const { content } = await PageResourceLoader.instance().loadResource(url, initiator);
    const sourceMap = parseSourceMap(content);
    if ("debugId" in sourceMap && sourceMap.debugId) {
      await SourceMapCache.instance().set(sourceMap.debugId, sourceMap).catch();
    }
    return sourceMap;
  } catch (cause) {
    throw new Error(`Could not load content for ${url}: ${cause.message}`, { cause });
  }
}
async function tryLoadSourceMap(url, initiator) {
  try {
    return await loadSourceMap(url, null, initiator);
  } catch (cause) {
    console.error(cause);
    return null;
  }
}
var Events4;
(function(Events12) {
  Events12["SourceMapWillAttach"] = "SourceMapWillAttach";
  Events12["SourceMapFailedToAttach"] = "SourceMapFailedToAttach";
  Events12["SourceMapAttached"] = "SourceMapAttached";
  Events12["SourceMapDetached"] = "SourceMapDetached";
})(Events4 || (Events4 = {}));

// gen/front_end/core/sdk/CSSModel.js
var CSSModel = class _CSSModel extends SDKModel {
  agent;
  #domModel;
  #fontFaces = /* @__PURE__ */ new Map();
  #originalStyleSheetText = /* @__PURE__ */ new Map();
  #resourceTreeModel;
  #sourceMapManager;
  #styleLoader;
  #stylePollingThrottler = new Common14.Throttler.Throttler(StylePollingInterval);
  #styleSheetIdsForURL = /* @__PURE__ */ new Map();
  #styleSheetIdToHeader = /* @__PURE__ */ new Map();
  #cachedMatchedCascadeNode = null;
  #cachedMatchedCascadePromise = null;
  #cssPropertyTracker = null;
  #isCSSPropertyTrackingEnabled = false;
  #isEnabled = false;
  #isRuleUsageTrackingEnabled = false;
  #isTrackingRequestPending = false;
  #colorScheme;
  constructor(target) {
    super(target);
    this.#domModel = target.model(DOMModel);
    this.#sourceMapManager = new SourceMapManager(target);
    this.agent = target.cssAgent();
    this.#styleLoader = new ComputedStyleLoader(this);
    this.#resourceTreeModel = target.model(ResourceTreeModel);
    if (this.#resourceTreeModel) {
      this.#resourceTreeModel.addEventListener(Events3.PrimaryPageChanged, this.onPrimaryPageChanged, this);
    }
    target.registerCSSDispatcher(new CSSDispatcher(this));
    if (!target.suspended()) {
      void this.enable();
    }
    this.#sourceMapManager.setEnabled(Common14.Settings.Settings.instance().moduleSetting("css-source-maps-enabled").get());
    Common14.Settings.Settings.instance().moduleSetting("css-source-maps-enabled").addChangeListener((event) => this.#sourceMapManager.setEnabled(event.data));
  }
  async colorScheme() {
    if (!this.#colorScheme) {
      const colorSchemeResponse = await this.domModel()?.target().runtimeAgent().invoke_evaluate({ expression: 'window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches' });
      if (colorSchemeResponse && !colorSchemeResponse.exceptionDetails && !colorSchemeResponse.getError()) {
        this.#colorScheme = colorSchemeResponse.result.value ? "dark" : "light";
      }
    }
    return this.#colorScheme;
  }
  async resolveValues(propertyName, nodeId, ...values) {
    if (propertyName && cssMetadata().getLonghands(propertyName)?.length) {
      return null;
    }
    const response = await this.agent.invoke_resolveValues({ values, nodeId, propertyName });
    if (response.getError()) {
      return null;
    }
    return response.results;
  }
  headersForSourceURL(sourceURL) {
    const headers = [];
    for (const headerId of this.getStyleSheetIdsForURL(sourceURL)) {
      const header = this.styleSheetHeaderForId(headerId);
      if (header) {
        headers.push(header);
      }
    }
    return headers;
  }
  createRawLocationsByURL(sourceURL, lineNumber, columnNumber = 0) {
    const headers = this.headersForSourceURL(sourceURL);
    headers.sort(stylesheetComparator);
    const endIndex = Platform10.ArrayUtilities.upperBound(headers, void 0, (_, header) => lineNumber - header.startLine || columnNumber - header.startColumn);
    if (!endIndex) {
      return [];
    }
    const locations = [];
    const last = headers[endIndex - 1];
    for (let index = endIndex - 1; index >= 0 && headers[index].startLine === last.startLine && headers[index].startColumn === last.startColumn; --index) {
      if (headers[index].containsLocation(lineNumber, columnNumber)) {
        locations.push(new CSSLocation(headers[index], lineNumber, columnNumber));
      }
    }
    return locations;
    function stylesheetComparator(a, b) {
      return a.startLine - b.startLine || a.startColumn - b.startColumn || a.id.localeCompare(b.id);
    }
  }
  sourceMapManager() {
    return this.#sourceMapManager;
  }
  static readableLayerName(text) {
    return text || "<anonymous>";
  }
  static trimSourceURL(text) {
    let sourceURLIndex = text.lastIndexOf("/*# sourceURL=");
    if (sourceURLIndex === -1) {
      sourceURLIndex = text.lastIndexOf("/*@ sourceURL=");
      if (sourceURLIndex === -1) {
        return text;
      }
    }
    const sourceURLLineIndex = text.lastIndexOf("\n", sourceURLIndex);
    if (sourceURLLineIndex === -1) {
      return text;
    }
    const sourceURLLine = text.substr(sourceURLLineIndex + 1).split("\n", 1)[0];
    const sourceURLRegex2 = /[\x20\t]*\/\*[#@] sourceURL=[\x20\t]*([^\s]*)[\x20\t]*\*\/[\x20\t]*$/;
    if (sourceURLLine.search(sourceURLRegex2) === -1) {
      return text;
    }
    return text.substr(0, sourceURLLineIndex) + text.substr(sourceURLLineIndex + sourceURLLine.length + 1);
  }
  domModel() {
    return this.#domModel;
  }
  async trackComputedStyleUpdatesForNode(nodeId) {
    await this.agent.invoke_trackComputedStyleUpdatesForNode({ nodeId });
  }
  async setStyleText(styleSheetId, range, text, majorChange) {
    try {
      await this.ensureOriginalStyleSheetText(styleSheetId);
      const { styles } = await this.agent.invoke_setStyleTexts({ edits: [{ styleSheetId, range: range.serializeToObject(), text }] });
      if (!styles || styles.length !== 1) {
        return false;
      }
      this.#domModel.markUndoableState(!majorChange);
      const edit = new Edit(styleSheetId, range, text, styles[0]);
      this.fireStyleSheetChanged(styleSheetId, edit);
      return true;
    } catch (e) {
      console.error(e);
      return false;
    }
  }
  async setSelectorText(styleSheetId, range, text) {
    Host4.userMetrics.actionTaken(Host4.UserMetrics.Action.StyleRuleEdited);
    try {
      await this.ensureOriginalStyleSheetText(styleSheetId);
      const { selectorList } = await this.agent.invoke_setRuleSelector({ styleSheetId, range, selector: text });
      if (!selectorList) {
        return false;
      }
      this.#domModel.markUndoableState();
      const edit = new Edit(styleSheetId, range, text, selectorList);
      this.fireStyleSheetChanged(styleSheetId, edit);
      return true;
    } catch (e) {
      console.error(e);
      return false;
    }
  }
  async setPropertyRulePropertyName(styleSheetId, range, text) {
    Host4.userMetrics.actionTaken(Host4.UserMetrics.Action.StyleRuleEdited);
    try {
      await this.ensureOriginalStyleSheetText(styleSheetId);
      const { propertyName } = await this.agent.invoke_setPropertyRulePropertyName({ styleSheetId, range, propertyName: text });
      if (!propertyName) {
        return false;
      }
      this.#domModel.markUndoableState();
      const edit = new Edit(styleSheetId, range, text, propertyName);
      this.fireStyleSheetChanged(styleSheetId, edit);
      return true;
    } catch (e) {
      console.error(e);
      return false;
    }
  }
  async setKeyframeKey(styleSheetId, range, text) {
    Host4.userMetrics.actionTaken(Host4.UserMetrics.Action.StyleRuleEdited);
    try {
      await this.ensureOriginalStyleSheetText(styleSheetId);
      const { keyText } = await this.agent.invoke_setKeyframeKey({ styleSheetId, range, keyText: text });
      if (!keyText) {
        return false;
      }
      this.#domModel.markUndoableState();
      const edit = new Edit(styleSheetId, range, text, keyText);
      this.fireStyleSheetChanged(styleSheetId, edit);
      return true;
    } catch (e) {
      console.error(e);
      return false;
    }
  }
  startCoverage() {
    this.#isRuleUsageTrackingEnabled = true;
    return this.agent.invoke_startRuleUsageTracking();
  }
  async takeCoverageDelta() {
    const r = await this.agent.invoke_takeCoverageDelta();
    const timestamp = r?.timestamp || 0;
    const coverage = r?.coverage || [];
    return { timestamp, coverage };
  }
  setLocalFontsEnabled(enabled) {
    return this.agent.invoke_setLocalFontsEnabled({
      enabled
    });
  }
  async stopCoverage() {
    this.#isRuleUsageTrackingEnabled = false;
    await this.agent.invoke_stopRuleUsageTracking();
  }
  async getMediaQueries() {
    const { medias } = await this.agent.invoke_getMediaQueries();
    return medias ? CSSMedia.parseMediaArrayPayload(this, medias) : [];
  }
  async getRootLayer(nodeId) {
    const { rootLayer } = await this.agent.invoke_getLayersForNode({ nodeId });
    return rootLayer;
  }
  isEnabled() {
    return this.#isEnabled;
  }
  async enable() {
    await this.agent.invoke_enable();
    this.#isEnabled = true;
    if (this.#isRuleUsageTrackingEnabled) {
      await this.startCoverage();
    }
    this.dispatchEventToListeners(Events5.ModelWasEnabled);
  }
  async getAnimatedStylesForNode(nodeId) {
    const response = await this.agent.invoke_getAnimatedStylesForNode({ nodeId });
    if (response.getError()) {
      return null;
    }
    return response;
  }
  async getMatchedStyles(nodeId) {
    const node = this.#domModel.nodeForId(nodeId);
    if (!node) {
      return null;
    }
    const shouldGetAnimatedStyles = Root5.Runtime.hostConfig.devToolsAnimationStylesInStylesTab?.enabled;
    const [matchedStylesResponse, animatedStylesResponse] = await Promise.all([
      this.agent.invoke_getMatchedStylesForNode({ nodeId }),
      shouldGetAnimatedStyles ? this.agent.invoke_getAnimatedStylesForNode({ nodeId }) : void 0
    ]);
    if (matchedStylesResponse.getError()) {
      return null;
    }
    const payload = {
      cssModel: this,
      node,
      inlinePayload: matchedStylesResponse.inlineStyle || null,
      attributesPayload: matchedStylesResponse.attributesStyle || null,
      matchedPayload: matchedStylesResponse.matchedCSSRules || [],
      pseudoPayload: matchedStylesResponse.pseudoElements || [],
      inheritedPayload: matchedStylesResponse.inherited || [],
      inheritedPseudoPayload: matchedStylesResponse.inheritedPseudoElements || [],
      animationsPayload: matchedStylesResponse.cssKeyframesRules || [],
      parentLayoutNodeId: matchedStylesResponse.parentLayoutNodeId,
      positionTryRules: matchedStylesResponse.cssPositionTryRules || [],
      propertyRules: matchedStylesResponse.cssPropertyRules ?? [],
      functionRules: matchedStylesResponse.cssFunctionRules ?? [],
      cssPropertyRegistrations: matchedStylesResponse.cssPropertyRegistrations ?? [],
      fontPaletteValuesRule: matchedStylesResponse.cssFontPaletteValuesRule,
      activePositionFallbackIndex: matchedStylesResponse.activePositionFallbackIndex ?? -1,
      animationStylesPayload: animatedStylesResponse?.animationStyles || [],
      inheritedAnimatedPayload: animatedStylesResponse?.inherited || [],
      transitionsStylePayload: animatedStylesResponse?.transitionsStyle || null
    };
    return await CSSMatchedStyles.create(payload);
  }
  async getClassNames(styleSheetId) {
    const { classNames } = await this.agent.invoke_collectClassNames({ styleSheetId });
    return classNames || [];
  }
  async getComputedStyle(nodeId) {
    if (!this.isEnabled()) {
      await this.enable();
    }
    return await this.#styleLoader.computedStylePromise(nodeId);
  }
  async getLayoutPropertiesFromComputedStyle(nodeId) {
    const styles = await this.getComputedStyle(nodeId);
    if (!styles) {
      return null;
    }
    const display = styles.get("display");
    const isFlex = display === "flex" || display === "inline-flex";
    const isGrid = display === "grid" || display === "inline-grid";
    const isSubgrid = (isGrid && (styles.get("grid-template-columns")?.startsWith("subgrid") || styles.get("grid-template-rows")?.startsWith("subgrid"))) ?? false;
    const isMasonry = display === "masonry" || display === "inline-masonry";
    const containerType = styles.get("container-type");
    const isContainer = Boolean(containerType) && containerType !== "" && containerType !== "normal";
    const hasScroll = Boolean(styles.get("scroll-snap-type")) && styles.get("scroll-snap-type") !== "none";
    return {
      isFlex,
      isGrid,
      isSubgrid,
      isMasonry,
      isContainer,
      hasScroll
    };
  }
  async getEnvironmentVariables() {
    const response = await this.agent.invoke_getEnvironmentVariables();
    if (response.getError()) {
      return {};
    }
    return response.environmentVariables;
  }
  async getBackgroundColors(nodeId) {
    const response = await this.agent.invoke_getBackgroundColors({ nodeId });
    if (response.getError()) {
      return null;
    }
    return {
      backgroundColors: response.backgroundColors || null,
      computedFontSize: response.computedFontSize || "",
      computedFontWeight: response.computedFontWeight || ""
    };
  }
  async getPlatformFonts(nodeId) {
    const { fonts } = await this.agent.invoke_getPlatformFontsForNode({ nodeId });
    return fonts;
  }
  allStyleSheets() {
    const values = [...this.#styleSheetIdToHeader.values()];
    function styleSheetComparator(a, b) {
      if (a.sourceURL < b.sourceURL) {
        return -1;
      }
      if (a.sourceURL > b.sourceURL) {
        return 1;
      }
      return a.startLine - b.startLine || a.startColumn - b.startColumn;
    }
    values.sort(styleSheetComparator);
    return values;
  }
  async getInlineStyles(nodeId) {
    const response = await this.agent.invoke_getInlineStylesForNode({ nodeId });
    if (response.getError() || !response.inlineStyle) {
      return null;
    }
    const inlineStyle = new CSSStyleDeclaration(this, null, response.inlineStyle, Type2.Inline);
    const attributesStyle = response.attributesStyle ? new CSSStyleDeclaration(this, null, response.attributesStyle, Type2.Attributes) : null;
    return new InlineStyleResult(inlineStyle, attributesStyle);
  }
  forceStartingStyle(node, forced) {
    void this.agent.invoke_forceStartingStyle({ nodeId: node.id, forced });
    this.dispatchEventToListeners(Events5.StartingStylesStateForced, node);
    return true;
  }
  forcePseudoState(node, pseudoClass, enable) {
    const forcedPseudoClasses = node.marker(PseudoStateMarker) || [];
    const hasPseudoClass = forcedPseudoClasses.includes(pseudoClass);
    if (enable) {
      if (hasPseudoClass) {
        return false;
      }
      forcedPseudoClasses.push(pseudoClass);
      node.setMarker(PseudoStateMarker, forcedPseudoClasses);
    } else {
      if (!hasPseudoClass) {
        return false;
      }
      Platform10.ArrayUtilities.removeElement(forcedPseudoClasses, pseudoClass);
      if (forcedPseudoClasses.length) {
        node.setMarker(PseudoStateMarker, forcedPseudoClasses);
      } else {
        node.setMarker(PseudoStateMarker, null);
      }
    }
    if (node.id === void 0) {
      return false;
    }
    void this.agent.invoke_forcePseudoState({ nodeId: node.id, forcedPseudoClasses });
    this.dispatchEventToListeners(Events5.PseudoStateForced, { node, pseudoClass, enable });
    return true;
  }
  pseudoState(node) {
    return node.marker(PseudoStateMarker) || [];
  }
  async setMediaText(styleSheetId, range, newMediaText) {
    Host4.userMetrics.actionTaken(Host4.UserMetrics.Action.StyleRuleEdited);
    try {
      await this.ensureOriginalStyleSheetText(styleSheetId);
      const { media } = await this.agent.invoke_setMediaText({ styleSheetId, range, text: newMediaText });
      if (!media) {
        return false;
      }
      this.#domModel.markUndoableState();
      const edit = new Edit(styleSheetId, range, newMediaText, media);
      this.fireStyleSheetChanged(styleSheetId, edit);
      return true;
    } catch (e) {
      console.error(e);
      return false;
    }
  }
  async setContainerQueryText(styleSheetId, range, newContainerQueryText) {
    Host4.userMetrics.actionTaken(Host4.UserMetrics.Action.StyleRuleEdited);
    try {
      await this.ensureOriginalStyleSheetText(styleSheetId);
      const { containerQuery } = await this.agent.invoke_setContainerQueryText({ styleSheetId, range, text: newContainerQueryText });
      if (!containerQuery) {
        return false;
      }
      this.#domModel.markUndoableState();
      const edit = new Edit(styleSheetId, range, newContainerQueryText, containerQuery);
      this.fireStyleSheetChanged(styleSheetId, edit);
      return true;
    } catch (e) {
      console.error(e);
      return false;
    }
  }
  async setSupportsText(styleSheetId, range, newSupportsText) {
    Host4.userMetrics.actionTaken(Host4.UserMetrics.Action.StyleRuleEdited);
    try {
      await this.ensureOriginalStyleSheetText(styleSheetId);
      const { supports } = await this.agent.invoke_setSupportsText({ styleSheetId, range, text: newSupportsText });
      if (!supports) {
        return false;
      }
      this.#domModel.markUndoableState();
      const edit = new Edit(styleSheetId, range, newSupportsText, supports);
      this.fireStyleSheetChanged(styleSheetId, edit);
      return true;
    } catch (e) {
      console.error(e);
      return false;
    }
  }
  async setScopeText(styleSheetId, range, newScopeText) {
    Host4.userMetrics.actionTaken(Host4.UserMetrics.Action.StyleRuleEdited);
    try {
      await this.ensureOriginalStyleSheetText(styleSheetId);
      const { scope } = await this.agent.invoke_setScopeText({ styleSheetId, range, text: newScopeText });
      if (!scope) {
        return false;
      }
      this.#domModel.markUndoableState();
      const edit = new Edit(styleSheetId, range, newScopeText, scope);
      this.fireStyleSheetChanged(styleSheetId, edit);
      return true;
    } catch (e) {
      console.error(e);
      return false;
    }
  }
  async addRule(styleSheetId, ruleText, ruleLocation) {
    try {
      await this.ensureOriginalStyleSheetText(styleSheetId);
      const { rule } = await this.agent.invoke_addRule({ styleSheetId, ruleText, location: ruleLocation });
      if (!rule) {
        return null;
      }
      this.#domModel.markUndoableState();
      const edit = new Edit(styleSheetId, ruleLocation, ruleText, rule);
      this.fireStyleSheetChanged(styleSheetId, edit);
      return new CSSStyleRule(this, rule);
    } catch (e) {
      console.error(e);
      return null;
    }
  }
  async requestViaInspectorStylesheet(maybeFrameId) {
    const frameId = maybeFrameId || (this.#resourceTreeModel && this.#resourceTreeModel.mainFrame ? this.#resourceTreeModel.mainFrame.id : null);
    const headers = [...this.#styleSheetIdToHeader.values()];
    const styleSheetHeader = headers.find((header) => header.frameId === frameId && header.isViaInspector());
    if (styleSheetHeader) {
      return styleSheetHeader;
    }
    if (!frameId) {
      return null;
    }
    try {
      return await this.createInspectorStylesheet(frameId);
    } catch (e) {
      console.error(e);
      return null;
    }
  }
  async createInspectorStylesheet(frameId, force = false) {
    const result = await this.agent.invoke_createStyleSheet({ frameId, force });
    if (result.getError()) {
      throw new Error(result.getError());
    }
    return this.#styleSheetIdToHeader.get(result.styleSheetId) || null;
  }
  mediaQueryResultChanged() {
    this.#colorScheme = void 0;
    this.dispatchEventToListeners(Events5.MediaQueryResultChanged);
  }
  fontsUpdated(fontFace) {
    if (fontFace) {
      this.#fontFaces.set(fontFace.src, new CSSFontFace(fontFace));
    }
    this.dispatchEventToListeners(Events5.FontsUpdated);
  }
  fontFaces() {
    return [...this.#fontFaces.values()];
  }
  fontFaceForSource(src) {
    return this.#fontFaces.get(src);
  }
  styleSheetHeaderForId(id) {
    return this.#styleSheetIdToHeader.get(id) || null;
  }
  styleSheetHeaders() {
    return [...this.#styleSheetIdToHeader.values()];
  }
  fireStyleSheetChanged(styleSheetId, edit) {
    this.dispatchEventToListeners(Events5.StyleSheetChanged, { styleSheetId, edit });
  }
  ensureOriginalStyleSheetText(styleSheetId) {
    const header = this.styleSheetHeaderForId(styleSheetId);
    if (!header) {
      return Promise.resolve(null);
    }
    let promise = this.#originalStyleSheetText.get(header);
    if (!promise) {
      promise = this.getStyleSheetText(header.id);
      this.#originalStyleSheetText.set(header, promise);
      this.originalContentRequestedForTest(header);
    }
    return promise;
  }
  originalContentRequestedForTest(_header) {
  }
  originalStyleSheetText(header) {
    return this.ensureOriginalStyleSheetText(header.id);
  }
  getAllStyleSheetHeaders() {
    return this.#styleSheetIdToHeader.values();
  }
  computedStyleUpdated(nodeId) {
    this.dispatchEventToListeners(Events5.ComputedStyleUpdated, { nodeId });
  }
  styleSheetAdded(header) {
    console.assert(!this.#styleSheetIdToHeader.get(header.styleSheetId));
    if (header.loadingFailed) {
      header.hasSourceURL = false;
      header.isConstructed = true;
      header.isInline = false;
      header.isMutable = false;
      header.sourceURL = "";
      header.sourceMapURL = void 0;
    }
    const styleSheetHeader = new CSSStyleSheetHeader(this, header);
    this.#styleSheetIdToHeader.set(header.styleSheetId, styleSheetHeader);
    const url = styleSheetHeader.resourceURL();
    let frameIdToStyleSheetIds = this.#styleSheetIdsForURL.get(url);
    if (!frameIdToStyleSheetIds) {
      frameIdToStyleSheetIds = /* @__PURE__ */ new Map();
      this.#styleSheetIdsForURL.set(url, frameIdToStyleSheetIds);
    }
    if (frameIdToStyleSheetIds) {
      let styleSheetIds = frameIdToStyleSheetIds.get(styleSheetHeader.frameId);
      if (!styleSheetIds) {
        styleSheetIds = /* @__PURE__ */ new Set();
        frameIdToStyleSheetIds.set(styleSheetHeader.frameId, styleSheetIds);
      }
      styleSheetIds.add(styleSheetHeader.id);
    }
    this.#sourceMapManager.attachSourceMap(styleSheetHeader, styleSheetHeader.sourceURL, styleSheetHeader.sourceMapURL);
    this.dispatchEventToListeners(Events5.StyleSheetAdded, styleSheetHeader);
  }
  styleSheetRemoved(id) {
    const header = this.#styleSheetIdToHeader.get(id);
    console.assert(Boolean(header));
    if (!header) {
      return;
    }
    this.#styleSheetIdToHeader.delete(id);
    const url = header.resourceURL();
    const frameIdToStyleSheetIds = this.#styleSheetIdsForURL.get(url);
    console.assert(Boolean(frameIdToStyleSheetIds), "No frameId to styleSheetId map is available for given style sheet URL.");
    if (frameIdToStyleSheetIds) {
      const stylesheetIds = frameIdToStyleSheetIds.get(header.frameId);
      if (stylesheetIds) {
        stylesheetIds.delete(id);
        if (!stylesheetIds.size) {
          frameIdToStyleSheetIds.delete(header.frameId);
          if (!frameIdToStyleSheetIds.size) {
            this.#styleSheetIdsForURL.delete(url);
          }
        }
      }
    }
    this.#originalStyleSheetText.delete(header);
    this.#sourceMapManager.detachSourceMap(header);
    this.dispatchEventToListeners(Events5.StyleSheetRemoved, header);
  }
  getStyleSheetIdsForURL(url) {
    const frameIdToStyleSheetIds = this.#styleSheetIdsForURL.get(url);
    if (!frameIdToStyleSheetIds) {
      return [];
    }
    const result = [];
    for (const styleSheetIds of frameIdToStyleSheetIds.values()) {
      result.push(...styleSheetIds);
    }
    return result;
  }
  async setStyleSheetText(styleSheetId, newText, majorChange) {
    const header = this.#styleSheetIdToHeader.get(styleSheetId);
    if (!header) {
      return "Unknown stylesheet in CSS.setStyleSheetText";
    }
    newText = _CSSModel.trimSourceURL(newText);
    if (header.hasSourceURL) {
      newText += "\n/*# sourceURL=" + header.sourceURL + " */";
    }
    await this.ensureOriginalStyleSheetText(styleSheetId);
    const response = await this.agent.invoke_setStyleSheetText({ styleSheetId: header.id, text: newText });
    const sourceMapURL = response.sourceMapURL;
    this.#sourceMapManager.detachSourceMap(header);
    header.setSourceMapURL(sourceMapURL);
    this.#sourceMapManager.attachSourceMap(header, header.sourceURL, header.sourceMapURL);
    if (sourceMapURL === null) {
      return "Error in CSS.setStyleSheetText";
    }
    this.#domModel.markUndoableState(!majorChange);
    this.fireStyleSheetChanged(styleSheetId);
    return null;
  }
  async getStyleSheetText(styleSheetId) {
    const response = await this.agent.invoke_getStyleSheetText({ styleSheetId });
    if (response.getError()) {
      return null;
    }
    const { text } = response;
    return text && _CSSModel.trimSourceURL(text);
  }
  async onPrimaryPageChanged(event) {
    if (event.data.frame.backForwardCacheDetails.restoredFromCache) {
      await this.suspendModel();
      await this.resumeModel();
    } else if (event.data.type !== "Activation") {
      this.resetStyleSheets();
      this.resetFontFaces();
    }
  }
  resetStyleSheets() {
    const headers = [...this.#styleSheetIdToHeader.values()];
    this.#styleSheetIdsForURL.clear();
    this.#styleSheetIdToHeader.clear();
    for (const header of headers) {
      this.#sourceMapManager.detachSourceMap(header);
      this.dispatchEventToListeners(Events5.StyleSheetRemoved, header);
    }
  }
  resetFontFaces() {
    this.#fontFaces.clear();
  }
  async suspendModel() {
    this.#isEnabled = false;
    await this.agent.invoke_disable();
    this.resetStyleSheets();
    this.resetFontFaces();
  }
  async resumeModel() {
    return await this.enable();
  }
  setEffectivePropertyValueForNode(nodeId, propertyName, value) {
    void this.agent.invoke_setEffectivePropertyValueForNode({ nodeId, propertyName, value });
  }
  cachedMatchedCascadeForNode(node) {
    if (this.#cachedMatchedCascadeNode !== node) {
      this.discardCachedMatchedCascade();
    }
    this.#cachedMatchedCascadeNode = node;
    if (!this.#cachedMatchedCascadePromise) {
      if (node.id) {
        this.#cachedMatchedCascadePromise = this.getMatchedStyles(node.id);
      } else {
        return Promise.resolve(null);
      }
    }
    return this.#cachedMatchedCascadePromise;
  }
  discardCachedMatchedCascade() {
    this.#cachedMatchedCascadeNode = null;
    this.#cachedMatchedCascadePromise = null;
  }
  createCSSPropertyTracker(propertiesToTrack) {
    const cssPropertyTracker = new CSSPropertyTracker(this, propertiesToTrack);
    return cssPropertyTracker;
  }
  enableCSSPropertyTracker(cssPropertyTracker) {
    const propertiesToTrack = cssPropertyTracker.getTrackedProperties();
    if (propertiesToTrack.length === 0) {
      return;
    }
    void this.agent.invoke_trackComputedStyleUpdates({ propertiesToTrack });
    this.#isCSSPropertyTrackingEnabled = true;
    this.#cssPropertyTracker = cssPropertyTracker;
    void this.pollComputedStyleUpdates();
  }
  // Since we only support one tracker at a time, this call effectively disables
  // style tracking.
  disableCSSPropertyTracker() {
    this.#isCSSPropertyTrackingEnabled = false;
    this.#cssPropertyTracker = null;
    void this.agent.invoke_trackComputedStyleUpdates({ propertiesToTrack: [] });
  }
  async pollComputedStyleUpdates() {
    if (this.#isTrackingRequestPending) {
      return;
    }
    if (this.#isCSSPropertyTrackingEnabled) {
      this.#isTrackingRequestPending = true;
      const result = await this.agent.invoke_takeComputedStyleUpdates();
      this.#isTrackingRequestPending = false;
      if (result.getError() || !result.nodeIds || !this.#isCSSPropertyTrackingEnabled) {
        return;
      }
      if (this.#cssPropertyTracker) {
        this.#cssPropertyTracker.dispatchEventToListeners("TrackedCSSPropertiesUpdated", result.nodeIds.map((nodeId) => this.#domModel.nodeForId(nodeId)));
      }
    }
    if (this.#isCSSPropertyTrackingEnabled) {
      void this.#stylePollingThrottler.schedule(this.pollComputedStyleUpdates.bind(this));
    }
  }
  dispose() {
    this.disableCSSPropertyTracker();
    super.dispose();
    this.dispatchEventToListeners(Events5.ModelDisposed, this);
  }
  getAgent() {
    return this.agent;
  }
};
var Events5;
(function(Events12) {
  Events12["FontsUpdated"] = "FontsUpdated";
  Events12["MediaQueryResultChanged"] = "MediaQueryResultChanged";
  Events12["ModelWasEnabled"] = "ModelWasEnabled";
  Events12["ModelDisposed"] = "ModelDisposed";
  Events12["PseudoStateForced"] = "PseudoStateForced";
  Events12["StartingStylesStateForced"] = "StartingStylesStateForced";
  Events12["StyleSheetAdded"] = "StyleSheetAdded";
  Events12["StyleSheetChanged"] = "StyleSheetChanged";
  Events12["StyleSheetRemoved"] = "StyleSheetRemoved";
  Events12["ComputedStyleUpdated"] = "ComputedStyleUpdated";
})(Events5 || (Events5 = {}));
var PseudoStateMarker = "pseudo-state-marker";
var Edit = class {
  styleSheetId;
  oldRange;
  newRange;
  newText;
  payload;
  constructor(styleSheetId, oldRange, newText, payload) {
    this.styleSheetId = styleSheetId;
    this.oldRange = oldRange;
    this.newRange = TextUtils17.TextRange.TextRange.fromEdit(oldRange, newText);
    this.newText = newText;
    this.payload = payload;
  }
};
var CSSLocation = class {
  #cssModel;
  styleSheetId;
  url;
  lineNumber;
  columnNumber;
  constructor(header, lineNumber, columnNumber) {
    this.#cssModel = header.cssModel();
    this.styleSheetId = header.id;
    this.url = header.resourceURL();
    this.lineNumber = lineNumber;
    this.columnNumber = columnNumber || 0;
  }
  cssModel() {
    return this.#cssModel;
  }
  header() {
    return this.#cssModel.styleSheetHeaderForId(this.styleSheetId);
  }
};
var CSSDispatcher = class {
  #cssModel;
  constructor(cssModel) {
    this.#cssModel = cssModel;
  }
  mediaQueryResultChanged() {
    this.#cssModel.mediaQueryResultChanged();
  }
  fontsUpdated({ font }) {
    this.#cssModel.fontsUpdated(font);
  }
  styleSheetChanged({ styleSheetId }) {
    this.#cssModel.fireStyleSheetChanged(styleSheetId);
  }
  styleSheetAdded({ header }) {
    this.#cssModel.styleSheetAdded(header);
  }
  styleSheetRemoved({ styleSheetId }) {
    this.#cssModel.styleSheetRemoved(styleSheetId);
  }
  computedStyleUpdated({ nodeId }) {
    this.#cssModel.computedStyleUpdated(nodeId);
  }
};
var ComputedStyleLoader = class {
  #cssModel;
  #nodeIdToPromise = /* @__PURE__ */ new Map();
  constructor(cssModel) {
    this.#cssModel = cssModel;
  }
  computedStylePromise(nodeId) {
    let promise = this.#nodeIdToPromise.get(nodeId);
    if (promise) {
      return promise;
    }
    promise = this.#cssModel.getAgent().invoke_getComputedStyleForNode({ nodeId }).then(({ computedStyle }) => {
      this.#nodeIdToPromise.delete(nodeId);
      if (!computedStyle?.length) {
        return null;
      }
      const result = /* @__PURE__ */ new Map();
      for (const property of computedStyle) {
        result.set(property.name, property.value);
      }
      return result;
    });
    this.#nodeIdToPromise.set(nodeId, promise);
    return promise;
  }
};
var InlineStyleResult = class {
  inlineStyle;
  attributesStyle;
  constructor(inlineStyle, attributesStyle) {
    this.inlineStyle = inlineStyle;
    this.attributesStyle = attributesStyle;
  }
};
var CSSPropertyTracker = class extends Common14.ObjectWrapper.ObjectWrapper {
  #cssModel;
  #properties;
  constructor(cssModel, propertiesToTrack) {
    super();
    this.#cssModel = cssModel;
    this.#properties = propertiesToTrack;
  }
  start() {
    this.#cssModel.enableCSSPropertyTracker(this);
  }
  stop() {
    this.#cssModel.disableCSSPropertyTracker();
  }
  getTrackedProperties() {
    return this.#properties;
  }
};
var StylePollingInterval = 1e3;
SDKModel.register(CSSModel, { capabilities: 2, autostart: true });

// gen/front_end/core/sdk/OverlayModel.js
var OverlayModel_exports = {};
__export(OverlayModel_exports, {
  OverlayModel: () => OverlayModel,
  SourceOrderHighlighter: () => SourceOrderHighlighter,
  WindowControls: () => WindowControls
});
import * as Common20 from "./../common/common.js";
import * as i18n13 from "./../i18n/i18n.js";
import * as Root7 from "./../root/root.js";

// gen/front_end/core/sdk/DebuggerModel.js
var DebuggerModel_exports = {};
__export(DebuggerModel_exports, {
  BreakLocation: () => BreakLocation,
  COND_BREAKPOINT_SOURCE_URL: () => COND_BREAKPOINT_SOURCE_URL,
  CallFrame: () => CallFrame,
  DebuggerModel: () => DebuggerModel,
  DebuggerPausedDetails: () => DebuggerPausedDetails,
  Events: () => Events7,
  LOGPOINT_SOURCE_URL: () => LOGPOINT_SOURCE_URL,
  Location: () => Location,
  PauseOnExceptionsState: () => PauseOnExceptionsState,
  Scope: () => Scope,
  WASM_SYMBOLS_PRIORITY: () => WASM_SYMBOLS_PRIORITY,
  sortAndMergeRanges: () => sortAndMergeRanges
});
import * as Common17 from "./../common/common.js";
import * as Host6 from "./../host/host.js";
import * as i18n11 from "./../i18n/i18n.js";
import * as Platform12 from "./../platform/platform.js";
import * as Root6 from "./../root/root.js";

// gen/front_end/core/sdk/RuntimeModel.js
var RuntimeModel_exports = {};
__export(RuntimeModel_exports, {
  Events: () => Events6,
  ExecutionContext: () => ExecutionContext,
  RuntimeModel: () => RuntimeModel
});
import * as Common15 from "./../common/common.js";
import * as Host5 from "./../host/host.js";

// gen/front_end/core/sdk/HeapProfilerModel.js
var HeapProfilerModel_exports = {};
__export(HeapProfilerModel_exports, {
  HeapProfilerModel: () => HeapProfilerModel
});
var HeapProfilerModel = class extends SDKModel {
  #enabled;
  #heapProfilerAgent;
  #runtimeModel;
  #samplingProfilerDepth;
  constructor(target) {
    super(target);
    target.registerHeapProfilerDispatcher(new HeapProfilerDispatcher(this));
    this.#enabled = false;
    this.#heapProfilerAgent = target.heapProfilerAgent();
    this.#runtimeModel = target.model(RuntimeModel);
    this.#samplingProfilerDepth = 0;
  }
  debuggerModel() {
    return this.#runtimeModel.debuggerModel();
  }
  runtimeModel() {
    return this.#runtimeModel;
  }
  async enable() {
    if (this.#enabled) {
      return;
    }
    this.#enabled = true;
    await this.#heapProfilerAgent.invoke_enable();
  }
  async startSampling(samplingRateInBytes) {
    if (this.#samplingProfilerDepth++) {
      return false;
    }
    const defaultSamplingIntervalInBytes = 16384;
    const response = await this.#heapProfilerAgent.invoke_startSampling({ samplingInterval: samplingRateInBytes || defaultSamplingIntervalInBytes });
    return Boolean(response.getError());
  }
  async stopSampling() {
    if (!this.#samplingProfilerDepth) {
      throw new Error("Sampling profiler is not running.");
    }
    if (--this.#samplingProfilerDepth) {
      return await this.getSamplingProfile();
    }
    const response = await this.#heapProfilerAgent.invoke_stopSampling();
    if (response.getError()) {
      return null;
    }
    return response.profile;
  }
  async getSamplingProfile() {
    const response = await this.#heapProfilerAgent.invoke_getSamplingProfile();
    if (response.getError()) {
      return null;
    }
    return response.profile;
  }
  async collectGarbage() {
    const response = await this.#heapProfilerAgent.invoke_collectGarbage();
    return Boolean(response.getError());
  }
  async snapshotObjectIdForObjectId(objectId) {
    const response = await this.#heapProfilerAgent.invoke_getHeapObjectId({ objectId });
    if (response.getError()) {
      return null;
    }
    return response.heapSnapshotObjectId;
  }
  async objectForSnapshotObjectId(snapshotObjectId, objectGroupName) {
    const result = await this.#heapProfilerAgent.invoke_getObjectByHeapObjectId({ objectId: snapshotObjectId, objectGroup: objectGroupName });
    if (result.getError()) {
      return null;
    }
    return this.#runtimeModel.createRemoteObject(result.result);
  }
  async addInspectedHeapObject(snapshotObjectId) {
    const response = await this.#heapProfilerAgent.invoke_addInspectedHeapObject({ heapObjectId: snapshotObjectId });
    return Boolean(response.getError());
  }
  async takeHeapSnapshot(heapSnapshotOptions) {
    await this.#heapProfilerAgent.invoke_takeHeapSnapshot(heapSnapshotOptions);
  }
  async startTrackingHeapObjects(recordAllocationStacks) {
    const response = await this.#heapProfilerAgent.invoke_startTrackingHeapObjects({ trackAllocations: recordAllocationStacks });
    return Boolean(response.getError());
  }
  async stopTrackingHeapObjects(reportProgress) {
    const response = await this.#heapProfilerAgent.invoke_stopTrackingHeapObjects({ reportProgress });
    return Boolean(response.getError());
  }
  heapStatsUpdate(samples) {
    this.dispatchEventToListeners("HeapStatsUpdate", samples);
  }
  lastSeenObjectId(lastSeenObjectId, timestamp) {
    this.dispatchEventToListeners("LastSeenObjectId", { lastSeenObjectId, timestamp });
  }
  addHeapSnapshotChunk(chunk) {
    this.dispatchEventToListeners("AddHeapSnapshotChunk", chunk);
  }
  reportHeapSnapshotProgress(done, total, finished) {
    this.dispatchEventToListeners("ReportHeapSnapshotProgress", { done, total, finished });
  }
  resetProfiles() {
    this.dispatchEventToListeners("ResetProfiles", this);
  }
};
var HeapProfilerDispatcher = class {
  #heapProfilerModel;
  constructor(model) {
    this.#heapProfilerModel = model;
  }
  heapStatsUpdate({ statsUpdate }) {
    this.#heapProfilerModel.heapStatsUpdate(statsUpdate);
  }
  lastSeenObjectId({ lastSeenObjectId, timestamp }) {
    this.#heapProfilerModel.lastSeenObjectId(lastSeenObjectId, timestamp);
  }
  addHeapSnapshotChunk({ chunk }) {
    this.#heapProfilerModel.addHeapSnapshotChunk(chunk);
  }
  reportHeapSnapshotProgress({ done, total, finished }) {
    this.#heapProfilerModel.reportHeapSnapshotProgress(done, total, finished);
  }
  resetProfiles() {
    this.#heapProfilerModel.resetProfiles();
  }
};
SDKModel.register(HeapProfilerModel, { capabilities: 4, autostart: false });

// gen/front_end/core/sdk/RuntimeModel.js
var RuntimeModel = class extends SDKModel {
  agent;
  #executionContextById = /* @__PURE__ */ new Map();
  #executionContextComparator = ExecutionContext.comparator;
  constructor(target) {
    super(target);
    this.agent = target.runtimeAgent();
    this.target().registerRuntimeDispatcher(new RuntimeDispatcher(this));
    void this.agent.invoke_enable();
    if (Common15.Settings.Settings.instance().moduleSetting("custom-formatters").get()) {
      void this.agent.invoke_setCustomObjectFormatterEnabled({ enabled: true });
    }
    Common15.Settings.Settings.instance().moduleSetting("custom-formatters").addChangeListener(this.customFormattersStateChanged.bind(this));
  }
  static isSideEffectFailure(response) {
    const exceptionDetails = "exceptionDetails" in response && response.exceptionDetails;
    return Boolean(exceptionDetails && exceptionDetails.exception?.description?.startsWith("EvalError: Possible side-effect in debug-evaluate"));
  }
  debuggerModel() {
    return this.target().model(DebuggerModel);
  }
  heapProfilerModel() {
    return this.target().model(HeapProfilerModel);
  }
  executionContexts() {
    return [...this.#executionContextById.values()].sort(this.executionContextComparator());
  }
  setExecutionContextComparator(comparator) {
    this.#executionContextComparator = comparator;
  }
  /**
   * comparator
   */
  executionContextComparator() {
    return this.#executionContextComparator;
  }
  defaultExecutionContext() {
    for (const context of this.executionContexts()) {
      if (context.isDefault) {
        return context;
      }
    }
    return null;
  }
  executionContext(id) {
    return this.#executionContextById.get(id) || null;
  }
  executionContextCreated(context) {
    const data = context.auxData || { isDefault: true };
    const executionContext = new ExecutionContext(this, context.id, context.uniqueId, context.name, context.origin, data["isDefault"], data["frameId"]);
    this.#executionContextById.set(executionContext.id, executionContext);
    this.dispatchEventToListeners(Events6.ExecutionContextCreated, executionContext);
  }
  executionContextDestroyed(executionContextId) {
    const executionContext = this.#executionContextById.get(executionContextId);
    if (!executionContext) {
      return;
    }
    this.debuggerModel().executionContextDestroyed(executionContext);
    this.#executionContextById.delete(executionContextId);
    this.dispatchEventToListeners(Events6.ExecutionContextDestroyed, executionContext);
  }
  fireExecutionContextOrderChanged() {
    this.dispatchEventToListeners(Events6.ExecutionContextOrderChanged, this);
  }
  executionContextsCleared() {
    this.debuggerModel().globalObjectCleared();
    const contexts = this.executionContexts();
    this.#executionContextById.clear();
    for (let i = 0; i < contexts.length; ++i) {
      this.dispatchEventToListeners(Events6.ExecutionContextDestroyed, contexts[i]);
    }
  }
  createRemoteObject(payload) {
    console.assert(typeof payload === "object", "Remote object payload should only be an object");
    return new RemoteObjectImpl(this, payload.objectId, payload.type, payload.subtype, payload.value, payload.unserializableValue, payload.description, payload.preview, payload.customPreview, payload.className);
  }
  createScopeRemoteObject(payload, scopeRef) {
    return new ScopeRemoteObject(this, payload.objectId, scopeRef, payload.type, payload.subtype, payload.value, payload.unserializableValue, payload.description, payload.preview);
  }
  createRemoteObjectFromPrimitiveValue(value) {
    const type = typeof value;
    let unserializableValue = void 0;
    const unserializableDescription = RemoteObject.unserializableDescription(value);
    if (unserializableDescription !== null) {
      unserializableValue = unserializableDescription;
    }
    if (typeof unserializableValue !== "undefined") {
      value = void 0;
    }
    return new RemoteObjectImpl(this, void 0, type, void 0, value, unserializableValue);
  }
  createRemotePropertyFromPrimitiveValue(name, value) {
    return new RemoteObjectProperty(name, this.createRemoteObjectFromPrimitiveValue(value));
  }
  discardConsoleEntries() {
    void this.agent.invoke_discardConsoleEntries();
  }
  releaseObjectGroup(objectGroup) {
    void this.agent.invoke_releaseObjectGroup({ objectGroup });
  }
  releaseEvaluationResult(result) {
    if ("object" in result && result.object) {
      result.object.release();
    }
    if ("exceptionDetails" in result && result.exceptionDetails?.exception) {
      const exception = result.exceptionDetails.exception;
      const exceptionObject = this.createRemoteObject({ type: exception.type, objectId: exception.objectId });
      exceptionObject.release();
    }
  }
  runIfWaitingForDebugger() {
    void this.agent.invoke_runIfWaitingForDebugger();
  }
  customFormattersStateChanged({ data: enabled }) {
    void this.agent.invoke_setCustomObjectFormatterEnabled({ enabled });
  }
  async compileScript(expression, sourceURL, persistScript, executionContextId) {
    const response = await this.agent.invoke_compileScript({
      expression,
      sourceURL,
      persistScript,
      executionContextId
    });
    if (response.getError()) {
      console.error(response.getError());
      return null;
    }
    return { scriptId: response.scriptId, exceptionDetails: response.exceptionDetails };
  }
  async runScript(scriptId, executionContextId, objectGroup, silent, includeCommandLineAPI, returnByValue, generatePreview, awaitPromise) {
    const response = await this.agent.invoke_runScript({
      scriptId,
      executionContextId,
      objectGroup,
      silent,
      includeCommandLineAPI,
      returnByValue,
      generatePreview,
      awaitPromise
    });
    const error = response.getError();
    if (error) {
      console.error(error);
      return { error };
    }
    return { object: this.createRemoteObject(response.result), exceptionDetails: response.exceptionDetails };
  }
  async queryObjects(prototype) {
    if (!prototype.objectId) {
      return { error: "Prototype should be an Object." };
    }
    const response = await this.agent.invoke_queryObjects({ prototypeObjectId: prototype.objectId, objectGroup: "console" });
    const error = response.getError();
    if (error) {
      console.error(error);
      return { error };
    }
    return { objects: this.createRemoteObject(response.objects) };
  }
  async isolateId() {
    const response = await this.agent.invoke_getIsolateId();
    if (response.getError() || !response.id) {
      return this.target().id();
    }
    return response.id;
  }
  async heapUsage() {
    const result = await this.agent.invoke_getHeapUsage();
    return result.getError() ? null : result;
  }
  inspectRequested(payload, hints, executionContextId) {
    const object = this.createRemoteObject(payload);
    if (hints !== null && typeof hints === "object") {
      if ("copyToClipboard" in hints && Boolean(hints.copyToClipboard)) {
        this.copyRequested(object);
        return;
      }
      if ("queryObjects" in hints && hints.queryObjects) {
        void this.queryObjectsRequested(object, executionContextId);
        return;
      }
    }
    if (object.isNode()) {
      void Common15.Revealer.reveal(object).then(object.release.bind(object));
      return;
    }
    if (object.type === "function") {
      void RemoteFunction.objectAsFunction(object).targetFunctionDetails().then(didGetDetails);
      return;
    }
    function didGetDetails(response) {
      object.release();
      if (!response?.location) {
        return;
      }
      void Common15.Revealer.reveal(response.location);
    }
    object.release();
  }
  async addBinding(event) {
    return await this.agent.invoke_addBinding(event);
  }
  async removeBinding(request) {
    return await this.agent.invoke_removeBinding(request);
  }
  bindingCalled(event) {
    this.dispatchEventToListeners(Events6.BindingCalled, event);
  }
  copyRequested(object) {
    if (!object.objectId) {
      Host5.InspectorFrontendHost.InspectorFrontendHostInstance.copyText(object.unserializableValue() || object.value);
      return;
    }
    const indent = Common15.Settings.Settings.instance().moduleSetting("text-editor-indent").get();
    void object.callFunctionJSON(toStringForClipboard, [{
      value: {
        subtype: object.subtype,
        indent
      }
    }]).then(Host5.InspectorFrontendHost.InspectorFrontendHostInstance.copyText.bind(Host5.InspectorFrontendHost.InspectorFrontendHostInstance));
    function toStringForClipboard(data) {
      const subtype = data.subtype;
      const indent2 = data.indent;
      if (subtype === "node") {
        return this instanceof Element ? this.outerHTML : void 0;
      }
      if (subtype && typeof this === "undefined") {
        return String(subtype);
      }
      try {
        return JSON.stringify(this, null, indent2);
      } catch {
        return String(this);
      }
    }
  }
  async queryObjectsRequested(object, executionContextId) {
    const result = await this.queryObjects(object);
    object.release();
    if ("error" in result) {
      Common15.Console.Console.instance().error(result.error);
      return;
    }
    this.dispatchEventToListeners(Events6.QueryObjectRequested, { objects: result.objects, executionContextId });
  }
  static simpleTextFromException(exceptionDetails) {
    let text = exceptionDetails.text;
    if (exceptionDetails.exception?.description) {
      let description = exceptionDetails.exception.description;
      if (description.indexOf("\n") !== -1) {
        description = description.substring(0, description.indexOf("\n"));
      }
      text += " " + description;
    }
    return text;
  }
  exceptionThrown(timestamp, exceptionDetails) {
    const exceptionWithTimestamp = { timestamp, details: exceptionDetails };
    this.dispatchEventToListeners(Events6.ExceptionThrown, exceptionWithTimestamp);
  }
  exceptionRevoked(exceptionId) {
    this.dispatchEventToListeners(Events6.ExceptionRevoked, exceptionId);
  }
  consoleAPICalled(type, args, executionContextId, timestamp, stackTrace, context) {
    const consoleAPICall = {
      type,
      args,
      executionContextId,
      timestamp,
      stackTrace,
      context
    };
    this.dispatchEventToListeners(Events6.ConsoleAPICalled, consoleAPICall);
  }
  executionContextIdForScriptId(scriptId) {
    const script = this.debuggerModel().scriptForId(scriptId);
    return script ? script.executionContextId : 0;
  }
  executionContextForStackTrace(stackTrace) {
    let currentStackTrace = stackTrace;
    while (currentStackTrace && !currentStackTrace.callFrames.length) {
      currentStackTrace = currentStackTrace.parent || null;
    }
    if (!currentStackTrace?.callFrames.length) {
      return 0;
    }
    return this.executionContextIdForScriptId(currentStackTrace.callFrames[0].scriptId);
  }
  terminateExecution() {
    return this.agent.invoke_terminateExecution();
  }
  async getExceptionDetails(errorObjectId) {
    const response = await this.agent.invoke_getExceptionDetails({ errorObjectId });
    if (response.getError()) {
      return void 0;
    }
    return response.exceptionDetails;
  }
};
var Events6;
(function(Events12) {
  Events12["BindingCalled"] = "BindingCalled";
  Events12["ExecutionContextCreated"] = "ExecutionContextCreated";
  Events12["ExecutionContextDestroyed"] = "ExecutionContextDestroyed";
  Events12["ExecutionContextChanged"] = "ExecutionContextChanged";
  Events12["ExecutionContextOrderChanged"] = "ExecutionContextOrderChanged";
  Events12["ExceptionThrown"] = "ExceptionThrown";
  Events12["ExceptionRevoked"] = "ExceptionRevoked";
  Events12["ConsoleAPICalled"] = "ConsoleAPICalled";
  Events12["QueryObjectRequested"] = "QueryObjectRequested";
})(Events6 || (Events6 = {}));
var RuntimeDispatcher = class {
  #runtimeModel;
  constructor(runtimeModel) {
    this.#runtimeModel = runtimeModel;
  }
  executionContextCreated({ context }) {
    this.#runtimeModel.executionContextCreated(context);
  }
  executionContextDestroyed({ executionContextId }) {
    this.#runtimeModel.executionContextDestroyed(executionContextId);
  }
  executionContextsCleared() {
    this.#runtimeModel.executionContextsCleared();
  }
  exceptionThrown({ timestamp, exceptionDetails }) {
    this.#runtimeModel.exceptionThrown(timestamp, exceptionDetails);
  }
  exceptionRevoked({ exceptionId }) {
    this.#runtimeModel.exceptionRevoked(exceptionId);
  }
  consoleAPICalled({ type, args, executionContextId, timestamp, stackTrace, context }) {
    this.#runtimeModel.consoleAPICalled(type, args, executionContextId, timestamp, stackTrace, context);
  }
  inspectRequested({ object, hints, executionContextId }) {
    this.#runtimeModel.inspectRequested(object, hints, executionContextId);
  }
  bindingCalled(event) {
    this.#runtimeModel.bindingCalled(event);
  }
};
var ExecutionContext = class {
  id;
  uniqueId;
  name;
  #label;
  origin;
  isDefault;
  runtimeModel;
  debuggerModel;
  frameId;
  constructor(runtimeModel, id, uniqueId, name, origin, isDefault, frameId) {
    this.id = id;
    this.uniqueId = uniqueId;
    this.name = name;
    this.#label = null;
    this.origin = origin;
    this.isDefault = isDefault;
    this.runtimeModel = runtimeModel;
    this.debuggerModel = runtimeModel.debuggerModel();
    this.frameId = frameId;
    this.#setLabel("");
  }
  target() {
    return this.runtimeModel.target();
  }
  static comparator(a, b) {
    function targetWeight(target) {
      if (target.parentTarget()?.type() !== Type.FRAME) {
        return 5;
      }
      if (target.type() === Type.FRAME) {
        return 4;
      }
      if (target.type() === Type.ServiceWorker) {
        return 3;
      }
      if (target.type() === Type.Worker || target.type() === Type.SHARED_WORKER) {
        return 2;
      }
      return 1;
    }
    function targetPath(target) {
      let currentTarget = target;
      const parents = [];
      while (currentTarget) {
        parents.push(currentTarget);
        currentTarget = currentTarget.parentTarget();
      }
      return parents.reverse();
    }
    const tagetsA = targetPath(a.target());
    const targetsB = targetPath(b.target());
    let targetA;
    let targetB;
    for (let i = 0; ; i++) {
      if (!tagetsA[i] || !targetsB[i] || tagetsA[i] !== targetsB[i]) {
        targetA = tagetsA[i];
        targetB = targetsB[i];
        break;
      }
    }
    if (!targetA && targetB) {
      return -1;
    }
    if (!targetB && targetA) {
      return 1;
    }
    if (targetA && targetB) {
      const weightDiff = targetWeight(targetA) - targetWeight(targetB);
      if (weightDiff) {
        return -weightDiff;
      }
      return targetA.id().localeCompare(targetB.id());
    }
    if (a.isDefault) {
      return -1;
    }
    if (b.isDefault) {
      return 1;
    }
    return a.name.localeCompare(b.name);
  }
  async evaluate(options, userGesture, awaitPromise) {
    if (this.debuggerModel.selectedCallFrame()) {
      return await this.debuggerModel.evaluateOnSelectedCallFrame(options);
    }
    return await this.evaluateGlobal(options, userGesture, awaitPromise);
  }
  globalObject(objectGroup, generatePreview) {
    const evaluationOptions = {
      expression: "this",
      objectGroup,
      includeCommandLineAPI: false,
      silent: true,
      returnByValue: false,
      generatePreview
    };
    return this.evaluateGlobal(evaluationOptions, false, false);
  }
  async callFunctionOn(options) {
    const response = await this.runtimeModel.agent.invoke_callFunctionOn({
      functionDeclaration: options.functionDeclaration,
      returnByValue: options.returnByValue,
      userGesture: options.userGesture,
      awaitPromise: options.awaitPromise,
      throwOnSideEffect: options.throwOnSideEffect,
      arguments: options.arguments,
      // Old back-ends don't know about uniqueContextId (and also don't generate
      // one), so fall back to contextId in that case (https://crbug.com/1192621).
      ...this.uniqueId ? { uniqueContextId: this.uniqueId } : { contextId: this.id }
    });
    const error = response.getError();
    if (error) {
      return { error };
    }
    return { object: this.runtimeModel.createRemoteObject(response.result), exceptionDetails: response.exceptionDetails };
  }
  async evaluateGlobal(options, userGesture, awaitPromise) {
    if (!options.expression) {
      options.expression = "this";
    }
    const response = await this.runtimeModel.agent.invoke_evaluate({
      expression: options.expression,
      objectGroup: options.objectGroup,
      includeCommandLineAPI: options.includeCommandLineAPI,
      silent: options.silent,
      returnByValue: options.returnByValue,
      generatePreview: options.generatePreview,
      userGesture,
      awaitPromise,
      throwOnSideEffect: options.throwOnSideEffect,
      timeout: options.timeout,
      disableBreaks: options.disableBreaks,
      replMode: options.replMode,
      allowUnsafeEvalBlockedByCSP: options.allowUnsafeEvalBlockedByCSP,
      // Old back-ends don't know about uniqueContextId (and also don't generate
      // one), so fall back to contextId in that case (https://crbug.com/1192621).
      ...this.uniqueId ? { uniqueContextId: this.uniqueId } : { contextId: this.id }
    });
    const error = response.getError();
    if (error) {
      console.error(error);
      return { error };
    }
    return { object: this.runtimeModel.createRemoteObject(response.result), exceptionDetails: response.exceptionDetails };
  }
  async globalLexicalScopeNames() {
    const response = await this.runtimeModel.agent.invoke_globalLexicalScopeNames({ executionContextId: this.id });
    return response.getError() ? [] : response.names;
  }
  label() {
    return this.#label;
  }
  setLabel(label) {
    this.#setLabel(label);
    this.runtimeModel.dispatchEventToListeners(Events6.ExecutionContextChanged, this);
  }
  #setLabel(label) {
    if (label) {
      this.#label = label;
      return;
    }
    if (this.name) {
      this.#label = this.name;
      return;
    }
    const parsedUrl = Common15.ParsedURL.ParsedURL.fromString(this.origin);
    this.#label = parsedUrl ? parsedUrl.lastPathComponentWithFragment() : "";
  }
};
SDKModel.register(RuntimeModel, { capabilities: 4, autostart: true });

// gen/front_end/core/sdk/Script.js
var Script_exports = {};
__export(Script_exports, {
  Script: () => Script,
  disassembleWasm: () => disassembleWasm,
  sourceURLRegex: () => sourceURLRegex
});
import * as TextUtils18 from "./../../models/text_utils/text_utils.js";
import * as Common16 from "./../common/common.js";
import * as i18n9 from "./../i18n/i18n.js";
var UIStrings5 = {
  /**
   * @description Error message for when a script can't be loaded which had been previously
   */
  scriptRemovedOrDeleted: "Script removed or deleted.",
  /**
   * @description Error message when failing to load a script source text
   */
  unableToFetchScriptSource: "Unable to fetch script source."
};
var str_5 = i18n9.i18n.registerUIStrings("core/sdk/Script.ts", UIStrings5);
var i18nString5 = i18n9.i18n.getLocalizedString.bind(void 0, str_5);
var scriptCacheInstance = null;
var Script = class _Script {
  debuggerModel;
  scriptId;
  /**
   * The URL of the script. When `hasSourceURL` is true, this value comes from a `//# sourceURL=` directive. Otherwise,
   * it's the original `src` URL from which the script was loaded.
   */
  sourceURL;
  lineOffset;
  columnOffset;
  endLine;
  endColumn;
  executionContextId;
  hash;
  #isContentScript;
  #isLiveEdit;
  sourceMapURL;
  debugSymbols;
  hasSourceURL;
  contentLength;
  originStackTrace;
  #codeOffset;
  #language;
  #contentPromise;
  #embedderName;
  isModule;
  buildId;
  constructor(debuggerModel, scriptId, sourceURL, startLine, startColumn, endLine, endColumn, executionContextId, hash, isContentScript, isLiveEdit, sourceMapURL, hasSourceURL, length, isModule, originStackTrace, codeOffset, scriptLanguage, debugSymbols, embedderName, buildId) {
    this.debuggerModel = debuggerModel;
    this.scriptId = scriptId;
    this.sourceURL = sourceURL;
    this.lineOffset = startLine;
    this.columnOffset = startColumn;
    this.endLine = endLine;
    this.endColumn = endColumn;
    this.isModule = isModule;
    this.buildId = buildId;
    this.executionContextId = executionContextId;
    this.hash = hash;
    this.#isContentScript = isContentScript;
    this.#isLiveEdit = isLiveEdit;
    this.sourceMapURL = sourceMapURL;
    this.debugSymbols = debugSymbols;
    this.hasSourceURL = hasSourceURL;
    this.contentLength = length;
    this.originStackTrace = originStackTrace;
    this.#codeOffset = codeOffset;
    this.#language = scriptLanguage;
    this.#contentPromise = null;
    this.#embedderName = embedderName;
  }
  embedderName() {
    return this.#embedderName;
  }
  target() {
    return this.debuggerModel.target();
  }
  static trimSourceURLComment(source) {
    let sourceURLIndex = source.lastIndexOf("//# sourceURL=");
    if (sourceURLIndex === -1) {
      sourceURLIndex = source.lastIndexOf("//@ sourceURL=");
      if (sourceURLIndex === -1) {
        return source;
      }
    }
    const sourceURLLineIndex = source.lastIndexOf("\n", sourceURLIndex);
    if (sourceURLLineIndex === -1) {
      return source;
    }
    const sourceURLLine = source.substr(sourceURLLineIndex + 1);
    if (!sourceURLLine.match(sourceURLRegex)) {
      return source;
    }
    return source.substr(0, sourceURLLineIndex);
  }
  isContentScript() {
    return this.#isContentScript;
  }
  codeOffset() {
    return this.#codeOffset;
  }
  isJavaScript() {
    return this.#language === "JavaScript";
  }
  isWasm() {
    return this.#language === "WebAssembly";
  }
  scriptLanguage() {
    return this.#language;
  }
  executionContext() {
    return this.debuggerModel.runtimeModel().executionContext(this.executionContextId);
  }
  isLiveEdit() {
    return this.#isLiveEdit;
  }
  contentURL() {
    return this.sourceURL;
  }
  contentType() {
    return Common16.ResourceType.resourceTypes.Script;
  }
  async loadTextContent() {
    const result = await this.debuggerModel.target().debuggerAgent().invoke_getScriptSource({ scriptId: this.scriptId });
    if (result.getError()) {
      throw new Error(result.getError());
    }
    const { scriptSource, bytecode } = result;
    if (bytecode) {
      return new TextUtils18.ContentData.ContentData(
        bytecode,
        /* isBase64 */
        true,
        "application/wasm"
      );
    }
    let content = scriptSource || "";
    if (this.hasSourceURL && Common16.ParsedURL.schemeIs(this.sourceURL, "snippet:")) {
      content = _Script.trimSourceURLComment(content);
    }
    return new TextUtils18.ContentData.ContentData(
      content,
      /* isBase64 */
      false,
      "text/javascript"
    );
  }
  async loadWasmContent() {
    if (!this.isWasm()) {
      throw new Error("Not a wasm script");
    }
    const result = await this.debuggerModel.target().debuggerAgent().invoke_disassembleWasmModule({ scriptId: this.scriptId });
    if (result.getError()) {
      const contentData = await this.loadTextContent();
      return await disassembleWasm(contentData.base64);
    }
    const { streamId, functionBodyOffsets, chunk: { lines, bytecodeOffsets } } = result;
    const lineChunks = [];
    const bytecodeOffsetChunks = [];
    let totalLength = lines.reduce((sum, line) => sum + line.length + 1, 0);
    const truncationMessage = "<truncated>";
    const cmSizeLimit = 1e9 - truncationMessage.length;
    if (streamId) {
      while (true) {
        const result2 = await this.debuggerModel.target().debuggerAgent().invoke_nextWasmDisassemblyChunk({ streamId });
        if (result2.getError()) {
          throw new Error(result2.getError());
        }
        const { chunk: { lines: linesChunk, bytecodeOffsets: bytecodeOffsetsChunk } } = result2;
        totalLength += linesChunk.reduce((sum, line) => sum + line.length + 1, 0);
        if (linesChunk.length === 0) {
          break;
        }
        if (totalLength >= cmSizeLimit) {
          lineChunks.push([truncationMessage]);
          bytecodeOffsetChunks.push([0]);
          break;
        }
        lineChunks.push(linesChunk);
        bytecodeOffsetChunks.push(bytecodeOffsetsChunk);
      }
    }
    const functionBodyRanges = [];
    for (let i = 0; i < functionBodyOffsets.length; i += 2) {
      functionBodyRanges.push({ start: functionBodyOffsets[i], end: functionBodyOffsets[i + 1] });
    }
    return new TextUtils18.WasmDisassembly.WasmDisassembly(lines.concat(...lineChunks), bytecodeOffsets.concat(...bytecodeOffsetChunks), functionBodyRanges);
  }
  requestContentData() {
    if (!this.#contentPromise) {
      const fileSizeToCache = 65535;
      if (this.hash && !this.#isLiveEdit && this.contentLength > fileSizeToCache) {
        if (!scriptCacheInstance) {
          scriptCacheInstance = {
            cache: /* @__PURE__ */ new Map(),
            registry: new FinalizationRegistry((hashCode) => scriptCacheInstance?.cache.delete(hashCode))
          };
        }
        const fullHash = [
          this.#language,
          this.contentLength,
          this.lineOffset,
          this.columnOffset,
          this.endLine,
          this.endColumn,
          this.#codeOffset,
          this.hash
        ].join(":");
        const cachedContentPromise = scriptCacheInstance.cache.get(fullHash)?.deref();
        if (cachedContentPromise) {
          this.#contentPromise = cachedContentPromise;
        } else {
          this.#contentPromise = this.#requestContent();
          scriptCacheInstance.cache.set(fullHash, new WeakRef(this.#contentPromise));
          scriptCacheInstance.registry.register(this.#contentPromise, fullHash);
        }
      } else {
        this.#contentPromise = this.#requestContent();
      }
    }
    return this.#contentPromise;
  }
  async #requestContent() {
    if (!this.scriptId) {
      return { error: i18nString5(UIStrings5.scriptRemovedOrDeleted) };
    }
    try {
      return this.isWasm() ? await this.loadWasmContent() : await this.loadTextContent();
    } catch {
      return { error: i18nString5(UIStrings5.unableToFetchScriptSource) };
    }
  }
  async getWasmBytecode() {
    const base64 = await this.debuggerModel.target().debuggerAgent().invoke_getWasmBytecode({ scriptId: this.scriptId });
    const response = await fetch(`data:application/wasm;base64,${base64.bytecode}`);
    return await response.arrayBuffer();
  }
  originalContentProvider() {
    return new TextUtils18.StaticContentProvider.StaticContentProvider(this.contentURL(), this.contentType(), () => this.requestContentData());
  }
  async searchInContent(query, caseSensitive, isRegex) {
    if (!this.scriptId) {
      return [];
    }
    const matches = await this.debuggerModel.target().debuggerAgent().invoke_searchInContent({ scriptId: this.scriptId, query, caseSensitive, isRegex });
    return TextUtils18.TextUtils.performSearchInSearchMatches(matches.result || [], query, caseSensitive, isRegex);
  }
  appendSourceURLCommentIfNeeded(source) {
    if (!this.hasSourceURL) {
      return source;
    }
    return source + "\n //# sourceURL=" + this.sourceURL;
  }
  async editSource(newSource) {
    newSource = _Script.trimSourceURLComment(newSource);
    newSource = this.appendSourceURLCommentIfNeeded(newSource);
    const oldSource = TextUtils18.ContentData.ContentData.textOr(await this.requestContentData(), null);
    if (oldSource === newSource) {
      return {
        changed: false,
        status: "Ok"
        /* Protocol.Debugger.SetScriptSourceResponseStatus.Ok */
      };
    }
    const response = await this.debuggerModel.target().debuggerAgent().invoke_setScriptSource({ scriptId: this.scriptId, scriptSource: newSource, allowTopFrameEditing: true });
    if (response.getError()) {
      throw new Error(`Script#editSource failed for script with id ${this.scriptId}: ${response.getError()}`);
    }
    if (!response.getError() && response.status === "Ok") {
      this.#contentPromise = Promise.resolve(new TextUtils18.ContentData.ContentData(
        newSource,
        /* isBase64 */
        false,
        "text/javascript"
      ));
    }
    this.debuggerModel.dispatchEventToListeners(Events7.ScriptSourceWasEdited, { script: this, status: response.status });
    return { changed: true, status: response.status, exceptionDetails: response.exceptionDetails };
  }
  rawLocation(lineNumber, columnNumber) {
    if (this.containsLocation(lineNumber, columnNumber)) {
      return new Location(this.debuggerModel, this.scriptId, lineNumber, columnNumber);
    }
    return null;
  }
  isInlineScript() {
    const startsAtZero = !this.lineOffset && !this.columnOffset;
    return !this.isWasm() && Boolean(this.sourceURL) && !startsAtZero;
  }
  isAnonymousScript() {
    return !this.sourceURL;
  }
  async setBlackboxedRanges(positions) {
    const response = await this.debuggerModel.target().debuggerAgent().invoke_setBlackboxedRanges({ scriptId: this.scriptId, positions });
    return !response.getError();
  }
  containsLocation(lineNumber, columnNumber) {
    const afterStart = lineNumber === this.lineOffset && columnNumber >= this.columnOffset || lineNumber > this.lineOffset;
    const beforeEnd = lineNumber < this.endLine || lineNumber === this.endLine && columnNumber <= this.endColumn;
    return afterStart && beforeEnd;
  }
  get frameId() {
    if (typeof this[frameIdSymbol] !== "string") {
      this[frameIdSymbol] = frameIdForScript(this);
    }
    return this[frameIdSymbol];
  }
  /**
   * @returns true, iff this script originates from a breakpoint/logpoint condition
   */
  get isBreakpointCondition() {
    return [COND_BREAKPOINT_SOURCE_URL, LOGPOINT_SOURCE_URL].includes(this.sourceURL);
  }
  /**
   * @returns the currently attached source map for this Script or `undefined` if there is none or it
   * hasn't loaded yet.
   */
  sourceMap() {
    return this.debuggerModel.sourceMapManager().sourceMapForClient(this);
  }
  createPageResourceLoadInitiator() {
    return { target: this.target(), frameId: this.frameId, initiatorUrl: this.embedderName() };
  }
  debugId() {
    return this.buildId;
  }
  rawLocationToRelativeLocation(rawLocation) {
    let { lineNumber, columnNumber } = rawLocation;
    if (!this.hasSourceURL && this.isInlineScript()) {
      lineNumber -= this.lineOffset;
      if (lineNumber === 0 && columnNumber !== void 0) {
        columnNumber -= this.columnOffset;
      }
    }
    return { lineNumber, columnNumber };
  }
  relativeLocationToRawLocation(relativeLocation) {
    let { lineNumber, columnNumber } = relativeLocation;
    if (!this.hasSourceURL && this.isInlineScript()) {
      if (lineNumber === 0 && columnNumber !== void 0) {
        columnNumber += this.columnOffset;
      }
      lineNumber += this.lineOffset;
    }
    return { lineNumber, columnNumber };
  }
};
var frameIdSymbol = Symbol("frameid");
function frameIdForScript(script) {
  const executionContext = script.executionContext();
  if (executionContext) {
    return executionContext.frameId || null;
  }
  const resourceTreeModel = script.debuggerModel.target().model(ResourceTreeModel);
  if (!resourceTreeModel?.mainFrame) {
    return null;
  }
  return resourceTreeModel.mainFrame.id;
}
var sourceURLRegex = /^[\x20\t]*\/\/[@#] sourceURL=\s*(\S*?)\s*$/;
async function disassembleWasm(content) {
  const worker = Common16.Worker.WorkerWrapper.fromURL(new URL("../../entrypoints/wasmparser_worker/wasmparser_worker-entrypoint.js", import.meta.url));
  const promise = new Promise((resolve, reject) => {
    worker.onmessage = ({ data }) => {
      if ("method" in data) {
        switch (data.method) {
          case "disassemble":
            if ("error" in data) {
              reject(data.error);
            } else if ("result" in data) {
              const { lines, offsets, functionBodyOffsets } = data.result;
              resolve(new TextUtils18.WasmDisassembly.WasmDisassembly(lines, offsets, functionBodyOffsets));
            }
            break;
        }
      }
    };
    worker.onerror = reject;
  });
  worker.postMessage({ method: "disassemble", params: { content } });
  try {
    return await promise;
  } finally {
    worker.terminate();
  }
}

// gen/front_end/core/sdk/DebuggerModel.js
var UIStrings6 = {
  /**
   * @description Title of a section in the debugger showing local JavaScript variables.
   */
  local: "Local",
  /**
   * @description Text that refers to closure as a programming term
   */
  closure: "Closure",
  /**
   * @description Noun that represents a section or block of code in the Debugger Model. Shown in the Sources tab, while paused on a breakpoint.
   */
  block: "Block",
  /**
   * @description Label for a group of JavaScript files
   */
  script: "Script",
  /**
   * @description Title of a section in the debugger showing JavaScript variables from the a 'with'
   *block. Block here means section of code, 'with' refers to a JavaScript programming concept and
   *is a fixed term.
   */
  withBlock: "`With` block",
  /**
   * @description Title of a section in the debugger showing JavaScript variables from the a 'catch'
   *block. Block here means section of code, 'catch' refers to a JavaScript programming concept and
   *is a fixed term.
   */
  catchBlock: "`Catch` block",
  /**
   * @description Title of a section in the debugger showing JavaScript variables from the global scope.
   */
  global: "Global",
  /**
   * @description Text for a JavaScript module, the programming concept
   */
  module: "Module",
  /**
   * @description Text describing the expression scope in WebAssembly
   */
  expression: "Expression",
  /**
   * @description Text in Scope Chain Sidebar Pane of the Sources panel
   */
  exception: "Exception",
  /**
   * @description Text in Scope Chain Sidebar Pane of the Sources panel
   */
  returnValue: "Return value"
};
var str_6 = i18n11.i18n.registerUIStrings("core/sdk/DebuggerModel.ts", UIStrings6);
var i18nString6 = i18n11.i18n.getLocalizedString.bind(void 0, str_6);
function sortAndMergeRanges(locationRanges) {
  function compare(p1, p2) {
    return p1.lineNumber - p2.lineNumber || p1.columnNumber - p2.columnNumber;
  }
  function overlap(r1, r2) {
    if (r1.scriptId !== r2.scriptId) {
      return false;
    }
    const n = compare(r1.start, r2.start);
    if (n < 0) {
      return compare(r1.end, r2.start) >= 0;
    }
    if (n > 0) {
      return compare(r1.start, r2.end) <= 0;
    }
    return true;
  }
  if (locationRanges.length === 0) {
    return [];
  }
  locationRanges.sort((r1, r2) => {
    if (r1.scriptId < r2.scriptId) {
      return -1;
    }
    if (r1.scriptId > r2.scriptId) {
      return 1;
    }
    return compare(r1.start, r2.start) || compare(r1.end, r2.end);
  });
  let prev = locationRanges[0];
  const merged = [];
  for (let i = 1; i < locationRanges.length; ++i) {
    const curr = locationRanges[i];
    if (overlap(prev, curr)) {
      if (compare(prev.end, curr.end) <= 0) {
        prev = { ...prev, end: curr.end };
      }
    } else {
      merged.push(prev);
      prev = curr;
    }
  }
  merged.push(prev);
  return merged;
}
var WASM_SYMBOLS_PRIORITY = [
  "ExternalDWARF",
  "EmbeddedDWARF",
  "SourceMap"
];
var DebuggerModel = class _DebuggerModel extends SDKModel {
  agent;
  #runtimeModel;
  #sourceMapManager;
  #debuggerPausedDetails = null;
  #scripts = /* @__PURE__ */ new Map();
  #scriptsBySourceURL = /* @__PURE__ */ new Map();
  #discardableScripts = [];
  continueToLocationCallback = null;
  #selectedCallFrame = null;
  #debuggerEnabled = false;
  #debuggerId = null;
  #skipAllPausesTimeout = 0;
  #beforePausedCallback = null;
  #computeAutoStepRangesCallback = null;
  #expandCallFramesCallback = null;
  evaluateOnCallFrameCallback = null;
  #synchronizeBreakpointsCallback = null;
  // We need to be able to register listeners for individual breakpoints. As such, we dispatch
  // on breakpoint ids, which are not statically known. The event #payload will always be a `Location`.
  #breakpointResolvedEventTarget = new Common17.ObjectWrapper.ObjectWrapper();
  // When stepping over with autostepping enabled, the context denotes the function to which autostepping is restricted
  // to by way of its functionLocation (as per Debugger.CallFrame).
  #autoSteppingContext = null;
  #isPausing = false;
  constructor(target) {
    super(target);
    target.registerDebuggerDispatcher(new DebuggerDispatcher(this));
    this.agent = target.debuggerAgent();
    this.#runtimeModel = target.model(RuntimeModel);
    this.#sourceMapManager = new SourceMapManager(target, (compiledURL, sourceMappingURL, payload, script) => new SourceMap(compiledURL, sourceMappingURL, payload, script));
    Common17.Settings.Settings.instance().moduleSetting("pause-on-exception-enabled").addChangeListener(this.pauseOnExceptionStateChanged, this);
    Common17.Settings.Settings.instance().moduleSetting("pause-on-caught-exception").addChangeListener(this.pauseOnExceptionStateChanged, this);
    Common17.Settings.Settings.instance().moduleSetting("pause-on-uncaught-exception").addChangeListener(this.pauseOnExceptionStateChanged, this);
    Common17.Settings.Settings.instance().moduleSetting("disable-async-stack-traces").addChangeListener(this.asyncStackTracesStateChanged, this);
    Common17.Settings.Settings.instance().moduleSetting("breakpoints-active").addChangeListener(this.breakpointsActiveChanged, this);
    if (!target.suspended()) {
      void this.enableDebugger();
    }
    this.#sourceMapManager.setEnabled(Common17.Settings.Settings.instance().moduleSetting("js-source-maps-enabled").get());
    Common17.Settings.Settings.instance().moduleSetting("js-source-maps-enabled").addChangeListener((event) => this.#sourceMapManager.setEnabled(event.data));
    const resourceTreeModel = target.model(ResourceTreeModel);
    if (resourceTreeModel) {
      resourceTreeModel.addEventListener(Events3.FrameNavigated, this.onFrameNavigated, this);
    }
  }
  static selectSymbolSource(debugSymbols) {
    if (!debugSymbols || debugSymbols.length === 0) {
      return null;
    }
    if ("type" in debugSymbols) {
      if (debugSymbols.type === "None") {
        return null;
      }
      return debugSymbols;
    }
    let debugSymbolsSource = null;
    const symbolTypes = new Map(debugSymbols.map((symbol) => [symbol.type, symbol]));
    for (const symbol of WASM_SYMBOLS_PRIORITY) {
      if (symbolTypes.has(symbol)) {
        debugSymbolsSource = symbolTypes.get(symbol) || null;
        break;
      }
    }
    console.assert(debugSymbolsSource !== null, "Unknown symbol types. Front-end and back-end should be kept in sync regarding Protocol.Debugger.DebugSymbolTypes");
    if (debugSymbolsSource && debugSymbols.length > 1) {
      Common17.Console.Console.instance().warn(`Multiple debug symbols for script were found. Using ${debugSymbolsSource.type}`);
    }
    return debugSymbolsSource;
  }
  sourceMapManager() {
    return this.#sourceMapManager;
  }
  runtimeModel() {
    return this.#runtimeModel;
  }
  debuggerEnabled() {
    return Boolean(this.#debuggerEnabled);
  }
  debuggerId() {
    return this.#debuggerId;
  }
  async enableDebugger() {
    if (this.#debuggerEnabled) {
      return;
    }
    this.#debuggerEnabled = true;
    const isRemoteFrontend = Root6.Runtime.Runtime.queryParam("remoteFrontend") || Root6.Runtime.Runtime.queryParam("ws");
    const maxScriptsCacheSize = isRemoteFrontend ? 1e7 : 1e8;
    const enablePromise = this.agent.invoke_enable({ maxScriptsCacheSize });
    let instrumentationPromise;
    if (Root6.Runtime.experiments.isEnabled(
      "instrumentation-breakpoints"
      /* Root.Runtime.ExperimentName.INSTRUMENTATION_BREAKPOINTS */
    )) {
      instrumentationPromise = this.agent.invoke_setInstrumentationBreakpoint({
        instrumentation: "beforeScriptExecution"
      });
    }
    this.pauseOnExceptionStateChanged();
    void this.asyncStackTracesStateChanged();
    if (!Common17.Settings.Settings.instance().moduleSetting("breakpoints-active").get()) {
      this.breakpointsActiveChanged();
    }
    this.dispatchEventToListeners(Events7.DebuggerWasEnabled, this);
    const [enableResult] = await Promise.all([enablePromise, instrumentationPromise]);
    this.registerDebugger(enableResult);
  }
  async syncDebuggerId() {
    const isRemoteFrontend = Root6.Runtime.Runtime.queryParam("remoteFrontend") || Root6.Runtime.Runtime.queryParam("ws");
    const maxScriptsCacheSize = isRemoteFrontend ? 1e7 : 1e8;
    const enablePromise = this.agent.invoke_enable({ maxScriptsCacheSize });
    void enablePromise.then(this.registerDebugger.bind(this));
    return await enablePromise;
  }
  onFrameNavigated() {
    if (_DebuggerModel.shouldResyncDebuggerId) {
      return;
    }
    _DebuggerModel.shouldResyncDebuggerId = true;
  }
  registerDebugger(response) {
    if (response.getError()) {
      this.#debuggerEnabled = false;
      return;
    }
    const { debuggerId } = response;
    debuggerIdToModel.set(debuggerId, this);
    this.#debuggerId = debuggerId;
    this.dispatchEventToListeners(Events7.DebuggerIsReadyToPause, this);
  }
  isReadyToPause() {
    return Boolean(this.#debuggerId);
  }
  static async modelForDebuggerId(debuggerId) {
    if (_DebuggerModel.shouldResyncDebuggerId) {
      await _DebuggerModel.resyncDebuggerIdForModels();
      _DebuggerModel.shouldResyncDebuggerId = false;
    }
    return debuggerIdToModel.get(debuggerId) || null;
  }
  static async resyncDebuggerIdForModels() {
    const dbgModels = debuggerIdToModel.values();
    for (const dbgModel of dbgModels) {
      if (dbgModel.debuggerEnabled()) {
        await dbgModel.syncDebuggerId();
      }
    }
  }
  async disableDebugger() {
    if (!this.#debuggerEnabled) {
      return;
    }
    this.#debuggerEnabled = false;
    await this.asyncStackTracesStateChanged();
    await this.agent.invoke_disable();
    this.#isPausing = false;
    this.globalObjectCleared();
    this.dispatchEventToListeners(Events7.DebuggerWasDisabled, this);
    if (typeof this.#debuggerId === "string") {
      debuggerIdToModel.delete(this.#debuggerId);
    }
    this.#debuggerId = null;
  }
  skipAllPauses(skip) {
    if (this.#skipAllPausesTimeout) {
      clearTimeout(this.#skipAllPausesTimeout);
      this.#skipAllPausesTimeout = 0;
    }
    void this.agent.invoke_setSkipAllPauses({ skip });
  }
  skipAllPausesUntilReloadOrTimeout(timeout) {
    if (this.#skipAllPausesTimeout) {
      clearTimeout(this.#skipAllPausesTimeout);
    }
    void this.agent.invoke_setSkipAllPauses({ skip: true });
    this.#skipAllPausesTimeout = window.setTimeout(this.skipAllPauses.bind(this, false), timeout);
  }
  pauseOnExceptionStateChanged() {
    const pauseOnCaughtEnabled = Common17.Settings.Settings.instance().moduleSetting("pause-on-caught-exception").get();
    let state;
    const pauseOnUncaughtEnabled = Common17.Settings.Settings.instance().moduleSetting("pause-on-uncaught-exception").get();
    if (pauseOnCaughtEnabled && pauseOnUncaughtEnabled) {
      state = "all";
    } else if (pauseOnCaughtEnabled) {
      state = "caught";
    } else if (pauseOnUncaughtEnabled) {
      state = "uncaught";
    } else {
      state = "none";
    }
    void this.agent.invoke_setPauseOnExceptions({ state });
  }
  asyncStackTracesStateChanged() {
    const maxAsyncStackChainDepth = 32;
    const enabled = !Common17.Settings.Settings.instance().moduleSetting("disable-async-stack-traces").get() && this.#debuggerEnabled;
    const maxDepth = enabled ? maxAsyncStackChainDepth : 0;
    return this.agent.invoke_setAsyncCallStackDepth({ maxDepth });
  }
  breakpointsActiveChanged() {
    void this.agent.invoke_setBreakpointsActive({ active: Common17.Settings.Settings.instance().moduleSetting("breakpoints-active").get() });
  }
  setComputeAutoStepRangesCallback(callback) {
    this.#computeAutoStepRangesCallback = callback;
  }
  async computeAutoStepSkipList(mode) {
    let ranges = [];
    if (this.#computeAutoStepRangesCallback && this.#debuggerPausedDetails && this.#debuggerPausedDetails.callFrames.length > 0) {
      const [callFrame] = this.#debuggerPausedDetails.callFrames;
      ranges = await this.#computeAutoStepRangesCallback.call(null, mode, callFrame);
    }
    const skipList = ranges.map(({ start, end }) => ({
      scriptId: start.scriptId,
      start: { lineNumber: start.lineNumber, columnNumber: start.columnNumber },
      end: { lineNumber: end.lineNumber, columnNumber: end.columnNumber }
    }));
    return sortAndMergeRanges(skipList);
  }
  async stepInto() {
    const skipList = await this.computeAutoStepSkipList(
      "StepInto"
      /* StepMode.STEP_INTO */
    );
    void this.agent.invoke_stepInto({ breakOnAsyncCall: false, skipList });
  }
  async stepOver() {
    this.#autoSteppingContext = this.#debuggerPausedDetails?.callFrames[0]?.functionLocation() ?? null;
    const skipList = await this.computeAutoStepSkipList(
      "StepOver"
      /* StepMode.STEP_OVER */
    );
    void this.agent.invoke_stepOver({ skipList });
  }
  async stepOut() {
    const skipList = await this.computeAutoStepSkipList(
      "StepOut"
      /* StepMode.STEP_OUT */
    );
    if (skipList.length !== 0) {
      void this.agent.invoke_stepOver({ skipList });
    } else {
      void this.agent.invoke_stepOut();
    }
  }
  scheduleStepIntoAsync() {
    void this.computeAutoStepSkipList(
      "StepInto"
      /* StepMode.STEP_INTO */
    ).then((skipList) => {
      void this.agent.invoke_stepInto({ breakOnAsyncCall: true, skipList });
    });
  }
  resume() {
    void this.agent.invoke_resume({ terminateOnResume: false });
    this.#isPausing = false;
  }
  pause() {
    this.#isPausing = true;
    this.skipAllPauses(false);
    void this.agent.invoke_pause();
  }
  async setBreakpointByURL(url, lineNumber, columnNumber, condition) {
    let urlRegex;
    if (this.target().type() === Type.NODE && Common17.ParsedURL.schemeIs(url, "file:")) {
      const platformPath = Common17.ParsedURL.ParsedURL.urlToRawPathString(url, Host6.Platform.isWin());
      urlRegex = `${Platform12.StringUtilities.escapeForRegExp(platformPath)}|${Platform12.StringUtilities.escapeForRegExp(url)}`;
      if (Host6.Platform.isWin() && platformPath.match(/^.:\\/)) {
        urlRegex = `[${platformPath[0].toUpperCase()}${platformPath[0].toLowerCase()}]` + urlRegex.substr(1);
      }
    }
    let minColumnNumber = 0;
    const scripts = this.#scriptsBySourceURL.get(url) || [];
    for (let i = 0, l = scripts.length; i < l; ++i) {
      const script = scripts[i];
      if (lineNumber === script.lineOffset) {
        minColumnNumber = minColumnNumber ? Math.min(minColumnNumber, script.columnOffset) : script.columnOffset;
      }
    }
    columnNumber = Math.max(columnNumber || 0, minColumnNumber);
    const response = await this.agent.invoke_setBreakpointByUrl({
      lineNumber,
      url: urlRegex ? void 0 : url,
      urlRegex,
      columnNumber,
      condition
    });
    if (response.getError()) {
      return { locations: [], breakpointId: null };
    }
    let locations = [];
    if (response.locations) {
      locations = response.locations.map((payload) => Location.fromPayload(this, payload));
    }
    return { locations, breakpointId: response.breakpointId };
  }
  async setBreakpointInAnonymousScript(scriptHash, lineNumber, columnNumber, condition) {
    const response = await this.agent.invoke_setBreakpointByUrl({ lineNumber, scriptHash, columnNumber, condition });
    if (response.getError()) {
      return { locations: [], breakpointId: null };
    }
    let locations = [];
    if (response.locations) {
      locations = response.locations.map((payload) => Location.fromPayload(this, payload));
    }
    return { locations, breakpointId: response.breakpointId };
  }
  async removeBreakpoint(breakpointId) {
    await this.agent.invoke_removeBreakpoint({ breakpointId });
  }
  async getPossibleBreakpoints(startLocation, endLocation, restrictToFunction) {
    const response = await this.agent.invoke_getPossibleBreakpoints({
      start: startLocation.payload(),
      end: endLocation ? endLocation.payload() : void 0,
      restrictToFunction
    });
    if (response.getError() || !response.locations) {
      return [];
    }
    return response.locations.map((location) => BreakLocation.fromPayload(this, location));
  }
  async fetchAsyncStackTrace(stackId) {
    const response = await this.agent.invoke_getStackTrace({ stackTraceId: stackId });
    return response.getError() ? null : response.stackTrace;
  }
  breakpointResolved(breakpointId, location) {
    this.#breakpointResolvedEventTarget.dispatchEventToListeners(breakpointId, Location.fromPayload(this, location));
  }
  globalObjectCleared() {
    this.resetDebuggerPausedDetails();
    this.reset();
    this.dispatchEventToListeners(Events7.GlobalObjectCleared, this);
  }
  reset() {
    for (const script of this.#scripts.values()) {
      this.#sourceMapManager.detachSourceMap(script);
    }
    this.#scripts.clear();
    this.#scriptsBySourceURL.clear();
    this.#discardableScripts = [];
    this.#autoSteppingContext = null;
  }
  scripts() {
    return Array.from(this.#scripts.values());
  }
  scriptForId(scriptId) {
    return this.#scripts.get(scriptId) || null;
  }
  /**
   * Returns all `Script` objects with the same provided `sourceURL`. The
   * resulting array is sorted by time with the newest `Script` in the front.
   */
  scriptsForSourceURL(sourceURL) {
    return this.#scriptsBySourceURL.get(sourceURL) || [];
  }
  scriptsForExecutionContext(executionContext) {
    const result = [];
    for (const script of this.#scripts.values()) {
      if (script.executionContextId === executionContext.id) {
        result.push(script);
      }
    }
    return result;
  }
  get callFrames() {
    return this.#debuggerPausedDetails ? this.#debuggerPausedDetails.callFrames : null;
  }
  debuggerPausedDetails() {
    return this.#debuggerPausedDetails;
  }
  async setDebuggerPausedDetails(debuggerPausedDetails) {
    this.#isPausing = false;
    this.#debuggerPausedDetails = debuggerPausedDetails;
    if (this.#beforePausedCallback) {
      if (!await this.#beforePausedCallback.call(null, debuggerPausedDetails, this.#autoSteppingContext)) {
        return false;
      }
    }
    this.#autoSteppingContext = null;
    this.dispatchEventToListeners(Events7.DebuggerPaused, this);
    this.setSelectedCallFrame(debuggerPausedDetails.callFrames[0]);
    return true;
  }
  resetDebuggerPausedDetails() {
    this.#isPausing = false;
    this.#debuggerPausedDetails = null;
    this.setSelectedCallFrame(null);
  }
  setBeforePausedCallback(callback) {
    this.#beforePausedCallback = callback;
  }
  setExpandCallFramesCallback(callback) {
    this.#expandCallFramesCallback = callback;
  }
  setEvaluateOnCallFrameCallback(callback) {
    this.evaluateOnCallFrameCallback = callback;
  }
  setSynchronizeBreakpointsCallback(callback) {
    this.#synchronizeBreakpointsCallback = callback;
  }
  async pausedScript(callFrames, reason, auxData, breakpointIds, asyncStackTrace, asyncStackTraceId) {
    if (reason === "instrumentation") {
      const script = this.scriptForId(auxData.scriptId);
      if (this.#synchronizeBreakpointsCallback && script) {
        await this.#synchronizeBreakpointsCallback(script);
      }
      this.resume();
      return;
    }
    const pausedDetails = new DebuggerPausedDetails(this, callFrames, reason, auxData, breakpointIds, asyncStackTrace, asyncStackTraceId);
    await this.#expandCallFrames(pausedDetails);
    if (this.continueToLocationCallback) {
      const callback = this.continueToLocationCallback;
      this.continueToLocationCallback = null;
      if (callback(pausedDetails)) {
        return;
      }
    }
    if (!await this.setDebuggerPausedDetails(pausedDetails)) {
      if (this.#autoSteppingContext) {
        void this.stepOver();
      } else {
        void this.stepInto();
      }
    } else {
      Common17.EventTarget.fireEvent("DevTools.DebuggerPaused");
    }
  }
  /** Delegates to the DebuggerLanguagePlugin and potential attached source maps to expand inlined call frames */
  async #expandCallFrames(pausedDetails) {
    if (this.#expandCallFramesCallback) {
      pausedDetails.callFrames = await this.#expandCallFramesCallback.call(null, pausedDetails.callFrames);
    }
    if (!Root6.Runtime.experiments.isEnabled(
      "use-source-map-scopes"
      /* Root.Runtime.ExperimentName.USE_SOURCE_MAP_SCOPES */
    )) {
      return;
    }
    const finalFrames = [];
    for (const frame of pausedDetails.callFrames) {
      const sourceMap = await this.sourceMapManager().sourceMapForClientPromise(frame.script);
      if (sourceMap?.hasScopeInfo()) {
        finalFrames.push(...sourceMap.expandCallFrame(frame));
      } else {
        finalFrames.push(frame);
      }
    }
    pausedDetails.callFrames = finalFrames;
  }
  resumedScript() {
    this.resetDebuggerPausedDetails();
    this.dispatchEventToListeners(Events7.DebuggerResumed, this);
  }
  parsedScriptSource(scriptId, sourceURL, startLine, startColumn, endLine, endColumn, executionContextId, hash, executionContextAuxData, isLiveEdit, sourceMapURL, hasSourceURLComment, hasSyntaxError, length, isModule, originStackTrace, codeOffset, scriptLanguage, debugSymbols, embedderName, buildId) {
    const knownScript = this.#scripts.get(scriptId);
    if (knownScript) {
      return knownScript;
    }
    let isContentScript = false;
    if (executionContextAuxData && "isDefault" in executionContextAuxData) {
      isContentScript = !executionContextAuxData["isDefault"];
    }
    const selectedDebugSymbol = _DebuggerModel.selectSymbolSource(debugSymbols);
    const script = new Script(this, scriptId, sourceURL, startLine, startColumn, endLine, endColumn, executionContextId, hash, isContentScript, isLiveEdit, sourceMapURL, hasSourceURLComment, length, isModule, originStackTrace, codeOffset, scriptLanguage, selectedDebugSymbol, embedderName, buildId);
    this.registerScript(script);
    this.dispatchEventToListeners(Events7.ParsedScriptSource, script);
    if (script.sourceMapURL && !hasSyntaxError) {
      this.#sourceMapManager.attachSourceMap(script, script.sourceURL, script.sourceMapURL);
    }
    const isDiscardable = hasSyntaxError && script.isAnonymousScript();
    if (isDiscardable) {
      this.#discardableScripts.push(script);
      this.collectDiscardedScripts();
    }
    return script;
  }
  setSourceMapURL(script, newSourceMapURL) {
    this.#sourceMapManager.detachSourceMap(script);
    script.sourceMapURL = newSourceMapURL;
    this.#sourceMapManager.attachSourceMap(script, script.sourceURL, script.sourceMapURL);
  }
  async setDebugInfoURL(script, _externalURL) {
    if (this.#expandCallFramesCallback && this.#debuggerPausedDetails) {
      this.#debuggerPausedDetails.callFrames = await this.#expandCallFramesCallback.call(null, this.#debuggerPausedDetails.callFrames);
    }
    this.dispatchEventToListeners(Events7.DebugInfoAttached, script);
  }
  executionContextDestroyed(executionContext) {
    for (const script of this.#scripts.values()) {
      if (script.executionContextId === executionContext.id) {
        this.#sourceMapManager.detachSourceMap(script);
      }
    }
  }
  registerScript(script) {
    this.#scripts.set(script.scriptId, script);
    if (script.isAnonymousScript()) {
      return;
    }
    let scripts = this.#scriptsBySourceURL.get(script.sourceURL);
    if (!scripts) {
      scripts = [];
      this.#scriptsBySourceURL.set(script.sourceURL, scripts);
    }
    scripts.unshift(script);
  }
  unregisterScript(script) {
    console.assert(script.isAnonymousScript());
    this.#scripts.delete(script.scriptId);
  }
  collectDiscardedScripts() {
    if (this.#discardableScripts.length < 1e3) {
      return;
    }
    const scriptsToDiscard = this.#discardableScripts.splice(0, 100);
    for (const script of scriptsToDiscard) {
      this.unregisterScript(script);
      this.dispatchEventToListeners(Events7.DiscardedAnonymousScriptSource, script);
    }
  }
  createRawLocation(script, lineNumber, columnNumber, inlineFrameIndex) {
    return this.createRawLocationByScriptId(script.scriptId, lineNumber, columnNumber, inlineFrameIndex);
  }
  createRawLocationByURL(sourceURL, lineNumber, columnNumber, inlineFrameIndex) {
    for (const script of this.#scriptsBySourceURL.get(sourceURL) || []) {
      if (script.lineOffset > lineNumber || script.lineOffset === lineNumber && columnNumber !== void 0 && script.columnOffset > columnNumber) {
        continue;
      }
      if (script.endLine < lineNumber || script.endLine === lineNumber && columnNumber !== void 0 && script.endColumn <= columnNumber) {
        continue;
      }
      return new Location(this, script.scriptId, lineNumber, columnNumber, inlineFrameIndex);
    }
    return null;
  }
  createRawLocationByScriptId(scriptId, lineNumber, columnNumber, inlineFrameIndex) {
    return new Location(this, scriptId, lineNumber, columnNumber, inlineFrameIndex);
  }
  createRawLocationsByStackTrace(stackTrace) {
    const rawLocations = [];
    for (let current = stackTrace; current; current = current.parent) {
      for (const { scriptId, lineNumber, columnNumber } of current.callFrames) {
        rawLocations.push(this.createRawLocationByScriptId(scriptId, lineNumber, columnNumber));
      }
    }
    return rawLocations;
  }
  isPaused() {
    return Boolean(this.debuggerPausedDetails());
  }
  isPausing() {
    return this.#isPausing;
  }
  setSelectedCallFrame(callFrame) {
    if (this.#selectedCallFrame === callFrame) {
      return;
    }
    this.#selectedCallFrame = callFrame;
    this.dispatchEventToListeners(Events7.CallFrameSelected, this);
  }
  selectedCallFrame() {
    return this.#selectedCallFrame;
  }
  async evaluateOnSelectedCallFrame(options) {
    const callFrame = this.selectedCallFrame();
    if (!callFrame) {
      throw new Error("No call frame selected");
    }
    return await callFrame.evaluate(options);
  }
  functionDetailsPromise(remoteObject) {
    return remoteObject.getAllProperties(
      false,
      false
      /* generatePreview */
    ).then(buildDetails.bind(this));
    function buildDetails(response) {
      if (!response) {
        return null;
      }
      let location = null;
      if (response.internalProperties) {
        for (const prop of response.internalProperties) {
          if (prop.name === "[[FunctionLocation]]") {
            location = prop.value;
          }
        }
      }
      let functionName = null;
      if (response.properties) {
        for (const prop of response.properties) {
          if (prop.name === "name" && prop.value && prop.value.type === "string") {
            functionName = prop.value;
          }
        }
      }
      let debuggerLocation = null;
      if (location) {
        debuggerLocation = this.createRawLocationByScriptId(location.value.scriptId, location.value.lineNumber, location.value.columnNumber);
      }
      return { location: debuggerLocation, functionName: functionName ? functionName.value : "" };
    }
  }
  async setVariableValue(scopeNumber, variableName, newValue, callFrameId) {
    const response = await this.agent.invoke_setVariableValue({ scopeNumber, variableName, newValue, callFrameId });
    const error = response.getError();
    return error;
  }
  addBreakpointListener(breakpointId, listener, thisObject) {
    this.#breakpointResolvedEventTarget.addEventListener(breakpointId, listener, thisObject);
  }
  removeBreakpointListener(breakpointId, listener, thisObject) {
    this.#breakpointResolvedEventTarget.removeEventListener(breakpointId, listener, thisObject);
  }
  async setBlackboxPatterns(patterns, skipAnonymous) {
    const response = await this.agent.invoke_setBlackboxPatterns({ patterns, skipAnonymous });
    const error = response.getError();
    return !error;
  }
  async setBlackboxExecutionContexts(uniqueIds) {
    const response = await this.agent.invoke_setBlackboxExecutionContexts({ uniqueIds });
    const error = response.getError();
    return !error;
  }
  dispose() {
    if (this.#debuggerId) {
      debuggerIdToModel.delete(this.#debuggerId);
    }
    Common17.Settings.Settings.instance().moduleSetting("pause-on-exception-enabled").removeChangeListener(this.pauseOnExceptionStateChanged, this);
    Common17.Settings.Settings.instance().moduleSetting("pause-on-caught-exception").removeChangeListener(this.pauseOnExceptionStateChanged, this);
    Common17.Settings.Settings.instance().moduleSetting("disable-async-stack-traces").removeChangeListener(this.asyncStackTracesStateChanged, this);
  }
  async suspendModel() {
    await this.disableDebugger();
  }
  async resumeModel() {
    await this.enableDebugger();
  }
  static shouldResyncDebuggerId = false;
  getEvaluateOnCallFrameCallback() {
    return this.evaluateOnCallFrameCallback;
  }
  /**
   * Iterates the async stack trace parents.
   *
   * Retrieving cross-target async stack fragments requires CDP interaction, so this is an async generator.
   *
   * Important: This iterator will not yield the "synchronous" part of the stack trace, only the async parent chain.
   */
  async *iterateAsyncParents(stackTraceOrPausedDetails) {
    let stackTrace = stackTraceOrPausedDetails instanceof DebuggerPausedDetails ? {
      callFrames: [],
      parent: stackTraceOrPausedDetails.asyncStackTrace,
      parentId: stackTraceOrPausedDetails.asyncStackTraceId
    } : stackTraceOrPausedDetails;
    let target = this.target();
    while (true) {
      if (stackTrace.parent) {
        stackTrace = stackTrace.parent;
      } else if (stackTrace.parentId) {
        const model = stackTrace.parentId.debuggerId ? await _DebuggerModel.modelForDebuggerId(stackTrace.parentId.debuggerId) : this;
        if (!model) {
          return;
        }
        const maybeStackTrace = await model.fetchAsyncStackTrace(stackTrace.parentId);
        if (!maybeStackTrace) {
          return;
        }
        stackTrace = maybeStackTrace;
        target = model.target();
      } else {
        return;
      }
      yield { stackTrace, target };
    }
  }
};
var debuggerIdToModel = /* @__PURE__ */ new Map();
var PauseOnExceptionsState;
(function(PauseOnExceptionsState2) {
  PauseOnExceptionsState2["DontPauseOnExceptions"] = "none";
  PauseOnExceptionsState2["PauseOnAllExceptions"] = "all";
  PauseOnExceptionsState2["PauseOnCaughtExceptions"] = "caught";
  PauseOnExceptionsState2["PauseOnUncaughtExceptions"] = "uncaught";
})(PauseOnExceptionsState || (PauseOnExceptionsState = {}));
var Events7;
(function(Events12) {
  Events12["DebuggerWasEnabled"] = "DebuggerWasEnabled";
  Events12["DebuggerWasDisabled"] = "DebuggerWasDisabled";
  Events12["DebuggerPaused"] = "DebuggerPaused";
  Events12["DebuggerResumed"] = "DebuggerResumed";
  Events12["DebugInfoAttached"] = "DebugInfoAttached";
  Events12["ParsedScriptSource"] = "ParsedScriptSource";
  Events12["DiscardedAnonymousScriptSource"] = "DiscardedAnonymousScriptSource";
  Events12["GlobalObjectCleared"] = "GlobalObjectCleared";
  Events12["CallFrameSelected"] = "CallFrameSelected";
  Events12["DebuggerIsReadyToPause"] = "DebuggerIsReadyToPause";
  Events12["ScriptSourceWasEdited"] = "ScriptSourceWasEdited";
})(Events7 || (Events7 = {}));
var DebuggerDispatcher = class {
  #debuggerModel;
  constructor(debuggerModel) {
    this.#debuggerModel = debuggerModel;
  }
  paused({ callFrames, reason, data, hitBreakpoints, asyncStackTrace, asyncStackTraceId }) {
    if (!this.#debuggerModel.debuggerEnabled()) {
      return;
    }
    void this.#debuggerModel.pausedScript(callFrames, reason, data, hitBreakpoints || [], asyncStackTrace, asyncStackTraceId);
  }
  resumed() {
    if (!this.#debuggerModel.debuggerEnabled()) {
      return;
    }
    this.#debuggerModel.resumedScript();
  }
  scriptParsed({ scriptId, url, startLine, startColumn, endLine, endColumn, executionContextId, hash, executionContextAuxData, isLiveEdit, sourceMapURL, hasSourceURL, length, isModule, stackTrace, codeOffset, scriptLanguage, debugSymbols, embedderName, buildId }) {
    if (!this.#debuggerModel.debuggerEnabled()) {
      return;
    }
    this.#debuggerModel.parsedScriptSource(scriptId, url, startLine, startColumn, endLine, endColumn, executionContextId, hash, executionContextAuxData, Boolean(isLiveEdit), sourceMapURL, Boolean(hasSourceURL), false, length || 0, isModule || null, stackTrace || null, codeOffset || null, scriptLanguage || null, debugSymbols || null, embedderName || null, buildId || null);
  }
  scriptFailedToParse({ scriptId, url, startLine, startColumn, endLine, endColumn, executionContextId, hash, executionContextAuxData, sourceMapURL, hasSourceURL, length, isModule, stackTrace, codeOffset, scriptLanguage, embedderName, buildId }) {
    if (!this.#debuggerModel.debuggerEnabled()) {
      return;
    }
    this.#debuggerModel.parsedScriptSource(scriptId, url, startLine, startColumn, endLine, endColumn, executionContextId, hash, executionContextAuxData, false, sourceMapURL, Boolean(hasSourceURL), true, length || 0, isModule || null, stackTrace || null, codeOffset || null, scriptLanguage || null, null, embedderName || null, buildId || null);
  }
  breakpointResolved({ breakpointId, location }) {
    if (!this.#debuggerModel.debuggerEnabled()) {
      return;
    }
    this.#debuggerModel.breakpointResolved(breakpointId, location);
  }
};
var Location = class _Location {
  debuggerModel;
  scriptId;
  lineNumber;
  columnNumber;
  inlineFrameIndex;
  constructor(debuggerModel, scriptId, lineNumber, columnNumber, inlineFrameIndex) {
    this.debuggerModel = debuggerModel;
    this.scriptId = scriptId;
    this.lineNumber = lineNumber;
    this.columnNumber = columnNumber || 0;
    this.inlineFrameIndex = inlineFrameIndex || 0;
  }
  static fromPayload(debuggerModel, payload, inlineFrameIndex) {
    return new _Location(debuggerModel, payload.scriptId, payload.lineNumber, payload.columnNumber, inlineFrameIndex);
  }
  payload() {
    return { scriptId: this.scriptId, lineNumber: this.lineNumber, columnNumber: this.columnNumber };
  }
  script() {
    return this.debuggerModel.scriptForId(this.scriptId);
  }
  continueToLocation(pausedCallback) {
    if (pausedCallback) {
      this.debuggerModel.continueToLocationCallback = this.paused.bind(this, pausedCallback);
    }
    void this.debuggerModel.agent.invoke_continueToLocation({
      location: this.payload(),
      targetCallFrames: "current"
    });
  }
  paused(pausedCallback, debuggerPausedDetails) {
    const location = debuggerPausedDetails.callFrames[0].location();
    if (location.scriptId === this.scriptId && location.lineNumber === this.lineNumber && location.columnNumber === this.columnNumber) {
      pausedCallback();
      return true;
    }
    return false;
  }
  id() {
    return this.debuggerModel.target().id() + ":" + this.scriptId + ":" + this.lineNumber + ":" + this.columnNumber;
  }
};
var BreakLocation = class _BreakLocation extends Location {
  type;
  constructor(debuggerModel, scriptId, lineNumber, columnNumber, type) {
    super(debuggerModel, scriptId, lineNumber, columnNumber);
    if (type) {
      this.type = type;
    }
  }
  static fromPayload(debuggerModel, payload) {
    return new _BreakLocation(debuggerModel, payload.scriptId, payload.lineNumber, payload.columnNumber, payload.type);
  }
};
var CallFrame = class _CallFrame {
  debuggerModel;
  script;
  payload;
  #location;
  #scopeChain;
  #localScope;
  inlineFrameIndex;
  functionName;
  #functionLocation;
  #returnValue;
  missingDebugInfoDetails;
  exception;
  canBeRestarted;
  constructor(debuggerModel, script, payload, inlineFrameIndex, functionName, exception = null) {
    this.debuggerModel = debuggerModel;
    this.script = script;
    this.payload = payload;
    this.#location = Location.fromPayload(debuggerModel, payload.location, inlineFrameIndex);
    this.#scopeChain = [];
    this.#localScope = null;
    this.inlineFrameIndex = inlineFrameIndex || 0;
    this.functionName = functionName ?? payload.functionName;
    this.missingDebugInfoDetails = null;
    this.canBeRestarted = Boolean(payload.canBeRestarted);
    this.exception = exception;
    for (let i = 0; i < payload.scopeChain.length; ++i) {
      const scope = new Scope(this, i);
      this.#scopeChain.push(scope);
      if (scope.type() === "local") {
        this.#localScope = scope;
      }
    }
    if (payload.functionLocation) {
      this.#functionLocation = Location.fromPayload(debuggerModel, payload.functionLocation);
    }
    this.#returnValue = payload.returnValue ? this.debuggerModel.runtimeModel().createRemoteObject(payload.returnValue) : null;
  }
  static fromPayloadArray(debuggerModel, callFrames, exception) {
    const result = [];
    for (let i = 0; i < callFrames.length; ++i) {
      const callFrame = callFrames[i];
      const script = debuggerModel.scriptForId(callFrame.location.scriptId);
      if (script) {
        const ex = i === 0 ? exception : null;
        result.push(new _CallFrame(debuggerModel, script, callFrame, void 0, void 0, ex));
      }
    }
    return result;
  }
  createVirtualCallFrame(inlineFrameIndex, name) {
    return new _CallFrame(this.debuggerModel, this.script, this.payload, inlineFrameIndex, name, this.exception);
  }
  get id() {
    return this.payload.callFrameId;
  }
  scopeChain() {
    return this.#scopeChain;
  }
  localScope() {
    return this.#localScope;
  }
  thisObject() {
    return this.payload.this ? this.debuggerModel.runtimeModel().createRemoteObject(this.payload.this) : null;
  }
  returnValue() {
    return this.#returnValue;
  }
  async setReturnValue(expression) {
    if (!this.#returnValue) {
      return null;
    }
    const evaluateResponse = await this.debuggerModel.agent.invoke_evaluateOnCallFrame({ callFrameId: this.id, expression, silent: true, objectGroup: "backtrace" });
    if (evaluateResponse.getError() || evaluateResponse.exceptionDetails) {
      return null;
    }
    const response = await this.debuggerModel.agent.invoke_setReturnValue({ newValue: evaluateResponse.result });
    if (response.getError()) {
      return null;
    }
    this.#returnValue = this.debuggerModel.runtimeModel().createRemoteObject(evaluateResponse.result);
    return this.#returnValue;
  }
  location() {
    return this.#location;
  }
  functionLocation() {
    return this.#functionLocation || null;
  }
  async evaluate(options) {
    const debuggerModel = this.debuggerModel;
    const runtimeModel = debuggerModel.runtimeModel();
    const evaluateOnCallFrameCallback = debuggerModel.getEvaluateOnCallFrameCallback();
    if (evaluateOnCallFrameCallback) {
      const result = await evaluateOnCallFrameCallback(this, options);
      if (result) {
        return result;
      }
    }
    const response = await this.debuggerModel.agent.invoke_evaluateOnCallFrame({
      callFrameId: this.id,
      expression: options.expression,
      objectGroup: options.objectGroup,
      includeCommandLineAPI: options.includeCommandLineAPI,
      silent: options.silent,
      returnByValue: options.returnByValue,
      generatePreview: options.generatePreview,
      throwOnSideEffect: options.throwOnSideEffect,
      timeout: options.timeout
    });
    const error = response.getError();
    if (error) {
      return { error };
    }
    return { object: runtimeModel.createRemoteObject(response.result), exceptionDetails: response.exceptionDetails };
  }
  async restart() {
    console.assert(this.canBeRestarted, "This frame can not be restarted.");
    await this.debuggerModel.agent.invoke_restartFrame({
      callFrameId: this.id,
      mode: "StepInto"
      /* Protocol.Debugger.RestartFrameRequestMode.StepInto */
    });
  }
  getPayload() {
    return this.payload;
  }
};
var Scope = class {
  #callFrame;
  #payload;
  #type;
  #name;
  #ordinal;
  #locationRange;
  #object = null;
  constructor(callFrame, ordinal) {
    this.#callFrame = callFrame;
    this.#payload = callFrame.getPayload().scopeChain[ordinal];
    this.#type = this.#payload.type;
    this.#name = this.#payload.name;
    this.#ordinal = ordinal;
    const start = this.#payload.startLocation ? Location.fromPayload(callFrame.debuggerModel, this.#payload.startLocation) : null;
    const end = this.#payload.endLocation ? Location.fromPayload(callFrame.debuggerModel, this.#payload.endLocation) : null;
    if (start && end && start.scriptId === end.scriptId) {
      this.#locationRange = { start, end };
    } else {
      this.#locationRange = null;
    }
  }
  callFrame() {
    return this.#callFrame;
  }
  type() {
    return this.#type;
  }
  typeName() {
    switch (this.#type) {
      case "local":
        return i18nString6(UIStrings6.local);
      case "closure":
        return i18nString6(UIStrings6.closure);
      case "catch":
        return i18nString6(UIStrings6.catchBlock);
      case "eval":
        return i18n11.i18n.lockedString("Eval");
      case "block":
        return i18nString6(UIStrings6.block);
      case "script":
        return i18nString6(UIStrings6.script);
      case "with":
        return i18nString6(UIStrings6.withBlock);
      case "global":
        return i18nString6(UIStrings6.global);
      case "module":
        return i18nString6(UIStrings6.module);
      case "wasm-expression-stack":
        return i18nString6(UIStrings6.expression);
    }
    return "";
  }
  name() {
    return this.#name;
  }
  range() {
    return this.#locationRange;
  }
  object() {
    if (this.#object) {
      return this.#object;
    }
    const runtimeModel = this.#callFrame.debuggerModel.runtimeModel();
    const declarativeScope = this.#type !== "with" && this.#type !== "global";
    if (declarativeScope) {
      this.#object = runtimeModel.createScopeRemoteObject(this.#payload.object, new ScopeRef(this.#ordinal, this.#callFrame.id));
    } else {
      this.#object = runtimeModel.createRemoteObject(this.#payload.object);
    }
    return this.#object;
  }
  description() {
    const declarativeScope = this.#type !== "with" && this.#type !== "global";
    return declarativeScope ? "" : this.#payload.object.description || "";
  }
  icon() {
    return void 0;
  }
  extraProperties() {
    if (this.#ordinal !== 0 || this.#type !== "local" || this.#callFrame.script.isWasm()) {
      return [];
    }
    const extraProperties = [];
    const exception = this.#callFrame.exception;
    if (exception) {
      extraProperties.push(new RemoteObjectProperty(
        i18nString6(UIStrings6.exception),
        exception,
        void 0,
        void 0,
        void 0,
        void 0,
        void 0,
        /* synthetic */
        true
      ));
    }
    const returnValue = this.#callFrame.returnValue();
    if (returnValue) {
      extraProperties.push(new RemoteObjectProperty(
        i18nString6(UIStrings6.returnValue),
        returnValue,
        void 0,
        void 0,
        void 0,
        void 0,
        void 0,
        /* synthetic */
        true,
        this.#callFrame.setReturnValue.bind(this.#callFrame)
      ));
    }
    return extraProperties;
  }
};
var DebuggerPausedDetails = class {
  debuggerModel;
  callFrames;
  reason;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  auxData;
  breakpointIds;
  asyncStackTrace;
  asyncStackTraceId;
  constructor(debuggerModel, callFrames, reason, auxData, breakpointIds, asyncStackTrace, asyncStackTraceId) {
    this.debuggerModel = debuggerModel;
    this.reason = reason;
    this.auxData = auxData;
    this.breakpointIds = breakpointIds;
    if (asyncStackTrace) {
      this.asyncStackTrace = this.cleanRedundantFrames(asyncStackTrace);
    }
    this.asyncStackTraceId = asyncStackTraceId;
    this.callFrames = CallFrame.fromPayloadArray(debuggerModel, callFrames, this.exception());
  }
  exception() {
    if (this.reason !== "exception" && this.reason !== "promiseRejection") {
      return null;
    }
    return this.debuggerModel.runtimeModel().createRemoteObject(this.auxData);
  }
  cleanRedundantFrames(asyncStackTrace) {
    let stack = asyncStackTrace;
    let previous = null;
    while (stack) {
      if (previous && !stack.callFrames.length) {
        previous.parent = stack.parent;
      } else {
        previous = stack;
      }
      stack = stack.parent;
    }
    return asyncStackTrace;
  }
};
SDKModel.register(DebuggerModel, { capabilities: 4, autostart: true });
var LOGPOINT_SOURCE_URL = "debugger://logpoint";
var COND_BREAKPOINT_SOURCE_URL = "debugger://breakpoint";

// gen/front_end/core/sdk/OverlayPersistentHighlighter.js
var OverlayPersistentHighlighter_exports = {};
__export(OverlayPersistentHighlighter_exports, {
  OverlayPersistentHighlighter: () => OverlayPersistentHighlighter
});
import * as Common19 from "./../common/common.js";
import * as Platform13 from "./../platform/platform.js";

// gen/front_end/core/sdk/OverlayColorGenerator.js
var OverlayColorGenerator_exports = {};
__export(OverlayColorGenerator_exports, {
  OverlayColorGenerator: () => OverlayColorGenerator
});
import * as Common18 from "./../common/common.js";
var OverlayColorGenerator = class {
  #colors;
  #index;
  constructor() {
    const format = "rgba";
    this.#colors = [
      // F59794
      new Common18.Color.Legacy([0.9607843137254902, 0.592156862745098, 0.5803921568627451, 1], format),
      // F0BF4C
      new Common18.Color.Legacy([0.9411764705882353, 0.7490196078431373, 0.2980392156862745, 1], format),
      // D4ED31
      new Common18.Color.Legacy([0.8313725490196079, 0.9294117647058824, 0.19215686274509805, 1], format),
      // 9EEB47
      new Common18.Color.Legacy([0.6196078431372549, 0.9215686274509803, 0.2784313725490196, 1], format),
      // 5BD1D7
      new Common18.Color.Legacy([0.3568627450980392, 0.8196078431372549, 0.8431372549019608, 1], format),
      // BCCEFB
      new Common18.Color.Legacy([0.7372549019607844, 0.807843137254902, 0.984313725490196, 1], format),
      // C6BEEE
      new Common18.Color.Legacy([0.7764705882352941, 0.7450980392156863, 0.9333333333333333, 1], format),
      // D094EA
      new Common18.Color.Legacy([0.8156862745098039, 0.5803921568627451, 0.9176470588235294, 1], format),
      // EB94CF
      new Common18.Color.Legacy([0.9215686274509803, 0.5803921568627451, 0.8117647058823529, 1], format)
    ];
    this.#index = 0;
  }
  /**
   * Generate the next color in the spectrum
   */
  next() {
    const color = this.#colors[this.#index];
    this.#index++;
    if (this.#index >= this.#colors.length) {
      this.#index = 0;
    }
    return color;
  }
};

// gen/front_end/core/sdk/OverlayPersistentHighlighter.js
var OverlayPersistentHighlighter = class {
  #model;
  #colors = /* @__PURE__ */ new Map();
  #persistentHighlightSetting = Common19.Settings.Settings.instance().createLocalSetting("persistent-highlight-setting", []);
  #gridHighlights = /* @__PURE__ */ new Map();
  #scrollSnapHighlights = /* @__PURE__ */ new Map();
  #flexHighlights = /* @__PURE__ */ new Map();
  #containerQueryHighlights = /* @__PURE__ */ new Map();
  #isolatedElementHighlights = /* @__PURE__ */ new Map();
  #gridColorGenerator = new OverlayColorGenerator();
  #flexColorGenerator = new OverlayColorGenerator();
  /**
   * @see `front_end/core/sdk/sdk-meta.ts`
   */
  #showGridLineLabelsSetting = Common19.Settings.Settings.instance().moduleSetting("show-grid-line-labels");
  #extendGridLinesSetting = Common19.Settings.Settings.instance().moduleSetting("extend-grid-lines");
  #showGridAreasSetting = Common19.Settings.Settings.instance().moduleSetting("show-grid-areas");
  #showGridTrackSizesSetting = Common19.Settings.Settings.instance().moduleSetting("show-grid-track-sizes");
  #callbacks;
  constructor(model, callbacks) {
    this.#model = model;
    this.#callbacks = callbacks;
    this.#showGridLineLabelsSetting.addChangeListener(this.onSettingChange, this);
    this.#extendGridLinesSetting.addChangeListener(this.onSettingChange, this);
    this.#showGridAreasSetting.addChangeListener(this.onSettingChange, this);
    this.#showGridTrackSizesSetting.addChangeListener(this.onSettingChange, this);
  }
  onSettingChange() {
    this.resetOverlay();
  }
  buildGridHighlightConfig(nodeId) {
    const mainColor = this.colorOfGrid(nodeId).asLegacyColor();
    const background = mainColor.setAlpha(0.1).asLegacyColor();
    const gapBackground = mainColor.setAlpha(0.3).asLegacyColor();
    const gapHatch = mainColor.setAlpha(0.8).asLegacyColor();
    const showGridExtensionLines = this.#extendGridLinesSetting.get();
    const showPositiveLineNumbers = this.#showGridLineLabelsSetting.get() === "lineNumbers";
    const showNegativeLineNumbers = showPositiveLineNumbers;
    const showLineNames = this.#showGridLineLabelsSetting.get() === "lineNames";
    return {
      rowGapColor: gapBackground.toProtocolRGBA(),
      rowHatchColor: gapHatch.toProtocolRGBA(),
      columnGapColor: gapBackground.toProtocolRGBA(),
      columnHatchColor: gapHatch.toProtocolRGBA(),
      gridBorderColor: mainColor.toProtocolRGBA(),
      gridBorderDash: false,
      rowLineColor: mainColor.toProtocolRGBA(),
      columnLineColor: mainColor.toProtocolRGBA(),
      rowLineDash: true,
      columnLineDash: true,
      showGridExtensionLines,
      showPositiveLineNumbers,
      showNegativeLineNumbers,
      showLineNames,
      showAreaNames: this.#showGridAreasSetting.get(),
      showTrackSizes: this.#showGridTrackSizesSetting.get(),
      areaBorderColor: mainColor.toProtocolRGBA(),
      gridBackgroundColor: background.toProtocolRGBA()
    };
  }
  buildFlexContainerHighlightConfig(nodeId) {
    const mainColor = this.colorOfFlex(nodeId).asLegacyColor();
    return {
      containerBorder: {
        color: mainColor.toProtocolRGBA(),
        pattern: "dashed"
        /* Protocol.Overlay.LineStylePattern.Dashed */
      },
      itemSeparator: {
        color: mainColor.toProtocolRGBA(),
        pattern: "dotted"
        /* Protocol.Overlay.LineStylePattern.Dotted */
      },
      lineSeparator: {
        color: mainColor.toProtocolRGBA(),
        pattern: "dashed"
        /* Protocol.Overlay.LineStylePattern.Dashed */
      },
      mainDistributedSpace: { hatchColor: mainColor.toProtocolRGBA() },
      crossDistributedSpace: { hatchColor: mainColor.toProtocolRGBA() }
    };
  }
  buildScrollSnapContainerHighlightConfig(_nodeId) {
    return {
      snapAreaBorder: {
        color: Common19.Color.PageHighlight.GridBorder.toProtocolRGBA(),
        pattern: "dashed"
      },
      snapportBorder: { color: Common19.Color.PageHighlight.GridBorder.toProtocolRGBA() },
      scrollMarginColor: Common19.Color.PageHighlight.Margin.toProtocolRGBA(),
      scrollPaddingColor: Common19.Color.PageHighlight.Padding.toProtocolRGBA()
    };
  }
  highlightGridInOverlay(nodeId) {
    this.#gridHighlights.set(nodeId, this.buildGridHighlightConfig(nodeId));
    this.updateHighlightsInOverlay();
    this.savePersistentHighlightSetting();
    this.#callbacks.onGridOverlayStateChanged({ nodeId, enabled: true });
  }
  isGridHighlighted(nodeId) {
    return this.#gridHighlights.has(nodeId);
  }
  colorOfGrid(nodeId) {
    let color = this.#colors.get(nodeId);
    if (!color) {
      color = this.#gridColorGenerator.next();
      this.#colors.set(nodeId, color);
    }
    return color;
  }
  setColorOfGrid(nodeId, color) {
    this.#colors.set(nodeId, color);
  }
  hideGridInOverlay(nodeId) {
    if (this.#gridHighlights.has(nodeId)) {
      this.#gridHighlights.delete(nodeId);
      this.updateHighlightsInOverlay();
      this.savePersistentHighlightSetting();
      this.#callbacks.onGridOverlayStateChanged({ nodeId, enabled: false });
    }
  }
  highlightScrollSnapInOverlay(nodeId) {
    this.#scrollSnapHighlights.set(nodeId, this.buildScrollSnapContainerHighlightConfig(nodeId));
    this.updateHighlightsInOverlay();
    this.#callbacks.onScrollSnapOverlayStateChanged({ nodeId, enabled: true });
    this.savePersistentHighlightSetting();
  }
  isScrollSnapHighlighted(nodeId) {
    return this.#scrollSnapHighlights.has(nodeId);
  }
  hideScrollSnapInOverlay(nodeId) {
    if (this.#scrollSnapHighlights.has(nodeId)) {
      this.#scrollSnapHighlights.delete(nodeId);
      this.updateHighlightsInOverlay();
      this.#callbacks.onScrollSnapOverlayStateChanged({ nodeId, enabled: false });
      this.savePersistentHighlightSetting();
    }
  }
  highlightFlexInOverlay(nodeId) {
    this.#flexHighlights.set(nodeId, this.buildFlexContainerHighlightConfig(nodeId));
    this.updateHighlightsInOverlay();
    this.savePersistentHighlightSetting();
    this.#callbacks.onFlexOverlayStateChanged({ nodeId, enabled: true });
  }
  isFlexHighlighted(nodeId) {
    return this.#flexHighlights.has(nodeId);
  }
  colorOfFlex(nodeId) {
    let color = this.#colors.get(nodeId);
    if (!color) {
      color = this.#flexColorGenerator.next();
      this.#colors.set(nodeId, color);
    }
    return color;
  }
  setColorOfFlex(nodeId, color) {
    this.#colors.set(nodeId, color);
  }
  hideFlexInOverlay(nodeId) {
    if (this.#flexHighlights.has(nodeId)) {
      this.#flexHighlights.delete(nodeId);
      this.updateHighlightsInOverlay();
      this.savePersistentHighlightSetting();
      this.#callbacks.onFlexOverlayStateChanged({ nodeId, enabled: false });
    }
  }
  highlightContainerQueryInOverlay(nodeId) {
    this.#containerQueryHighlights.set(nodeId, this.buildContainerQueryContainerHighlightConfig());
    this.updateHighlightsInOverlay();
    this.savePersistentHighlightSetting();
    this.#callbacks.onContainerQueryOverlayStateChanged({ nodeId, enabled: true });
  }
  hideContainerQueryInOverlay(nodeId) {
    if (this.#containerQueryHighlights.has(nodeId)) {
      this.#containerQueryHighlights.delete(nodeId);
      this.updateHighlightsInOverlay();
      this.savePersistentHighlightSetting();
      this.#callbacks.onContainerQueryOverlayStateChanged({ nodeId, enabled: false });
    }
  }
  isContainerQueryHighlighted(nodeId) {
    return this.#containerQueryHighlights.has(nodeId);
  }
  buildContainerQueryContainerHighlightConfig() {
    return {
      containerBorder: {
        color: Common19.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
        pattern: "dashed"
      },
      descendantBorder: {
        color: Common19.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
        pattern: "dashed"
      }
    };
  }
  highlightIsolatedElementInOverlay(nodeId) {
    this.#isolatedElementHighlights.set(nodeId, this.buildIsolationModeHighlightConfig());
    this.updateHighlightsInOverlay();
    this.savePersistentHighlightSetting();
  }
  hideIsolatedElementInOverlay(nodeId) {
    if (this.#isolatedElementHighlights.has(nodeId)) {
      this.#isolatedElementHighlights.delete(nodeId);
      this.updateHighlightsInOverlay();
      this.savePersistentHighlightSetting();
    }
  }
  isIsolatedElementHighlighted(nodeId) {
    return this.#isolatedElementHighlights.has(nodeId);
  }
  buildIsolationModeHighlightConfig() {
    return {
      resizerColor: Common19.Color.IsolationModeHighlight.Resizer.toProtocolRGBA(),
      resizerHandleColor: Common19.Color.IsolationModeHighlight.ResizerHandle.toProtocolRGBA(),
      maskColor: Common19.Color.IsolationModeHighlight.Mask.toProtocolRGBA()
    };
  }
  hideAllInOverlayWithoutSave() {
    this.#flexHighlights.clear();
    this.#gridHighlights.clear();
    this.#scrollSnapHighlights.clear();
    this.#containerQueryHighlights.clear();
    this.#isolatedElementHighlights.clear();
    this.updateHighlightsInOverlay();
  }
  refreshHighlights() {
    const gridsNeedUpdate = this.updateHighlightsForDeletedNodes(this.#gridHighlights);
    const flexboxesNeedUpdate = this.updateHighlightsForDeletedNodes(this.#flexHighlights);
    const scrollSnapsNeedUpdate = this.updateHighlightsForDeletedNodes(this.#scrollSnapHighlights);
    const containerQueriesNeedUpdate = this.updateHighlightsForDeletedNodes(this.#containerQueryHighlights);
    const isolatedElementsNeedUpdate = this.updateHighlightsForDeletedNodes(this.#isolatedElementHighlights);
    if (flexboxesNeedUpdate || gridsNeedUpdate || scrollSnapsNeedUpdate || containerQueriesNeedUpdate || isolatedElementsNeedUpdate) {
      this.updateHighlightsInOverlay();
      this.savePersistentHighlightSetting();
    }
  }
  updateHighlightsForDeletedNodes(highlights) {
    let needsUpdate = false;
    for (const nodeId of highlights.keys()) {
      if (this.#model.getDOMModel().nodeForId(nodeId) === null) {
        highlights.delete(nodeId);
        needsUpdate = true;
      }
    }
    return needsUpdate;
  }
  resetOverlay() {
    for (const nodeId of this.#gridHighlights.keys()) {
      this.#gridHighlights.set(nodeId, this.buildGridHighlightConfig(nodeId));
    }
    for (const nodeId of this.#flexHighlights.keys()) {
      this.#flexHighlights.set(nodeId, this.buildFlexContainerHighlightConfig(nodeId));
    }
    for (const nodeId of this.#scrollSnapHighlights.keys()) {
      this.#scrollSnapHighlights.set(nodeId, this.buildScrollSnapContainerHighlightConfig(nodeId));
    }
    for (const nodeId of this.#containerQueryHighlights.keys()) {
      this.#containerQueryHighlights.set(nodeId, this.buildContainerQueryContainerHighlightConfig());
    }
    for (const nodeId of this.#isolatedElementHighlights.keys()) {
      this.#isolatedElementHighlights.set(nodeId, this.buildIsolationModeHighlightConfig());
    }
    this.updateHighlightsInOverlay();
  }
  updateHighlightsInOverlay() {
    const hasNodesToHighlight = this.#gridHighlights.size > 0 || this.#flexHighlights.size > 0 || this.#containerQueryHighlights.size > 0 || this.#isolatedElementHighlights.size > 0;
    this.#model.setShowViewportSizeOnResize(!hasNodesToHighlight);
    this.updateGridHighlightsInOverlay();
    this.updateFlexHighlightsInOverlay();
    this.updateScrollSnapHighlightsInOverlay();
    this.updateContainerQueryHighlightsInOverlay();
    this.updateIsolatedElementHighlightsInOverlay();
  }
  updateGridHighlightsInOverlay() {
    const overlayModel = this.#model;
    const gridNodeHighlightConfigs = [];
    for (const [nodeId, gridHighlightConfig] of this.#gridHighlights.entries()) {
      gridNodeHighlightConfigs.push({ nodeId, gridHighlightConfig });
    }
    overlayModel.target().overlayAgent().invoke_setShowGridOverlays({ gridNodeHighlightConfigs });
  }
  updateFlexHighlightsInOverlay() {
    const overlayModel = this.#model;
    const flexNodeHighlightConfigs = [];
    for (const [nodeId, flexContainerHighlightConfig] of this.#flexHighlights.entries()) {
      flexNodeHighlightConfigs.push({ nodeId, flexContainerHighlightConfig });
    }
    overlayModel.target().overlayAgent().invoke_setShowFlexOverlays({ flexNodeHighlightConfigs });
  }
  updateScrollSnapHighlightsInOverlay() {
    const overlayModel = this.#model;
    const scrollSnapHighlightConfigs = [];
    for (const [nodeId, scrollSnapContainerHighlightConfig] of this.#scrollSnapHighlights.entries()) {
      scrollSnapHighlightConfigs.push({ nodeId, scrollSnapContainerHighlightConfig });
    }
    overlayModel.target().overlayAgent().invoke_setShowScrollSnapOverlays({ scrollSnapHighlightConfigs });
  }
  updateContainerQueryHighlightsInOverlay() {
    const overlayModel = this.#model;
    const containerQueryHighlightConfigs = [];
    for (const [nodeId, containerQueryContainerHighlightConfig] of this.#containerQueryHighlights.entries()) {
      containerQueryHighlightConfigs.push({ nodeId, containerQueryContainerHighlightConfig });
    }
    overlayModel.target().overlayAgent().invoke_setShowContainerQueryOverlays({ containerQueryHighlightConfigs });
  }
  updateIsolatedElementHighlightsInOverlay() {
    const overlayModel = this.#model;
    const isolatedElementHighlightConfigs = [];
    for (const [nodeId, isolationModeHighlightConfig] of this.#isolatedElementHighlights.entries()) {
      isolatedElementHighlightConfigs.push({ nodeId, isolationModeHighlightConfig });
    }
    overlayModel.target().overlayAgent().invoke_setShowIsolatedElements({ isolatedElementHighlightConfigs });
  }
  async restoreHighlightsForDocument() {
    this.#flexHighlights = /* @__PURE__ */ new Map();
    this.#gridHighlights = /* @__PURE__ */ new Map();
    this.#scrollSnapHighlights = /* @__PURE__ */ new Map();
    this.#containerQueryHighlights = /* @__PURE__ */ new Map();
    this.#isolatedElementHighlights = /* @__PURE__ */ new Map();
    const document2 = await this.#model.getDOMModel().requestDocument();
    const currentURL = document2 ? document2.documentURL : Platform13.DevToolsPath.EmptyUrlString;
    await Promise.all(this.#persistentHighlightSetting.get().map(async (persistentHighlight) => {
      if (persistentHighlight.url === currentURL) {
        return await this.#model.getDOMModel().pushNodeByPathToFrontend(persistentHighlight.path).then((nodeId) => {
          const node = this.#model.getDOMModel().nodeForId(nodeId);
          if (!node) {
            return;
          }
          switch (persistentHighlight.type) {
            case "GRID":
              this.#gridHighlights.set(node.id, this.buildGridHighlightConfig(node.id));
              this.#callbacks.onGridOverlayStateChanged({ nodeId: node.id, enabled: true });
              break;
            case "FLEX":
              this.#flexHighlights.set(node.id, this.buildFlexContainerHighlightConfig(node.id));
              this.#callbacks.onFlexOverlayStateChanged({ nodeId: node.id, enabled: true });
              break;
            case "CONTAINER_QUERY":
              this.#containerQueryHighlights.set(node.id, this.buildContainerQueryContainerHighlightConfig());
              this.#callbacks.onContainerQueryOverlayStateChanged({ nodeId: node.id, enabled: true });
              break;
            case "SCROLL_SNAP":
              this.#scrollSnapHighlights.set(node.id, this.buildScrollSnapContainerHighlightConfig(node.id));
              this.#callbacks.onScrollSnapOverlayStateChanged({ nodeId: node.id, enabled: true });
              break;
            case "ISOLATED_ELEMENT":
              this.#isolatedElementHighlights.set(node.id, this.buildIsolationModeHighlightConfig());
              break;
          }
        });
      }
    }));
    this.updateHighlightsInOverlay();
  }
  currentUrl() {
    const domDocument = this.#model.getDOMModel().existingDocument();
    return domDocument ? domDocument.documentURL : Platform13.DevToolsPath.EmptyUrlString;
  }
  getPersistentHighlightSettingForOneType(highlights, type) {
    const persistentHighlights = [];
    for (const nodeId of highlights.keys()) {
      const node = this.#model.getDOMModel().nodeForId(nodeId);
      if (node) {
        persistentHighlights.push({ url: this.currentUrl(), path: node.path(), type });
      }
    }
    return persistentHighlights;
  }
  savePersistentHighlightSetting() {
    const currentURL = this.currentUrl();
    const highlightsInOtherDocuments = this.#persistentHighlightSetting.get().filter((persistentSetting) => persistentSetting.url !== currentURL);
    const persistentHighlights = [
      ...highlightsInOtherDocuments,
      ...this.getPersistentHighlightSettingForOneType(
        this.#gridHighlights,
        "GRID"
        /* HighlightType.GRID */
      ),
      ...this.getPersistentHighlightSettingForOneType(
        this.#flexHighlights,
        "FLEX"
        /* HighlightType.FLEX */
      ),
      ...this.getPersistentHighlightSettingForOneType(
        this.#containerQueryHighlights,
        "CONTAINER_QUERY"
        /* HighlightType.CONTAINER_QUERY */
      ),
      ...this.getPersistentHighlightSettingForOneType(
        this.#scrollSnapHighlights,
        "SCROLL_SNAP"
        /* HighlightType.SCROLL_SNAP */
      ),
      ...this.getPersistentHighlightSettingForOneType(
        this.#isolatedElementHighlights,
        "ISOLATED_ELEMENT"
        /* HighlightType.ISOLATED_ELEMENT */
      )
    ];
    this.#persistentHighlightSetting.set(persistentHighlights);
  }
};

// gen/front_end/core/sdk/OverlayModel.js
var UIStrings7 = {
  /**
   * @description Text in Overlay Model
   */
  pausedInDebugger: "Paused in debugger"
};
var str_7 = i18n13.i18n.registerUIStrings("core/sdk/OverlayModel.ts", UIStrings7);
var i18nString7 = i18n13.i18n.getLocalizedString.bind(void 0, str_7);
var platformOverlayDimensions = {
  mac: { x: 85, y: 0, width: 185, height: 40 },
  linux: { x: 0, y: 0, width: 196, height: 34 },
  windows: { x: 0, y: 0, width: 238, height: 33 }
};
var OverlayModel = class _OverlayModel extends SDKModel {
  #domModel;
  overlayAgent;
  #debuggerModel;
  #inspectModeEnabled = false;
  #hideHighlightTimeout = null;
  #defaultHighlighter;
  #highlighter;
  #showPaintRectsSetting;
  #showLayoutShiftRegionsSetting;
  #showAdHighlightsSetting;
  #showDebugBordersSetting;
  #showFPSCounterSetting;
  #showScrollBottleneckRectsSetting;
  #registeredListeners = [];
  #showViewportSizeOnResize = true;
  #persistentHighlighter;
  #sourceOrderHighlighter;
  #sourceOrderModeActive = false;
  #windowControls;
  constructor(target) {
    super(target);
    this.#domModel = target.model(DOMModel);
    target.registerOverlayDispatcher(this);
    this.overlayAgent = target.overlayAgent();
    this.#debuggerModel = target.model(DebuggerModel);
    if (this.#debuggerModel) {
      Common20.Settings.Settings.instance().moduleSetting("disable-paused-state-overlay").addChangeListener(this.updatePausedInDebuggerMessage, this);
      this.#debuggerModel.addEventListener(Events7.DebuggerPaused, this.updatePausedInDebuggerMessage, this);
      this.#debuggerModel.addEventListener(Events7.DebuggerResumed, this.updatePausedInDebuggerMessage, this);
      this.#debuggerModel.addEventListener(Events7.GlobalObjectCleared, this.updatePausedInDebuggerMessage, this);
    }
    this.#defaultHighlighter = new DefaultHighlighter(this);
    this.#highlighter = this.#defaultHighlighter;
    this.#showPaintRectsSetting = Common20.Settings.Settings.instance().moduleSetting("show-paint-rects");
    this.#showLayoutShiftRegionsSetting = Common20.Settings.Settings.instance().moduleSetting("show-layout-shift-regions");
    this.#showAdHighlightsSetting = Common20.Settings.Settings.instance().moduleSetting("show-ad-highlights");
    this.#showDebugBordersSetting = Common20.Settings.Settings.instance().moduleSetting("show-debug-borders");
    this.#showFPSCounterSetting = Common20.Settings.Settings.instance().moduleSetting("show-fps-counter");
    this.#showScrollBottleneckRectsSetting = Common20.Settings.Settings.instance().moduleSetting("show-scroll-bottleneck-rects");
    if (!target.suspended()) {
      void this.overlayAgent.invoke_enable();
      void this.wireAgentToSettings();
    }
    this.#persistentHighlighter = new OverlayPersistentHighlighter(this, {
      onGridOverlayStateChanged: ({ nodeId, enabled }) => this.dispatchEventToListeners("PersistentGridOverlayStateChanged", { nodeId, enabled }),
      onFlexOverlayStateChanged: ({ nodeId, enabled }) => this.dispatchEventToListeners("PersistentFlexContainerOverlayStateChanged", { nodeId, enabled }),
      onContainerQueryOverlayStateChanged: ({ nodeId, enabled }) => this.dispatchEventToListeners("PersistentContainerQueryOverlayStateChanged", { nodeId, enabled }),
      onScrollSnapOverlayStateChanged: ({ nodeId, enabled }) => this.dispatchEventToListeners("PersistentScrollSnapOverlayStateChanged", { nodeId, enabled })
    });
    this.#domModel.addEventListener(Events8.NodeRemoved, () => {
      if (!this.#persistentHighlighter) {
        return;
      }
      this.#persistentHighlighter.refreshHighlights();
    });
    this.#domModel.addEventListener(Events8.DocumentUpdated, () => {
      if (!this.#persistentHighlighter) {
        return;
      }
      this.#persistentHighlighter.hideAllInOverlayWithoutSave();
      if (!target.suspended()) {
        void this.#persistentHighlighter.restoreHighlightsForDocument();
      }
    });
    this.#sourceOrderHighlighter = new SourceOrderHighlighter(this);
    this.#windowControls = new WindowControls(this.#domModel.cssModel());
  }
  static highlightObjectAsDOMNode(object) {
    const domModel = object.runtimeModel().target().model(DOMModel);
    if (domModel) {
      domModel.overlayModel().highlightInOverlay({ object, selectorList: void 0 });
    }
  }
  static hideDOMNodeHighlight() {
    for (const overlayModel of TargetManager.instance().models(_OverlayModel)) {
      overlayModel.delayedHideHighlight(0);
    }
  }
  static async muteHighlight() {
    return await Promise.all(TargetManager.instance().models(_OverlayModel).map((model) => model.suspendModel()));
  }
  static async unmuteHighlight() {
    return await Promise.all(TargetManager.instance().models(_OverlayModel).map((model) => model.resumeModel()));
  }
  static highlightRect(rect) {
    for (const overlayModel of TargetManager.instance().models(_OverlayModel)) {
      void overlayModel.highlightRect(rect);
    }
  }
  static clearHighlight() {
    for (const overlayModel of TargetManager.instance().models(_OverlayModel)) {
      void overlayModel.clearHighlight();
    }
  }
  getDOMModel() {
    return this.#domModel;
  }
  highlightRect({ x, y, width, height, color, outlineColor }) {
    const highlightColor = color || { r: 255, g: 0, b: 255, a: 0.3 };
    const highlightOutlineColor = outlineColor || { r: 255, g: 0, b: 255, a: 0.5 };
    return this.overlayAgent.invoke_highlightRect({ x, y, width, height, color: highlightColor, outlineColor: highlightOutlineColor });
  }
  clearHighlight() {
    return this.overlayAgent.invoke_hideHighlight();
  }
  async wireAgentToSettings() {
    this.#registeredListeners = [
      this.#showPaintRectsSetting.addChangeListener(() => this.overlayAgent.invoke_setShowPaintRects({ result: this.#showPaintRectsSetting.get() })),
      this.#showLayoutShiftRegionsSetting.addChangeListener(() => this.overlayAgent.invoke_setShowLayoutShiftRegions({ result: this.#showLayoutShiftRegionsSetting.get() })),
      this.#showAdHighlightsSetting.addChangeListener(() => this.overlayAgent.invoke_setShowAdHighlights({ show: this.#showAdHighlightsSetting.get() })),
      this.#showDebugBordersSetting.addChangeListener(() => this.overlayAgent.invoke_setShowDebugBorders({ show: this.#showDebugBordersSetting.get() })),
      this.#showFPSCounterSetting.addChangeListener(() => this.overlayAgent.invoke_setShowFPSCounter({ show: this.#showFPSCounterSetting.get() })),
      this.#showScrollBottleneckRectsSetting.addChangeListener(() => this.overlayAgent.invoke_setShowScrollBottleneckRects({ show: this.#showScrollBottleneckRectsSetting.get() }))
    ];
    if (this.#showPaintRectsSetting.get()) {
      void this.overlayAgent.invoke_setShowPaintRects({ result: true });
    }
    if (this.#showLayoutShiftRegionsSetting.get()) {
      void this.overlayAgent.invoke_setShowLayoutShiftRegions({ result: true });
    }
    if (this.#showAdHighlightsSetting.get()) {
      void this.overlayAgent.invoke_setShowAdHighlights({ show: true });
    }
    if (this.#showDebugBordersSetting.get()) {
      void this.overlayAgent.invoke_setShowDebugBorders({ show: true });
    }
    if (this.#showFPSCounterSetting.get()) {
      void this.overlayAgent.invoke_setShowFPSCounter({ show: true });
    }
    if (this.#showScrollBottleneckRectsSetting.get()) {
      void this.overlayAgent.invoke_setShowScrollBottleneckRects({ show: true });
    }
    if (this.#debuggerModel && this.#debuggerModel.isPaused()) {
      this.updatePausedInDebuggerMessage();
    }
    await this.overlayAgent.invoke_setShowViewportSizeOnResize({ show: this.#showViewportSizeOnResize });
    this.#persistentHighlighter?.resetOverlay();
  }
  async suspendModel() {
    Common20.EventTarget.removeEventListeners(this.#registeredListeners);
    await this.overlayAgent.invoke_disable();
  }
  async resumeModel() {
    await Promise.all([this.overlayAgent.invoke_enable(), this.wireAgentToSettings()]);
  }
  setShowViewportSizeOnResize(show) {
    if (this.#showViewportSizeOnResize === show) {
      return;
    }
    this.#showViewportSizeOnResize = show;
    if (this.target().suspended()) {
      return;
    }
    void this.overlayAgent.invoke_setShowViewportSizeOnResize({ show });
  }
  updatePausedInDebuggerMessage() {
    if (this.target().suspended()) {
      return;
    }
    const message = this.#debuggerModel && this.#debuggerModel.isPaused() && !Common20.Settings.Settings.instance().moduleSetting("disable-paused-state-overlay").get() ? i18nString7(UIStrings7.pausedInDebugger) : void 0;
    void this.overlayAgent.invoke_setPausedInDebuggerMessage({ message });
  }
  setHighlighter(highlighter) {
    this.#highlighter = highlighter || this.#defaultHighlighter;
  }
  async setInspectMode(mode, showDetailedTooltip = true) {
    await this.#domModel.requestDocument();
    this.#inspectModeEnabled = mode !== "none";
    this.dispatchEventToListeners("InspectModeWillBeToggled", this);
    void this.#highlighter.setInspectMode(mode, this.buildHighlightConfig("all", showDetailedTooltip));
  }
  inspectModeEnabled() {
    return this.#inspectModeEnabled;
  }
  highlightInOverlay(data, mode, showInfo) {
    if (this.#sourceOrderModeActive) {
      return;
    }
    if (this.#hideHighlightTimeout) {
      clearTimeout(this.#hideHighlightTimeout);
      this.#hideHighlightTimeout = null;
    }
    const highlightConfig = this.buildHighlightConfig(mode);
    if (typeof showInfo !== "undefined") {
      highlightConfig.showInfo = showInfo;
    }
    this.#highlighter.highlightInOverlay(data, highlightConfig);
  }
  highlightInOverlayForTwoSeconds(data) {
    this.highlightInOverlay(data);
    this.delayedHideHighlight(2e3);
  }
  highlightGridInPersistentOverlay(nodeId) {
    if (!this.#persistentHighlighter) {
      return;
    }
    this.#persistentHighlighter.highlightGridInOverlay(nodeId);
  }
  isHighlightedGridInPersistentOverlay(nodeId) {
    if (!this.#persistentHighlighter) {
      return false;
    }
    return this.#persistentHighlighter.isGridHighlighted(nodeId);
  }
  hideGridInPersistentOverlay(nodeId) {
    if (!this.#persistentHighlighter) {
      return;
    }
    this.#persistentHighlighter.hideGridInOverlay(nodeId);
  }
  highlightScrollSnapInPersistentOverlay(nodeId) {
    if (!this.#persistentHighlighter) {
      return;
    }
    this.#persistentHighlighter.highlightScrollSnapInOverlay(nodeId);
  }
  isHighlightedScrollSnapInPersistentOverlay(nodeId) {
    if (!this.#persistentHighlighter) {
      return false;
    }
    return this.#persistentHighlighter.isScrollSnapHighlighted(nodeId);
  }
  hideScrollSnapInPersistentOverlay(nodeId) {
    if (!this.#persistentHighlighter) {
      return;
    }
    this.#persistentHighlighter.hideScrollSnapInOverlay(nodeId);
  }
  highlightFlexContainerInPersistentOverlay(nodeId) {
    if (!this.#persistentHighlighter) {
      return;
    }
    this.#persistentHighlighter.highlightFlexInOverlay(nodeId);
  }
  isHighlightedFlexContainerInPersistentOverlay(nodeId) {
    if (!this.#persistentHighlighter) {
      return false;
    }
    return this.#persistentHighlighter.isFlexHighlighted(nodeId);
  }
  hideFlexContainerInPersistentOverlay(nodeId) {
    if (!this.#persistentHighlighter) {
      return;
    }
    this.#persistentHighlighter.hideFlexInOverlay(nodeId);
  }
  highlightContainerQueryInPersistentOverlay(nodeId) {
    if (!this.#persistentHighlighter) {
      return;
    }
    this.#persistentHighlighter.highlightContainerQueryInOverlay(nodeId);
  }
  isHighlightedContainerQueryInPersistentOverlay(nodeId) {
    if (!this.#persistentHighlighter) {
      return false;
    }
    return this.#persistentHighlighter.isContainerQueryHighlighted(nodeId);
  }
  hideContainerQueryInPersistentOverlay(nodeId) {
    if (!this.#persistentHighlighter) {
      return;
    }
    this.#persistentHighlighter.hideContainerQueryInOverlay(nodeId);
  }
  highlightSourceOrderInOverlay(node) {
    const sourceOrderConfig = {
      parentOutlineColor: Common20.Color.SourceOrderHighlight.ParentOutline.toProtocolRGBA(),
      childOutlineColor: Common20.Color.SourceOrderHighlight.ChildOutline.toProtocolRGBA()
    };
    this.#sourceOrderHighlighter.highlightSourceOrderInOverlay(node, sourceOrderConfig);
  }
  colorOfGridInPersistentOverlay(nodeId) {
    if (!this.#persistentHighlighter) {
      return null;
    }
    return this.#persistentHighlighter.colorOfGrid(nodeId).asString(
      "hex"
      /* Common.Color.Format.HEX */
    );
  }
  setColorOfGridInPersistentOverlay(nodeId, colorStr) {
    if (!this.#persistentHighlighter) {
      return;
    }
    const color = Common20.Color.parse(colorStr);
    if (!color) {
      return;
    }
    this.#persistentHighlighter.setColorOfGrid(nodeId, color);
    this.#persistentHighlighter.resetOverlay();
  }
  colorOfFlexInPersistentOverlay(nodeId) {
    if (!this.#persistentHighlighter) {
      return null;
    }
    return this.#persistentHighlighter.colorOfFlex(nodeId).asString(
      "hex"
      /* Common.Color.Format.HEX */
    );
  }
  setColorOfFlexInPersistentOverlay(nodeId, colorStr) {
    if (!this.#persistentHighlighter) {
      return;
    }
    const color = Common20.Color.parse(colorStr);
    if (!color) {
      return;
    }
    this.#persistentHighlighter.setColorOfFlex(nodeId, color);
    this.#persistentHighlighter.resetOverlay();
  }
  hideSourceOrderInOverlay() {
    this.#sourceOrderHighlighter.hideSourceOrderHighlight();
  }
  setSourceOrderActive(isActive) {
    this.#sourceOrderModeActive = isActive;
  }
  delayedHideHighlight(delay) {
    if (this.#hideHighlightTimeout === null) {
      this.#hideHighlightTimeout = window.setTimeout(() => this.highlightInOverlay({ clear: true }), delay);
    }
  }
  highlightFrame(frameId) {
    if (this.#hideHighlightTimeout) {
      clearTimeout(this.#hideHighlightTimeout);
      this.#hideHighlightTimeout = null;
    }
    this.#highlighter.highlightFrame(frameId);
  }
  showHingeForDualScreen(hinge) {
    if (hinge) {
      const { x, y, width, height, contentColor, outlineColor } = hinge;
      void this.overlayAgent.invoke_setShowHinge({
        hingeConfig: { rect: { x, y, width, height }, contentColor, outlineColor }
      });
    } else {
      void this.overlayAgent.invoke_setShowHinge({});
    }
  }
  setWindowControlsPlatform(selectedPlatform) {
    this.#windowControls.selectedPlatform = selectedPlatform;
  }
  setWindowControlsThemeColor(themeColor) {
    this.#windowControls.themeColor = themeColor;
  }
  getWindowControlsConfig() {
    return this.#windowControls.config;
  }
  async toggleWindowControlsToolbar(show) {
    const wcoConfigObj = show ? { windowControlsOverlayConfig: this.#windowControls.config } : {};
    const setWindowControlsOverlayOperation = this.overlayAgent.invoke_setShowWindowControlsOverlay(wcoConfigObj);
    const toggleStylesheetOperation = this.#windowControls.toggleEmulatedOverlay(show);
    await Promise.all([setWindowControlsOverlayOperation, toggleStylesheetOperation]);
    this.setShowViewportSizeOnResize(!show);
  }
  buildHighlightConfig(mode = "all", showDetailedToolip = false) {
    const showRulers = Common20.Settings.Settings.instance().moduleSetting("show-metrics-rulers").get();
    const highlightConfig = {
      showInfo: mode === "all" || mode === "container-outline",
      showRulers,
      showStyles: showDetailedToolip,
      showAccessibilityInfo: showDetailedToolip,
      showExtensionLines: showRulers,
      gridHighlightConfig: {},
      flexContainerHighlightConfig: {},
      flexItemHighlightConfig: {},
      contrastAlgorithm: Root7.Runtime.experiments.isEnabled("apca") ? "apca" : "aa"
    };
    if (mode === "all" || mode === "content") {
      highlightConfig.contentColor = Common20.Color.PageHighlight.Content.toProtocolRGBA();
    }
    if (mode === "all" || mode === "padding") {
      highlightConfig.paddingColor = Common20.Color.PageHighlight.Padding.toProtocolRGBA();
    }
    if (mode === "all" || mode === "border") {
      highlightConfig.borderColor = Common20.Color.PageHighlight.Border.toProtocolRGBA();
    }
    if (mode === "all" || mode === "margin") {
      highlightConfig.marginColor = Common20.Color.PageHighlight.Margin.toProtocolRGBA();
    }
    if (mode === "all") {
      highlightConfig.eventTargetColor = Common20.Color.PageHighlight.EventTarget.toProtocolRGBA();
      highlightConfig.shapeColor = Common20.Color.PageHighlight.Shape.toProtocolRGBA();
      highlightConfig.shapeMarginColor = Common20.Color.PageHighlight.ShapeMargin.toProtocolRGBA();
      highlightConfig.gridHighlightConfig = {
        rowGapColor: Common20.Color.PageHighlight.GapBackground.toProtocolRGBA(),
        rowHatchColor: Common20.Color.PageHighlight.GapHatch.toProtocolRGBA(),
        columnGapColor: Common20.Color.PageHighlight.GapBackground.toProtocolRGBA(),
        columnHatchColor: Common20.Color.PageHighlight.GapHatch.toProtocolRGBA(),
        rowLineColor: Common20.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
        columnLineColor: Common20.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
        rowLineDash: true,
        columnLineDash: true
      };
      highlightConfig.flexContainerHighlightConfig = {
        containerBorder: {
          color: Common20.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
          pattern: "dashed"
        },
        itemSeparator: {
          color: Common20.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
          pattern: "dotted"
        },
        lineSeparator: {
          color: Common20.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
          pattern: "dashed"
        },
        mainDistributedSpace: {
          hatchColor: Common20.Color.PageHighlight.GapHatch.toProtocolRGBA(),
          fillColor: Common20.Color.PageHighlight.GapBackground.toProtocolRGBA()
        },
        crossDistributedSpace: {
          hatchColor: Common20.Color.PageHighlight.GapHatch.toProtocolRGBA(),
          fillColor: Common20.Color.PageHighlight.GapBackground.toProtocolRGBA()
        },
        rowGapSpace: {
          hatchColor: Common20.Color.PageHighlight.GapHatch.toProtocolRGBA(),
          fillColor: Common20.Color.PageHighlight.GapBackground.toProtocolRGBA()
        },
        columnGapSpace: {
          hatchColor: Common20.Color.PageHighlight.GapHatch.toProtocolRGBA(),
          fillColor: Common20.Color.PageHighlight.GapBackground.toProtocolRGBA()
        }
      };
      highlightConfig.flexItemHighlightConfig = {
        baseSizeBox: {
          hatchColor: Common20.Color.PageHighlight.GapHatch.toProtocolRGBA()
        },
        baseSizeBorder: {
          color: Common20.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
          pattern: "dotted"
        },
        flexibilityArrow: {
          color: Common20.Color.PageHighlight.LayoutLine.toProtocolRGBA()
        }
      };
    }
    if (mode.endsWith("gap")) {
      highlightConfig.gridHighlightConfig = {
        gridBorderColor: Common20.Color.PageHighlight.GridBorder.toProtocolRGBA(),
        gridBorderDash: true
      };
      if (mode === "gap" || mode === "row-gap") {
        highlightConfig.gridHighlightConfig.rowGapColor = Common20.Color.PageHighlight.GapBackground.toProtocolRGBA();
        highlightConfig.gridHighlightConfig.rowHatchColor = Common20.Color.PageHighlight.GapHatch.toProtocolRGBA();
      }
      if (mode === "gap" || mode === "column-gap") {
        highlightConfig.gridHighlightConfig.columnGapColor = Common20.Color.PageHighlight.GapBackground.toProtocolRGBA();
        highlightConfig.gridHighlightConfig.columnHatchColor = Common20.Color.PageHighlight.GapHatch.toProtocolRGBA();
      }
    }
    if (mode.endsWith("gap")) {
      highlightConfig.flexContainerHighlightConfig = {
        containerBorder: {
          color: Common20.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
          pattern: "dashed"
        }
      };
      if (mode === "gap" || mode === "row-gap") {
        highlightConfig.flexContainerHighlightConfig.rowGapSpace = {
          hatchColor: Common20.Color.PageHighlight.GapHatch.toProtocolRGBA(),
          fillColor: Common20.Color.PageHighlight.GapBackground.toProtocolRGBA()
        };
      }
      if (mode === "gap" || mode === "column-gap") {
        highlightConfig.flexContainerHighlightConfig.columnGapSpace = {
          hatchColor: Common20.Color.PageHighlight.GapHatch.toProtocolRGBA(),
          fillColor: Common20.Color.PageHighlight.GapBackground.toProtocolRGBA()
        };
      }
    }
    if (mode === "grid-areas") {
      highlightConfig.gridHighlightConfig = {
        rowLineColor: Common20.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
        columnLineColor: Common20.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
        rowLineDash: true,
        columnLineDash: true,
        showAreaNames: true,
        areaBorderColor: Common20.Color.PageHighlight.GridAreaBorder.toProtocolRGBA()
      };
    }
    if (mode === "grid-template-columns") {
      highlightConfig.contentColor = Common20.Color.PageHighlight.Content.toProtocolRGBA();
      highlightConfig.gridHighlightConfig = {
        columnLineColor: Common20.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
        columnLineDash: true
      };
    }
    if (mode === "grid-template-rows") {
      highlightConfig.contentColor = Common20.Color.PageHighlight.Content.toProtocolRGBA();
      highlightConfig.gridHighlightConfig = {
        rowLineColor: Common20.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
        rowLineDash: true
      };
    }
    if (mode === "justify-content") {
      highlightConfig.flexContainerHighlightConfig = {
        containerBorder: {
          color: Common20.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
          pattern: "dashed"
        },
        mainDistributedSpace: {
          hatchColor: Common20.Color.PageHighlight.GapHatch.toProtocolRGBA(),
          fillColor: Common20.Color.PageHighlight.GapBackground.toProtocolRGBA()
        }
      };
    }
    if (mode === "align-content") {
      highlightConfig.flexContainerHighlightConfig = {
        containerBorder: {
          color: Common20.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
          pattern: "dashed"
        },
        crossDistributedSpace: {
          hatchColor: Common20.Color.PageHighlight.GapHatch.toProtocolRGBA(),
          fillColor: Common20.Color.PageHighlight.GapBackground.toProtocolRGBA()
        }
      };
    }
    if (mode === "align-items") {
      highlightConfig.flexContainerHighlightConfig = {
        containerBorder: {
          color: Common20.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
          pattern: "dashed"
        },
        lineSeparator: {
          color: Common20.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
          pattern: "dashed"
        },
        crossAlignment: { color: Common20.Color.PageHighlight.LayoutLine.toProtocolRGBA() }
      };
    }
    if (mode === "flexibility") {
      highlightConfig.flexItemHighlightConfig = {
        baseSizeBox: {
          hatchColor: Common20.Color.PageHighlight.GapHatch.toProtocolRGBA()
        },
        baseSizeBorder: {
          color: Common20.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
          pattern: "dotted"
        },
        flexibilityArrow: {
          color: Common20.Color.PageHighlight.LayoutLine.toProtocolRGBA()
        }
      };
    }
    if (mode === "container-outline") {
      highlightConfig.containerQueryContainerHighlightConfig = {
        containerBorder: {
          color: Common20.Color.PageHighlight.LayoutLine.toProtocolRGBA(),
          pattern: "dashed"
        }
      };
    }
    return highlightConfig;
  }
  nodeHighlightRequested({ nodeId }) {
    const node = this.#domModel.nodeForId(nodeId);
    if (node) {
      this.dispatchEventToListeners("HighlightNodeRequested", node);
    }
  }
  static setInspectNodeHandler(handler) {
    _OverlayModel.inspectNodeHandler = handler;
  }
  inspectNodeRequested({ backendNodeId }) {
    const deferredNode = new DeferredDOMNode(this.target(), backendNodeId);
    if (_OverlayModel.inspectNodeHandler) {
      void deferredNode.resolvePromise().then((node) => {
        if (node && _OverlayModel.inspectNodeHandler) {
          void _OverlayModel.inspectNodeHandler(node);
        }
      });
    } else {
      void Common20.Revealer.reveal(deferredNode);
    }
    this.dispatchEventToListeners(
      "InspectModeExited"
      /* Events.EXITED_INSPECT_MODE */
    );
  }
  screenshotRequested({ viewport }) {
    this.dispatchEventToListeners("ScreenshotRequested", viewport);
    this.dispatchEventToListeners(
      "InspectModeExited"
      /* Events.EXITED_INSPECT_MODE */
    );
  }
  inspectModeCanceled() {
    this.dispatchEventToListeners(
      "InspectModeExited"
      /* Events.EXITED_INSPECT_MODE */
    );
  }
  static inspectNodeHandler = null;
  getOverlayAgent() {
    return this.overlayAgent;
  }
  async hasStyleSheetText(url) {
    return await this.#windowControls.initializeStyleSheetText(url);
  }
};
var WindowControls = class _WindowControls {
  #cssModel;
  #originalStylesheetText;
  #stylesheetId;
  #currentUrl;
  #config = {
    showCSS: false,
    selectedPlatform: "Windows",
    themeColor: "#ffffff"
  };
  constructor(cssModel) {
    this.#cssModel = cssModel;
  }
  get selectedPlatform() {
    return this.#config.selectedPlatform;
  }
  set selectedPlatform(osType) {
    this.#config.selectedPlatform = osType;
  }
  get themeColor() {
    return this.#config.themeColor;
  }
  set themeColor(color) {
    this.#config.themeColor = color;
  }
  get config() {
    return this.#config;
  }
  async initializeStyleSheetText(url) {
    if (this.#originalStylesheetText && url === this.#currentUrl) {
      return true;
    }
    const cssSourceUrl = this.#fetchCssSourceUrl(url);
    if (!cssSourceUrl) {
      return false;
    }
    this.#stylesheetId = this.#fetchCurrentStyleSheet(cssSourceUrl);
    if (!this.#stylesheetId) {
      return false;
    }
    const stylesheetText = await this.#cssModel.getStyleSheetText(this.#stylesheetId);
    if (!stylesheetText) {
      return false;
    }
    this.#originalStylesheetText = stylesheetText;
    this.#currentUrl = url;
    return true;
  }
  async toggleEmulatedOverlay(showOverlay) {
    if (!this.#stylesheetId || !this.#originalStylesheetText) {
      return;
    }
    if (showOverlay) {
      const styleSheetText = _WindowControls.#getStyleSheetForPlatform(this.#config.selectedPlatform.toLowerCase(), this.#originalStylesheetText);
      if (styleSheetText) {
        await this.#cssModel.setStyleSheetText(this.#stylesheetId, styleSheetText, false);
      }
    } else {
      await this.#cssModel.setStyleSheetText(this.#stylesheetId, this.#originalStylesheetText, false);
    }
  }
  static #getStyleSheetForPlatform(platform, originalStyleSheet) {
    const overlayDimensions = platformOverlayDimensions[platform];
    return _WindowControls.#transformStyleSheet(overlayDimensions.x, overlayDimensions.y, overlayDimensions.width, overlayDimensions.height, originalStyleSheet);
  }
  #fetchCssSourceUrl(url) {
    const parentURL = Common20.ParsedURL.ParsedURL.extractOrigin(url);
    const cssHeaders = this.#cssModel.styleSheetHeaders();
    const header = cssHeaders.find((header2) => header2.sourceURL && header2.sourceURL.includes(parentURL));
    return header?.sourceURL;
  }
  #fetchCurrentStyleSheet(cssSourceUrl) {
    const stylesheetIds = this.#cssModel.getStyleSheetIdsForURL(cssSourceUrl);
    return stylesheetIds.length > 0 ? stylesheetIds[0] : void 0;
  }
  // The primary objective of this function is to adjust certain CSS environment variables within the existing stylesheet
  // and provide it as the style sheet for the emulated overlay.
  static #transformStyleSheet(x, y, width, height, originalStyleSheet) {
    if (!originalStyleSheet) {
      return void 0;
    }
    const stylesheetText = originalStyleSheet;
    const updatedStylesheet = stylesheetText.replace(/: env\(titlebar-area-x(?:,[^)]*)?\);/g, `: env(titlebar-area-x, ${x}px);`).replace(/: env\(titlebar-area-y(?:,[^)]*)?\);/g, `: env(titlebar-area-y, ${y}px);`).replace(/: env\(titlebar-area-width(?:,[^)]*)?\);/g, `: env(titlebar-area-width, calc(100% - ${width}px));`).replace(/: env\(titlebar-area-height(?:,[^)]*)?\);/g, `: env(titlebar-area-height, ${height}px);`);
    return updatedStylesheet;
  }
  transformStyleSheetforTesting(x, y, width, height, originalStyleSheet) {
    return _WindowControls.#transformStyleSheet(x, y, width, height, originalStyleSheet);
  }
};
var DefaultHighlighter = class {
  #model;
  constructor(model) {
    this.#model = model;
  }
  highlightInOverlay(data, highlightConfig) {
    const { node, deferredNode, object, selectorList } = { node: void 0, deferredNode: void 0, object: void 0, selectorList: void 0, ...data };
    const nodeId = node ? node.id : void 0;
    const backendNodeId = deferredNode ? deferredNode.backendNodeId() : void 0;
    const objectId = object ? object.objectId : void 0;
    if (nodeId || backendNodeId || objectId) {
      void this.#model.target().overlayAgent().invoke_highlightNode({ highlightConfig, nodeId, backendNodeId, objectId, selector: selectorList });
    } else {
      void this.#model.target().overlayAgent().invoke_hideHighlight();
    }
  }
  async setInspectMode(mode, highlightConfig) {
    await this.#model.target().overlayAgent().invoke_setInspectMode({ mode, highlightConfig });
  }
  highlightFrame(frameId) {
    void this.#model.target().overlayAgent().invoke_highlightFrame({
      frameId,
      contentColor: Common20.Color.PageHighlight.Content.toProtocolRGBA(),
      contentOutlineColor: Common20.Color.PageHighlight.ContentOutline.toProtocolRGBA()
    });
  }
};
var SourceOrderHighlighter = class {
  #model;
  constructor(model) {
    this.#model = model;
  }
  highlightSourceOrderInOverlay(node, sourceOrderConfig) {
    this.#model.setSourceOrderActive(true);
    this.#model.setShowViewportSizeOnResize(false);
    void this.#model.getOverlayAgent().invoke_highlightSourceOrder({ sourceOrderConfig, nodeId: node.id });
  }
  hideSourceOrderHighlight() {
    this.#model.setSourceOrderActive(false);
    this.#model.setShowViewportSizeOnResize(true);
    void this.#model.clearHighlight();
  }
};
SDKModel.register(OverlayModel, { capabilities: 2, autostart: true });

// gen/front_end/core/sdk/DOMModel.js
var ARIA_ATTRIBUTES = /* @__PURE__ */ new Set([
  "role",
  "aria-activedescendant",
  "aria-atomic",
  "aria-autocomplete",
  "aria-braillelabel",
  "aria-brailleroledescription",
  "aria-busy",
  "aria-checked",
  "aria-colcount",
  "aria-colindex",
  "aria-colindextext",
  "aria-colspan",
  "aria-controls",
  "aria-current",
  "aria-describedby",
  "aria-description",
  "aria-details",
  "aria-disabled",
  "aria-dropeffect",
  "aria-errormessage",
  "aria-expanded",
  "aria-flowto",
  "aria-grabbed",
  "aria-haspopup",
  "aria-hidden",
  "aria-invalid",
  "aria-keyshortcuts",
  "aria-label",
  "aria-labelledby",
  "aria-level",
  "aria-live",
  "aria-modal",
  "aria-multiline",
  "aria-multiselectable",
  "aria-orientation",
  "aria-owns",
  "aria-placeholder",
  "aria-posinset",
  "aria-pressed",
  "aria-readonly",
  "aria-relevant",
  "aria-required",
  "aria-roledescription",
  "aria-rowcount",
  "aria-rowindex",
  "aria-rowindextext",
  "aria-rowspan",
  "aria-selected",
  "aria-setsize",
  "aria-sort",
  "aria-valuemax",
  "aria-valuemin",
  "aria-valuenow",
  "aria-valuetext"
]);
var DOMNode = class _DOMNode {
  #domModel;
  #agent;
  ownerDocument;
  #isInShadowTree;
  id;
  index = void 0;
  #backendNodeId;
  #nodeType;
  #nodeName;
  #localName;
  nodeValueInternal;
  #pseudoType;
  #pseudoIdentifier;
  #shadowRootType;
  #frameOwnerFrameId;
  #xmlVersion;
  #isSVGNode;
  #isScrollable;
  #affectedByStartingStyles;
  #creationStackTrace = null;
  #pseudoElements = /* @__PURE__ */ new Map();
  #distributedNodes = [];
  assignedSlot = null;
  shadowRootsInternal = [];
  #attributes = /* @__PURE__ */ new Map();
  #markers = /* @__PURE__ */ new Map();
  #subtreeMarkerCount = 0;
  childNodeCountInternal;
  childrenInternal = null;
  nextSibling = null;
  previousSibling = null;
  firstChild = null;
  lastChild = null;
  parentNode = null;
  templateContentInternal;
  contentDocumentInternal;
  childDocumentPromiseForTesting;
  #importedDocument;
  publicId;
  systemId;
  internalSubset;
  name;
  value;
  /**
   * Set when a DOMNode is retained in a detached sub-tree.
   */
  retained = false;
  /**
   * Set if a DOMNode is a root of a detached sub-tree.
   */
  detached = false;
  #retainedNodes;
  constructor(domModel) {
    this.#domModel = domModel;
    this.#agent = this.#domModel.getAgent();
  }
  static create(domModel, doc, isInShadowTree, payload, retainedNodes) {
    const node = new _DOMNode(domModel);
    node.init(doc, isInShadowTree, payload, retainedNodes);
    return node;
  }
  init(doc, isInShadowTree, payload, retainedNodes) {
    this.#agent = this.#domModel.getAgent();
    this.ownerDocument = doc;
    this.#isInShadowTree = isInShadowTree;
    this.id = payload.nodeId;
    this.#backendNodeId = payload.backendNodeId;
    this.#domModel.registerNode(this);
    this.#nodeType = payload.nodeType;
    this.#nodeName = payload.nodeName;
    this.#localName = payload.localName;
    this.nodeValueInternal = payload.nodeValue;
    this.#pseudoType = payload.pseudoType;
    this.#pseudoIdentifier = payload.pseudoIdentifier;
    this.#shadowRootType = payload.shadowRootType;
    this.#frameOwnerFrameId = payload.frameId || null;
    this.#xmlVersion = payload.xmlVersion;
    this.#isSVGNode = Boolean(payload.isSVG);
    this.#isScrollable = Boolean(payload.isScrollable);
    this.#affectedByStartingStyles = Boolean(payload.affectedByStartingStyles);
    this.#retainedNodes = retainedNodes;
    if (this.#retainedNodes?.has(this.backendNodeId())) {
      this.retained = true;
    }
    if (payload.attributes) {
      this.setAttributesPayload(payload.attributes);
    }
    this.childNodeCountInternal = payload.childNodeCount || 0;
    if (payload.shadowRoots) {
      for (let i = 0; i < payload.shadowRoots.length; ++i) {
        const root = payload.shadowRoots[i];
        const node = _DOMNode.create(this.#domModel, this.ownerDocument, true, root, retainedNodes);
        this.shadowRootsInternal.push(node);
        node.parentNode = this;
      }
    }
    if (payload.templateContent) {
      this.templateContentInternal = _DOMNode.create(this.#domModel, this.ownerDocument, true, payload.templateContent, retainedNodes);
      this.templateContentInternal.parentNode = this;
      this.childrenInternal = [];
    }
    const frameOwnerTags = /* @__PURE__ */ new Set(["EMBED", "IFRAME", "OBJECT", "FENCEDFRAME"]);
    if (payload.contentDocument) {
      this.contentDocumentInternal = new DOMDocument(this.#domModel, payload.contentDocument);
      this.contentDocumentInternal.parentNode = this;
      this.childrenInternal = [];
    } else if (payload.frameId && frameOwnerTags.has(payload.nodeName)) {
      this.childDocumentPromiseForTesting = this.requestChildDocument(payload.frameId, this.#domModel.target());
      this.childrenInternal = [];
    }
    if (payload.importedDocument) {
      this.#importedDocument = _DOMNode.create(this.#domModel, this.ownerDocument, true, payload.importedDocument, retainedNodes);
      this.#importedDocument.parentNode = this;
      this.childrenInternal = [];
    }
    if (payload.distributedNodes) {
      this.setDistributedNodePayloads(payload.distributedNodes);
    }
    if (payload.assignedSlot) {
      this.setAssignedSlot(payload.assignedSlot);
    }
    if (payload.children) {
      this.setChildrenPayload(payload.children);
    }
    this.setPseudoElements(payload.pseudoElements);
    if (this.#nodeType === Node.ELEMENT_NODE) {
      if (this.ownerDocument && !this.ownerDocument.documentElement && this.#nodeName === "HTML") {
        this.ownerDocument.documentElement = this;
      }
      if (this.ownerDocument && !this.ownerDocument.body && this.#nodeName === "BODY") {
        this.ownerDocument.body = this;
      }
    } else if (this.#nodeType === Node.DOCUMENT_TYPE_NODE) {
      this.publicId = payload.publicId;
      this.systemId = payload.systemId;
      this.internalSubset = payload.internalSubset;
    } else if (this.#nodeType === Node.ATTRIBUTE_NODE) {
      this.name = payload.name;
      this.value = payload.value;
    }
  }
  async requestChildDocument(frameId, notInTarget) {
    const frame = await FrameManager.instance().getOrWaitForFrame(frameId, notInTarget);
    const childModel = frame.resourceTreeModel()?.target().model(DOMModel);
    return await (childModel?.requestDocument() || null);
  }
  isAdFrameNode() {
    if (this.isIframe() && this.#frameOwnerFrameId) {
      const frame = FrameManager.instance().getFrame(this.#frameOwnerFrameId);
      if (!frame) {
        return false;
      }
      return frame.adFrameType() !== "none";
    }
    return false;
  }
  isSVGNode() {
    return this.#isSVGNode;
  }
  isScrollable() {
    return this.#isScrollable;
  }
  affectedByStartingStyles() {
    return this.#affectedByStartingStyles;
  }
  isMediaNode() {
    return this.#nodeName === "AUDIO" || this.#nodeName === "VIDEO";
  }
  isViewTransitionPseudoNode() {
    if (!this.#pseudoType) {
      return false;
    }
    return [
      "view-transition",
      "view-transition-group",
      "view-transition-group-children",
      "view-transition-image-pair",
      "view-transition-old",
      "view-transition-new"
    ].includes(this.#pseudoType);
  }
  creationStackTrace() {
    if (this.#creationStackTrace) {
      return this.#creationStackTrace;
    }
    const stackTracesPromise = this.#agent.invoke_getNodeStackTraces({ nodeId: this.id });
    this.#creationStackTrace = stackTracesPromise.then((res) => res.creation || null);
    return this.#creationStackTrace;
  }
  get subtreeMarkerCount() {
    return this.#subtreeMarkerCount;
  }
  domModel() {
    return this.#domModel;
  }
  backendNodeId() {
    return this.#backendNodeId;
  }
  children() {
    return this.childrenInternal ? this.childrenInternal.slice() : null;
  }
  setChildren(children) {
    this.childrenInternal = children;
  }
  setIsScrollable(isScrollable) {
    this.#isScrollable = isScrollable;
  }
  setAffectedByStartingStyles(affectedByStartingStyles) {
    this.#affectedByStartingStyles = affectedByStartingStyles;
  }
  hasAttributes() {
    return this.#attributes.size > 0;
  }
  childNodeCount() {
    return this.childNodeCountInternal;
  }
  setChildNodeCount(childNodeCount) {
    this.childNodeCountInternal = childNodeCount;
  }
  shadowRoots() {
    return this.shadowRootsInternal.slice();
  }
  templateContent() {
    return this.templateContentInternal || null;
  }
  contentDocument() {
    return this.contentDocumentInternal || null;
  }
  setContentDocument(node) {
    this.contentDocumentInternal = node;
  }
  isIframe() {
    return this.#nodeName === "IFRAME";
  }
  importedDocument() {
    return this.#importedDocument || null;
  }
  nodeType() {
    return this.#nodeType;
  }
  nodeName() {
    return this.#nodeName;
  }
  pseudoType() {
    return this.#pseudoType;
  }
  pseudoIdentifier() {
    return this.#pseudoIdentifier;
  }
  hasPseudoElements() {
    return this.#pseudoElements.size > 0;
  }
  pseudoElements() {
    return this.#pseudoElements;
  }
  checkmarkPseudoElement() {
    return this.#pseudoElements.get(
      "checkmark"
      /* Protocol.DOM.PseudoType.Checkmark */
    )?.at(-1);
  }
  beforePseudoElement() {
    return this.#pseudoElements.get(
      "before"
      /* Protocol.DOM.PseudoType.Before */
    )?.at(-1);
  }
  afterPseudoElement() {
    return this.#pseudoElements.get(
      "after"
      /* Protocol.DOM.PseudoType.After */
    )?.at(-1);
  }
  pickerIconPseudoElement() {
    return this.#pseudoElements.get(
      "picker-icon"
      /* Protocol.DOM.PseudoType.PickerIcon */
    )?.at(-1);
  }
  markerPseudoElement() {
    return this.#pseudoElements.get(
      "marker"
      /* Protocol.DOM.PseudoType.Marker */
    )?.at(-1);
  }
  backdropPseudoElement() {
    return this.#pseudoElements.get(
      "backdrop"
      /* Protocol.DOM.PseudoType.Backdrop */
    )?.at(-1);
  }
  viewTransitionPseudoElements() {
    return [
      ...this.#pseudoElements.get(
        "view-transition"
        /* Protocol.DOM.PseudoType.ViewTransition */
      ) || [],
      ...this.#pseudoElements.get(
        "view-transition-group"
        /* Protocol.DOM.PseudoType.ViewTransitionGroup */
      ) || [],
      ...this.#pseudoElements.get(
        "view-transition-group-children"
        /* Protocol.DOM.PseudoType.ViewTransitionGroupChildren */
      ) || [],
      ...this.#pseudoElements.get(
        "view-transition-image-pair"
        /* Protocol.DOM.PseudoType.ViewTransitionImagePair */
      ) || [],
      ...this.#pseudoElements.get(
        "view-transition-old"
        /* Protocol.DOM.PseudoType.ViewTransitionOld */
      ) || [],
      ...this.#pseudoElements.get(
        "view-transition-new"
        /* Protocol.DOM.PseudoType.ViewTransitionNew */
      ) || []
    ];
  }
  carouselPseudoElements() {
    return [
      ...this.#pseudoElements.get(
        "scroll-button"
        /* Protocol.DOM.PseudoType.ScrollButton */
      ) || [],
      ...this.#pseudoElements.get(
        "column"
        /* Protocol.DOM.PseudoType.Column */
      ) || [],
      ...this.#pseudoElements.get(
        "scroll-marker"
        /* Protocol.DOM.PseudoType.ScrollMarker */
      ) || [],
      ...this.#pseudoElements.get(
        "scroll-marker-group"
        /* Protocol.DOM.PseudoType.ScrollMarkerGroup */
      ) || []
    ];
  }
  hasAssignedSlot() {
    return this.assignedSlot !== null;
  }
  isInsertionPoint() {
    return !this.isXMLNode() && (this.#nodeName === "SHADOW" || this.#nodeName === "CONTENT" || this.#nodeName === "SLOT");
  }
  distributedNodes() {
    return this.#distributedNodes;
  }
  isInShadowTree() {
    return this.#isInShadowTree;
  }
  getTreeRoot() {
    return this.isShadowRoot() ? this : this.ancestorShadowRoot() ?? this.ownerDocument ?? this;
  }
  ancestorShadowHost() {
    const ancestorShadowRoot = this.ancestorShadowRoot();
    return ancestorShadowRoot ? ancestorShadowRoot.parentNode : null;
  }
  ancestorShadowRoot() {
    if (!this.#isInShadowTree) {
      return null;
    }
    let current = this;
    while (current && !current.isShadowRoot()) {
      current = current.parentNode;
    }
    return current;
  }
  ancestorUserAgentShadowRoot() {
    const ancestorShadowRoot = this.ancestorShadowRoot();
    if (!ancestorShadowRoot) {
      return null;
    }
    return ancestorShadowRoot.shadowRootType() === _DOMNode.ShadowRootTypes.UserAgent ? ancestorShadowRoot : null;
  }
  isShadowRoot() {
    return Boolean(this.#shadowRootType);
  }
  shadowRootType() {
    return this.#shadowRootType || null;
  }
  nodeNameInCorrectCase() {
    const shadowRootType = this.shadowRootType();
    if (shadowRootType) {
      return "#shadow-root (" + shadowRootType + ")";
    }
    if (!this.localName()) {
      return this.nodeName();
    }
    if (this.localName().length !== this.nodeName().length) {
      return this.nodeName();
    }
    return this.localName();
  }
  setNodeName(name, callback) {
    void this.#agent.invoke_setNodeName({ nodeId: this.id, name }).then((response) => {
      if (!response.getError()) {
        this.#domModel.markUndoableState();
      }
      if (callback) {
        callback(response.getError() || null, this.#domModel.nodeForId(response.nodeId));
      }
    });
  }
  localName() {
    return this.#localName;
  }
  nodeValue() {
    return this.nodeValueInternal;
  }
  setNodeValueInternal(nodeValue) {
    this.nodeValueInternal = nodeValue;
  }
  setNodeValue(value, callback) {
    void this.#agent.invoke_setNodeValue({ nodeId: this.id, value }).then((response) => {
      if (!response.getError()) {
        this.#domModel.markUndoableState();
      }
      if (callback) {
        callback(response.getError() || null);
      }
    });
  }
  getAttribute(name) {
    const attr = this.#attributes.get(name);
    return attr ? attr.value : void 0;
  }
  setAttribute(name, text, callback) {
    void this.#agent.invoke_setAttributesAsText({ nodeId: this.id, text, name }).then((response) => {
      if (!response.getError()) {
        this.#domModel.markUndoableState();
      }
      if (callback) {
        callback(response.getError() || null);
      }
    });
  }
  setAttributeValue(name, value, callback) {
    void this.#agent.invoke_setAttributeValue({ nodeId: this.id, name, value }).then((response) => {
      if (!response.getError()) {
        this.#domModel.markUndoableState();
      }
      if (callback) {
        callback(response.getError() || null);
      }
    });
  }
  setAttributeValuePromise(name, value) {
    return new Promise((fulfill) => this.setAttributeValue(name, value, fulfill));
  }
  attributes() {
    return [...this.#attributes.values()];
  }
  async removeAttribute(name) {
    const response = await this.#agent.invoke_removeAttribute({ nodeId: this.id, name });
    if (response.getError()) {
      return;
    }
    this.#attributes.delete(name);
    this.#domModel.markUndoableState();
  }
  getChildNodesPromise() {
    return new Promise((resolve) => {
      return this.getChildNodes((childNodes) => resolve(childNodes));
    });
  }
  getChildNodes(callback) {
    if (this.childrenInternal) {
      callback(this.children());
      return;
    }
    void this.#agent.invoke_requestChildNodes({ nodeId: this.id }).then((response) => {
      callback(response.getError() ? null : this.children());
    });
  }
  async getSubtree(depth, pierce) {
    const response = await this.#agent.invoke_requestChildNodes({ nodeId: this.id, depth, pierce });
    return response.getError() ? null : this.childrenInternal;
  }
  async getOuterHTML(includeShadowDOM = false) {
    const { outerHTML } = await this.#agent.invoke_getOuterHTML({ nodeId: this.id, includeShadowDOM });
    return outerHTML;
  }
  setOuterHTML(html, callback) {
    void this.#agent.invoke_setOuterHTML({ nodeId: this.id, outerHTML: html }).then((response) => {
      if (!response.getError()) {
        this.#domModel.markUndoableState();
      }
      if (callback) {
        callback(response.getError() || null);
      }
    });
  }
  removeNode(callback) {
    return this.#agent.invoke_removeNode({ nodeId: this.id }).then((response) => {
      if (!response.getError()) {
        this.#domModel.markUndoableState();
      }
      if (callback) {
        callback(response.getError() || null);
      }
    });
  }
  path() {
    function getNodeKey(node2) {
      if (!node2.#nodeName.length) {
        return null;
      }
      if (node2.index !== void 0) {
        return node2.index;
      }
      if (!node2.parentNode) {
        return null;
      }
      if (node2.isShadowRoot()) {
        return node2.shadowRootType() === _DOMNode.ShadowRootTypes.UserAgent ? "u" : "a";
      }
      if (node2.nodeType() === Node.DOCUMENT_NODE) {
        return "d";
      }
      return null;
    }
    const path = [];
    let node = this;
    while (node) {
      const key = getNodeKey(node);
      if (key === null) {
        break;
      }
      path.push([key, node.#nodeName]);
      node = node.parentNode;
    }
    path.reverse();
    return path.join(",");
  }
  isAncestor(node) {
    if (!node) {
      return false;
    }
    let currentNode = node.parentNode;
    while (currentNode) {
      if (this === currentNode) {
        return true;
      }
      currentNode = currentNode.parentNode;
    }
    return false;
  }
  isDescendant(descendant) {
    return descendant.isAncestor(this);
  }
  frameOwnerFrameId() {
    return this.#frameOwnerFrameId;
  }
  frameId() {
    let node = this.parentNode || this;
    while (!node.#frameOwnerFrameId && node.parentNode) {
      node = node.parentNode;
    }
    return node.#frameOwnerFrameId;
  }
  setAttributesPayload(attrs) {
    let attributesChanged = !this.#attributes || attrs.length !== this.#attributes.size * 2;
    const oldAttributesMap = this.#attributes || /* @__PURE__ */ new Map();
    this.#attributes = /* @__PURE__ */ new Map();
    for (let i = 0; i < attrs.length; i += 2) {
      const name = attrs[i];
      const value = attrs[i + 1];
      this.addAttribute(name, value);
      if (attributesChanged) {
        continue;
      }
      const oldAttribute = oldAttributesMap.get(name);
      if (!oldAttribute || oldAttribute.value !== value) {
        attributesChanged = true;
      }
    }
    return attributesChanged;
  }
  insertChild(prev, payload) {
    if (!this.childrenInternal) {
      throw new Error("DOMNode._children is expected to not be null.");
    }
    const node = _DOMNode.create(this.#domModel, this.ownerDocument, this.#isInShadowTree, payload, this.#retainedNodes);
    this.childrenInternal.splice(prev ? this.childrenInternal.indexOf(prev) + 1 : 0, 0, node);
    this.renumber();
    return node;
  }
  removeChild(node) {
    const pseudoType = node.pseudoType();
    if (pseudoType) {
      const updatedPseudoElements = this.#pseudoElements.get(pseudoType)?.filter((element) => element !== node);
      if (updatedPseudoElements && updatedPseudoElements.length > 0) {
        this.#pseudoElements.set(pseudoType, updatedPseudoElements);
      } else {
        this.#pseudoElements.delete(pseudoType);
      }
    } else {
      const shadowRootIndex = this.shadowRootsInternal.indexOf(node);
      if (shadowRootIndex !== -1) {
        this.shadowRootsInternal.splice(shadowRootIndex, 1);
      } else {
        if (!this.childrenInternal) {
          throw new Error("DOMNode._children is expected to not be null.");
        }
        if (this.childrenInternal.indexOf(node) === -1) {
          throw new Error("DOMNode._children is expected to contain the node to be removed.");
        }
        this.childrenInternal.splice(this.childrenInternal.indexOf(node), 1);
      }
    }
    node.parentNode = null;
    this.#subtreeMarkerCount -= node.#subtreeMarkerCount;
    if (node.#subtreeMarkerCount) {
      this.#domModel.dispatchEventToListeners(Events8.MarkersChanged, this);
    }
    this.renumber();
  }
  setChildrenPayload(payloads) {
    this.childrenInternal = [];
    for (let i = 0; i < payloads.length; ++i) {
      const payload = payloads[i];
      const node = _DOMNode.create(this.#domModel, this.ownerDocument, this.#isInShadowTree, payload, this.#retainedNodes);
      this.childrenInternal.push(node);
    }
    this.renumber();
  }
  setPseudoElements(payloads) {
    if (!payloads) {
      return;
    }
    for (let i = 0; i < payloads.length; ++i) {
      const node = _DOMNode.create(this.#domModel, this.ownerDocument, this.#isInShadowTree, payloads[i], this.#retainedNodes);
      node.parentNode = this;
      const pseudoType = node.pseudoType();
      if (!pseudoType) {
        throw new Error("DOMNode.pseudoType() is expected to be defined.");
      }
      const currentPseudoElements = this.#pseudoElements.get(pseudoType);
      if (currentPseudoElements) {
        currentPseudoElements.push(node);
      } else {
        this.#pseudoElements.set(pseudoType, [node]);
      }
    }
  }
  setDistributedNodePayloads(payloads) {
    this.#distributedNodes = [];
    for (const payload of payloads) {
      this.#distributedNodes.push(new DOMNodeShortcut(this.#domModel.target(), payload.backendNodeId, payload.nodeType, payload.nodeName));
    }
  }
  setAssignedSlot(payload) {
    this.assignedSlot = new DOMNodeShortcut(this.#domModel.target(), payload.backendNodeId, payload.nodeType, payload.nodeName);
  }
  renumber() {
    if (!this.childrenInternal) {
      throw new Error("DOMNode._children is expected to not be null.");
    }
    this.childNodeCountInternal = this.childrenInternal.length;
    if (this.childNodeCountInternal === 0) {
      this.firstChild = null;
      this.lastChild = null;
      return;
    }
    this.firstChild = this.childrenInternal[0];
    this.lastChild = this.childrenInternal[this.childNodeCountInternal - 1];
    for (let i = 0; i < this.childNodeCountInternal; ++i) {
      const child = this.childrenInternal[i];
      child.index = i;
      child.nextSibling = i + 1 < this.childNodeCountInternal ? this.childrenInternal[i + 1] : null;
      child.previousSibling = i - 1 >= 0 ? this.childrenInternal[i - 1] : null;
      child.parentNode = this;
    }
  }
  addAttribute(name, value) {
    const attr = { name, value, _node: this };
    this.#attributes.set(name, attr);
  }
  setAttributeInternal(name, value) {
    const attr = this.#attributes.get(name);
    if (attr) {
      attr.value = value;
    } else {
      this.addAttribute(name, value);
    }
  }
  removeAttributeInternal(name) {
    this.#attributes.delete(name);
  }
  copyTo(targetNode, anchorNode, callback) {
    void this.#agent.invoke_copyTo({ nodeId: this.id, targetNodeId: targetNode.id, insertBeforeNodeId: anchorNode ? anchorNode.id : void 0 }).then((response) => {
      if (!response.getError()) {
        this.#domModel.markUndoableState();
      }
      const pastedNode = this.#domModel.nodeForId(response.nodeId);
      if (pastedNode) {
        for (const [name, value] of this.#markers) {
          pastedNode.setMarker(name, value);
        }
      }
      if (callback) {
        callback(response.getError() || null, pastedNode);
      }
    });
  }
  moveTo(targetNode, anchorNode, callback) {
    void this.#agent.invoke_moveTo({ nodeId: this.id, targetNodeId: targetNode.id, insertBeforeNodeId: anchorNode ? anchorNode.id : void 0 }).then((response) => {
      if (!response.getError()) {
        this.#domModel.markUndoableState();
      }
      if (callback) {
        callback(response.getError() || null, this.#domModel.nodeForId(response.nodeId));
      }
    });
  }
  isXMLNode() {
    return Boolean(this.#xmlVersion);
  }
  setMarker(name, value) {
    if (value === null) {
      if (!this.#markers.has(name)) {
        return;
      }
      this.#markers.delete(name);
      for (let node = this; node; node = node.parentNode) {
        --node.#subtreeMarkerCount;
      }
      for (let node = this; node; node = node.parentNode) {
        this.#domModel.dispatchEventToListeners(Events8.MarkersChanged, node);
      }
      return;
    }
    if (this.parentNode && !this.#markers.has(name)) {
      for (let node = this; node; node = node.parentNode) {
        ++node.#subtreeMarkerCount;
      }
    }
    this.#markers.set(name, value);
    for (let node = this; node; node = node.parentNode) {
      this.#domModel.dispatchEventToListeners(Events8.MarkersChanged, node);
    }
  }
  marker(name) {
    return this.#markers.get(name) || null;
  }
  getMarkerKeysForTest() {
    return [...this.#markers.keys()];
  }
  traverseMarkers(visitor) {
    function traverse(node) {
      if (!node.#subtreeMarkerCount) {
        return;
      }
      for (const marker of node.#markers.keys()) {
        visitor(node, marker);
      }
      if (!node.childrenInternal) {
        return;
      }
      for (const child of node.childrenInternal) {
        traverse(child);
      }
    }
    traverse(this);
  }
  resolveURL(url) {
    if (!url) {
      return url;
    }
    for (let frameOwnerCandidate = this; frameOwnerCandidate; frameOwnerCandidate = frameOwnerCandidate.parentNode) {
      if (frameOwnerCandidate instanceof DOMDocument && frameOwnerCandidate.baseURL) {
        return Common21.ParsedURL.ParsedURL.completeURL(frameOwnerCandidate.baseURL, url);
      }
    }
    return null;
  }
  highlight(mode) {
    this.#domModel.overlayModel().highlightInOverlay({ node: this, selectorList: void 0 }, mode);
  }
  highlightForTwoSeconds() {
    this.#domModel.overlayModel().highlightInOverlayForTwoSeconds({ node: this, selectorList: void 0 });
  }
  async resolveToObject(objectGroup, executionContextId) {
    const { object } = await this.#agent.invoke_resolveNode({ nodeId: this.id, backendNodeId: void 0, executionContextId, objectGroup });
    return object && this.#domModel.runtimeModelInternal.createRemoteObject(object) || null;
  }
  async boxModel() {
    const { model } = await this.#agent.invoke_getBoxModel({ nodeId: this.id });
    return model;
  }
  async setAsInspectedNode() {
    let node = this;
    if (node?.pseudoType()) {
      node = node.parentNode;
    }
    while (node) {
      let ancestor = node.ancestorUserAgentShadowRoot();
      if (!ancestor) {
        break;
      }
      ancestor = node.ancestorShadowHost();
      if (!ancestor) {
        break;
      }
      node = ancestor;
    }
    if (!node) {
      throw new Error("In DOMNode.setAsInspectedNode: node is expected to not be null.");
    }
    await this.#agent.invoke_setInspectedNode({ nodeId: node.id });
  }
  enclosingElementOrSelf() {
    let node = this;
    if (node && node.nodeType() === Node.TEXT_NODE && node.parentNode) {
      node = node.parentNode;
    }
    if (node && node.nodeType() !== Node.ELEMENT_NODE) {
      node = null;
    }
    return node;
  }
  async callFunction(fn, args = []) {
    const object = await this.resolveToObject();
    if (!object) {
      return null;
    }
    const result = await object.callFunction(fn, args.map((arg) => RemoteObject.toCallArgument(arg)));
    object.release();
    if (result.wasThrown || !result.object) {
      return null;
    }
    return {
      value: result.object.value
    };
  }
  async scrollIntoView() {
    const node = this.enclosingElementOrSelf();
    if (!node) {
      return;
    }
    const result = await node.callFunction(scrollIntoViewInPage);
    if (!result) {
      return;
    }
    node.highlightForTwoSeconds();
    function scrollIntoViewInPage() {
      this.scrollIntoViewIfNeeded(true);
    }
  }
  async focus() {
    const node = this.enclosingElementOrSelf();
    if (!node) {
      throw new Error("DOMNode.focus expects node to not be null.");
    }
    const result = await node.callFunction(focusInPage);
    if (!result) {
      return;
    }
    node.highlightForTwoSeconds();
    await this.#domModel.target().pageAgent().invoke_bringToFront();
    function focusInPage() {
      this.focus();
    }
  }
  simpleSelector() {
    const lowerCaseName = this.localName() || this.nodeName().toLowerCase();
    if (this.nodeType() !== Node.ELEMENT_NODE) {
      return lowerCaseName;
    }
    const type = this.getAttribute("type");
    const id = this.getAttribute("id");
    const classes = this.getAttribute("class");
    if (lowerCaseName === "input" && type && !id && !classes) {
      return lowerCaseName + '[type="' + CSS.escape(type) + '"]';
    }
    if (id) {
      return lowerCaseName + "#" + CSS.escape(id);
    }
    if (classes) {
      const classList = classes.trim().split(/\s+/g);
      return (lowerCaseName === "div" ? "" : lowerCaseName) + "." + classList.map((cls) => CSS.escape(cls)).join(".");
    }
    if (this.pseudoIdentifier()) {
      return `${lowerCaseName}(${this.pseudoIdentifier()})`;
    }
    return lowerCaseName;
  }
  async getAnchorBySpecifier(specifier) {
    const response = await this.#agent.invoke_getAnchorElement({
      nodeId: this.id,
      anchorSpecifier: specifier
    });
    if (response.getError()) {
      return null;
    }
    return this.domModel().nodeForId(response.nodeId);
  }
  classNames() {
    const classes = this.getAttribute("class");
    return classes ? classes.split(/\s+/) : [];
  }
};
(function(DOMNode2) {
  let ShadowRootTypes;
  (function(ShadowRootTypes2) {
    ShadowRootTypes2["UserAgent"] = "user-agent";
    ShadowRootTypes2["Open"] = "open";
    ShadowRootTypes2["Closed"] = "closed";
  })(ShadowRootTypes = DOMNode2.ShadowRootTypes || (DOMNode2.ShadowRootTypes = {}));
})(DOMNode || (DOMNode = {}));
var DeferredDOMNode = class {
  #domModelInternal;
  #backendNodeIdInternal;
  constructor(target, backendNodeId) {
    this.#domModelInternal = target.model(DOMModel);
    this.#backendNodeIdInternal = backendNodeId;
  }
  resolve(callback) {
    void this.resolvePromise().then(callback);
  }
  async resolvePromise() {
    const nodeIds = await this.#domModelInternal.pushNodesByBackendIdsToFrontend(/* @__PURE__ */ new Set([this.#backendNodeIdInternal]));
    return nodeIds?.get(this.#backendNodeIdInternal) || null;
  }
  backendNodeId() {
    return this.#backendNodeIdInternal;
  }
  domModel() {
    return this.#domModelInternal;
  }
  highlight() {
    this.#domModelInternal.overlayModel().highlightInOverlay({ deferredNode: this, selectorList: void 0 });
  }
};
var DOMNodeShortcut = class {
  nodeType;
  nodeName;
  deferredNode;
  constructor(target, backendNodeId, nodeType, nodeName) {
    this.nodeType = nodeType;
    this.nodeName = nodeName;
    this.deferredNode = new DeferredDOMNode(target, backendNodeId);
  }
};
var DOMDocument = class extends DOMNode {
  body;
  documentElement;
  documentURL;
  baseURL;
  constructor(domModel, payload) {
    super(domModel);
    this.body = null;
    this.documentElement = null;
    this.init(this, false, payload);
    this.documentURL = payload.documentURL || "";
    this.baseURL = payload.baseURL || "";
  }
};
var DOMModel = class _DOMModel extends SDKModel {
  agent;
  idToDOMNode = /* @__PURE__ */ new Map();
  #document = null;
  #attributeLoadNodeIds = /* @__PURE__ */ new Set();
  runtimeModelInternal;
  #lastMutationId;
  #pendingDocumentRequestPromise = null;
  #frameOwnerNode;
  #loadNodeAttributesTimeout;
  #searchId;
  constructor(target) {
    super(target);
    this.agent = target.domAgent();
    target.registerDOMDispatcher(new DOMDispatcher(this));
    this.runtimeModelInternal = target.model(RuntimeModel);
    if (!target.suspended()) {
      void this.agent.invoke_enable({});
    }
    if (Root8.Runtime.experiments.isEnabled("capture-node-creation-stacks")) {
      void this.agent.invoke_setNodeStackTracesEnabled({ enable: true });
    }
  }
  runtimeModel() {
    return this.runtimeModelInternal;
  }
  cssModel() {
    return this.target().model(CSSModel);
  }
  overlayModel() {
    return this.target().model(OverlayModel);
  }
  static cancelSearch() {
    for (const domModel of TargetManager.instance().models(_DOMModel)) {
      domModel.cancelSearch();
    }
  }
  scheduleMutationEvent(node) {
    if (!this.hasEventListeners(Events8.DOMMutated)) {
      return;
    }
    this.#lastMutationId = (this.#lastMutationId || 0) + 1;
    void Promise.resolve().then(callObserve.bind(this, node, this.#lastMutationId));
    function callObserve(node2, mutationId) {
      if (!this.hasEventListeners(Events8.DOMMutated) || this.#lastMutationId !== mutationId) {
        return;
      }
      this.dispatchEventToListeners(Events8.DOMMutated, node2);
    }
  }
  requestDocument() {
    if (this.#document) {
      return Promise.resolve(this.#document);
    }
    if (!this.#pendingDocumentRequestPromise) {
      this.#pendingDocumentRequestPromise = this.requestDocumentInternal();
    }
    return this.#pendingDocumentRequestPromise;
  }
  async getOwnerNodeForFrame(frameId) {
    const response = await this.agent.invoke_getFrameOwner({ frameId });
    if (response.getError()) {
      return null;
    }
    return new DeferredDOMNode(this.target(), response.backendNodeId);
  }
  async requestDocumentInternal() {
    const response = await this.agent.invoke_getDocument({});
    if (response.getError()) {
      return null;
    }
    const { root: documentPayload } = response;
    this.#pendingDocumentRequestPromise = null;
    if (documentPayload) {
      this.setDocument(documentPayload);
    }
    if (!this.#document) {
      console.error("No document");
      return null;
    }
    const parentModel = this.parentModel();
    if (parentModel && !this.#frameOwnerNode) {
      await parentModel.requestDocument();
      const mainFrame = this.target().model(ResourceTreeModel)?.mainFrame;
      if (mainFrame) {
        const response2 = await parentModel.agent.invoke_getFrameOwner({ frameId: mainFrame.id });
        if (!response2.getError() && response2.nodeId) {
          this.#frameOwnerNode = parentModel.nodeForId(response2.nodeId);
        }
      }
    }
    if (this.#frameOwnerNode) {
      const oldDocument = this.#frameOwnerNode.contentDocument();
      this.#frameOwnerNode.setContentDocument(this.#document);
      this.#frameOwnerNode.setChildren([]);
      if (this.#document) {
        this.#document.parentNode = this.#frameOwnerNode;
        this.dispatchEventToListeners(Events8.NodeInserted, this.#document);
      } else if (oldDocument) {
        this.dispatchEventToListeners(Events8.NodeRemoved, { node: oldDocument, parent: this.#frameOwnerNode });
      }
    }
    return this.#document;
  }
  existingDocument() {
    return this.#document;
  }
  async pushNodeToFrontend(objectId) {
    await this.requestDocument();
    const { nodeId } = await this.agent.invoke_requestNode({ objectId });
    return this.nodeForId(nodeId);
  }
  pushNodeByPathToFrontend(path) {
    return this.requestDocument().then(() => this.agent.invoke_pushNodeByPathToFrontend({ path })).then(({ nodeId }) => nodeId);
  }
  async pushNodesByBackendIdsToFrontend(backendNodeIds) {
    await this.requestDocument();
    const backendNodeIdsArray = [...backendNodeIds];
    const { nodeIds } = await this.agent.invoke_pushNodesByBackendIdsToFrontend({ backendNodeIds: backendNodeIdsArray });
    if (!nodeIds) {
      return null;
    }
    const map = /* @__PURE__ */ new Map();
    for (let i = 0; i < nodeIds.length; ++i) {
      if (nodeIds[i]) {
        map.set(backendNodeIdsArray[i], this.nodeForId(nodeIds[i]));
      }
    }
    return map;
  }
  attributeModified(nodeId, name, value) {
    const node = this.idToDOMNode.get(nodeId);
    if (!node) {
      return;
    }
    node.setAttributeInternal(name, value);
    this.dispatchEventToListeners(Events8.AttrModified, { node, name });
    this.scheduleMutationEvent(node);
  }
  attributeRemoved(nodeId, name) {
    const node = this.idToDOMNode.get(nodeId);
    if (!node) {
      return;
    }
    node.removeAttributeInternal(name);
    this.dispatchEventToListeners(Events8.AttrRemoved, { node, name });
    this.scheduleMutationEvent(node);
  }
  inlineStyleInvalidated(nodeIds) {
    nodeIds.forEach((nodeId) => this.#attributeLoadNodeIds.add(nodeId));
    if (!this.#loadNodeAttributesTimeout) {
      this.#loadNodeAttributesTimeout = window.setTimeout(this.loadNodeAttributes.bind(this), 20);
    }
  }
  loadNodeAttributes() {
    this.#loadNodeAttributesTimeout = void 0;
    for (const nodeId of this.#attributeLoadNodeIds) {
      void this.agent.invoke_getAttributes({ nodeId }).then(({ attributes }) => {
        if (!attributes) {
          return;
        }
        const node = this.idToDOMNode.get(nodeId);
        if (!node) {
          return;
        }
        if (node.setAttributesPayload(attributes)) {
          this.dispatchEventToListeners(Events8.AttrModified, { node, name: "style" });
          this.scheduleMutationEvent(node);
        }
      });
    }
    this.#attributeLoadNodeIds.clear();
  }
  characterDataModified(nodeId, newValue) {
    const node = this.idToDOMNode.get(nodeId);
    if (!node) {
      console.error("nodeId could not be resolved to a node");
      return;
    }
    node.setNodeValueInternal(newValue);
    this.dispatchEventToListeners(Events8.CharacterDataModified, node);
    this.scheduleMutationEvent(node);
  }
  nodeForId(nodeId) {
    return nodeId ? this.idToDOMNode.get(nodeId) || null : null;
  }
  documentUpdated() {
    const alreadyHasDocument = Boolean(this.#document);
    this.setDocument(null);
    if (this.parentModel() && alreadyHasDocument && !this.#pendingDocumentRequestPromise) {
      void this.requestDocument();
    }
  }
  setDocument(payload) {
    this.idToDOMNode = /* @__PURE__ */ new Map();
    if (payload && "nodeId" in payload) {
      this.#document = new DOMDocument(this, payload);
    } else {
      this.#document = null;
    }
    DOMModelUndoStack.instance().dispose(this);
    if (!this.parentModel()) {
      this.dispatchEventToListeners(Events8.DocumentUpdated, this);
    }
  }
  setDocumentForTest(document2) {
    this.setDocument(document2);
  }
  setDetachedRoot(payload) {
    if (payload.nodeName === "#document") {
      new DOMDocument(this, payload);
    } else {
      DOMNode.create(this, null, false, payload);
    }
  }
  setChildNodes(parentId, payloads) {
    if (!parentId && payloads.length) {
      this.setDetachedRoot(payloads[0]);
      return;
    }
    const parent = this.idToDOMNode.get(parentId);
    parent?.setChildrenPayload(payloads);
  }
  childNodeCountUpdated(nodeId, newValue) {
    const node = this.idToDOMNode.get(nodeId);
    if (!node) {
      console.error("nodeId could not be resolved to a node");
      return;
    }
    node.setChildNodeCount(newValue);
    this.dispatchEventToListeners(Events8.ChildNodeCountUpdated, node);
    this.scheduleMutationEvent(node);
  }
  childNodeInserted(parentId, prevId, payload) {
    const parent = this.idToDOMNode.get(parentId);
    const prev = this.idToDOMNode.get(prevId);
    if (!parent) {
      console.error("parentId could not be resolved to a node");
      return;
    }
    const node = parent.insertChild(prev, payload);
    this.idToDOMNode.set(node.id, node);
    this.dispatchEventToListeners(Events8.NodeInserted, node);
    this.scheduleMutationEvent(node);
  }
  childNodeRemoved(parentId, nodeId) {
    const parent = this.idToDOMNode.get(parentId);
    const node = this.idToDOMNode.get(nodeId);
    if (!parent || !node) {
      console.error("parentId or nodeId could not be resolved to a node");
      return;
    }
    parent.removeChild(node);
    this.unbind(node);
    this.dispatchEventToListeners(Events8.NodeRemoved, { node, parent });
    this.scheduleMutationEvent(node);
  }
  shadowRootPushed(hostId, root) {
    const host = this.idToDOMNode.get(hostId);
    if (!host) {
      return;
    }
    const node = DOMNode.create(this, host.ownerDocument, true, root);
    node.parentNode = host;
    this.idToDOMNode.set(node.id, node);
    host.shadowRootsInternal.unshift(node);
    this.dispatchEventToListeners(Events8.NodeInserted, node);
    this.scheduleMutationEvent(node);
  }
  shadowRootPopped(hostId, rootId) {
    const host = this.idToDOMNode.get(hostId);
    if (!host) {
      return;
    }
    const root = this.idToDOMNode.get(rootId);
    if (!root) {
      return;
    }
    host.removeChild(root);
    this.unbind(root);
    this.dispatchEventToListeners(Events8.NodeRemoved, { node: root, parent: host });
    this.scheduleMutationEvent(root);
  }
  pseudoElementAdded(parentId, pseudoElement) {
    const parent = this.idToDOMNode.get(parentId);
    if (!parent) {
      return;
    }
    const node = DOMNode.create(this, parent.ownerDocument, false, pseudoElement);
    node.parentNode = parent;
    this.idToDOMNode.set(node.id, node);
    const pseudoType = node.pseudoType();
    if (!pseudoType) {
      throw new Error("DOMModel._pseudoElementAdded expects pseudoType to be defined.");
    }
    const currentPseudoElements = parent.pseudoElements().get(pseudoType);
    if (currentPseudoElements && currentPseudoElements.length > 0) {
      if (!(pseudoType.startsWith("view-transition") || pseudoType.startsWith("scroll-") || pseudoType === "column")) {
        throw new Error(`DOMModel.pseudoElementAdded expects parent to not already have this pseudo type added; only view-transition* and scrolling pseudo elements can coexist under the same parent. ${currentPseudoElements.length} elements of type ${pseudoType} already exist on parent.`);
      }
      currentPseudoElements.push(node);
    } else {
      parent.pseudoElements().set(pseudoType, [node]);
    }
    this.dispatchEventToListeners(Events8.NodeInserted, node);
    this.scheduleMutationEvent(node);
  }
  scrollableFlagUpdated(nodeId, isScrollable) {
    const node = this.nodeForId(nodeId);
    if (!node || node.isScrollable() === isScrollable) {
      return;
    }
    node.setIsScrollable(isScrollable);
    this.dispatchEventToListeners(Events8.ScrollableFlagUpdated, { node });
  }
  affectedByStartingStylesFlagUpdated(nodeId, affectedByStartingStyles) {
    const node = this.nodeForId(nodeId);
    if (!node || node.affectedByStartingStyles() === affectedByStartingStyles) {
      return;
    }
    node.setAffectedByStartingStyles(affectedByStartingStyles);
    this.dispatchEventToListeners(Events8.AffectedByStartingStylesFlagUpdated, { node });
  }
  topLayerElementsUpdated() {
    this.dispatchEventToListeners(Events8.TopLayerElementsChanged);
  }
  pseudoElementRemoved(parentId, pseudoElementId) {
    const parent = this.idToDOMNode.get(parentId);
    if (!parent) {
      return;
    }
    const pseudoElement = this.idToDOMNode.get(pseudoElementId);
    if (!pseudoElement) {
      return;
    }
    parent.removeChild(pseudoElement);
    this.unbind(pseudoElement);
    this.dispatchEventToListeners(Events8.NodeRemoved, { node: pseudoElement, parent });
    this.scheduleMutationEvent(pseudoElement);
  }
  distributedNodesUpdated(insertionPointId, distributedNodes) {
    const insertionPoint = this.idToDOMNode.get(insertionPointId);
    if (!insertionPoint) {
      return;
    }
    insertionPoint.setDistributedNodePayloads(distributedNodes);
    this.dispatchEventToListeners(Events8.DistributedNodesChanged, insertionPoint);
    this.scheduleMutationEvent(insertionPoint);
  }
  unbind(node) {
    this.idToDOMNode.delete(node.id);
    const children = node.children();
    for (let i = 0; children && i < children.length; ++i) {
      this.unbind(children[i]);
    }
    for (let i = 0; i < node.shadowRootsInternal.length; ++i) {
      this.unbind(node.shadowRootsInternal[i]);
    }
    const pseudoElements = node.pseudoElements();
    for (const value of pseudoElements.values()) {
      for (const pseudoElement of value) {
        this.unbind(pseudoElement);
      }
    }
    const templateContent = node.templateContent();
    if (templateContent) {
      this.unbind(templateContent);
    }
  }
  async getNodesByStyle(computedStyles, pierce = false) {
    await this.requestDocument();
    if (!this.#document) {
      throw new Error("DOMModel.getNodesByStyle expects to have a document.");
    }
    const response = await this.agent.invoke_getNodesForSubtreeByStyle({ nodeId: this.#document.id, computedStyles, pierce });
    if (response.getError()) {
      throw new Error(response.getError());
    }
    return response.nodeIds;
  }
  async performSearch(query, includeUserAgentShadowDOM) {
    const response = await this.agent.invoke_performSearch({ query, includeUserAgentShadowDOM });
    if (!response.getError()) {
      this.#searchId = response.searchId;
    }
    return response.getError() ? 0 : response.resultCount;
  }
  async searchResult(index) {
    if (!this.#searchId) {
      return null;
    }
    const { nodeIds } = await this.agent.invoke_getSearchResults({ searchId: this.#searchId, fromIndex: index, toIndex: index + 1 });
    return nodeIds && nodeIds.length === 1 ? this.nodeForId(nodeIds[0]) : null;
  }
  cancelSearch() {
    if (!this.#searchId) {
      return;
    }
    void this.agent.invoke_discardSearchResults({ searchId: this.#searchId });
    this.#searchId = void 0;
  }
  classNamesPromise(nodeId) {
    return this.agent.invoke_collectClassNamesFromSubtree({ nodeId }).then(({ classNames }) => classNames || []);
  }
  querySelector(nodeId, selector) {
    return this.agent.invoke_querySelector({ nodeId, selector }).then(({ nodeId: nodeId2 }) => nodeId2);
  }
  querySelectorAll(nodeId, selector) {
    return this.agent.invoke_querySelectorAll({ nodeId, selector }).then(({ nodeIds }) => nodeIds);
  }
  getTopLayerElements() {
    return this.agent.invoke_getTopLayerElements().then(({ nodeIds }) => nodeIds);
  }
  getDetachedDOMNodes() {
    return this.agent.invoke_getDetachedDomNodes().then(({ detachedNodes }) => detachedNodes);
  }
  getElementByRelation(nodeId, relation) {
    return this.agent.invoke_getElementByRelation({ nodeId, relation }).then(({ nodeId: nodeId2 }) => nodeId2);
  }
  markUndoableState(minorChange) {
    void DOMModelUndoStack.instance().markUndoableState(this, minorChange || false);
  }
  async nodeForLocation(x, y, includeUserAgentShadowDOM) {
    const response = await this.agent.invoke_getNodeForLocation({ x, y, includeUserAgentShadowDOM });
    if (response.getError() || !response.nodeId) {
      return null;
    }
    return this.nodeForId(response.nodeId);
  }
  async getContainerForNode(nodeId, containerName, physicalAxes, logicalAxes, queriesScrollState, queriesAnchored) {
    const { nodeId: containerNodeId } = await this.agent.invoke_getContainerForNode({ nodeId, containerName, physicalAxes, logicalAxes, queriesScrollState, queriesAnchored });
    if (!containerNodeId) {
      return null;
    }
    return this.nodeForId(containerNodeId);
  }
  pushObjectAsNodeToFrontend(object) {
    return object.isNode() && object.objectId ? this.pushNodeToFrontend(object.objectId) : Promise.resolve(null);
  }
  suspendModel() {
    return this.agent.invoke_disable().then(() => this.setDocument(null));
  }
  async resumeModel() {
    await this.agent.invoke_enable({});
  }
  dispose() {
    DOMModelUndoStack.instance().dispose(this);
  }
  parentModel() {
    const parentTarget = this.target().parentTarget();
    return parentTarget ? parentTarget.model(_DOMModel) : null;
  }
  getAgent() {
    return this.agent;
  }
  registerNode(node) {
    this.idToDOMNode.set(node.id, node);
  }
};
var Events8;
(function(Events12) {
  Events12["AttrModified"] = "AttrModified";
  Events12["AttrRemoved"] = "AttrRemoved";
  Events12["CharacterDataModified"] = "CharacterDataModified";
  Events12["DOMMutated"] = "DOMMutated";
  Events12["NodeInserted"] = "NodeInserted";
  Events12["NodeRemoved"] = "NodeRemoved";
  Events12["DocumentUpdated"] = "DocumentUpdated";
  Events12["ChildNodeCountUpdated"] = "ChildNodeCountUpdated";
  Events12["DistributedNodesChanged"] = "DistributedNodesChanged";
  Events12["MarkersChanged"] = "MarkersChanged";
  Events12["TopLayerElementsChanged"] = "TopLayerElementsChanged";
  Events12["ScrollableFlagUpdated"] = "ScrollableFlagUpdated";
  Events12["AffectedByStartingStylesFlagUpdated"] = "AffectedByStartingStylesFlagUpdated";
})(Events8 || (Events8 = {}));
var DOMDispatcher = class {
  #domModel;
  constructor(domModel) {
    this.#domModel = domModel;
  }
  documentUpdated() {
    this.#domModel.documentUpdated();
  }
  attributeModified({ nodeId, name, value }) {
    this.#domModel.attributeModified(nodeId, name, value);
  }
  attributeRemoved({ nodeId, name }) {
    this.#domModel.attributeRemoved(nodeId, name);
  }
  inlineStyleInvalidated({ nodeIds }) {
    this.#domModel.inlineStyleInvalidated(nodeIds);
  }
  characterDataModified({ nodeId, characterData }) {
    this.#domModel.characterDataModified(nodeId, characterData);
  }
  setChildNodes({ parentId, nodes }) {
    this.#domModel.setChildNodes(parentId, nodes);
  }
  childNodeCountUpdated({ nodeId, childNodeCount }) {
    this.#domModel.childNodeCountUpdated(nodeId, childNodeCount);
  }
  childNodeInserted({ parentNodeId, previousNodeId, node }) {
    this.#domModel.childNodeInserted(parentNodeId, previousNodeId, node);
  }
  childNodeRemoved({ parentNodeId, nodeId }) {
    this.#domModel.childNodeRemoved(parentNodeId, nodeId);
  }
  shadowRootPushed({ hostId, root }) {
    this.#domModel.shadowRootPushed(hostId, root);
  }
  shadowRootPopped({ hostId, rootId }) {
    this.#domModel.shadowRootPopped(hostId, rootId);
  }
  pseudoElementAdded({ parentId, pseudoElement }) {
    this.#domModel.pseudoElementAdded(parentId, pseudoElement);
  }
  pseudoElementRemoved({ parentId, pseudoElementId }) {
    this.#domModel.pseudoElementRemoved(parentId, pseudoElementId);
  }
  distributedNodesUpdated({ insertionPointId, distributedNodes }) {
    this.#domModel.distributedNodesUpdated(insertionPointId, distributedNodes);
  }
  topLayerElementsUpdated() {
    this.#domModel.topLayerElementsUpdated();
  }
  scrollableFlagUpdated({ nodeId, isScrollable }) {
    this.#domModel.scrollableFlagUpdated(nodeId, isScrollable);
  }
  affectedByStartingStylesFlagUpdated({ nodeId, affectedByStartingStyles }) {
    this.#domModel.affectedByStartingStylesFlagUpdated(nodeId, affectedByStartingStyles);
  }
};
var domModelUndoStackInstance = null;
var DOMModelUndoStack = class _DOMModelUndoStack {
  #stack;
  #index;
  #lastModelWithMinorChange;
  constructor() {
    this.#stack = [];
    this.#index = 0;
    this.#lastModelWithMinorChange = null;
  }
  static instance(opts = { forceNew: null }) {
    const { forceNew } = opts;
    if (!domModelUndoStackInstance || forceNew) {
      domModelUndoStackInstance = new _DOMModelUndoStack();
    }
    return domModelUndoStackInstance;
  }
  async markUndoableState(model, minorChange) {
    if (this.#lastModelWithMinorChange && model !== this.#lastModelWithMinorChange) {
      this.#lastModelWithMinorChange.markUndoableState();
      this.#lastModelWithMinorChange = null;
    }
    if (minorChange && this.#lastModelWithMinorChange === model) {
      return;
    }
    this.#stack = this.#stack.slice(0, this.#index);
    this.#stack.push(model);
    this.#index = this.#stack.length;
    if (minorChange) {
      this.#lastModelWithMinorChange = model;
    } else {
      await model.getAgent().invoke_markUndoableState();
      this.#lastModelWithMinorChange = null;
    }
  }
  async undo() {
    if (this.#index === 0) {
      return await Promise.resolve();
    }
    --this.#index;
    this.#lastModelWithMinorChange = null;
    await this.#stack[this.#index].getAgent().invoke_undo();
  }
  async redo() {
    if (this.#index >= this.#stack.length) {
      return await Promise.resolve();
    }
    ++this.#index;
    this.#lastModelWithMinorChange = null;
    await this.#stack[this.#index - 1].getAgent().invoke_redo();
  }
  dispose(model) {
    let shift = 0;
    for (let i = 0; i < this.#index; ++i) {
      if (this.#stack[i] === model) {
        ++shift;
      }
    }
    Platform14.ArrayUtilities.removeElement(this.#stack, model);
    this.#index -= shift;
    if (this.#lastModelWithMinorChange === model) {
      this.#lastModelWithMinorChange = null;
    }
  }
};
SDKModel.register(DOMModel, { capabilities: 2, autostart: true });

// gen/front_end/core/sdk/Resource.js
var Resource_exports = {};
__export(Resource_exports, {
  Resource: () => Resource
});
import * as TextUtils20 from "./../../models/text_utils/text_utils.js";
import * as Common22 from "./../common/common.js";
import * as Platform15 from "./../platform/platform.js";
var Resource = class {
  #resourceTreeModel;
  #request;
  #url;
  #documentURL;
  #frameId;
  #loaderId;
  #type;
  #mimeType;
  #isGenerated;
  #lastModified;
  #contentSize;
  #parsedURL;
  #contentData = null;
  /**
   * There is always at most one CDP "getResourceContent" call in-flight. But once it's done
   * we'll hit the backend again in case we failed.
   */
  #pendingContentData = null;
  constructor(resourceTreeModel, request, url, documentURL, frameId, loaderId, type, mimeType, lastModified, contentSize) {
    this.#resourceTreeModel = resourceTreeModel;
    this.#request = request;
    this.url = url;
    this.#documentURL = documentURL;
    this.#frameId = frameId;
    this.#loaderId = loaderId;
    this.#type = type || Common22.ResourceType.resourceTypes.Other;
    this.#mimeType = mimeType;
    this.#isGenerated = false;
    this.#lastModified = lastModified && Platform15.DateUtilities.isValid(lastModified) ? lastModified : null;
    this.#contentSize = contentSize;
  }
  lastModified() {
    if (this.#lastModified || !this.#request) {
      return this.#lastModified;
    }
    const lastModifiedHeader = this.#request.responseLastModified();
    const date = lastModifiedHeader ? new Date(lastModifiedHeader) : null;
    this.#lastModified = date && Platform15.DateUtilities.isValid(date) ? date : null;
    return this.#lastModified;
  }
  contentSize() {
    if (typeof this.#contentSize === "number" || !this.#request) {
      return this.#contentSize;
    }
    return this.#request.resourceSize;
  }
  get request() {
    return this.#request;
  }
  get url() {
    return this.#url;
  }
  set url(x) {
    this.#url = x;
    this.#parsedURL = new Common22.ParsedURL.ParsedURL(x);
  }
  get parsedURL() {
    return this.#parsedURL;
  }
  get documentURL() {
    return this.#documentURL;
  }
  get frameId() {
    return this.#frameId;
  }
  get loaderId() {
    return this.#loaderId;
  }
  get displayName() {
    return this.#parsedURL ? this.#parsedURL.displayName : "";
  }
  resourceType() {
    return this.#request ? this.#request.resourceType() : this.#type;
  }
  get mimeType() {
    return this.#request ? this.#request.mimeType : this.#mimeType;
  }
  get content() {
    if (this.#contentData?.isTextContent) {
      return this.#contentData.text;
    }
    return this.#contentData?.base64 ?? null;
  }
  get isGenerated() {
    return this.#isGenerated;
  }
  set isGenerated(val) {
    this.#isGenerated = val;
  }
  contentURL() {
    return this.#url;
  }
  contentType() {
    if (this.resourceType() === Common22.ResourceType.resourceTypes.Document && this.mimeType.indexOf("javascript") !== -1) {
      return Common22.ResourceType.resourceTypes.Script;
    }
    return this.resourceType();
  }
  async requestContentData() {
    if (this.#contentData) {
      return this.#contentData;
    }
    if (this.#pendingContentData) {
      return await this.#pendingContentData;
    }
    this.#pendingContentData = this.innerRequestContent().then((contentData) => {
      if (!TextUtils20.ContentData.ContentData.isError(contentData)) {
        this.#contentData = contentData;
      }
      this.#pendingContentData = null;
      return contentData;
    });
    return await this.#pendingContentData;
  }
  canonicalMimeType() {
    return this.contentType().canonicalMimeType() || this.mimeType;
  }
  async searchInContent(query, caseSensitive, isRegex) {
    if (!this.frameId) {
      return [];
    }
    if (this.request) {
      return await this.request.searchInContent(query, caseSensitive, isRegex);
    }
    const result = await this.#resourceTreeModel.target().pageAgent().invoke_searchInResource({ frameId: this.frameId, url: this.url, query, caseSensitive, isRegex });
    return TextUtils20.TextUtils.performSearchInSearchMatches(result.result || [], query, caseSensitive, isRegex);
  }
  async populateImageSource(image) {
    const contentData = await this.requestContentData();
    if (TextUtils20.ContentData.ContentData.isError(contentData)) {
      return;
    }
    image.src = contentData.asDataUrl() ?? this.#url;
  }
  async innerRequestContent() {
    if (this.request) {
      return await this.request.requestContentData();
    }
    const response = await this.#resourceTreeModel.target().pageAgent().invoke_getResourceContent({ frameId: this.frameId, url: this.url });
    const error = response.getError();
    if (error) {
      return { error };
    }
    return new TextUtils20.ContentData.ContentData(response.content, response.base64Encoded, this.mimeType);
  }
  frame() {
    return this.#frameId ? this.#resourceTreeModel.frameForId(this.#frameId) : null;
  }
  statusCode() {
    return this.#request ? this.#request.statusCode : 0;
  }
};

// gen/front_end/core/sdk/SecurityOriginManager.js
var SecurityOriginManager_exports = {};
__export(SecurityOriginManager_exports, {
  Events: () => Events9,
  SecurityOriginManager: () => SecurityOriginManager
});
var SecurityOriginManager = class extends SDKModel {
  // if a URL is unreachable, the browser will jump to an error page at
  // 'chrome-error://chromewebdata/', and |this.#mainSecurityOriginInternal| stores
  // its origin. In this situation, the original unreachable URL's security
  // origin will be stored in |this.#unreachableMainSecurityOriginInternal|.
  #mainSecurityOrigin = "";
  #unreachableMainSecurityOrigin = "";
  #securityOrigins = /* @__PURE__ */ new Set();
  updateSecurityOrigins(securityOrigins) {
    const oldOrigins = this.#securityOrigins;
    this.#securityOrigins = securityOrigins;
    for (const origin of oldOrigins) {
      if (!this.#securityOrigins.has(origin)) {
        this.dispatchEventToListeners(Events9.SecurityOriginRemoved, origin);
      }
    }
    for (const origin of this.#securityOrigins) {
      if (!oldOrigins.has(origin)) {
        this.dispatchEventToListeners(Events9.SecurityOriginAdded, origin);
      }
    }
  }
  securityOrigins() {
    return [...this.#securityOrigins];
  }
  mainSecurityOrigin() {
    return this.#mainSecurityOrigin;
  }
  unreachableMainSecurityOrigin() {
    return this.#unreachableMainSecurityOrigin;
  }
  setMainSecurityOrigin(securityOrigin, unreachableSecurityOrigin) {
    this.#mainSecurityOrigin = securityOrigin;
    this.#unreachableMainSecurityOrigin = unreachableSecurityOrigin || null;
    this.dispatchEventToListeners(Events9.MainSecurityOriginChanged, {
      mainSecurityOrigin: this.#mainSecurityOrigin,
      unreachableMainSecurityOrigin: this.#unreachableMainSecurityOrigin
    });
  }
};
var Events9;
(function(Events12) {
  Events12["SecurityOriginAdded"] = "SecurityOriginAdded";
  Events12["SecurityOriginRemoved"] = "SecurityOriginRemoved";
  Events12["MainSecurityOriginChanged"] = "MainSecurityOriginChanged";
})(Events9 || (Events9 = {}));
SDKModel.register(SecurityOriginManager, { capabilities: 0, autostart: false });

// gen/front_end/core/sdk/StorageKeyManager.js
var StorageKeyManager_exports = {};
__export(StorageKeyManager_exports, {
  StorageKeyManager: () => StorageKeyManager,
  parseStorageKey: () => parseStorageKey
});
import * as Common23 from "./../common/common.js";
var StorageKeyManager = class extends SDKModel {
  #mainStorageKey;
  #storageKeys;
  constructor(target) {
    super(target);
    this.#mainStorageKey = "";
    this.#storageKeys = /* @__PURE__ */ new Set();
  }
  updateStorageKeys(storageKeys) {
    const oldStorageKeys = this.#storageKeys;
    this.#storageKeys = storageKeys;
    for (const storageKey of oldStorageKeys) {
      if (!this.#storageKeys.has(storageKey)) {
        this.dispatchEventToListeners("StorageKeyRemoved", storageKey);
      }
    }
    for (const storageKey of this.#storageKeys) {
      if (!oldStorageKeys.has(storageKey)) {
        this.dispatchEventToListeners("StorageKeyAdded", storageKey);
      }
    }
  }
  storageKeys() {
    return [...this.#storageKeys];
  }
  mainStorageKey() {
    return this.#mainStorageKey;
  }
  setMainStorageKey(storageKey) {
    this.#mainStorageKey = storageKey;
    this.dispatchEventToListeners("MainStorageKeyChanged", {
      mainStorageKey: this.#mainStorageKey
    });
  }
};
function parseStorageKey(storageKeyString) {
  const components = storageKeyString.split("^");
  const origin = Common23.ParsedURL.ParsedURL.extractOrigin(components[0]);
  const storageKey = { origin, components: /* @__PURE__ */ new Map() };
  for (let i = 1; i < components.length; ++i) {
    storageKey.components.set(components[i].charAt(0), components[i].substring(1));
  }
  return storageKey;
}
SDKModel.register(StorageKeyManager, { capabilities: 0, autostart: false });

// gen/front_end/core/sdk/ResourceTreeModel.js
var ResourceTreeModel = class _ResourceTreeModel extends SDKModel {
  agent;
  storageAgent;
  #securityOriginManager;
  #storageKeyManager;
  framesInternal = /* @__PURE__ */ new Map();
  #cachedResourcesProcessed = false;
  #pendingReloadOptions = null;
  #reloadSuspensionCount = 0;
  isInterstitialShowing = false;
  mainFrame = null;
  #pendingBackForwardCacheNotUsedEvents = /* @__PURE__ */ new Set();
  constructor(target) {
    super(target);
    const networkManager = target.model(NetworkManager);
    if (networkManager) {
      networkManager.addEventListener(Events2.RequestFinished, this.onRequestFinished, this);
      networkManager.addEventListener(Events2.RequestUpdateDropped, this.onRequestUpdateDropped, this);
    }
    this.agent = target.pageAgent();
    this.storageAgent = target.storageAgent();
    void this.agent.invoke_enable({});
    this.#securityOriginManager = target.model(SecurityOriginManager);
    this.#storageKeyManager = target.model(StorageKeyManager);
    target.registerPageDispatcher(new PageDispatcher(this));
    void this.#buildResourceTree();
  }
  async #buildResourceTree() {
    return await this.agent.invoke_getResourceTree().then((event) => {
      this.processCachedResources(event.getError() ? null : event.frameTree);
      if (this.mainFrame) {
        this.processPendingEvents(this.mainFrame);
      }
    });
  }
  static frameForRequest(request) {
    const networkManager = NetworkManager.forRequest(request);
    const resourceTreeModel = networkManager ? networkManager.target().model(_ResourceTreeModel) : null;
    if (!resourceTreeModel) {
      return null;
    }
    return request.frameId ? resourceTreeModel.frameForId(request.frameId) : null;
  }
  static frames() {
    const result = [];
    for (const resourceTreeModel of TargetManager.instance().models(_ResourceTreeModel)) {
      result.push(...resourceTreeModel.frames());
    }
    return result;
  }
  static resourceForURL(url) {
    for (const resourceTreeModel of TargetManager.instance().models(_ResourceTreeModel)) {
      const mainFrame = resourceTreeModel.mainFrame;
      const result = mainFrame ? mainFrame.resourceForURL(url) : null;
      if (result) {
        return result;
      }
    }
    return null;
  }
  static reloadAllPages(bypassCache, scriptToEvaluateOnLoad) {
    for (const resourceTreeModel of TargetManager.instance().models(_ResourceTreeModel)) {
      if (resourceTreeModel.target().parentTarget()?.type() !== Type.FRAME) {
        resourceTreeModel.reloadPage(bypassCache, scriptToEvaluateOnLoad);
      }
    }
  }
  async storageKeyForFrame(frameId) {
    if (!this.framesInternal.has(frameId)) {
      return null;
    }
    const response = await this.storageAgent.invoke_getStorageKey({ frameId });
    if (response.getError() === "Frame tree node for given frame not found") {
      return null;
    }
    return response.storageKey;
  }
  domModel() {
    return this.target().model(DOMModel);
  }
  processCachedResources(mainFramePayload) {
    if (mainFramePayload && mainFramePayload.frame.url !== ":") {
      this.dispatchEventToListeners(Events3.WillLoadCachedResources);
      this.addFramesRecursively(null, mainFramePayload);
      this.target().setInspectedURL(mainFramePayload.frame.url);
    }
    this.#cachedResourcesProcessed = true;
    const runtimeModel = this.target().model(RuntimeModel);
    if (runtimeModel) {
      runtimeModel.setExecutionContextComparator(this.executionContextComparator.bind(this));
      runtimeModel.fireExecutionContextOrderChanged();
    }
    this.dispatchEventToListeners(Events3.CachedResourcesLoaded, this);
  }
  cachedResourcesLoaded() {
    return this.#cachedResourcesProcessed;
  }
  addFrame(frame, _aboutToNavigate) {
    this.framesInternal.set(frame.id, frame);
    if (frame.isMainFrame()) {
      this.mainFrame = frame;
    }
    this.dispatchEventToListeners(Events3.FrameAdded, frame);
    this.updateSecurityOrigins();
    void this.updateStorageKeys();
  }
  frameAttached(frameId, parentFrameId, stackTrace) {
    const sameTargetParentFrame = parentFrameId ? this.framesInternal.get(parentFrameId) || null : null;
    if (!this.#cachedResourcesProcessed && sameTargetParentFrame) {
      return null;
    }
    if (this.framesInternal.has(frameId)) {
      return null;
    }
    const frame = new ResourceTreeFrame(this, sameTargetParentFrame, frameId, null, stackTrace || null);
    if (parentFrameId && !sameTargetParentFrame) {
      frame.crossTargetParentFrameId = parentFrameId;
    }
    if (frame.isMainFrame() && this.mainFrame) {
      this.frameDetached(this.mainFrame.id, false);
    }
    this.addFrame(frame, true);
    return frame;
  }
  frameNavigated(framePayload, type) {
    const sameTargetParentFrame = framePayload.parentId ? this.framesInternal.get(framePayload.parentId) || null : null;
    if (!this.#cachedResourcesProcessed && sameTargetParentFrame) {
      return;
    }
    let frame = this.framesInternal.get(framePayload.id) || null;
    if (!frame) {
      frame = this.frameAttached(framePayload.id, framePayload.parentId || null);
      console.assert(Boolean(frame));
      if (!frame) {
        return;
      }
    }
    this.dispatchEventToListeners(Events3.FrameWillNavigate, frame);
    frame.navigate(framePayload);
    if (type) {
      frame.backForwardCacheDetails.restoredFromCache = type === "BackForwardCacheRestore";
    }
    if (frame.isMainFrame()) {
      this.target().setInspectedURL(frame.url);
    }
    this.dispatchEventToListeners(Events3.FrameNavigated, frame);
    if (frame.isPrimaryFrame()) {
      this.primaryPageChanged(
        frame,
        "Navigation"
        /* PrimaryPageChangeType.NAVIGATION */
      );
    }
    const resources = frame.resources();
    for (let i = 0; i < resources.length; ++i) {
      this.dispatchEventToListeners(Events3.ResourceAdded, resources[i]);
    }
    this.updateSecurityOrigins();
    void this.updateStorageKeys();
    if (frame.backForwardCacheDetails.restoredFromCache) {
      FrameManager.instance().modelRemoved(this);
      FrameManager.instance().modelAdded(this);
      void this.#buildResourceTree();
    }
  }
  primaryPageChanged(frame, type) {
    this.processPendingEvents(frame);
    this.dispatchEventToListeners(Events3.PrimaryPageChanged, { frame, type });
    const networkManager = this.target().model(NetworkManager);
    if (networkManager && frame.isOutermostFrame()) {
      networkManager.clearRequests();
    }
  }
  documentOpened(framePayload) {
    this.frameNavigated(framePayload, void 0);
    const frame = this.framesInternal.get(framePayload.id);
    if (frame && !frame.getResourcesMap().get(framePayload.url)) {
      const frameResource = this.createResourceFromFramePayload(framePayload, framePayload.url, Common24.ResourceType.resourceTypes.Document, framePayload.mimeType, null, null);
      frameResource.isGenerated = true;
      frame.addResource(frameResource);
    }
  }
  frameDetached(frameId, isSwap) {
    if (!this.#cachedResourcesProcessed) {
      return;
    }
    const frame = this.framesInternal.get(frameId);
    if (!frame) {
      return;
    }
    const sameTargetParentFrame = frame.sameTargetParentFrame();
    if (sameTargetParentFrame) {
      sameTargetParentFrame.removeChildFrame(frame, isSwap);
    } else {
      frame.remove(isSwap);
    }
    this.updateSecurityOrigins();
    void this.updateStorageKeys();
  }
  onRequestFinished(event) {
    if (!this.#cachedResourcesProcessed) {
      return;
    }
    const request = event.data;
    if (request.failed) {
      return;
    }
    const frame = request.frameId ? this.framesInternal.get(request.frameId) : null;
    if (frame) {
      frame.addRequest(request);
    }
  }
  onRequestUpdateDropped(event) {
    if (!this.#cachedResourcesProcessed) {
      return;
    }
    const data = event.data;
    const frameId = data.frameId;
    if (!frameId) {
      return;
    }
    const frame = this.framesInternal.get(frameId);
    if (!frame) {
      return;
    }
    const url = data.url;
    if (frame.getResourcesMap().get(url)) {
      return;
    }
    const resource = new Resource(this, null, url, frame.url, frameId, data.loaderId, Common24.ResourceType.resourceTypes[data.resourceType], data.mimeType, data.lastModified, null);
    frame.addResource(resource);
  }
  frameForId(frameId) {
    return this.framesInternal.get(frameId) || null;
  }
  forAllResources(callback) {
    if (this.mainFrame) {
      return this.mainFrame.callForFrameResources(callback);
    }
    return false;
  }
  frames() {
    return [...this.framesInternal.values()];
  }
  addFramesRecursively(sameTargetParentFrame, frameTreePayload) {
    const framePayload = frameTreePayload.frame;
    let frame = this.framesInternal.get(framePayload.id);
    if (!frame) {
      frame = new ResourceTreeFrame(this, sameTargetParentFrame, framePayload.id, framePayload, null);
    }
    if (!sameTargetParentFrame && framePayload.parentId) {
      frame.crossTargetParentFrameId = framePayload.parentId;
    }
    this.addFrame(frame);
    for (const childFrame of frameTreePayload.childFrames || []) {
      this.addFramesRecursively(frame, childFrame);
    }
    for (let i = 0; i < frameTreePayload.resources.length; ++i) {
      const subresource = frameTreePayload.resources[i];
      const resource = this.createResourceFromFramePayload(framePayload, subresource.url, Common24.ResourceType.resourceTypes[subresource.type], subresource.mimeType, subresource.lastModified || null, subresource.contentSize || null);
      frame.addResource(resource);
    }
    if (!frame.getResourcesMap().get(framePayload.url)) {
      const frameResource = this.createResourceFromFramePayload(framePayload, framePayload.url, Common24.ResourceType.resourceTypes.Document, framePayload.mimeType, null, null);
      frame.addResource(frameResource);
    }
  }
  createResourceFromFramePayload(frame, url, type, mimeType, lastModifiedTime, contentSize) {
    const lastModified = typeof lastModifiedTime === "number" ? new Date(lastModifiedTime * 1e3) : null;
    return new Resource(this, null, url, frame.url, frame.id, frame.loaderId, type, mimeType, lastModified, contentSize);
  }
  suspendReload() {
    this.#reloadSuspensionCount++;
  }
  resumeReload() {
    this.#reloadSuspensionCount--;
    console.assert(this.#reloadSuspensionCount >= 0, "Unbalanced call to ResourceTreeModel.resumeReload()");
    if (!this.#reloadSuspensionCount && this.#pendingReloadOptions) {
      const { ignoreCache, scriptToEvaluateOnLoad } = this.#pendingReloadOptions;
      this.reloadPage(ignoreCache, scriptToEvaluateOnLoad);
    }
  }
  reloadPage(ignoreCache, scriptToEvaluateOnLoad) {
    const loaderId = this.mainFrame?.loaderId;
    if (!loaderId) {
      return;
    }
    if (!this.#pendingReloadOptions) {
      this.dispatchEventToListeners(Events3.PageReloadRequested, this);
    }
    if (this.#reloadSuspensionCount) {
      this.#pendingReloadOptions = { ignoreCache, scriptToEvaluateOnLoad };
      return;
    }
    this.#pendingReloadOptions = null;
    const networkManager = this.target().model(NetworkManager);
    if (networkManager) {
      networkManager.clearRequests();
    }
    this.dispatchEventToListeners(Events3.WillReloadPage);
    void this.agent.invoke_reload({ ignoreCache, scriptToEvaluateOnLoad, loaderId });
  }
  navigate(url) {
    return this.agent.invoke_navigate({ url });
  }
  async navigationHistory() {
    const response = await this.agent.invoke_getNavigationHistory();
    if (response.getError()) {
      return null;
    }
    return { currentIndex: response.currentIndex, entries: response.entries };
  }
  navigateToHistoryEntry(entry) {
    void this.agent.invoke_navigateToHistoryEntry({ entryId: entry.id });
  }
  setLifecycleEventsEnabled(enabled) {
    return this.agent.invoke_setLifecycleEventsEnabled({ enabled });
  }
  async fetchAppManifest() {
    const response = await this.agent.invoke_getAppManifest({});
    if (response.getError()) {
      return { url: response.url, data: null, errors: [] };
    }
    return { url: response.url, data: response.data || null, errors: response.errors };
  }
  async getInstallabilityErrors() {
    const response = await this.agent.invoke_getInstallabilityErrors();
    return response.installabilityErrors || [];
  }
  async getAppId() {
    return await this.agent.invoke_getAppId();
  }
  executionContextComparator(a, b) {
    function framePath(frame) {
      let currentFrame = frame;
      const parents = [];
      while (currentFrame) {
        parents.push(currentFrame);
        currentFrame = currentFrame.sameTargetParentFrame();
      }
      return parents.reverse();
    }
    if (a.target() !== b.target()) {
      return ExecutionContext.comparator(a, b);
    }
    const framesA = a.frameId ? framePath(this.frameForId(a.frameId)) : [];
    const framesB = b.frameId ? framePath(this.frameForId(b.frameId)) : [];
    let frameA;
    let frameB;
    for (let i = 0; ; i++) {
      if (!framesA[i] || !framesB[i] || framesA[i] !== framesB[i]) {
        frameA = framesA[i];
        frameB = framesB[i];
        break;
      }
    }
    if (!frameA && frameB) {
      return -1;
    }
    if (!frameB && frameA) {
      return 1;
    }
    if (frameA && frameB) {
      return frameA.id.localeCompare(frameB.id);
    }
    return ExecutionContext.comparator(a, b);
  }
  getSecurityOriginData() {
    const securityOrigins = /* @__PURE__ */ new Set();
    let mainSecurityOrigin = null;
    let unreachableMainSecurityOrigin = null;
    for (const frame of this.framesInternal.values()) {
      const origin = frame.securityOrigin;
      if (!origin) {
        continue;
      }
      securityOrigins.add(origin);
      if (frame.isMainFrame()) {
        mainSecurityOrigin = origin;
        if (frame.unreachableUrl()) {
          const unreachableParsed = new Common24.ParsedURL.ParsedURL(frame.unreachableUrl());
          unreachableMainSecurityOrigin = unreachableParsed.securityOrigin();
        }
      }
    }
    return {
      securityOrigins,
      mainSecurityOrigin,
      unreachableMainSecurityOrigin
    };
  }
  async getStorageKeyData() {
    const storageKeys = /* @__PURE__ */ new Set();
    let mainStorageKey = null;
    for (const { isMainFrame, storageKey } of await Promise.all([...this.framesInternal.values()].map((f) => f.getStorageKey(
      /* forceFetch */
      false
    ).then((k) => ({
      isMainFrame: f.isMainFrame(),
      storageKey: k
    }))))) {
      if (isMainFrame) {
        mainStorageKey = storageKey;
      }
      if (storageKey) {
        storageKeys.add(storageKey);
      }
    }
    return { storageKeys, mainStorageKey };
  }
  updateSecurityOrigins() {
    const data = this.getSecurityOriginData();
    this.#securityOriginManager.setMainSecurityOrigin(data.mainSecurityOrigin || "", data.unreachableMainSecurityOrigin || "");
    this.#securityOriginManager.updateSecurityOrigins(data.securityOrigins);
  }
  async updateStorageKeys() {
    const data = await this.getStorageKeyData();
    this.#storageKeyManager.setMainStorageKey(data.mainStorageKey || "");
    this.#storageKeyManager.updateStorageKeys(data.storageKeys);
  }
  async getMainStorageKey() {
    return this.mainFrame ? await this.mainFrame.getStorageKey(
      /* forceFetch */
      false
    ) : null;
  }
  getMainSecurityOrigin() {
    const data = this.getSecurityOriginData();
    return data.mainSecurityOrigin || data.unreachableMainSecurityOrigin;
  }
  onBackForwardCacheNotUsed(event) {
    if (this.mainFrame && this.mainFrame.id === event.frameId && this.mainFrame.loaderId === event.loaderId) {
      this.mainFrame.setBackForwardCacheDetails(event);
      this.dispatchEventToListeners(Events3.BackForwardCacheDetailsUpdated, this.mainFrame);
    } else {
      this.#pendingBackForwardCacheNotUsedEvents.add(event);
    }
  }
  processPendingEvents(frame) {
    if (!frame.isMainFrame()) {
      return;
    }
    for (const event of this.#pendingBackForwardCacheNotUsedEvents) {
      if (frame.id === event.frameId && frame.loaderId === event.loaderId) {
        frame.setBackForwardCacheDetails(event);
        this.#pendingBackForwardCacheNotUsedEvents.delete(event);
        break;
      }
    }
  }
};
var Events3;
(function(Events12) {
  Events12["FrameAdded"] = "FrameAdded";
  Events12["FrameNavigated"] = "FrameNavigated";
  Events12["FrameDetached"] = "FrameDetached";
  Events12["FrameResized"] = "FrameResized";
  Events12["FrameWillNavigate"] = "FrameWillNavigate";
  Events12["PrimaryPageChanged"] = "PrimaryPageChanged";
  Events12["ResourceAdded"] = "ResourceAdded";
  Events12["WillLoadCachedResources"] = "WillLoadCachedResources";
  Events12["CachedResourcesLoaded"] = "CachedResourcesLoaded";
  Events12["DOMContentLoaded"] = "DOMContentLoaded";
  Events12["LifecycleEvent"] = "LifecycleEvent";
  Events12["Load"] = "Load";
  Events12["PageReloadRequested"] = "PageReloadRequested";
  Events12["WillReloadPage"] = "WillReloadPage";
  Events12["InterstitialShown"] = "InterstitialShown";
  Events12["InterstitialHidden"] = "InterstitialHidden";
  Events12["BackForwardCacheDetailsUpdated"] = "BackForwardCacheDetailsUpdated";
  Events12["JavaScriptDialogOpening"] = "JavaScriptDialogOpening";
})(Events3 || (Events3 = {}));
var ResourceTreeFrame = class {
  #model;
  #sameTargetParentFrame;
  #id;
  crossTargetParentFrameId = null;
  #loaderId;
  #name;
  #url;
  #domainAndRegistry;
  #securityOrigin;
  #securityOriginDetails;
  #storageKey;
  #unreachableUrl;
  #adFrameStatus;
  #secureContextType;
  #crossOriginIsolatedContextType;
  #gatedAPIFeatures;
  #creationStackTrace;
  #creationStackTraceTarget = null;
  #childFrames = /* @__PURE__ */ new Set();
  resourcesMap = /* @__PURE__ */ new Map();
  backForwardCacheDetails = {
    restoredFromCache: void 0,
    explanations: [],
    explanationsTree: void 0
  };
  constructor(model, parentFrame, frameId, payload, creationStackTrace) {
    this.#model = model;
    this.#sameTargetParentFrame = parentFrame;
    this.#id = frameId;
    this.#loaderId = payload?.loaderId ?? "";
    this.#name = payload?.name;
    this.#url = payload && payload.url || Platform16.DevToolsPath.EmptyUrlString;
    this.#domainAndRegistry = payload?.domainAndRegistry || "";
    this.#securityOrigin = payload?.securityOrigin ?? null;
    this.#securityOriginDetails = payload?.securityOriginDetails;
    this.#unreachableUrl = payload && payload.unreachableUrl || Platform16.DevToolsPath.EmptyUrlString;
    this.#adFrameStatus = payload?.adFrameStatus;
    this.#secureContextType = payload?.secureContextType ?? null;
    this.#crossOriginIsolatedContextType = payload?.crossOriginIsolatedContextType ?? null;
    this.#gatedAPIFeatures = payload?.gatedAPIFeatures ?? null;
    this.#creationStackTrace = creationStackTrace;
    if (this.#sameTargetParentFrame) {
      this.#sameTargetParentFrame.#childFrames.add(this);
    }
  }
  isSecureContext() {
    return this.#secureContextType !== null && this.#secureContextType.startsWith("Secure");
  }
  getSecureContextType() {
    return this.#secureContextType;
  }
  isCrossOriginIsolated() {
    return this.#crossOriginIsolatedContextType !== null && this.#crossOriginIsolatedContextType.startsWith("Isolated");
  }
  getCrossOriginIsolatedContextType() {
    return this.#crossOriginIsolatedContextType;
  }
  getGatedAPIFeatures() {
    return this.#gatedAPIFeatures;
  }
  getCreationStackTraceData() {
    return {
      creationStackTrace: this.#creationStackTrace,
      creationStackTraceTarget: this.#creationStackTraceTarget || this.resourceTreeModel().target()
    };
  }
  navigate(framePayload) {
    this.#loaderId = framePayload.loaderId;
    this.#name = framePayload.name;
    this.#url = framePayload.url;
    this.#domainAndRegistry = framePayload.domainAndRegistry;
    this.#securityOrigin = framePayload.securityOrigin;
    this.#securityOriginDetails = framePayload.securityOriginDetails;
    void this.getStorageKey(
      /* forceFetch */
      true
    );
    this.#unreachableUrl = framePayload.unreachableUrl || Platform16.DevToolsPath.EmptyUrlString;
    this.#adFrameStatus = framePayload?.adFrameStatus;
    this.#secureContextType = framePayload.secureContextType;
    this.#crossOriginIsolatedContextType = framePayload.crossOriginIsolatedContextType;
    this.#gatedAPIFeatures = framePayload.gatedAPIFeatures;
    this.backForwardCacheDetails = {
      restoredFromCache: void 0,
      explanations: [],
      explanationsTree: void 0
    };
    const mainResource = this.resourcesMap.get(this.#url);
    this.resourcesMap.clear();
    this.removeChildFrames();
    if (mainResource && mainResource.loaderId === this.#loaderId) {
      this.addResource(mainResource);
    }
  }
  resourceTreeModel() {
    return this.#model;
  }
  get id() {
    return this.#id;
  }
  get name() {
    return this.#name || "";
  }
  get url() {
    return this.#url;
  }
  domainAndRegistry() {
    return this.#domainAndRegistry;
  }
  async getAdScriptAncestry(frameId) {
    const res = await this.#model.agent.invoke_getAdScriptAncestry({ frameId });
    return res.adScriptAncestry || null;
  }
  get securityOrigin() {
    return this.#securityOrigin;
  }
  get securityOriginDetails() {
    return this.#securityOriginDetails ?? null;
  }
  getStorageKey(forceFetch) {
    if (!this.#storageKey || forceFetch) {
      this.#storageKey = this.#model.storageKeyForFrame(this.#id);
    }
    return this.#storageKey;
  }
  unreachableUrl() {
    return this.#unreachableUrl;
  }
  get loaderId() {
    return this.#loaderId;
  }
  adFrameType() {
    return this.#adFrameStatus?.adFrameType || "none";
  }
  adFrameStatus() {
    return this.#adFrameStatus;
  }
  get childFrames() {
    return [...this.#childFrames];
  }
  /**
   * Returns the parent frame if both #frames are part of the same process/target.
   */
  sameTargetParentFrame() {
    return this.#sameTargetParentFrame;
  }
  /**
   * Returns the parent frame if both #frames are part of different processes/targets (child is an OOPIF).
   */
  crossTargetParentFrame() {
    if (!this.crossTargetParentFrameId) {
      return null;
    }
    const parentTarget = this.#model.target().parentTarget();
    if (parentTarget?.type() !== Type.FRAME) {
      return null;
    }
    const parentModel = parentTarget.model(ResourceTreeModel);
    if (!parentModel) {
      return null;
    }
    return parentModel.framesInternal.get(this.crossTargetParentFrameId) || null;
  }
  /**
   * Returns the parent frame. There is only 1 parent and it's either in the
   * same target or it's cross-target.
   */
  parentFrame() {
    return this.sameTargetParentFrame() || this.crossTargetParentFrame();
  }
  /**
   * Returns true if this is the main frame of its target. A main frame is the root of the frame tree i.e. a frame without
   * a parent, but the whole frame tree could be embedded in another frame tree (e.g. OOPIFs, fenced frames, portals).
   * https://chromium.googlesource.com/chromium/src/+/HEAD/docs/frame_trees.md
   */
  isMainFrame() {
    return !this.#sameTargetParentFrame;
  }
  /**
   * Returns true if this is a main frame which is not embedded in another frame tree. With MPArch features such as
   * back/forward cache or prerender there can be multiple outermost frames.
   * https://chromium.googlesource.com/chromium/src/+/HEAD/docs/frame_trees.md
   */
  isOutermostFrame() {
    return this.#model.target().parentTarget()?.type() !== Type.FRAME && !this.#sameTargetParentFrame && !this.crossTargetParentFrameId;
  }
  /**
   * Returns true if this is the primary frame of the browser tab. There can only be one primary frame for each
   * browser tab. It is the outermost frame being actively displayed in the browser tab.
   * https://chromium.googlesource.com/chromium/src/+/HEAD/docs/frame_trees.md
   */
  isPrimaryFrame() {
    return !this.#sameTargetParentFrame && this.#model.target() === TargetManager.instance().primaryPageTarget();
  }
  removeChildFrame(frame, isSwap) {
    this.#childFrames.delete(frame);
    frame.remove(isSwap);
  }
  removeChildFrames() {
    const frames = this.#childFrames;
    this.#childFrames = /* @__PURE__ */ new Set();
    for (const frame of frames) {
      frame.remove(false);
    }
  }
  remove(isSwap) {
    this.removeChildFrames();
    this.#model.framesInternal.delete(this.id);
    this.#model.dispatchEventToListeners(Events3.FrameDetached, { frame: this, isSwap });
  }
  addResource(resource) {
    if (this.resourcesMap.get(resource.url) === resource) {
      return;
    }
    this.resourcesMap.set(resource.url, resource);
    this.#model.dispatchEventToListeners(Events3.ResourceAdded, resource);
  }
  addRequest(request) {
    let resource = this.resourcesMap.get(request.url());
    if (resource && resource.request === request) {
      return;
    }
    resource = new Resource(this.#model, request, request.url(), request.documentURL, request.frameId, request.loaderId, request.resourceType(), request.mimeType, null, null);
    this.resourcesMap.set(resource.url, resource);
    this.#model.dispatchEventToListeners(Events3.ResourceAdded, resource);
  }
  resources() {
    return Array.from(this.resourcesMap.values());
  }
  resourceForURL(url) {
    const resource = this.resourcesMap.get(url);
    if (resource) {
      return resource;
    }
    for (const frame of this.#childFrames) {
      const resource2 = frame.resourceForURL(url);
      if (resource2) {
        return resource2;
      }
    }
    return null;
  }
  callForFrameResources(callback) {
    for (const resource of this.resourcesMap.values()) {
      if (callback(resource)) {
        return true;
      }
    }
    for (const frame of this.#childFrames) {
      if (frame.callForFrameResources(callback)) {
        return true;
      }
    }
    return false;
  }
  displayName() {
    if (this.isOutermostFrame()) {
      return i18n15.i18n.lockedString("top");
    }
    const subtitle = new Common24.ParsedURL.ParsedURL(this.#url).displayName;
    if (subtitle) {
      if (!this.#name) {
        return subtitle;
      }
      return this.#name + " (" + subtitle + ")";
    }
    return i18n15.i18n.lockedString("iframe");
  }
  async getOwnerDeferredDOMNode() {
    const parentFrame = this.parentFrame();
    if (!parentFrame) {
      return null;
    }
    return await parentFrame.resourceTreeModel().domModel().getOwnerNodeForFrame(this.#id);
  }
  async getOwnerDOMNodeOrDocument() {
    const deferredNode = await this.getOwnerDeferredDOMNode();
    if (deferredNode) {
      return await deferredNode.resolvePromise();
    }
    if (this.isOutermostFrame()) {
      return await this.resourceTreeModel().domModel().requestDocument();
    }
    return null;
  }
  async highlight() {
    const parentFrame = this.parentFrame();
    const parentTarget = this.resourceTreeModel().target().parentTarget();
    const highlightFrameOwner = async (domModel) => {
      const deferredNode = await domModel.getOwnerNodeForFrame(this.#id);
      if (deferredNode) {
        domModel.overlayModel().highlightInOverlay({ deferredNode, selectorList: "" }, "all", true);
      }
    };
    if (parentFrame) {
      return await highlightFrameOwner(parentFrame.resourceTreeModel().domModel());
    }
    if (parentTarget?.type() === Type.FRAME) {
      const domModel = parentTarget.model(DOMModel);
      if (domModel) {
        return await highlightFrameOwner(domModel);
      }
    }
    const document2 = await this.resourceTreeModel().domModel().requestDocument();
    if (document2) {
      this.resourceTreeModel().domModel().overlayModel().highlightInOverlay({ node: document2, selectorList: "" }, "all", true);
    }
  }
  async getPermissionsPolicyState() {
    const response = await this.resourceTreeModel().target().pageAgent().invoke_getPermissionsPolicyState({ frameId: this.#id });
    if (response.getError()) {
      return null;
    }
    return response.states;
  }
  async getOriginTrials() {
    const response = await this.resourceTreeModel().target().pageAgent().invoke_getOriginTrials({ frameId: this.#id });
    if (response.getError()) {
      return [];
    }
    return response.originTrials;
  }
  setCreationStackTrace(creationStackTraceData) {
    this.#creationStackTrace = creationStackTraceData.creationStackTrace;
    this.#creationStackTraceTarget = creationStackTraceData.creationStackTraceTarget;
  }
  setBackForwardCacheDetails(event) {
    this.backForwardCacheDetails.restoredFromCache = false;
    this.backForwardCacheDetails.explanations = event.notRestoredExplanations;
    this.backForwardCacheDetails.explanationsTree = event.notRestoredExplanationsTree;
  }
  getResourcesMap() {
    return this.resourcesMap;
  }
};
var PageDispatcher = class {
  #resourceTreeModel;
  constructor(resourceTreeModel) {
    this.#resourceTreeModel = resourceTreeModel;
  }
  backForwardCacheNotUsed(params) {
    this.#resourceTreeModel.onBackForwardCacheNotUsed(params);
  }
  domContentEventFired({ timestamp }) {
    this.#resourceTreeModel.dispatchEventToListeners(Events3.DOMContentLoaded, timestamp);
  }
  loadEventFired({ timestamp }) {
    this.#resourceTreeModel.dispatchEventToListeners(Events3.Load, { resourceTreeModel: this.#resourceTreeModel, loadTime: timestamp });
  }
  lifecycleEvent({ frameId, name }) {
    this.#resourceTreeModel.dispatchEventToListeners(Events3.LifecycleEvent, { frameId, name });
  }
  frameAttached({ frameId, parentFrameId, stack }) {
    this.#resourceTreeModel.frameAttached(frameId, parentFrameId, stack);
  }
  frameNavigated({ frame, type }) {
    this.#resourceTreeModel.frameNavigated(frame, type);
  }
  documentOpened({ frame }) {
    this.#resourceTreeModel.documentOpened(frame);
  }
  frameDetached({ frameId, reason }) {
    this.#resourceTreeModel.frameDetached(
      frameId,
      reason === "swap"
      /* Protocol.Page.FrameDetachedEventReason.Swap */
    );
  }
  frameSubtreeWillBeDetached(_params) {
  }
  frameStartedLoading({}) {
  }
  frameStoppedLoading({}) {
  }
  frameRequestedNavigation({}) {
  }
  frameScheduledNavigation({}) {
  }
  frameClearedScheduledNavigation({}) {
  }
  frameStartedNavigating({}) {
  }
  navigatedWithinDocument({}) {
  }
  frameResized() {
    this.#resourceTreeModel.dispatchEventToListeners(Events3.FrameResized);
  }
  javascriptDialogOpening(event) {
    this.#resourceTreeModel.dispatchEventToListeners(Events3.JavaScriptDialogOpening, event);
    if (!event.hasBrowserHandler) {
      void this.#resourceTreeModel.agent.invoke_handleJavaScriptDialog({ accept: false });
    }
  }
  javascriptDialogClosed({}) {
  }
  screencastFrame({}) {
  }
  screencastVisibilityChanged({}) {
  }
  interstitialShown() {
    this.#resourceTreeModel.isInterstitialShowing = true;
    this.#resourceTreeModel.dispatchEventToListeners(Events3.InterstitialShown);
  }
  interstitialHidden() {
    this.#resourceTreeModel.isInterstitialShowing = false;
    this.#resourceTreeModel.dispatchEventToListeners(Events3.InterstitialHidden);
  }
  windowOpen({}) {
  }
  compilationCacheProduced({}) {
  }
  fileChooserOpened({}) {
  }
  downloadWillBegin({}) {
  }
  downloadProgress() {
  }
};
SDKModel.register(ResourceTreeModel, { capabilities: 2, autostart: true, early: true });

// gen/front_end/core/sdk/CookieModel.js
var CookieModel = class extends SDKModel {
  #blockedCookies = /* @__PURE__ */ new Map();
  #cookieToBlockedReasons = /* @__PURE__ */ new Map();
  #refreshThrottler = new Common25.Throttler.Throttler(300);
  #cookies = /* @__PURE__ */ new Map();
  constructor(target) {
    super(target);
    target.model(ResourceTreeModel)?.addEventListener(Events3.PrimaryPageChanged, this.#onPrimaryPageChanged, this);
    target.model(NetworkManager)?.addEventListener(Events2.ResponseReceived, this.#onResponseReceived, this);
    target.model(NetworkManager)?.addEventListener(Events2.LoadingFinished, this.#onLoadingFinished, this);
  }
  addBlockedCookie(cookie, blockedReasons) {
    const key = cookie.key();
    const previousCookie = this.#blockedCookies.get(key);
    this.#blockedCookies.set(key, cookie);
    if (blockedReasons) {
      this.#cookieToBlockedReasons.set(cookie, blockedReasons);
    } else {
      this.#cookieToBlockedReasons.delete(cookie);
    }
    if (previousCookie) {
      this.#cookieToBlockedReasons.delete(previousCookie);
    }
  }
  removeBlockedCookie(cookie) {
    this.#blockedCookies.delete(cookie.key());
  }
  async #onPrimaryPageChanged() {
    this.#blockedCookies.clear();
    this.#cookieToBlockedReasons.clear();
    await this.#refresh();
  }
  getCookieToBlockedReasonsMap() {
    return this.#cookieToBlockedReasons;
  }
  async #getCookies(urls) {
    const networkAgent = this.target().networkAgent();
    const newCookies = new Map(await Promise.all(urls.keysArray().map((domain) => networkAgent.invoke_getCookies({ urls: [...urls.get(domain).values()] }).then(({ cookies }) => [domain, cookies.map(Cookie.fromProtocolCookie)]))));
    const updated = this.#isUpdated(newCookies);
    this.#cookies = newCookies;
    if (updated) {
      this.dispatchEventToListeners(
        "CookieListUpdated"
        /* Events.COOKIE_LIST_UPDATED */
      );
    }
  }
  async deleteCookie(cookie) {
    await this.deleteCookies([cookie]);
  }
  async clear(domain, securityOrigin) {
    if (!this.#isRefreshing()) {
      await this.#refreshThrottled();
    }
    const cookies = domain ? this.#cookies.get(domain) || [] : [...this.#cookies.values()].flat();
    cookies.push(...this.#blockedCookies.values());
    if (securityOrigin) {
      const cookiesToDelete = cookies.filter((cookie) => {
        return cookie.matchesSecurityOrigin(securityOrigin);
      });
      await this.deleteCookies(cookiesToDelete);
    } else {
      await this.deleteCookies(cookies);
    }
  }
  async saveCookie(cookie) {
    let domain = cookie.domain();
    if (!domain.startsWith(".")) {
      domain = "";
    }
    let expires = void 0;
    if (cookie.expires()) {
      expires = Math.floor(Date.parse(`${cookie.expires()}`) / 1e3);
    }
    const enabled = Root9.Runtime.experiments.isEnabled("experimental-cookie-features");
    const preserveUnset = (scheme) => scheme === "Unset" ? scheme : void 0;
    const protocolCookie = {
      name: cookie.name(),
      value: cookie.value(),
      url: cookie.url() || void 0,
      domain,
      path: cookie.path(),
      secure: cookie.secure(),
      httpOnly: cookie.httpOnly(),
      sameSite: cookie.sameSite(),
      expires,
      priority: cookie.priority(),
      partitionKey: cookie.partitionKey(),
      sourceScheme: enabled ? cookie.sourceScheme() : preserveUnset(cookie.sourceScheme()),
      sourcePort: enabled ? cookie.sourcePort() : void 0
    };
    const response = await this.target().networkAgent().invoke_setCookie(protocolCookie);
    const error = response.getError();
    if (error || !response.success) {
      return false;
    }
    await this.#refreshThrottled();
    return response.success;
  }
  /**
   * Returns cookies needed by current page's frames whose security origins are |domain|.
   */
  async getCookiesForDomain(domain, forceUpdate) {
    if (!this.#isRefreshing() || forceUpdate) {
      await this.#refreshThrottled();
    }
    const normalCookies = this.#cookies.get(domain) || [];
    return normalCookies.concat(Array.from(this.#blockedCookies.values()));
  }
  async deleteCookies(cookies) {
    const networkAgent = this.target().networkAgent();
    this.#blockedCookies.clear();
    this.#cookieToBlockedReasons.clear();
    await Promise.all(cookies.map((cookie) => networkAgent.invoke_deleteCookies({
      name: cookie.name(),
      url: void 0,
      domain: cookie.domain(),
      path: cookie.path(),
      partitionKey: cookie.partitionKey()
    })));
    await this.#refreshThrottled();
  }
  #isRefreshing() {
    return Boolean(this.listeners?.size);
  }
  #isUpdated(newCookies) {
    if (newCookies.size !== this.#cookies.size) {
      return true;
    }
    for (const [domain, newDomainCookies] of newCookies) {
      if (!this.#cookies.has(domain)) {
        return true;
      }
      const oldDomainCookies = this.#cookies.get(domain) || [];
      if (newDomainCookies.length !== oldDomainCookies.length) {
        return true;
      }
      const comparisonKey = (c) => c.key() + " " + c.value();
      const oldDomainCookieKeys = new Set(oldDomainCookies.map(comparisonKey));
      for (const newCookie of newDomainCookies) {
        if (!oldDomainCookieKeys.has(comparisonKey(newCookie))) {
          return true;
        }
      }
    }
    return false;
  }
  #refreshThrottled() {
    return this.#refreshThrottler.schedule(() => this.#refresh());
  }
  #refresh() {
    const resourceURLs = new Platform17.MapUtilities.Multimap();
    function populateResourceURLs(resource) {
      const documentURL = Common25.ParsedURL.ParsedURL.fromString(resource.documentURL);
      if (documentURL) {
        resourceURLs.set(documentURL.securityOrigin(), resource.url);
      }
      return false;
    }
    const resourceTreeModel = this.target().model(ResourceTreeModel);
    if (resourceTreeModel) {
      const unreachableUrl = resourceTreeModel.mainFrame?.unreachableUrl();
      if (unreachableUrl) {
        const documentURL = Common25.ParsedURL.ParsedURL.fromString(unreachableUrl);
        if (documentURL) {
          resourceURLs.set(documentURL.securityOrigin(), unreachableUrl);
        }
      }
      resourceTreeModel.forAllResources(populateResourceURLs);
    }
    return this.#getCookies(resourceURLs);
  }
  #onResponseReceived() {
    if (this.#isRefreshing()) {
      void this.#refreshThrottled();
    }
  }
  #onLoadingFinished() {
    if (this.#isRefreshing()) {
      void this.#refreshThrottled();
    }
  }
};
SDKModel.register(CookieModel, { capabilities: 16, autostart: false });

// gen/front_end/core/sdk/CookieParser.js
var CookieParser_exports = {};
__export(CookieParser_exports, {
  CookieParser: () => CookieParser
});
var CookieParser = class _CookieParser {
  #domain;
  #cookies;
  #input;
  #originalInputLength;
  #lastCookie;
  #lastCookieLine;
  #lastCookiePosition;
  constructor(domain) {
    if (domain) {
      this.#domain = domain.toLowerCase().replace(/^\./, "");
    }
    this.#cookies = [];
    this.#originalInputLength = 0;
  }
  static parseSetCookie(header, domain) {
    return new _CookieParser(domain).parseSetCookie(header);
  }
  getCookieAttribute(header) {
    if (!header) {
      return null;
    }
    switch (header.toLowerCase()) {
      case "domain":
        return "domain";
      case "expires":
        return "expires";
      case "max-age":
        return "max-age";
      case "httponly":
        return "http-only";
      case "name":
        return "name";
      case "path":
        return "path";
      case "samesite":
        return "same-site";
      case "secure":
        return "secure";
      case "value":
        return "value";
      case "priority":
        return "priority";
      case "sourceport":
        return "source-port";
      case "sourcescheme":
        return "source-scheme";
      case "partitioned":
        return "partitioned";
      default:
        console.error("Failed getting cookie attribute: " + header);
        return null;
    }
  }
  cookies() {
    return this.#cookies;
  }
  parseSetCookie(setCookieHeader) {
    if (!this.initialize(setCookieHeader)) {
      return null;
    }
    for (let kv = this.extractKeyValue(); kv; kv = this.extractKeyValue()) {
      if (this.#lastCookie) {
        this.#lastCookie.addAttribute(this.getCookieAttribute(kv.key), kv.value);
      } else {
        this.addCookie(
          kv,
          1
          /* Type.RESPONSE */
        );
      }
      if (this.advanceAndCheckCookieDelimiter()) {
        this.flushCookie();
      }
    }
    this.flushCookie();
    return this.#cookies;
  }
  initialize(headerValue) {
    this.#input = headerValue;
    if (typeof headerValue !== "string") {
      return false;
    }
    this.#cookies = [];
    this.#lastCookie = null;
    this.#lastCookieLine = "";
    this.#originalInputLength = this.#input.length;
    return true;
  }
  flushCookie() {
    if (this.#lastCookie) {
      this.#lastCookie.setSize(this.#originalInputLength - this.#input.length - this.#lastCookiePosition);
      this.#lastCookie.setCookieLine(this.#lastCookieLine.replace("\n", ""));
    }
    this.#lastCookie = null;
    this.#lastCookieLine = "";
  }
  extractKeyValue() {
    if (!this.#input || !this.#input.length) {
      return null;
    }
    const keyValueMatch = /^[ \t]*([^=;\n]+)[ \t]*(?:=[ \t]*([^;\n]*))?/.exec(this.#input);
    if (!keyValueMatch) {
      console.error("Failed parsing cookie header before: " + this.#input);
      return null;
    }
    const result = new KeyValue(keyValueMatch[1]?.trim(), keyValueMatch[2]?.trim(), this.#originalInputLength - this.#input.length);
    this.#lastCookieLine += keyValueMatch[0];
    this.#input = this.#input.slice(keyValueMatch[0].length);
    return result;
  }
  advanceAndCheckCookieDelimiter() {
    if (!this.#input) {
      return false;
    }
    const match = /^\s*[\n;]\s*/.exec(this.#input);
    if (!match) {
      return false;
    }
    this.#lastCookieLine += match[0];
    this.#input = this.#input.slice(match[0].length);
    return match[0].match("\n") !== null;
  }
  addCookie(keyValue, type) {
    if (this.#lastCookie) {
      this.#lastCookie.setSize(keyValue.position - this.#lastCookiePosition);
    }
    this.#lastCookie = typeof keyValue.value === "string" ? new Cookie(keyValue.key, keyValue.value, type) : new Cookie("", keyValue.key, type);
    if (this.#domain) {
      this.#lastCookie.addAttribute("domain", this.#domain);
    }
    this.#lastCookiePosition = keyValue.position;
    this.#cookies.push(this.#lastCookie);
  }
};
var KeyValue = class {
  key;
  value;
  position;
  constructor(key, value, position) {
    this.key = key;
    this.value = value;
    this.position = position;
  }
};

// gen/front_end/core/sdk/HttpReasonPhraseStrings.js
import * as i18n17 from "./../i18n/i18n.js";
function getStatusText(statusCode) {
  const statusTextLookup = {
    100: "Continue",
    101: "Switching Protocols",
    102: "Processing",
    103: "Early Hints",
    200: "OK",
    201: "Created",
    202: "Accepted",
    203: "Non-Authoritative Information",
    204: "No Content",
    205: "Reset Content",
    206: "Partial Content",
    207: "Multi-Status",
    208: "Already Reported",
    226: "IM Used",
    300: "Multiple Choices",
    301: "Moved Permanently",
    302: "Found",
    303: "See Other",
    304: "Not Modified",
    305: "Use Proxy",
    307: "Temporary Redirect",
    308: "Permanent Redirect",
    400: "Bad Request",
    401: "Unauthorized",
    402: "Payment Required",
    403: "Forbidden",
    404: "Not Found",
    405: "Method Not Allowed",
    406: "Not Acceptable",
    407: "Proxy Authentication Required",
    408: "Request Timeout",
    409: "Conflict",
    410: "Gone",
    411: "Length Required",
    412: "Precondition Failed",
    413: "Content Too Large",
    414: "URI Too Long",
    415: "Unsupported Media Type",
    416: "Range Not Satisfiable",
    417: "Expectation Failed",
    418: "I'm a teapot",
    421: "Misdirected Request",
    422: "Unprocessable Content",
    423: "Locked",
    424: "Failed Dependency",
    425: "Too Early",
    426: "Upgrade Required",
    428: "Precondition Required",
    429: "Too Many Requests",
    431: "Request Header Fields Too Large",
    451: "Unavailable For Legal Reasons",
    500: "Internal Server Error",
    501: "Not Implemented",
    502: "Bad Gateway",
    503: "Service Unavailable",
    504: "Gateway Timeout",
    505: "HTTP Version Not Supported",
    506: "Variant Also Negotiates",
    507: "Insufficient Storage",
    508: "Loop Detected",
    510: "Not Extended",
    511: "Network Authentication Required"
  };
  return i18n17.i18n.lockedString(statusTextLookup[statusCode] ?? "");
}

// gen/front_end/core/sdk/ServerSentEvents.js
import * as TextUtils22 from "./../../models/text_utils/text_utils.js";

// gen/front_end/core/sdk/ServerSentEventsProtocol.js
var ServerSentEventsProtocol_exports = {};
__export(ServerSentEventsProtocol_exports, {
  ServerSentEventsParser: () => ServerSentEventsParser
});
var ServerSentEventsParser = class {
  #onEventCallback;
  #decoder;
  // Parser state.
  #isRecognizingCrLf = false;
  #line = "";
  #id = "";
  #data = "";
  #eventType = "";
  constructor(callback, encodingLabel) {
    this.#onEventCallback = callback;
    this.#decoder = new Base64TextDecoder(this.#onTextChunk.bind(this), encodingLabel);
  }
  async addBase64Chunk(raw) {
    await this.#decoder.addBase64Chunk(raw);
  }
  #onTextChunk(chunk) {
    let start = 0;
    for (let i = 0; i < chunk.length; ++i) {
      if (this.#isRecognizingCrLf && chunk[i] === "\n") {
        this.#isRecognizingCrLf = false;
        ++start;
        continue;
      }
      this.#isRecognizingCrLf = false;
      if (chunk[i] === "\r" || chunk[i] === "\n") {
        this.#line += chunk.substring(start, i);
        this.#parseLine();
        this.#line = "";
        start = i + 1;
        this.#isRecognizingCrLf = chunk[i] === "\r";
      }
    }
    this.#line += chunk.substring(start);
  }
  #parseLine() {
    if (this.#line.length === 0) {
      if (this.#data.length > 0) {
        const data = this.#data.slice(0, -1);
        this.#onEventCallback(this.#eventType || "message", data, this.#id);
        this.#data = "";
      }
      this.#eventType = "";
      return;
    }
    let fieldNameEnd = this.#line.indexOf(":");
    let fieldValueStart;
    if (fieldNameEnd < 0) {
      fieldNameEnd = this.#line.length;
      fieldValueStart = fieldNameEnd;
    } else {
      fieldValueStart = fieldNameEnd + 1;
      if (fieldValueStart < this.#line.length && this.#line[fieldValueStart] === " ") {
        ++fieldValueStart;
      }
    }
    const fieldName = this.#line.substring(0, fieldNameEnd);
    if (fieldName === "event") {
      this.#eventType = this.#line.substring(fieldValueStart);
      return;
    }
    if (fieldName === "data") {
      this.#data += this.#line.substring(fieldValueStart);
      this.#data += "\n";
    }
    if (fieldName === "id") {
      this.#id = this.#line.substring(fieldValueStart);
    }
  }
};
var Base64TextDecoder = class {
  #decoder;
  #writer;
  constructor(onTextChunk, encodingLabel) {
    this.#decoder = new TextDecoderStream(encodingLabel);
    this.#writer = this.#decoder.writable.getWriter();
    void this.#decoder.readable.pipeTo(new WritableStream({ write: onTextChunk }));
  }
  async addBase64Chunk(chunk) {
    const binString = window.atob(chunk);
    const bytes = Uint8Array.from(binString, (m) => m.codePointAt(0));
    await this.#writer.ready;
    await this.#writer.write(bytes);
  }
};

// gen/front_end/core/sdk/ServerSentEvents.js
var ServerSentEvents = class {
  #request;
  #parser;
  // In the case where we parse the events ourselves we use the time of the last 'dataReceived'
  // event for all the events that come out of the corresponding chunk of data.
  #lastDataReceivedTime = 0;
  #eventSourceMessages = [];
  constructor(request, parseFromStreamedData) {
    this.#request = request;
    if (parseFromStreamedData) {
      this.#lastDataReceivedTime = request.pseudoWallTime(request.startTime);
      this.#parser = new ServerSentEventsParser(this.#onParserEvent.bind(this), request.charset() ?? void 0);
      void this.#request.requestStreamingContent().then((streamingContentData) => {
        if (!TextUtils22.StreamingContentData.isError(streamingContentData)) {
          void this.#parser?.addBase64Chunk(streamingContentData.content().base64);
          streamingContentData.addEventListener("ChunkAdded", ({ data: { chunk } }) => {
            this.#lastDataReceivedTime = request.pseudoWallTime(request.endTime);
            void this.#parser?.addBase64Chunk(chunk);
          });
        }
      });
    }
  }
  get eventSourceMessages() {
    return this.#eventSourceMessages;
  }
  /** Forwarded Network.eventSourceMessage received */
  onProtocolEventSourceMessageReceived(eventName, data, eventId, time) {
    this.#recordMessageAndDispatchEvent({
      eventName,
      eventId,
      data,
      time
    });
  }
  #onParserEvent(eventName, data, eventId) {
    this.#recordMessageAndDispatchEvent({
      eventName,
      eventId,
      data,
      time: this.#lastDataReceivedTime
    });
  }
  #recordMessageAndDispatchEvent(message) {
    this.#eventSourceMessages.push(message);
    this.#request.dispatchEventToListeners(Events.EVENT_SOURCE_MESSAGE_ADDED, message);
  }
};

// gen/front_end/core/sdk/ServerTiming.js
var ServerTiming_exports = {};
__export(ServerTiming_exports, {
  ServerTiming: () => ServerTiming,
  cloudflarePrefix: () => cloudflarePrefix,
  cloudinaryPrefix: () => cloudinaryPrefix
});
import * as Common26 from "./../common/common.js";
import * as i18n19 from "./../i18n/i18n.js";
var UIStrings8 = {
  /**
   * @description Text in Server Timing
   * @example {sql-lookup} PH1
   */
  deprecatedSyntaxFoundPleaseUse: 'Deprecated syntax found for metric "{PH1}". Please use: <name>;dur=<duration>;desc=<description>',
  /**
   * @description Text in Server Timing
   * @example {https} PH1
   */
  duplicateParameterSIgnored: 'Duplicate parameter "{PH1}" ignored.',
  /**
   * @description Text in Server Timing
   * @example {https} PH1
   */
  noValueFoundForParameterS: 'No value found for parameter "{PH1}".',
  /**
   * @description Text in Server Timing
   * @example {https} PH1
   */
  unrecognizedParameterS: 'Unrecognized parameter "{PH1}".',
  /**
   * @description Text in Server Timing
   */
  extraneousTrailingCharacters: "Extraneous trailing characters.",
  /**
   * @description Text in Server Timing
   * @example {https} PH1
   * @example {2.0} PH2
   */
  unableToParseSValueS: 'Unable to parse "{PH1}" value "{PH2}".'
};
var str_8 = i18n19.i18n.registerUIStrings("core/sdk/ServerTiming.ts", UIStrings8);
var i18nString8 = i18n19.i18n.getLocalizedString.bind(void 0, str_8);
var cloudflarePrefix = "(cf) ";
var cloudinaryPrefix = "(cld) ";
var ServerTiming = class _ServerTiming {
  metric;
  value;
  description;
  constructor(metric, value, description) {
    this.metric = metric;
    this.value = value;
    this.description = description;
  }
  static parseHeaders(headers) {
    const rawServerTimingHeaders = headers.filter((item) => item.name.toLowerCase() === "server-timing");
    if (!rawServerTimingHeaders.length) {
      return null;
    }
    const serverTimings = rawServerTimingHeaders.reduce((timings, header) => {
      const timing = this.createFromHeaderValue(header.value);
      timings.push(...timing.map(function(entry) {
        return new _ServerTiming(entry.name, entry.dur ?? null, entry.desc ?? "");
      }));
      return timings;
    }, []);
    return serverTimings;
  }
  static createFromHeaderValue(valueString) {
    function trimLeadingWhiteSpace() {
      valueString = valueString.replace(/^\s*/, "");
    }
    function consumeDelimiter(char) {
      console.assert(char.length === 1);
      trimLeadingWhiteSpace();
      if (valueString.charAt(0) !== char) {
        return false;
      }
      valueString = valueString.substring(1);
      return true;
    }
    function consumeToken() {
      const result2 = /^(?:\s*)([\w!#$%&'*+\-.^`|~]+)(?:\s*)(.*)/.exec(valueString);
      if (!result2) {
        return null;
      }
      valueString = result2[2];
      return result2[1];
    }
    function consumeTokenOrQuotedString() {
      trimLeadingWhiteSpace();
      if (valueString.charAt(0) === '"') {
        return consumeQuotedString();
      }
      return consumeToken();
    }
    function consumeQuotedString() {
      console.assert(valueString.charAt(0) === '"');
      valueString = valueString.substring(1);
      let value = "";
      while (valueString.length) {
        const result2 = /^([^"\\]*)(.*)/.exec(valueString);
        if (!result2) {
          return null;
        }
        value += result2[1];
        if (result2[2].charAt(0) === '"') {
          valueString = result2[2].substring(1);
          return value;
        }
        console.assert(result2[2].charAt(0) === "\\");
        value += result2[2].charAt(1);
        valueString = result2[2].substring(2);
      }
      return null;
    }
    function consumeExtraneous() {
      const result2 = /([,;].*)/.exec(valueString);
      if (result2) {
        valueString = result2[1];
      }
    }
    const result = [];
    let name;
    while ((name = consumeToken()) !== null) {
      const entry = { name };
      if (valueString.charAt(0) === "=") {
        this.showWarning(i18nString8(UIStrings8.deprecatedSyntaxFoundPleaseUse, { PH1: name }));
      }
      while (consumeDelimiter(";")) {
        let paramName;
        if ((paramName = consumeToken()) === null) {
          continue;
        }
        paramName = paramName.toLowerCase();
        const parseParameter = this.getParserForParameter(paramName);
        let paramValue = null;
        if (consumeDelimiter("=")) {
          paramValue = consumeTokenOrQuotedString();
          consumeExtraneous();
        }
        if (parseParameter) {
          if (entry.hasOwnProperty(paramName)) {
            this.showWarning(i18nString8(UIStrings8.duplicateParameterSIgnored, { PH1: paramName }));
            continue;
          }
          if (paramValue === null) {
            this.showWarning(i18nString8(UIStrings8.noValueFoundForParameterS, { PH1: paramName }));
          }
          parseParameter.call(this, entry, paramValue);
        } else {
          this.showWarning(i18nString8(UIStrings8.unrecognizedParameterS, { PH1: paramName }));
        }
      }
      result.push(entry);
      if (entry.name === "cfL4" && entry.desc) {
        new URLSearchParams(entry.desc).entries().forEach(([key, val]) => {
          result.push({ name: `${cloudflarePrefix}${key}`, desc: val });
        });
      }
      if (entry.name === "content-info" && entry.desc) {
        new URLSearchParams(entry.desc.replace(/,/g, "&")).entries().forEach(([key, val]) => {
          result.push({ name: `${cloudinaryPrefix}${key}`, desc: val });
        });
      }
      if (!consumeDelimiter(",")) {
        break;
      }
    }
    if (valueString.length) {
      this.showWarning(i18nString8(UIStrings8.extraneousTrailingCharacters));
    }
    return result;
  }
  static getParserForParameter(paramName) {
    switch (paramName) {
      case "dur": {
        let durParser = function(entry, paramValue) {
          entry.dur = 0;
          if (paramValue !== null) {
            const duration = parseFloat(paramValue);
            if (isNaN(duration)) {
              _ServerTiming.showWarning(i18nString8(UIStrings8.unableToParseSValueS, { PH1: paramName, PH2: paramValue }));
              return;
            }
            entry.dur = duration;
          }
        };
        return durParser;
      }
      case "desc": {
        let descParser = function(entry, paramValue) {
          entry.desc = paramValue || "";
        };
        return descParser;
      }
      default: {
        return null;
      }
    }
  }
  static showWarning(msg) {
    Common26.Console.Console.instance().warn(`ServerTiming: ${msg}`);
  }
};

// gen/front_end/core/sdk/NetworkRequest.js
var UIStrings9 = {
  /**
   * @description Text in Network Request
   */
  binary: "(binary)",
  /**
   * @description Tooltip to explain why a cookie was blocked
   */
  secureOnly: 'This cookie was blocked because it had the "`Secure`" attribute and the connection was not secure.',
  /**
   * @description Tooltip to explain why a cookie was blocked
   */
  notOnPath: "This cookie was blocked because its path was not an exact match for or a superdirectory of the request url's path.",
  /**
   * @description Tooltip to explain why a cookie was blocked
   */
  domainMismatch: "This cookie was blocked because neither did the request URL's domain exactly match the cookie's domain, nor was the request URL's domain a subdomain of the cookie's Domain attribute value.",
  /**
   * @description Tooltip to explain why a cookie was blocked
   */
  sameSiteStrict: 'This cookie was blocked because it had the "`SameSite=Strict`" attribute and the request was made from a different site. This includes top-level navigation requests initiated by other sites.',
  /**
   * @description Tooltip to explain why a cookie was blocked
   */
  sameSiteLax: 'This cookie was blocked because it had the "`SameSite=Lax`" attribute and the request was made from a different site and was not initiated by a top-level navigation.',
  /**
   * @description Tooltip to explain why a cookie was blocked
   */
  sameSiteUnspecifiedTreatedAsLax: 'This cookie didn\'t specify a "`SameSite`" attribute when it was stored and was defaulted to "SameSite=Lax," and was blocked because the request was made from a different site and was not initiated by a top-level navigation. The cookie had to have been set with "`SameSite=None`" to enable cross-site usage.',
  /**
   * @description Tooltip to explain why a cookie was blocked
   */
  sameSiteNoneInsecure: 'This cookie was blocked because it had the "`SameSite=None`" attribute but was not marked "Secure". Cookies without SameSite restrictions must be marked "Secure" and sent over a secure connection.',
  /**
   * @description Tooltip to explain why a cookie was blocked
   */
  userPreferences: "This cookie was blocked due to user preferences.",
  /**
   * @description Tooltip to explain why a cookie was blocked
   */
  thirdPartyPhaseout: "This cookie was blocked either because of Chrome flags or browser configuration. Learn more in the Issues panel.",
  /**
   * @description Tooltip to explain why a cookie was blocked
   */
  unknownError: "An unknown error was encountered when trying to send this cookie.",
  /**
   * @description Tooltip to explain why a cookie was blocked due to Schemeful Same-Site
   */
  schemefulSameSiteStrict: 'This cookie was blocked because it had the "`SameSite=Strict`" attribute but the request was cross-site. This includes top-level navigation requests initiated by other sites. This request is considered cross-site because the URL has a different scheme than the current site.',
  /**
   * @description Tooltip to explain why a cookie was blocked due to Schemeful Same-Site
   */
  schemefulSameSiteLax: 'This cookie was blocked because it had the "`SameSite=Lax`" attribute but the request was cross-site and was not initiated by a top-level navigation. This request is considered cross-site because the URL has a different scheme than the current site.',
  /**
   * @description Tooltip to explain why a cookie was blocked due to Schemeful Same-Site
   */
  schemefulSameSiteUnspecifiedTreatedAsLax: 'This cookie didn\'t specify a "`SameSite`" attribute when it was stored, was defaulted to "`SameSite=Lax"`, and was blocked because the request was cross-site and was not initiated by a top-level navigation. This request is considered cross-site because the URL has a different scheme than the current site.',
  /**
   * @description Tooltip to explain why a cookie was blocked due to SameParty
   */
  samePartyFromCrossPartyContext: "This cookie was blocked because it had the \"`SameParty`\" attribute but the request was cross-party. The request was considered cross-party because the domain of the resource's URL and the domains of the resource's enclosing frames/documents are neither owners nor members in the same First-Party Set.",
  /**
   * @description Tooltip to explain why a cookie was blocked due to exceeding the maximum size
   */
  nameValuePairExceedsMaxSize: "This cookie was blocked because it was too large. The combined size of the name and value must be less than or equal to 4096 characters.",
  /**
   * @description Tooltip to explain why an attempt to set a cookie via `Set-Cookie` HTTP header on a request's response was blocked.
   */
  thisSetcookieWasBlockedDueToUser: "This attempt to set a cookie via a `Set-Cookie` header was blocked due to user preferences.",
  /**
   * @description Tooltip to explain why an attempt to set a cookie via `Set-Cookie` HTTP header on a request's response was blocked.
   */
  thisSetcookieWasBlockedDueThirdPartyPhaseout: "Setting this cookie was blocked either because of Chrome flags or browser configuration. Learn more in the Issues panel.",
  /**
   * @description Tooltip to explain why an attempt to set a cookie via `Set-Cookie` HTTP header on a request's response was blocked.
   */
  thisSetcookieHadInvalidSyntax: "This `Set-Cookie` header had invalid syntax.",
  /**
   * @description Tooltip to explain why a cookie was blocked
   */
  thisSetcookieHadADisallowedCharacter: "This `Set-Cookie` header contained a disallowed character (a forbidden ASCII control character, or the tab character if it appears in the middle of the cookie name, value, an attribute name, or an attribute value).",
  /**
   * @description Tooltip to explain why a cookie was blocked
   */
  theSchemeOfThisConnectionIsNot: "The scheme of this connection is not allowed to store cookies.",
  /**
   * @description Tooltip to explain why a cookie was blocked
   */
  anUnknownErrorWasEncounteredWhenTrying: "An unknown error was encountered when trying to store this cookie.",
  /**
   * @description Tooltip to explain why a cookie was blocked due to Schemeful Same-Site
   * @example {SameSite=Strict} PH1
   */
  thisSetcookieWasBlockedBecauseItHadTheSamesiteStrictLax: 'This attempt to set a cookie via a `Set-Cookie` header was blocked because it had the "{PH1}" attribute but came from a cross-site response which was not the response to a top-level navigation. This response is considered cross-site because the URL has a different scheme than the current site.',
  /**
   * @description Tooltip to explain why a cookie was blocked due to Schemeful Same-Site
   */
  thisSetcookieDidntSpecifyASamesite: 'This `Set-Cookie` header didn\'t specify a "`SameSite`" attribute, was defaulted to "`SameSite=Lax"`, and was blocked because it came from a cross-site response which was not the response to a top-level navigation. This response is considered cross-site because the URL has a different scheme than the current site.',
  /**
   * @description Tooltip to explain why a cookie was blocked due to SameParty
   */
  thisSetcookieWasBlockedBecauseItHadTheSameparty: "This attempt to set a cookie via a `Set-Cookie` header was blocked because it had the \"`SameParty`\" attribute but the request was cross-party. The request was considered cross-party because the domain of the resource's URL and the domains of the resource's enclosing frames/documents are neither owners nor members in the same First-Party Set.",
  /**
   * @description Tooltip to explain why a cookie was blocked due to SameParty
   */
  thisSetcookieWasBlockedBecauseItHadTheSamepartyAttribute: 'This attempt to set a cookie via a `Set-Cookie` header was blocked because it had the "`SameParty`" attribute but also had other conflicting attributes. Chrome requires cookies that use the "`SameParty`" attribute to also have the "Secure" attribute, and to not be restricted to "`SameSite=Strict`".',
  /**
   * @description Tooltip to explain why an attempt to set a cookie via a `Set-Cookie` HTTP header on a request's response was blocked.
   */
  blockedReasonSecureOnly: 'This attempt to set a cookie via a `Set-Cookie` header was blocked because it had the "Secure" attribute but was not received over a secure connection.',
  /**
   * @description Tooltip to explain why an attempt to set a cookie via a `Set-Cookie` HTTP header on a request's response was blocked.
   * @example {SameSite=Strict} PH1
   */
  blockedReasonSameSiteStrictLax: 'This attempt to set a cookie via a `Set-Cookie` header was blocked because it had the "{PH1}" attribute but came from a cross-site response which was not the response to a top-level navigation.',
  /**
   * @description Tooltip to explain why an attempt to set a cookie via a `Set-Cookie` HTTP header on a request's response was blocked.
   */
  blockedReasonSameSiteUnspecifiedTreatedAsLax: 'This `Set-Cookie` header didn\'t specify a "`SameSite`" attribute and was defaulted to "`SameSite=Lax,`" and was blocked because it came from a cross-site response which was not the response to a top-level navigation. The `Set-Cookie` had to have been set with "`SameSite=None`" to enable cross-site usage.',
  /**
   * @description Tooltip to explain why an attempt to set a cookie via a `Set-Cookie` HTTP header on a request's response was blocked.
   */
  blockedReasonSameSiteNoneInsecure: 'This attempt to set a cookie via a `Set-Cookie` header was blocked because it had the "`SameSite=None`" attribute but did not have the "Secure" attribute, which is required in order to use "`SameSite=None`".',
  /**
   * @description Tooltip to explain why an attempt to set a cookie via a `Set-Cookie` HTTP header on a request's response was blocked.
   */
  blockedReasonOverwriteSecure: "This attempt to set a cookie via a `Set-Cookie` header was blocked because it was not sent over a secure connection and would have overwritten a cookie with the Secure attribute.",
  /**
   * @description Tooltip to explain why an attempt to set a cookie via a `Set-Cookie` HTTP header on a request's response was blocked.
   */
  blockedReasonInvalidDomain: "This attempt to set a cookie via a `Set-Cookie` header was blocked because its Domain attribute was invalid with regards to the current host url.",
  /**
   * @description Tooltip to explain why an attempt to set a cookie via a `Set-Cookie` HTTP header on a request's response was blocked.
   */
  blockedReasonInvalidPrefix: 'This attempt to set a cookie via a `Set-Cookie` header was blocked because it used the "`__Secure-`" or "`__Host-`" prefix in its name and broke the additional rules applied to cookies with these prefixes as defined in `https://tools.ietf.org/html/draft-west-cookie-prefixes-05`.',
  /**
   * @description Tooltip to explain why a cookie was blocked when the size of the #name plus the size of the value exceeds the max size.
   */
  thisSetcookieWasBlockedBecauseTheNameValuePairExceedsMaxSize: "This attempt to set a cookie via a `Set-Cookie` header was blocked because the cookie was too large. The combined size of the name and value must be less than or equal to 4096 characters.",
  /**
   * @description Text in Network Manager
   * @example {https://example.com} PH1
   */
  setcookieHeaderIsIgnoredIn: "Set-Cookie header is ignored in response from url: {PH1}. The combined size of the name and value must be less than or equal to 4096 characters.",
  /**
   * @description Tooltip to explain why the cookie should have been blocked by third-party cookie phaseout but is exempted.
   */
  exemptionReasonUserSetting: "This cookie is allowed by user preference.",
  /**
   * @description Tooltip to explain why the cookie should have been blocked by third-party cookie phaseout but is exempted.
   */
  exemptionReasonTPCDMetadata: "This cookie is allowed by a third-party cookie deprecation trial grace period. Learn more: goo.gle/dt-grace.",
  /**
   * @description Tooltip to explain why the cookie should have been blocked by third-party cookie phaseout but is exempted.
   */
  exemptionReasonTPCDDeprecationTrial: "This cookie is allowed by third-party cookie deprecation trial. Learn more: goo.gle/ps-dt.",
  /**
   * @description Tooltip to explain why the cookie should have been blocked by third-party cookie phaseout but is exempted.
   */
  exemptionReasonTopLevelTPCDDeprecationTrial: "This cookie is allowed by top-level third-party cookie deprecation trial. Learn more: goo.gle/ps-dt.",
  /**
   * @description Tooltip to explain why the cookie should have been blocked by third-party cookie phaseout but is exempted.
   */
  exemptionReasonTPCDHeuristics: "This cookie is allowed by third-party cookie heuristics. Learn more: goo.gle/hbe",
  /**
   * @description Tooltip to explain why the cookie should have been blocked by third-party cookie phaseout but is exempted.
   */
  exemptionReasonEnterprisePolicy: "This cookie is allowed by Chrome Enterprise policy. Learn more: goo.gle/ce-3pc",
  /**
   * @description Tooltip to explain why the cookie should have been blocked by third-party cookie phaseout but is exempted.
   */
  exemptionReasonStorageAccessAPI: "This cookie is allowed by the Storage Access API. Learn more: goo.gle/saa",
  /**
   * @description Tooltip to explain why the cookie should have been blocked by third-party cookie phaseout but is exempted.
   */
  exemptionReasonTopLevelStorageAccessAPI: "This cookie is allowed by the top-level Storage Access API. Learn more: goo.gle/saa-top",
  /**
   * @description Tooltip to explain why the cookie should have been blocked by third-party cookie phaseout but is exempted.
   */
  exemptionReasonScheme: "This cookie is allowed by the top-level url scheme"
};
var str_9 = i18n21.i18n.registerUIStrings("core/sdk/NetworkRequest.ts", UIStrings9);
var i18nString9 = i18n21.i18n.getLocalizedString.bind(void 0, str_9);
var NetworkRequest = class _NetworkRequest extends Common27.ObjectWrapper.ObjectWrapper {
  #requestId;
  #backendRequestId;
  #documentURL;
  #frameId;
  #loaderId;
  #hasUserGesture;
  #initiator;
  #redirectSource = null;
  #preflightRequest = null;
  #preflightInitiatorRequest = null;
  #isRedirect = false;
  #redirectDestination = null;
  #issueTime = -1;
  #startTime = -1;
  #endTime = -1;
  #blockedReason = void 0;
  #corsErrorStatus = void 0;
  statusCode = 0;
  statusText = "";
  requestMethod = "";
  requestTime = 0;
  protocol = "";
  alternateProtocolUsage = void 0;
  mixedContentType = "none";
  #initialPriority = null;
  #currentPriority = null;
  #signedExchangeInfo = null;
  #resourceType = Common27.ResourceType.resourceTypes.Other;
  #contentData = null;
  #streamingContentData = null;
  #frames = [];
  #responseHeaderValues = {};
  #responseHeadersText = "";
  #originalResponseHeaders = [];
  #sortedOriginalResponseHeaders;
  // This field is only used when intercepting and overriding requests, because
  // in that case 'this.responseHeaders' does not contain 'set-cookie' headers.
  #setCookieHeaders = [];
  #requestHeaders = [];
  #requestHeaderValues = {};
  #remoteAddress = "";
  #remoteAddressSpace = "Unknown";
  #referrerPolicy = null;
  #securityState = "unknown";
  #securityDetails = null;
  connectionId = "0";
  connectionReused = false;
  hasNetworkData = false;
  #formParametersPromise = null;
  #requestFormDataPromise = Promise.resolve(null);
  #hasExtraRequestInfo = false;
  #hasExtraResponseInfo = false;
  #blockedRequestCookies = [];
  #includedRequestCookies = [];
  #blockedResponseCookies = [];
  #exemptedResponseCookies = [];
  #responseCookiesPartitionKey = null;
  #responseCookiesPartitionKeyOpaque = null;
  #siteHasCookieInOtherPartition = false;
  localizedFailDescription = null;
  #url;
  #responseReceivedTime;
  #transferSize;
  #finished;
  #failed;
  #canceled;
  #preserved;
  #mimeType;
  #charset;
  #parsedURL;
  #name;
  #path;
  #clientSecurityState;
  #trustTokenParams;
  #trustTokenOperationDoneEvent;
  #responseCacheStorageCacheName;
  #serviceWorkerResponseSource;
  #wallIssueTime;
  #responseRetrievalTime;
  #resourceSize;
  #fromMemoryCache;
  #fromDiskCache;
  #fromPrefetchCache;
  #fromEarlyHints;
  #fetchedViaServiceWorker;
  #serviceWorkerRouterInfo;
  #timing;
  #requestHeadersText;
  #responseHeaders;
  #earlyHintsHeaders;
  #sortedResponseHeaders;
  #responseCookies;
  #serverTimings;
  #queryString;
  #parsedQueryParameters;
  #contentDataProvider;
  #isSameSite = null;
  #wasIntercepted = false;
  #associatedData = /* @__PURE__ */ new Map();
  #hasOverriddenContent = false;
  #hasThirdPartyCookiePhaseoutIssue = false;
  #serverSentEvents;
  responseReceivedPromise;
  responseReceivedPromiseResolve;
  directSocketInfo;
  #directSocketChunks = [];
  #isIpProtectionUsed;
  #isAdRelated;
  #appliedNetworkConditionsId;
  constructor(requestId, backendRequestId, url, documentURL, frameId, loaderId, initiator, hasUserGesture) {
    super();
    this.#requestId = requestId;
    this.#backendRequestId = backendRequestId;
    this.setUrl(url);
    this.#documentURL = documentURL;
    this.#frameId = frameId;
    this.#loaderId = loaderId;
    this.#initiator = initiator;
    this.#hasUserGesture = hasUserGesture;
    this.#isIpProtectionUsed = false;
    this.#isAdRelated = false;
  }
  static create(backendRequestId, url, documentURL, frameId, loaderId, initiator, hasUserGesture) {
    return new _NetworkRequest(backendRequestId, backendRequestId, url, documentURL, frameId, loaderId, initiator, hasUserGesture);
  }
  static createForSocket(backendRequestId, requestURL, initiator) {
    return new _NetworkRequest(backendRequestId, backendRequestId, requestURL, Platform18.DevToolsPath.EmptyUrlString, null, null, initiator || null);
  }
  static createWithoutBackendRequest(requestId, url, documentURL, initiator) {
    return new _NetworkRequest(requestId, void 0, url, documentURL, null, null, initiator);
  }
  identityCompare(other) {
    const thisId = this.requestId();
    const thatId = other.requestId();
    if (thisId > thatId) {
      return 1;
    }
    if (thisId < thatId) {
      return -1;
    }
    return 0;
  }
  requestId() {
    return this.#requestId;
  }
  backendRequestId() {
    return this.#backendRequestId;
  }
  url() {
    return this.#url;
  }
  isBlobRequest() {
    return Common27.ParsedURL.schemeIs(this.#url, "blob:");
  }
  setUrl(x) {
    if (this.#url === x) {
      return;
    }
    this.#url = x;
    this.#parsedURL = new Common27.ParsedURL.ParsedURL(x);
    this.#queryString = void 0;
    this.#parsedQueryParameters = void 0;
    this.#name = void 0;
    this.#path = void 0;
  }
  get documentURL() {
    return this.#documentURL;
  }
  get parsedURL() {
    return this.#parsedURL;
  }
  get frameId() {
    return this.#frameId;
  }
  get loaderId() {
    return this.#loaderId;
  }
  get appliedNetworkConditionsId() {
    return this.#appliedNetworkConditionsId;
  }
  setRemoteAddress(ip, port) {
    this.#remoteAddress = ip + ":" + port;
    this.dispatchEventToListeners(Events.REMOTE_ADDRESS_CHANGED, this);
  }
  remoteAddress() {
    return this.#remoteAddress;
  }
  remoteAddressSpace() {
    return this.#remoteAddressSpace;
  }
  /**
   * The cache #name of the CacheStorage from where the response is served via
   * the ServiceWorker.
   */
  getResponseCacheStorageCacheName() {
    return this.#responseCacheStorageCacheName;
  }
  setResponseCacheStorageCacheName(x) {
    this.#responseCacheStorageCacheName = x;
  }
  serviceWorkerResponseSource() {
    return this.#serviceWorkerResponseSource;
  }
  setServiceWorkerResponseSource(serviceWorkerResponseSource) {
    this.#serviceWorkerResponseSource = serviceWorkerResponseSource;
  }
  setReferrerPolicy(referrerPolicy) {
    this.#referrerPolicy = referrerPolicy;
  }
  referrerPolicy() {
    return this.#referrerPolicy;
  }
  securityState() {
    return this.#securityState;
  }
  setSecurityState(securityState) {
    this.#securityState = securityState;
  }
  securityDetails() {
    return this.#securityDetails;
  }
  securityOrigin() {
    return this.#parsedURL.securityOrigin();
  }
  setSecurityDetails(securityDetails) {
    this.#securityDetails = securityDetails;
  }
  get startTime() {
    return this.#startTime || -1;
  }
  setIssueTime(monotonicTime, wallTime) {
    this.#issueTime = monotonicTime;
    this.#wallIssueTime = wallTime;
    this.#startTime = monotonicTime;
  }
  issueTime() {
    return this.#issueTime;
  }
  pseudoWallTime(monotonicTime) {
    return this.#wallIssueTime ? this.#wallIssueTime - this.#issueTime + monotonicTime : monotonicTime;
  }
  get responseReceivedTime() {
    return this.#responseReceivedTime || -1;
  }
  set responseReceivedTime(x) {
    this.#responseReceivedTime = x;
  }
  /**
   * The time at which the returned response was generated. For cached
   * responses, this is the last time the cache entry was validated.
   */
  getResponseRetrievalTime() {
    return this.#responseRetrievalTime;
  }
  setResponseRetrievalTime(x) {
    this.#responseRetrievalTime = x;
  }
  get endTime() {
    return this.#endTime || -1;
  }
  set endTime(x) {
    if (this.timing?.requestTime) {
      this.#endTime = Math.max(x, this.responseReceivedTime);
    } else {
      this.#endTime = x;
      if (this.#responseReceivedTime > x) {
        this.#responseReceivedTime = x;
      }
    }
    this.dispatchEventToListeners(Events.TIMING_CHANGED, this);
  }
  get duration() {
    if (this.#endTime === -1 || this.#startTime === -1) {
      return -1;
    }
    return this.#endTime - this.#startTime;
  }
  get latency() {
    if (this.#responseReceivedTime === -1 || this.#startTime === -1) {
      return -1;
    }
    return this.#responseReceivedTime - this.#startTime;
  }
  get resourceSize() {
    return this.#resourceSize || 0;
  }
  set resourceSize(x) {
    this.#resourceSize = x;
  }
  get transferSize() {
    return this.#transferSize || 0;
  }
  increaseTransferSize(x) {
    this.#transferSize = (this.#transferSize || 0) + x;
  }
  setTransferSize(x) {
    this.#transferSize = x;
  }
  get finished() {
    return this.#finished;
  }
  set finished(x) {
    if (this.#finished === x) {
      return;
    }
    this.#finished = x;
    if (x) {
      this.dispatchEventToListeners(Events.FINISHED_LOADING, this);
    }
  }
  get failed() {
    return this.#failed;
  }
  set failed(x) {
    this.#failed = x;
  }
  get canceled() {
    return this.#canceled;
  }
  set canceled(x) {
    this.#canceled = x;
  }
  get preserved() {
    return this.#preserved;
  }
  set preserved(x) {
    this.#preserved = x;
  }
  blockedReason() {
    return this.#blockedReason;
  }
  setBlockedReason(reason) {
    this.#blockedReason = reason;
  }
  corsErrorStatus() {
    return this.#corsErrorStatus;
  }
  setCorsErrorStatus(corsErrorStatus) {
    this.#corsErrorStatus = corsErrorStatus;
  }
  wasBlocked() {
    return Boolean(this.#blockedReason);
  }
  cached() {
    return (Boolean(this.#fromMemoryCache) || Boolean(this.#fromDiskCache)) && !this.#transferSize;
  }
  cachedInMemory() {
    return Boolean(this.#fromMemoryCache) && !this.#transferSize;
  }
  fromPrefetchCache() {
    return Boolean(this.#fromPrefetchCache);
  }
  setFromMemoryCache() {
    this.#fromMemoryCache = true;
    this.#timing = void 0;
  }
  get fromDiskCache() {
    return this.#fromDiskCache;
  }
  setFromDiskCache() {
    this.#fromDiskCache = true;
  }
  setFromPrefetchCache() {
    this.#fromPrefetchCache = true;
  }
  fromEarlyHints() {
    return Boolean(this.#fromEarlyHints);
  }
  setFromEarlyHints() {
    this.#fromEarlyHints = true;
  }
  /**
   * Returns true if the request was intercepted by a service worker and it
   * provided its own response.
   */
  get fetchedViaServiceWorker() {
    return Boolean(this.#fetchedViaServiceWorker);
  }
  set fetchedViaServiceWorker(x) {
    this.#fetchedViaServiceWorker = x;
  }
  get serviceWorkerRouterInfo() {
    return this.#serviceWorkerRouterInfo;
  }
  set serviceWorkerRouterInfo(x) {
    this.#serviceWorkerRouterInfo = x;
  }
  /**
   * Returns true if the request was matched to a route when using the
   * ServiceWorker static routing API.
   */
  hasMatchingServiceWorkerRouter() {
    return this.#serviceWorkerRouterInfo !== void 0 && this.serviceWorkerRouterInfo?.matchedSourceType !== void 0;
  }
  /**
   * Returns true if the request was sent by a service worker.
   */
  initiatedByServiceWorker() {
    const networkManager = NetworkManager.forRequest(this);
    if (!networkManager) {
      return false;
    }
    return networkManager.target().type() === Type.ServiceWorker;
  }
  get timing() {
    return this.#timing;
  }
  set timing(timingInfo) {
    if (!timingInfo || this.#fromMemoryCache) {
      return;
    }
    this.#startTime = timingInfo.requestTime;
    const headersReceivedTime = timingInfo.requestTime + timingInfo.receiveHeadersEnd / 1e3;
    if ((this.#responseReceivedTime || -1) < 0 || this.#responseReceivedTime > headersReceivedTime) {
      this.#responseReceivedTime = headersReceivedTime;
    }
    if (this.#startTime > this.#responseReceivedTime) {
      this.#responseReceivedTime = this.#startTime;
    }
    this.#timing = timingInfo;
    this.dispatchEventToListeners(Events.TIMING_CHANGED, this);
  }
  setConnectTimingFromExtraInfo(connectTiming) {
    this.#startTime = connectTiming.requestTime;
    this.dispatchEventToListeners(Events.TIMING_CHANGED, this);
  }
  get mimeType() {
    return this.#mimeType;
  }
  set mimeType(x) {
    this.#mimeType = x;
    if (x === "text/event-stream" && !this.#serverSentEvents) {
      const parseFromStreamedData = this.resourceType() !== Common27.ResourceType.resourceTypes.EventSource;
      this.#serverSentEvents = new ServerSentEvents(this, parseFromStreamedData);
    }
  }
  get displayName() {
    return this.#parsedURL.displayName;
  }
  name() {
    if (this.#name) {
      return this.#name;
    }
    this.parseNameAndPathFromURL();
    return this.#name;
  }
  path() {
    if (this.#path) {
      return this.#path;
    }
    this.parseNameAndPathFromURL();
    return this.#path;
  }
  parseNameAndPathFromURL() {
    if (this.#parsedURL.isDataURL()) {
      this.#name = this.#parsedURL.dataURLDisplayName();
      this.#path = "";
    } else if (this.#parsedURL.isBlobURL()) {
      this.#name = this.#parsedURL.url;
      this.#path = "";
    } else if (this.#parsedURL.isAboutBlank()) {
      this.#name = this.#parsedURL.url;
      this.#path = "";
    } else {
      this.#path = this.#parsedURL.host + this.#parsedURL.folderPathComponents;
      const networkManager = NetworkManager.forRequest(this);
      const inspectedURL = networkManager ? Common27.ParsedURL.ParsedURL.fromString(networkManager.target().inspectedURL()) : null;
      this.#path = Platform18.StringUtilities.trimURL(this.#path, inspectedURL ? inspectedURL.host : "");
      if (this.#parsedURL.lastPathComponent || this.#parsedURL.queryParams) {
        this.#name = this.#parsedURL.lastPathComponent + (this.#parsedURL.queryParams ? "?" + this.#parsedURL.queryParams : "");
      } else if (this.#parsedURL.folderPathComponents) {
        this.#name = this.#parsedURL.folderPathComponents.substring(this.#parsedURL.folderPathComponents.lastIndexOf("/") + 1) + "/";
        this.#path = this.#path.substring(0, this.#path.lastIndexOf("/"));
      } else {
        this.#name = this.#parsedURL.host;
        this.#path = "";
      }
    }
  }
  get folder() {
    let path = this.#parsedURL.path;
    const indexOfQuery = path.indexOf("?");
    if (indexOfQuery !== -1) {
      path = path.substring(0, indexOfQuery);
    }
    const lastSlashIndex = path.lastIndexOf("/");
    return lastSlashIndex !== -1 ? path.substring(0, lastSlashIndex) : "";
  }
  get pathname() {
    return this.#parsedURL.path;
  }
  resourceType() {
    return this.#resourceType;
  }
  setResourceType(resourceType) {
    this.#resourceType = resourceType;
  }
  get domain() {
    return this.#parsedURL.host;
  }
  get scheme() {
    return this.#parsedURL.scheme;
  }
  getInferredStatusText() {
    return this.statusText || getStatusText(this.statusCode);
  }
  redirectSource() {
    return this.#redirectSource;
  }
  setRedirectSource(originatingRequest) {
    this.#redirectSource = originatingRequest;
  }
  preflightRequest() {
    return this.#preflightRequest;
  }
  setPreflightRequest(preflightRequest) {
    this.#preflightRequest = preflightRequest;
  }
  preflightInitiatorRequest() {
    return this.#preflightInitiatorRequest;
  }
  setPreflightInitiatorRequest(preflightInitiatorRequest) {
    this.#preflightInitiatorRequest = preflightInitiatorRequest;
  }
  isPreflightRequest() {
    return this.#initiator !== null && this.#initiator !== void 0 && this.#initiator.type === "preflight";
  }
  redirectDestination() {
    return this.#redirectDestination;
  }
  setRedirectDestination(redirectDestination) {
    this.#redirectDestination = redirectDestination;
  }
  requestHeaders() {
    return this.#requestHeaders;
  }
  setRequestHeaders(headers) {
    this.#requestHeaders = headers;
    this.dispatchEventToListeners(Events.REQUEST_HEADERS_CHANGED);
  }
  requestHeadersText() {
    return this.#requestHeadersText;
  }
  setRequestHeadersText(text) {
    this.#requestHeadersText = text;
    this.dispatchEventToListeners(Events.REQUEST_HEADERS_CHANGED);
  }
  requestHeaderValue(headerName) {
    if (this.#requestHeaderValues[headerName]) {
      return this.#requestHeaderValues[headerName];
    }
    this.#requestHeaderValues[headerName] = this.computeHeaderValue(this.requestHeaders(), headerName);
    return this.#requestHeaderValues[headerName];
  }
  requestFormData() {
    if (!this.#requestFormDataPromise) {
      this.#requestFormDataPromise = NetworkManager.requestPostData(this);
    }
    return this.#requestFormDataPromise;
  }
  setRequestFormData(hasData, data) {
    this.#requestFormDataPromise = hasData && data === null ? null : Promise.resolve(data);
    this.#formParametersPromise = null;
  }
  filteredProtocolName() {
    const protocol = this.protocol.toLowerCase();
    if (protocol === "h2") {
      return "http/2.0";
    }
    return protocol.replace(/^http\/2(\.0)?\+/, "http/2.0+");
  }
  requestHttpVersion() {
    const headersText = this.requestHeadersText();
    if (!headersText) {
      const version = this.requestHeaderValue("version") || this.requestHeaderValue(":version");
      if (version) {
        return version;
      }
      return this.filteredProtocolName();
    }
    const firstLine = headersText.split(/\r\n/)[0];
    const match = firstLine.match(/(HTTP\/\d+\.\d+)$/);
    return match ? match[1] : "HTTP/0.9";
  }
  get responseHeaders() {
    return this.#responseHeaders || [];
  }
  set responseHeaders(x) {
    this.#responseHeaders = x;
    this.#sortedResponseHeaders = void 0;
    this.#serverTimings = void 0;
    this.#responseCookies = void 0;
    this.#responseHeaderValues = {};
    this.dispatchEventToListeners(Events.RESPONSE_HEADERS_CHANGED);
  }
  get earlyHintsHeaders() {
    return this.#earlyHintsHeaders || [];
  }
  set earlyHintsHeaders(x) {
    this.#earlyHintsHeaders = x;
  }
  get originalResponseHeaders() {
    return this.#originalResponseHeaders;
  }
  set originalResponseHeaders(headers) {
    this.#originalResponseHeaders = headers;
    this.#sortedOriginalResponseHeaders = void 0;
  }
  get setCookieHeaders() {
    return this.#setCookieHeaders;
  }
  set setCookieHeaders(headers) {
    this.#setCookieHeaders = headers;
  }
  get responseHeadersText() {
    return this.#responseHeadersText;
  }
  set responseHeadersText(x) {
    this.#responseHeadersText = x;
    this.dispatchEventToListeners(Events.RESPONSE_HEADERS_CHANGED);
  }
  get sortedResponseHeaders() {
    if (this.#sortedResponseHeaders !== void 0) {
      return this.#sortedResponseHeaders;
    }
    this.#sortedResponseHeaders = this.responseHeaders.slice();
    return this.#sortedResponseHeaders.sort(function(a, b) {
      return Platform18.StringUtilities.compare(a.name.toLowerCase(), b.name.toLowerCase());
    });
  }
  get sortedOriginalResponseHeaders() {
    if (this.#sortedOriginalResponseHeaders !== void 0) {
      return this.#sortedOriginalResponseHeaders;
    }
    this.#sortedOriginalResponseHeaders = this.originalResponseHeaders.slice();
    return this.#sortedOriginalResponseHeaders.sort(function(a, b) {
      return Platform18.StringUtilities.compare(a.name.toLowerCase(), b.name.toLowerCase());
    });
  }
  get overrideTypes() {
    const types = [];
    if (this.hasOverriddenContent) {
      types.push("content");
    }
    if (this.hasOverriddenHeaders()) {
      types.push("headers");
    }
    return types;
  }
  get hasOverriddenContent() {
    return this.#hasOverriddenContent;
  }
  set hasOverriddenContent(value) {
    this.#hasOverriddenContent = value;
  }
  #deduplicateHeaders(sortedHeaders) {
    const dedupedHeaders = [];
    for (const header of sortedHeaders) {
      if (dedupedHeaders.length && dedupedHeaders[dedupedHeaders.length - 1].name === header.name) {
        dedupedHeaders[dedupedHeaders.length - 1].value += `, ${header.value}`;
      } else {
        dedupedHeaders.push({ name: header.name, value: header.value });
      }
    }
    return dedupedHeaders;
  }
  hasOverriddenHeaders() {
    if (!this.#originalResponseHeaders.length) {
      return false;
    }
    const responseHeaders = this.#deduplicateHeaders(this.sortedResponseHeaders);
    const originalResponseHeaders = this.#deduplicateHeaders(this.sortedOriginalResponseHeaders);
    if (responseHeaders.length !== originalResponseHeaders.length) {
      return true;
    }
    for (let i = 0; i < responseHeaders.length; i++) {
      if (responseHeaders[i].name.toLowerCase() !== originalResponseHeaders[i].name.toLowerCase()) {
        return true;
      }
      if (responseHeaders[i].value !== originalResponseHeaders[i].value) {
        return true;
      }
    }
    return false;
  }
  responseHeaderValue(headerName) {
    if (headerName in this.#responseHeaderValues) {
      return this.#responseHeaderValues[headerName];
    }
    this.#responseHeaderValues[headerName] = this.computeHeaderValue(this.responseHeaders, headerName);
    return this.#responseHeaderValues[headerName];
  }
  wasIntercepted() {
    return this.#wasIntercepted;
  }
  setWasIntercepted(wasIntercepted) {
    this.#wasIntercepted = wasIntercepted;
  }
  setEarlyHintsHeaders(headers) {
    this.earlyHintsHeaders = headers;
  }
  get responseCookies() {
    if (!this.#responseCookies) {
      this.#responseCookies = CookieParser.parseSetCookie(this.responseHeaderValue("Set-Cookie"), this.domain) || [];
      if (this.#responseCookiesPartitionKey) {
        for (const cookie of this.#responseCookies) {
          if (cookie.partitioned()) {
            cookie.setPartitionKey(this.#responseCookiesPartitionKey.topLevelSite, this.#responseCookiesPartitionKey.hasCrossSiteAncestor);
          }
        }
      } else if (this.#responseCookiesPartitionKeyOpaque) {
        for (const cookie of this.#responseCookies) {
          cookie.setPartitionKeyOpaque();
        }
      }
    }
    return this.#responseCookies;
  }
  set responseCookies(responseCookies) {
    this.#responseCookies = responseCookies;
  }
  responseLastModified() {
    return this.responseHeaderValue("last-modified");
  }
  allCookiesIncludingBlockedOnes() {
    return [
      ...this.includedRequestCookies().map((includedRequestCookie) => includedRequestCookie.cookie),
      ...this.responseCookies,
      ...this.blockedRequestCookies().map((blockedRequestCookie) => blockedRequestCookie.cookie),
      ...this.blockedResponseCookies().map((blockedResponseCookie) => blockedResponseCookie.cookie)
    ].filter((v) => !!v);
  }
  get serverTimings() {
    if (typeof this.#serverTimings === "undefined") {
      this.#serverTimings = ServerTiming.parseHeaders(this.responseHeaders);
    }
    return this.#serverTimings;
  }
  queryString() {
    if (this.#queryString !== void 0) {
      return this.#queryString;
    }
    let queryString = null;
    const url = this.url();
    const questionMarkPosition = url.indexOf("?");
    if (questionMarkPosition !== -1) {
      queryString = url.substring(questionMarkPosition + 1);
      const hashSignPosition = queryString.indexOf("#");
      if (hashSignPosition !== -1) {
        queryString = queryString.substring(0, hashSignPosition);
      }
    }
    this.#queryString = queryString;
    return this.#queryString;
  }
  get queryParameters() {
    if (this.#parsedQueryParameters) {
      return this.#parsedQueryParameters;
    }
    const queryString = this.queryString();
    if (!queryString) {
      return null;
    }
    this.#parsedQueryParameters = this.parseParameters(queryString);
    return this.#parsedQueryParameters;
  }
  async parseFormParameters() {
    const requestContentType = this.requestContentType();
    if (!requestContentType) {
      return null;
    }
    if (requestContentType.match(/^application\/x-www-form-urlencoded\s*(;.*)?$/i)) {
      const formData2 = await this.requestFormData();
      if (!formData2) {
        return null;
      }
      return this.parseParameters(formData2);
    }
    const multipartDetails = requestContentType.match(/^multipart\/form-data\s*;\s*boundary\s*=\s*(\S+)\s*$/);
    if (!multipartDetails) {
      return null;
    }
    const boundary = multipartDetails[1];
    if (!boundary) {
      return null;
    }
    const formData = await this.requestFormData();
    if (!formData) {
      return null;
    }
    return this.parseMultipartFormDataParameters(formData, boundary);
  }
  formParameters() {
    if (!this.#formParametersPromise) {
      this.#formParametersPromise = this.parseFormParameters();
    }
    return this.#formParametersPromise;
  }
  responseHttpVersion() {
    const headersText = this.#responseHeadersText;
    if (!headersText) {
      const version = this.responseHeaderValue("version") || this.responseHeaderValue(":version");
      if (version) {
        return version;
      }
      return this.filteredProtocolName();
    }
    const firstLine = headersText.split(/\r\n/)[0];
    const match = firstLine.match(/^(HTTP\/\d+\.\d+)/);
    return match ? match[1] : "HTTP/0.9";
  }
  parseParameters(queryString) {
    function parseNameValue(pair) {
      const position = pair.indexOf("=");
      if (position === -1) {
        return { name: pair, value: "" };
      }
      return {
        name: pair.substring(0, position),
        value: pair.substring(position + 1)
      };
    }
    return queryString.split("&").map(parseNameValue);
  }
  /**
   * Parses multipart/form-data; boundary=boundaryString request bodies -
   * --boundaryString
   * Content-Disposition: form-data; #name="field-#name"; filename="r.gif"
   * Content-Type: application/octet-stream
   *
   * optionalValue
   * --boundaryString
   * Content-Disposition: form-data; #name="field-#name-2"
   *
   * optionalValue2
   * --boundaryString--
   */
  parseMultipartFormDataParameters(data, boundary) {
    const sanitizedBoundary = Platform18.StringUtilities.escapeForRegExp(boundary);
    const keyValuePattern = new RegExp(
      // Header with an optional file #name.
      '^\\r\\ncontent-disposition\\s*:\\s*form-data\\s*;\\s*name="([^"]*)"(?:\\s*;\\s*filename="([^"]*)")?(?:\\r\\ncontent-type\\s*:\\s*([^\\r\\n]*))?\\r\\n\\r\\n(.*)\\r\\n$',
      "is"
    );
    const fields = data.split(new RegExp(`--${sanitizedBoundary}(?:--s*$)?`, "g"));
    return fields.reduce(parseMultipartField, []);
    function parseMultipartField(result, field) {
      const [match, name, filename, contentType, value] = field.match(keyValuePattern) || [];
      if (!match) {
        return result;
      }
      const processedValue = filename || contentType ? i18nString9(UIStrings9.binary) : value;
      result.push({ name, value: processedValue });
      return result;
    }
  }
  computeHeaderValue(headers, headerName) {
    headerName = headerName.toLowerCase();
    const values = [];
    for (let i = 0; i < headers.length; ++i) {
      if (headers[i].name.toLowerCase() === headerName) {
        values.push(headers[i].value);
      }
    }
    if (!values.length) {
      return void 0;
    }
    if (headerName === "set-cookie") {
      return values.join("\n");
    }
    return values.join(", ");
  }
  requestContentData() {
    if (this.#contentData) {
      return this.#contentData;
    }
    if (this.#contentDataProvider) {
      this.#contentData = this.#contentDataProvider();
    } else {
      this.#contentData = NetworkManager.requestContentData(this);
    }
    return this.#contentData;
  }
  setContentDataProvider(dataProvider) {
    console.assert(!this.#contentData, "contentData can only be set once.");
    this.#contentDataProvider = dataProvider;
  }
  requestStreamingContent() {
    if (this.#streamingContentData) {
      return this.#streamingContentData;
    }
    const contentPromise = this.finished ? this.requestContentData() : NetworkManager.streamResponseBody(this);
    this.#streamingContentData = contentPromise.then((contentData) => {
      if (TextUtils23.ContentData.ContentData.isError(contentData)) {
        return contentData;
      }
      return TextUtils23.StreamingContentData.StreamingContentData.from(contentData);
    });
    return this.#streamingContentData;
  }
  contentURL() {
    return this.#url;
  }
  contentType() {
    return this.#resourceType;
  }
  async searchInContent(query, caseSensitive, isRegex) {
    if (!this.#contentDataProvider) {
      return await NetworkManager.searchInRequest(this, query, caseSensitive, isRegex);
    }
    const contentData = await this.requestContentData();
    if (TextUtils23.ContentData.ContentData.isError(contentData) || !contentData.isTextContent) {
      return [];
    }
    return TextUtils23.TextUtils.performSearchInContentData(contentData, query, caseSensitive, isRegex);
  }
  requestContentType() {
    return this.requestHeaderValue("Content-Type");
  }
  hasErrorStatusCode() {
    return this.statusCode >= 400;
  }
  setInitialPriority(priority) {
    this.#initialPriority = priority;
  }
  initialPriority() {
    return this.#initialPriority;
  }
  setPriority(priority) {
    this.#currentPriority = priority;
  }
  priority() {
    return this.#currentPriority || this.#initialPriority || null;
  }
  setSignedExchangeInfo(info) {
    this.#signedExchangeInfo = info;
  }
  signedExchangeInfo() {
    return this.#signedExchangeInfo;
  }
  async populateImageSource(image) {
    const contentData = await this.requestContentData();
    if (TextUtils23.ContentData.ContentData.isError(contentData)) {
      return;
    }
    let imageSrc = contentData.asDataUrl();
    if (imageSrc === null && !this.#failed) {
      const cacheControl = this.responseHeaderValue("cache-control") || "";
      if (!cacheControl.includes("no-cache")) {
        imageSrc = this.#url;
      }
    }
    if (imageSrc !== null) {
      image.src = imageSrc;
    }
  }
  initiator() {
    return this.#initiator || null;
  }
  hasUserGesture() {
    return this.#hasUserGesture ?? null;
  }
  frames() {
    return this.#frames;
  }
  addProtocolFrameError(errorMessage, time) {
    this.addFrame({
      type: WebSocketFrameType.Error,
      text: errorMessage,
      time: this.pseudoWallTime(time),
      opCode: -1,
      mask: false
    });
  }
  addProtocolFrame(response, time, sent) {
    const type = sent ? WebSocketFrameType.Send : WebSocketFrameType.Receive;
    this.addFrame({
      type,
      text: response.payloadData,
      time: this.pseudoWallTime(time),
      opCode: response.opcode,
      mask: response.mask
    });
  }
  addFrame(frame) {
    this.#frames.push(frame);
    this.dispatchEventToListeners(Events.WEBSOCKET_FRAME_ADDED, frame);
  }
  directSocketChunks() {
    return this.#directSocketChunks;
  }
  addDirectSocketChunk(chunk) {
    this.#directSocketChunks.push(chunk);
    this.dispatchEventToListeners(Events.DIRECTSOCKET_CHUNK_ADDED, chunk);
  }
  eventSourceMessages() {
    return this.#serverSentEvents?.eventSourceMessages ?? [];
  }
  addEventSourceMessage(time, eventName, eventId, data) {
    this.#serverSentEvents?.onProtocolEventSourceMessageReceived(eventName, data, eventId, this.pseudoWallTime(time));
  }
  markAsRedirect(redirectCount) {
    this.#isRedirect = true;
    this.#requestId = `${this.#backendRequestId}:redirected.${redirectCount}`;
  }
  isRedirect() {
    return this.#isRedirect;
  }
  setRequestIdForTest(requestId) {
    this.#backendRequestId = requestId;
    this.#requestId = requestId;
  }
  charset() {
    return this.#charset ?? null;
  }
  setCharset(charset) {
    this.#charset = charset;
  }
  addExtraRequestInfo(extraRequestInfo) {
    this.#blockedRequestCookies = extraRequestInfo.blockedRequestCookies;
    this.setIncludedRequestCookies(extraRequestInfo.includedRequestCookies);
    this.setRequestHeaders(extraRequestInfo.requestHeaders);
    this.#hasExtraRequestInfo = true;
    this.setRequestHeadersText("");
    this.#clientSecurityState = extraRequestInfo.clientSecurityState;
    this.#appliedNetworkConditionsId = extraRequestInfo.appliedNetworkConditionsId;
    if (extraRequestInfo.connectTiming) {
      this.setConnectTimingFromExtraInfo(extraRequestInfo.connectTiming);
    }
    this.#siteHasCookieInOtherPartition = extraRequestInfo.siteHasCookieInOtherPartition ?? false;
    this.#hasThirdPartyCookiePhaseoutIssue = this.#blockedRequestCookies.some((item) => item.blockedReasons.includes(
      "ThirdPartyPhaseout"
      /* Protocol.Network.CookieBlockedReason.ThirdPartyPhaseout */
    ));
  }
  hasExtraRequestInfo() {
    return this.#hasExtraRequestInfo;
  }
  blockedRequestCookies() {
    return this.#blockedRequestCookies;
  }
  setIncludedRequestCookies(includedRequestCookies) {
    this.#includedRequestCookies = includedRequestCookies;
  }
  includedRequestCookies() {
    return this.#includedRequestCookies;
  }
  hasRequestCookies() {
    return this.#includedRequestCookies.length > 0 || this.#blockedRequestCookies.length > 0;
  }
  siteHasCookieInOtherPartition() {
    return this.#siteHasCookieInOtherPartition;
  }
  // Parse the status text from the first line of the response headers text.
  // See net::HttpResponseHeaders::GetStatusText.
  static parseStatusTextFromResponseHeadersText(responseHeadersText) {
    const firstLineParts = responseHeadersText.split("\r")[0].split(" ");
    return firstLineParts.slice(2).join(" ");
  }
  addExtraResponseInfo(extraResponseInfo) {
    this.#blockedResponseCookies = extraResponseInfo.blockedResponseCookies;
    if (extraResponseInfo.exemptedResponseCookies) {
      this.#exemptedResponseCookies = extraResponseInfo.exemptedResponseCookies;
    }
    this.#responseCookiesPartitionKey = extraResponseInfo.cookiePartitionKey ? extraResponseInfo.cookiePartitionKey : null;
    this.#responseCookiesPartitionKeyOpaque = extraResponseInfo.cookiePartitionKeyOpaque || null;
    this.responseHeaders = extraResponseInfo.responseHeaders;
    this.originalResponseHeaders = extraResponseInfo.responseHeaders.map((headerEntry) => ({ ...headerEntry }));
    if (extraResponseInfo.responseHeadersText) {
      this.responseHeadersText = extraResponseInfo.responseHeadersText;
      if (!this.requestHeadersText()) {
        let requestHeadersText = `${this.requestMethod} ${this.parsedURL.path}`;
        if (this.parsedURL.queryParams) {
          requestHeadersText += `?${this.parsedURL.queryParams}`;
        }
        requestHeadersText += " HTTP/1.1\r\n";
        for (const { name, value } of this.requestHeaders()) {
          requestHeadersText += `${name}: ${value}\r
`;
        }
        this.setRequestHeadersText(requestHeadersText);
      }
      this.statusText = _NetworkRequest.parseStatusTextFromResponseHeadersText(extraResponseInfo.responseHeadersText);
    }
    this.#remoteAddressSpace = extraResponseInfo.resourceIPAddressSpace;
    if (extraResponseInfo.statusCode) {
      this.statusCode = extraResponseInfo.statusCode;
    }
    this.#hasExtraResponseInfo = true;
    const networkManager = NetworkManager.forRequest(this);
    if (!networkManager) {
      return;
    }
    for (const blockedCookie of this.#blockedResponseCookies) {
      if (blockedCookie.blockedReasons.includes(
        "NameValuePairExceedsMaxSize"
        /* Protocol.Network.SetCookieBlockedReason.NameValuePairExceedsMaxSize */
      )) {
        const message = i18nString9(UIStrings9.setcookieHeaderIsIgnoredIn, {
          PH1: this.url()
        });
        networkManager.dispatchEventToListeners(Events2.MessageGenerated, { message, requestId: this.#requestId, warning: true });
      }
    }
    const cookieModel = networkManager.target().model(CookieModel);
    if (!cookieModel) {
      return;
    }
    for (const exemptedCookie of this.#exemptedResponseCookies) {
      cookieModel.removeBlockedCookie(exemptedCookie.cookie);
    }
    for (const blockedCookie of this.#blockedResponseCookies) {
      const cookie = blockedCookie.cookie;
      if (!cookie) {
        continue;
      }
      if (blockedCookie.blockedReasons.includes(
        "ThirdPartyPhaseout"
        /* Protocol.Network.SetCookieBlockedReason.ThirdPartyPhaseout */
      )) {
        this.#hasThirdPartyCookiePhaseoutIssue = true;
      }
      cookieModel.addBlockedCookie(cookie, blockedCookie.blockedReasons.map((blockedReason) => ({
        attribute: setCookieBlockedReasonToAttribute(blockedReason),
        uiString: setCookieBlockedReasonToUiString(blockedReason)
      })));
    }
  }
  hasExtraResponseInfo() {
    return this.#hasExtraResponseInfo;
  }
  blockedResponseCookies() {
    return this.#blockedResponseCookies;
  }
  exemptedResponseCookies() {
    return this.#exemptedResponseCookies;
  }
  nonBlockedResponseCookies() {
    const blockedCookieLines = this.blockedResponseCookies().map((blockedCookie) => blockedCookie.cookieLine);
    const responseCookies = this.responseCookies.filter((cookie) => {
      const index = blockedCookieLines.indexOf(cookie.getCookieLine());
      if (index !== -1) {
        blockedCookieLines[index] = null;
        return false;
      }
      return true;
    });
    return responseCookies;
  }
  responseCookiesPartitionKey() {
    return this.#responseCookiesPartitionKey;
  }
  responseCookiesPartitionKeyOpaque() {
    return this.#responseCookiesPartitionKeyOpaque;
  }
  redirectSourceSignedExchangeInfoHasNoErrors() {
    return this.#redirectSource !== null && this.#redirectSource.#signedExchangeInfo !== null && !this.#redirectSource.#signedExchangeInfo.errors;
  }
  clientSecurityState() {
    return this.#clientSecurityState;
  }
  setTrustTokenParams(trustTokenParams) {
    this.#trustTokenParams = trustTokenParams;
  }
  trustTokenParams() {
    return this.#trustTokenParams;
  }
  setTrustTokenOperationDoneEvent(doneEvent) {
    this.#trustTokenOperationDoneEvent = doneEvent;
    this.dispatchEventToListeners(Events.TRUST_TOKEN_RESULT_ADDED);
  }
  trustTokenOperationDoneEvent() {
    return this.#trustTokenOperationDoneEvent;
  }
  setIsSameSite(isSameSite) {
    this.#isSameSite = isSameSite;
  }
  isSameSite() {
    return this.#isSameSite;
  }
  setIsIpProtectionUsed(isIpProtectionUsed) {
    this.#isIpProtectionUsed = isIpProtectionUsed;
  }
  isIpProtectionUsed() {
    return this.#isIpProtectionUsed;
  }
  setIsAdRelated(isAdRelated) {
    this.#isAdRelated = isAdRelated;
  }
  isAdRelated() {
    return this.#isAdRelated;
  }
  getAssociatedData(key) {
    return this.#associatedData.get(key) || null;
  }
  setAssociatedData(key, data) {
    this.#associatedData.set(key, data);
  }
  deleteAssociatedData(key) {
    this.#associatedData.delete(key);
  }
  hasThirdPartyCookiePhaseoutIssue() {
    return this.#hasThirdPartyCookiePhaseoutIssue;
  }
  addDataReceivedEvent({ timestamp, dataLength, encodedDataLength, data }) {
    this.resourceSize += dataLength;
    if (encodedDataLength !== -1) {
      this.increaseTransferSize(encodedDataLength);
    }
    this.endTime = timestamp;
    if (data) {
      void this.#streamingContentData?.then((contentData) => {
        if (!TextUtils23.StreamingContentData.isError(contentData)) {
          contentData.addChunk(data);
        }
      });
    }
  }
  waitForResponseReceived() {
    if (this.responseReceivedPromise) {
      return this.responseReceivedPromise;
    }
    const { promise, resolve } = Promise.withResolvers();
    this.responseReceivedPromise = promise;
    this.responseReceivedPromiseResolve = resolve;
    return this.responseReceivedPromise;
  }
};
var Events;
(function(Events12) {
  Events12["FINISHED_LOADING"] = "FinishedLoading";
  Events12["TIMING_CHANGED"] = "TimingChanged";
  Events12["REMOTE_ADDRESS_CHANGED"] = "RemoteAddressChanged";
  Events12["REQUEST_HEADERS_CHANGED"] = "RequestHeadersChanged";
  Events12["RESPONSE_HEADERS_CHANGED"] = "ResponseHeadersChanged";
  Events12["WEBSOCKET_FRAME_ADDED"] = "WebsocketFrameAdded";
  Events12["DIRECTSOCKET_CHUNK_ADDED"] = "DirectsocketChunkAdded";
  Events12["EVENT_SOURCE_MESSAGE_ADDED"] = "EventSourceMessageAdded";
  Events12["TRUST_TOKEN_RESULT_ADDED"] = "TrustTokenResultAdded";
})(Events || (Events = {}));
var WebSocketFrameType;
(function(WebSocketFrameType2) {
  WebSocketFrameType2["Send"] = "send";
  WebSocketFrameType2["Receive"] = "receive";
  WebSocketFrameType2["Error"] = "error";
})(WebSocketFrameType || (WebSocketFrameType = {}));
var cookieExemptionReasonToUiString = function(exemptionReason) {
  switch (exemptionReason) {
    case "UserSetting":
      return i18nString9(UIStrings9.exemptionReasonUserSetting);
    case "TPCDMetadata":
      return i18nString9(UIStrings9.exemptionReasonTPCDMetadata);
    case "TopLevelTPCDDeprecationTrial":
      return i18nString9(UIStrings9.exemptionReasonTopLevelTPCDDeprecationTrial);
    case "TPCDDeprecationTrial":
      return i18nString9(UIStrings9.exemptionReasonTPCDDeprecationTrial);
    case "TPCDHeuristics":
      return i18nString9(UIStrings9.exemptionReasonTPCDHeuristics);
    case "EnterprisePolicy":
      return i18nString9(UIStrings9.exemptionReasonEnterprisePolicy);
    case "StorageAccess":
      return i18nString9(UIStrings9.exemptionReasonStorageAccessAPI);
    case "TopLevelStorageAccess":
      return i18nString9(UIStrings9.exemptionReasonTopLevelStorageAccessAPI);
    case "Scheme":
      return i18nString9(UIStrings9.exemptionReasonScheme);
  }
  return "";
};
var cookieBlockedReasonToUiString = function(blockedReason) {
  switch (blockedReason) {
    case "SecureOnly":
      return i18nString9(UIStrings9.secureOnly);
    case "NotOnPath":
      return i18nString9(UIStrings9.notOnPath);
    case "DomainMismatch":
      return i18nString9(UIStrings9.domainMismatch);
    case "SameSiteStrict":
      return i18nString9(UIStrings9.sameSiteStrict);
    case "SameSiteLax":
      return i18nString9(UIStrings9.sameSiteLax);
    case "SameSiteUnspecifiedTreatedAsLax":
      return i18nString9(UIStrings9.sameSiteUnspecifiedTreatedAsLax);
    case "SameSiteNoneInsecure":
      return i18nString9(UIStrings9.sameSiteNoneInsecure);
    case "UserPreferences":
      return i18nString9(UIStrings9.userPreferences);
    case "UnknownError":
      return i18nString9(UIStrings9.unknownError);
    case "SchemefulSameSiteStrict":
      return i18nString9(UIStrings9.schemefulSameSiteStrict);
    case "SchemefulSameSiteLax":
      return i18nString9(UIStrings9.schemefulSameSiteLax);
    case "SchemefulSameSiteUnspecifiedTreatedAsLax":
      return i18nString9(UIStrings9.schemefulSameSiteUnspecifiedTreatedAsLax);
    case "SamePartyFromCrossPartyContext":
      return i18nString9(UIStrings9.samePartyFromCrossPartyContext);
    case "NameValuePairExceedsMaxSize":
      return i18nString9(UIStrings9.nameValuePairExceedsMaxSize);
    case "ThirdPartyPhaseout":
      return i18nString9(UIStrings9.thirdPartyPhaseout);
  }
  return "";
};
var setCookieBlockedReasonToUiString = function(blockedReason) {
  switch (blockedReason) {
    case "SecureOnly":
      return i18nString9(UIStrings9.blockedReasonSecureOnly);
    case "SameSiteStrict":
      return i18nString9(UIStrings9.blockedReasonSameSiteStrictLax, {
        PH1: "SameSite=Strict"
      });
    case "SameSiteLax":
      return i18nString9(UIStrings9.blockedReasonSameSiteStrictLax, {
        PH1: "SameSite=Lax"
      });
    case "SameSiteUnspecifiedTreatedAsLax":
      return i18nString9(UIStrings9.blockedReasonSameSiteUnspecifiedTreatedAsLax);
    case "SameSiteNoneInsecure":
      return i18nString9(UIStrings9.blockedReasonSameSiteNoneInsecure);
    case "UserPreferences":
      return i18nString9(UIStrings9.thisSetcookieWasBlockedDueToUser);
    case "SyntaxError":
      return i18nString9(UIStrings9.thisSetcookieHadInvalidSyntax);
    case "SchemeNotSupported":
      return i18nString9(UIStrings9.theSchemeOfThisConnectionIsNot);
    case "OverwriteSecure":
      return i18nString9(UIStrings9.blockedReasonOverwriteSecure);
    case "InvalidDomain":
      return i18nString9(UIStrings9.blockedReasonInvalidDomain);
    case "InvalidPrefix":
      return i18nString9(UIStrings9.blockedReasonInvalidPrefix);
    case "UnknownError":
      return i18nString9(UIStrings9.anUnknownErrorWasEncounteredWhenTrying);
    case "SchemefulSameSiteStrict":
      return i18nString9(UIStrings9.thisSetcookieWasBlockedBecauseItHadTheSamesiteStrictLax, { PH1: "SameSite=Strict" });
    case "SchemefulSameSiteLax":
      return i18nString9(UIStrings9.thisSetcookieWasBlockedBecauseItHadTheSamesiteStrictLax, { PH1: "SameSite=Lax" });
    case "SchemefulSameSiteUnspecifiedTreatedAsLax":
      return i18nString9(UIStrings9.thisSetcookieDidntSpecifyASamesite);
    case "SamePartyFromCrossPartyContext":
      return i18nString9(UIStrings9.thisSetcookieWasBlockedBecauseItHadTheSameparty);
    case "SamePartyConflictsWithOtherAttributes":
      return i18nString9(UIStrings9.thisSetcookieWasBlockedBecauseItHadTheSamepartyAttribute);
    case "NameValuePairExceedsMaxSize":
      return i18nString9(UIStrings9.thisSetcookieWasBlockedBecauseTheNameValuePairExceedsMaxSize);
    case "DisallowedCharacter":
      return i18nString9(UIStrings9.thisSetcookieHadADisallowedCharacter);
    case "ThirdPartyPhaseout":
      return i18nString9(UIStrings9.thisSetcookieWasBlockedDueThirdPartyPhaseout);
  }
  return "";
};
var cookieBlockedReasonToAttribute = function(blockedReason) {
  switch (blockedReason) {
    case "SecureOnly":
      return "secure";
    case "NotOnPath":
      return "path";
    case "DomainMismatch":
      return "domain";
    case "SameSiteStrict":
    case "SameSiteLax":
    case "SameSiteUnspecifiedTreatedAsLax":
    case "SameSiteNoneInsecure":
    case "SchemefulSameSiteStrict":
    case "SchemefulSameSiteLax":
    case "SchemefulSameSiteUnspecifiedTreatedAsLax":
      return "same-site";
    case "SamePartyFromCrossPartyContext":
    case "NameValuePairExceedsMaxSize":
    case "UserPreferences":
    case "ThirdPartyPhaseout":
    case "UnknownError":
      return null;
  }
  return null;
};
var setCookieBlockedReasonToAttribute = function(blockedReason) {
  switch (blockedReason) {
    case "SecureOnly":
    case "OverwriteSecure":
      return "secure";
    case "SameSiteStrict":
    case "SameSiteLax":
    case "SameSiteUnspecifiedTreatedAsLax":
    case "SameSiteNoneInsecure":
    case "SchemefulSameSiteStrict":
    case "SchemefulSameSiteLax":
    case "SchemefulSameSiteUnspecifiedTreatedAsLax":
      return "same-site";
    case "InvalidDomain":
      return "domain";
    case "InvalidPrefix":
      return "name";
    case "SamePartyConflictsWithOtherAttributes":
    case "SamePartyFromCrossPartyContext":
    case "NameValuePairExceedsMaxSize":
    case "UserPreferences":
    case "ThirdPartyPhaseout":
    case "SyntaxError":
    case "SchemeNotSupported":
    case "UnknownError":
    case "DisallowedCharacter":
      return null;
  }
  return null;
};
var DirectSocketType;
(function(DirectSocketType2) {
  DirectSocketType2[DirectSocketType2["TCP"] = 1] = "TCP";
  DirectSocketType2[DirectSocketType2["UDP_BOUND"] = 2] = "UDP_BOUND";
  DirectSocketType2[DirectSocketType2["UDP_CONNECTED"] = 3] = "UDP_CONNECTED";
})(DirectSocketType || (DirectSocketType = {}));
var DirectSocketStatus;
(function(DirectSocketStatus2) {
  DirectSocketStatus2[DirectSocketStatus2["OPENING"] = 1] = "OPENING";
  DirectSocketStatus2[DirectSocketStatus2["OPEN"] = 2] = "OPEN";
  DirectSocketStatus2[DirectSocketStatus2["CLOSED"] = 3] = "CLOSED";
  DirectSocketStatus2[DirectSocketStatus2["ABORTED"] = 4] = "ABORTED";
})(DirectSocketStatus || (DirectSocketStatus = {}));
var DirectSocketChunkType;
(function(DirectSocketChunkType2) {
  DirectSocketChunkType2["SEND"] = "send";
  DirectSocketChunkType2["RECEIVE"] = "receive";
})(DirectSocketChunkType || (DirectSocketChunkType = {}));

// gen/front_end/core/sdk/AccessibilityModel.js
var AccessibilityModel_exports = {};
__export(AccessibilityModel_exports, {
  AccessibilityModel: () => AccessibilityModel,
  AccessibilityNode: () => AccessibilityNode
});
var AccessibilityNode = class {
  #accessibilityModel;
  #id;
  #backendDOMNodeId;
  #deferredDOMNode;
  #ignored;
  #ignoredReasons;
  #role;
  #name;
  #description;
  #value;
  #properties;
  #parentId;
  #frameId;
  #childIds;
  constructor(accessibilityModel, payload) {
    this.#accessibilityModel = accessibilityModel;
    this.#id = payload.nodeId;
    accessibilityModel.setAXNodeForAXId(this.#id, this);
    if (payload.backendDOMNodeId) {
      accessibilityModel.setAXNodeForBackendDOMNodeId(payload.backendDOMNodeId, this);
      this.#backendDOMNodeId = payload.backendDOMNodeId;
      this.#deferredDOMNode = new DeferredDOMNode(accessibilityModel.target(), payload.backendDOMNodeId);
    } else {
      this.#backendDOMNodeId = null;
      this.#deferredDOMNode = null;
    }
    this.#ignored = payload.ignored;
    if (this.#ignored && "ignoredReasons" in payload) {
      this.#ignoredReasons = payload.ignoredReasons;
    }
    this.#role = payload.role || null;
    this.#name = payload.name || null;
    this.#description = payload.description || null;
    this.#value = payload.value || null;
    this.#properties = payload.properties || null;
    this.#childIds = [...new Set(payload.childIds)];
    this.#parentId = payload.parentId || null;
    if (payload.frameId && !payload.parentId) {
      this.#frameId = payload.frameId;
      accessibilityModel.setRootAXNodeForFrameId(payload.frameId, this);
    } else {
      this.#frameId = null;
    }
  }
  id() {
    return this.#id;
  }
  accessibilityModel() {
    return this.#accessibilityModel;
  }
  ignored() {
    return this.#ignored;
  }
  ignoredReasons() {
    return this.#ignoredReasons || null;
  }
  role() {
    return this.#role || null;
  }
  coreProperties() {
    const properties = [];
    if (this.#name) {
      properties.push({ name: "name", value: this.#name });
    }
    if (this.#description) {
      properties.push({ name: "description", value: this.#description });
    }
    if (this.#value) {
      properties.push({ name: "value", value: this.#value });
    }
    return properties;
  }
  name() {
    return this.#name || null;
  }
  description() {
    return this.#description || null;
  }
  value() {
    return this.#value || null;
  }
  properties() {
    return this.#properties || null;
  }
  parentNode() {
    if (this.#parentId) {
      return this.#accessibilityModel.axNodeForId(this.#parentId);
    }
    return null;
  }
  isDOMNode() {
    return Boolean(this.#backendDOMNodeId);
  }
  backendDOMNodeId() {
    return this.#backendDOMNodeId;
  }
  deferredDOMNode() {
    return this.#deferredDOMNode;
  }
  highlightDOMNode() {
    const deferredNode = this.deferredDOMNode();
    if (!deferredNode) {
      return;
    }
    deferredNode.highlight();
  }
  children() {
    if (!this.#childIds) {
      return [];
    }
    const children = [];
    for (const childId of this.#childIds) {
      const child = this.#accessibilityModel.axNodeForId(childId);
      if (child) {
        children.push(child);
      }
    }
    return children;
  }
  numChildren() {
    if (!this.#childIds) {
      return 0;
    }
    return this.#childIds.length;
  }
  hasOnlyUnloadedChildren() {
    if (!this.#childIds || !this.#childIds.length) {
      return false;
    }
    return this.#childIds.every((id) => this.#accessibilityModel.axNodeForId(id) === null);
  }
  hasUnloadedChildren() {
    if (!this.#childIds || !this.#childIds.length) {
      return false;
    }
    return this.#childIds.some((id) => this.#accessibilityModel.axNodeForId(id) === null);
  }
  // Only the root node gets a frameId, so nodes have to walk up the tree to find their frameId.
  getFrameId() {
    return this.#frameId || this.parentNode()?.getFrameId() || null;
  }
};
var AccessibilityModel = class extends SDKModel {
  agent;
  #axIdToAXNode = /* @__PURE__ */ new Map();
  #backendDOMNodeIdToAXNode = /* @__PURE__ */ new Map();
  #frameIdToAXNode = /* @__PURE__ */ new Map();
  #pendingChildRequests = /* @__PURE__ */ new Map();
  #root = null;
  constructor(target) {
    super(target);
    target.registerAccessibilityDispatcher(this);
    this.agent = target.accessibilityAgent();
    void this.resumeModel();
  }
  clear() {
    this.#root = null;
    this.#axIdToAXNode.clear();
    this.#backendDOMNodeIdToAXNode.clear();
    this.#frameIdToAXNode.clear();
  }
  async resumeModel() {
    await this.agent.invoke_enable();
  }
  async suspendModel() {
    await this.agent.invoke_disable();
  }
  async requestPartialAXTree(node) {
    const { nodes } = await this.agent.invoke_getPartialAXTree({ nodeId: node.id, fetchRelatives: true });
    if (!nodes) {
      return;
    }
    const axNodes = [];
    for (const payload of nodes) {
      axNodes.push(new AccessibilityNode(this, payload));
    }
  }
  loadComplete({ root }) {
    this.clear();
    this.#root = new AccessibilityNode(this, root);
    this.dispatchEventToListeners("TreeUpdated", { root: this.#root });
  }
  nodesUpdated({ nodes }) {
    this.createNodesFromPayload(nodes);
    this.dispatchEventToListeners("TreeUpdated", {});
    return;
  }
  createNodesFromPayload(payloadNodes) {
    const accessibilityNodes = payloadNodes.map((node) => {
      const sdkNode = new AccessibilityNode(this, node);
      return sdkNode;
    });
    return accessibilityNodes;
  }
  async requestRootNode(frameId) {
    if (frameId && this.#frameIdToAXNode.has(frameId)) {
      return this.#frameIdToAXNode.get(frameId);
    }
    if (!frameId && this.#root) {
      return this.#root;
    }
    const { node } = await this.agent.invoke_getRootAXNode({ frameId });
    if (!node) {
      return;
    }
    return this.createNodesFromPayload([node])[0];
  }
  async requestAXChildren(nodeId, frameId) {
    const parent = this.#axIdToAXNode.get(nodeId);
    if (!parent) {
      throw new Error("Cannot request children before parent");
    }
    if (!parent.hasUnloadedChildren()) {
      return parent.children();
    }
    const request = this.#pendingChildRequests.get(nodeId);
    if (request) {
      await request;
    } else {
      const request2 = this.agent.invoke_getChildAXNodes({ id: nodeId, frameId });
      this.#pendingChildRequests.set(nodeId, request2);
      const result = await request2;
      if (!result.getError()) {
        this.createNodesFromPayload(result.nodes);
        this.#pendingChildRequests.delete(nodeId);
      }
    }
    return parent.children();
  }
  async requestAndLoadSubTreeToNode(node) {
    const result = [];
    let ancestor = this.axNodeForDOMNode(node);
    while (ancestor) {
      result.push(ancestor);
      const parent = ancestor.parentNode();
      if (!parent) {
        return result;
      }
      ancestor = parent;
    }
    const { nodes } = await this.agent.invoke_getAXNodeAndAncestors({ backendNodeId: node.backendNodeId() });
    if (!nodes) {
      return null;
    }
    const ancestors = this.createNodesFromPayload(nodes);
    return ancestors;
  }
  axNodeForId(axId) {
    return this.#axIdToAXNode.get(axId) || null;
  }
  setRootAXNodeForFrameId(frameId, axNode) {
    this.#frameIdToAXNode.set(frameId, axNode);
  }
  setAXNodeForAXId(axId, axNode) {
    this.#axIdToAXNode.set(axId, axNode);
  }
  axNodeForDOMNode(domNode) {
    if (!domNode) {
      return null;
    }
    return this.#backendDOMNodeIdToAXNode.get(domNode.backendNodeId()) ?? null;
  }
  setAXNodeForBackendDOMNodeId(backendDOMNodeId, axNode) {
    this.#backendDOMNodeIdToAXNode.set(backendDOMNodeId, axNode);
  }
  getAgent() {
    return this.agent;
  }
};
SDKModel.register(AccessibilityModel, { capabilities: 2, autostart: false });

// gen/front_end/core/sdk/AnimationModel.js
var AnimationModel_exports = {};
__export(AnimationModel_exports, {
  AnimationDOMNode: () => AnimationDOMNode,
  AnimationDispatcher: () => AnimationDispatcher,
  AnimationEffect: () => AnimationEffect,
  AnimationGroup: () => AnimationGroup,
  AnimationImpl: () => AnimationImpl,
  AnimationModel: () => AnimationModel,
  Events: () => Events10,
  KeyframeStyle: () => KeyframeStyle,
  KeyframesRule: () => KeyframesRule
});
import * as Common28 from "./../common/common.js";
var DEVTOOLS_ANIMATIONS_WORLD_NAME = "devtools_animations";
var REPORT_SCROLL_POSITION_BINDING_NAME = "__devtools_report_scroll_position__";
var getScrollListenerNameInPage = (id) => `__devtools_scroll_listener_${id}__`;
async function resolveToObjectInWorld(domNode, worldName) {
  const resourceTreeModel = domNode.domModel().target().model(ResourceTreeModel);
  const pageAgent = domNode.domModel().target().pageAgent();
  for (const frame of resourceTreeModel.frames()) {
    const { executionContextId } = await pageAgent.invoke_createIsolatedWorld({ frameId: frame.id, worldName });
    const object = await domNode.resolveToObject(void 0, executionContextId);
    if (object) {
      return object;
    }
  }
  return null;
}
var AnimationDOMNode = class _AnimationDOMNode {
  #domNode;
  #scrollListenersById = /* @__PURE__ */ new Map();
  #scrollBindingListener;
  static lastAddedListenerId = 0;
  constructor(domNode) {
    this.#domNode = domNode;
  }
  async #addReportScrollPositionBinding() {
    if (this.#scrollBindingListener) {
      return;
    }
    this.#scrollBindingListener = (ev) => {
      const { name, payload } = ev.data;
      if (name !== REPORT_SCROLL_POSITION_BINDING_NAME) {
        return;
      }
      const { scrollTop, scrollLeft, id } = JSON.parse(payload);
      const scrollListener = this.#scrollListenersById.get(id);
      if (!scrollListener) {
        return;
      }
      scrollListener({ scrollTop, scrollLeft });
    };
    const runtimeModel = this.#domNode.domModel().target().model(RuntimeModel);
    await runtimeModel.addBinding({
      name: REPORT_SCROLL_POSITION_BINDING_NAME,
      executionContextName: DEVTOOLS_ANIMATIONS_WORLD_NAME
    });
    runtimeModel.addEventListener(Events6.BindingCalled, this.#scrollBindingListener);
  }
  async #removeReportScrollPositionBinding() {
    if (!this.#scrollBindingListener) {
      return;
    }
    const runtimeModel = this.#domNode.domModel().target().model(RuntimeModel);
    await runtimeModel.removeBinding({
      name: REPORT_SCROLL_POSITION_BINDING_NAME
    });
    runtimeModel.removeEventListener(Events6.BindingCalled, this.#scrollBindingListener);
    this.#scrollBindingListener = void 0;
  }
  async addScrollEventListener(onScroll) {
    _AnimationDOMNode.lastAddedListenerId++;
    const id = _AnimationDOMNode.lastAddedListenerId;
    this.#scrollListenersById.set(id, onScroll);
    if (!this.#scrollBindingListener) {
      await this.#addReportScrollPositionBinding();
    }
    const object = await resolveToObjectInWorld(this.#domNode, DEVTOOLS_ANIMATIONS_WORLD_NAME);
    if (!object) {
      return null;
    }
    await object.callFunction(scrollListenerInPage, [
      id,
      REPORT_SCROLL_POSITION_BINDING_NAME,
      getScrollListenerNameInPage(id)
    ].map((arg) => RemoteObject.toCallArgument(arg)));
    object.release();
    return id;
    function scrollListenerInPage(id2, reportScrollPositionBindingName, scrollListenerNameInPage) {
      if ("scrollingElement" in this && !this.scrollingElement) {
        return;
      }
      const scrollingElement = "scrollingElement" in this ? this.scrollingElement : this;
      this[scrollListenerNameInPage] = () => {
        globalThis[reportScrollPositionBindingName](JSON.stringify({ scrollTop: scrollingElement.scrollTop, scrollLeft: scrollingElement.scrollLeft, id: id2 }));
      };
      this.addEventListener("scroll", this[scrollListenerNameInPage], true);
    }
  }
  async removeScrollEventListener(id) {
    const object = await resolveToObjectInWorld(this.#domNode, DEVTOOLS_ANIMATIONS_WORLD_NAME);
    if (!object) {
      return;
    }
    await object.callFunction(removeScrollListenerInPage, [getScrollListenerNameInPage(id)].map((arg) => RemoteObject.toCallArgument(arg)));
    object.release();
    this.#scrollListenersById.delete(id);
    if (this.#scrollListenersById.size === 0) {
      await this.#removeReportScrollPositionBinding();
    }
    function removeScrollListenerInPage(scrollListenerNameInPage) {
      this.removeEventListener("scroll", this[scrollListenerNameInPage]);
      delete this[scrollListenerNameInPage];
    }
  }
  async scrollTop() {
    return await this.#domNode.callFunction(scrollTopInPage).then((res) => res?.value ?? null);
    function scrollTopInPage() {
      if ("scrollingElement" in this) {
        if (!this.scrollingElement) {
          return 0;
        }
        return this.scrollingElement.scrollTop;
      }
      return this.scrollTop;
    }
  }
  async scrollLeft() {
    return await this.#domNode.callFunction(scrollLeftInPage).then((res) => res?.value ?? null);
    function scrollLeftInPage() {
      if ("scrollingElement" in this) {
        if (!this.scrollingElement) {
          return 0;
        }
        return this.scrollingElement.scrollLeft;
      }
      return this.scrollLeft;
    }
  }
  async setScrollTop(offset) {
    await this.#domNode.callFunction(setScrollTopInPage, [offset]);
    function setScrollTopInPage(offsetInPage) {
      if ("scrollingElement" in this) {
        if (!this.scrollingElement) {
          return;
        }
        this.scrollingElement.scrollTop = offsetInPage;
      } else {
        this.scrollTop = offsetInPage;
      }
    }
  }
  async setScrollLeft(offset) {
    await this.#domNode.callFunction(setScrollLeftInPage, [offset]);
    function setScrollLeftInPage(offsetInPage) {
      if ("scrollingElement" in this) {
        if (!this.scrollingElement) {
          return;
        }
        this.scrollingElement.scrollLeft = offsetInPage;
      } else {
        this.scrollLeft = offsetInPage;
      }
    }
  }
  async verticalScrollRange() {
    return await this.#domNode.callFunction(verticalScrollRangeInPage).then((res) => res?.value ?? null);
    function verticalScrollRangeInPage() {
      if ("scrollingElement" in this) {
        if (!this.scrollingElement) {
          return 0;
        }
        return this.scrollingElement.scrollHeight - this.scrollingElement.clientHeight;
      }
      return this.scrollHeight - this.clientHeight;
    }
  }
  async horizontalScrollRange() {
    return await this.#domNode.callFunction(horizontalScrollRangeInPage).then((res) => res?.value ?? null);
    function horizontalScrollRangeInPage() {
      if ("scrollingElement" in this) {
        if (!this.scrollingElement) {
          return 0;
        }
        return this.scrollingElement.scrollWidth - this.scrollingElement.clientWidth;
      }
      return this.scrollWidth - this.clientWidth;
    }
  }
};
function shouldGroupAnimations(firstAnimation, anim) {
  const firstAnimationTimeline = firstAnimation.viewOrScrollTimeline();
  const animationTimeline = anim.viewOrScrollTimeline();
  if (firstAnimationTimeline) {
    return Boolean(animationTimeline && firstAnimationTimeline.sourceNodeId === animationTimeline.sourceNodeId && firstAnimationTimeline.axis === animationTimeline.axis);
  }
  return !animationTimeline && firstAnimation.startTime() === anim.startTime();
}
var AnimationModel = class extends SDKModel {
  runtimeModel;
  agent;
  #animationsById = /* @__PURE__ */ new Map();
  animationGroups = /* @__PURE__ */ new Map();
  #pendingAnimations = /* @__PURE__ */ new Set();
  playbackRate = 1;
  #flushPendingAnimations;
  constructor(target) {
    super(target);
    this.runtimeModel = target.model(RuntimeModel);
    this.agent = target.animationAgent();
    target.registerAnimationDispatcher(new AnimationDispatcher(this));
    if (!target.suspended()) {
      void this.agent.invoke_enable();
    }
    const resourceTreeModel = target.model(ResourceTreeModel);
    resourceTreeModel.addEventListener(Events3.PrimaryPageChanged, this.reset, this);
    this.#flushPendingAnimations = Common28.Debouncer.debounce(() => {
      while (this.#pendingAnimations.size) {
        this.matchExistingGroups(this.createGroupFromPendingAnimations());
      }
    }, 100);
  }
  reset() {
    this.#animationsById.clear();
    this.animationGroups.clear();
    this.#pendingAnimations.clear();
    this.dispatchEventToListeners(Events10.ModelReset);
  }
  async devicePixelRatio() {
    const evaluateResult = await this.target().runtimeAgent().invoke_evaluate({ expression: "window.devicePixelRatio" });
    if (evaluateResult?.result.type === "number") {
      return evaluateResult?.result.value ?? 1;
    }
    return 1;
  }
  async getAnimationGroupForAnimation(name, nodeId) {
    for (const animationGroup of this.animationGroups.values()) {
      for (const animation of animationGroup.animations()) {
        if (animation.name() === name) {
          const animationNode = await animation.source().node();
          if (animationNode?.id === nodeId) {
            return animationGroup;
          }
        }
      }
    }
    return null;
  }
  animationCanceled(id) {
    this.#pendingAnimations.delete(id);
  }
  async animationUpdated(payload) {
    let foundAnimationGroup;
    let foundAnimation;
    for (const animationGroup of this.animationGroups.values()) {
      foundAnimation = animationGroup.animations().find((animation) => animation.id() === payload.id);
      if (foundAnimation) {
        foundAnimationGroup = animationGroup;
        break;
      }
    }
    if (!foundAnimation || !foundAnimationGroup) {
      return;
    }
    await foundAnimation.setPayload(payload);
    this.dispatchEventToListeners(Events10.AnimationGroupUpdated, foundAnimationGroup);
  }
  async animationStarted(payload) {
    if (!payload.source?.backendNodeId) {
      return;
    }
    const animation = await AnimationImpl.parsePayload(this, payload);
    const keyframesRule = animation.source().keyframesRule();
    if (animation.type() === "WebAnimation" && keyframesRule && keyframesRule.keyframes().length === 0) {
      this.#pendingAnimations.delete(animation.id());
    } else {
      this.#animationsById.set(animation.id(), animation);
      this.#pendingAnimations.add(animation.id());
    }
    this.#flushPendingAnimations();
  }
  matchExistingGroups(incomingGroup) {
    let matchedGroup = null;
    for (const group of this.animationGroups.values()) {
      if (group.matches(incomingGroup)) {
        matchedGroup = group;
        group.rebaseTo(incomingGroup);
        break;
      }
      if (group.shouldInclude(incomingGroup)) {
        matchedGroup = group;
        group.appendAnimations(incomingGroup.animations());
        break;
      }
    }
    if (!matchedGroup) {
      this.animationGroups.set(incomingGroup.id(), incomingGroup);
      this.dispatchEventToListeners(Events10.AnimationGroupStarted, incomingGroup);
    } else {
      this.dispatchEventToListeners(Events10.AnimationGroupUpdated, matchedGroup);
    }
    return Boolean(matchedGroup);
  }
  createGroupFromPendingAnimations() {
    console.assert(this.#pendingAnimations.size > 0);
    const firstAnimationId = this.#pendingAnimations.values().next().value;
    this.#pendingAnimations.delete(firstAnimationId);
    const firstAnimation = this.#animationsById.get(firstAnimationId);
    if (!firstAnimation) {
      throw new Error("Unable to locate first animation");
    }
    const groupedAnimations = [firstAnimation];
    const remainingAnimations = /* @__PURE__ */ new Set();
    for (const id of this.#pendingAnimations) {
      const anim = this.#animationsById.get(id);
      if (shouldGroupAnimations(firstAnimation, anim)) {
        groupedAnimations.push(anim);
      } else {
        remainingAnimations.add(id);
      }
    }
    this.#pendingAnimations = remainingAnimations;
    groupedAnimations.sort((anim1, anim2) => anim1.startTime() - anim2.startTime());
    return new AnimationGroup(this, firstAnimationId, groupedAnimations);
  }
  setPlaybackRate(playbackRate) {
    this.playbackRate = playbackRate;
    void this.agent.invoke_setPlaybackRate({ playbackRate });
  }
  async releaseAllAnimations() {
    const animationIds = [...this.animationGroups.values()].flatMap((animationGroup) => animationGroup.animations().map((animation) => animation.id()));
    await this.agent.invoke_releaseAnimations({ animations: animationIds });
  }
  releaseAnimations(animations) {
    void this.agent.invoke_releaseAnimations({ animations });
  }
  async suspendModel() {
    await this.agent.invoke_disable().then(() => this.reset());
  }
  async resumeModel() {
    await this.agent.invoke_enable();
  }
};
var Events10;
(function(Events12) {
  Events12["AnimationGroupStarted"] = "AnimationGroupStarted";
  Events12["AnimationGroupUpdated"] = "AnimationGroupUpdated";
  Events12["ModelReset"] = "ModelReset";
})(Events10 || (Events10 = {}));
var AnimationImpl = class _AnimationImpl {
  #animationModel;
  #payload;
  // Assertion is safe because only way to create `AnimationImpl` is to use `parsePayload` which calls `setPayload` and sets the value.
  #source;
  // Assertion is safe because only way to create `AnimationImpl` is to use `parsePayload` which calls `setPayload` and sets the value.
  #playState;
  constructor(animationModel) {
    this.#animationModel = animationModel;
  }
  static async parsePayload(animationModel, payload) {
    const animation = new _AnimationImpl(animationModel);
    await animation.setPayload(payload);
    return animation;
  }
  async setPayload(payload) {
    if (payload.viewOrScrollTimeline) {
      const devicePixelRatio = await this.#animationModel.devicePixelRatio();
      if (payload.viewOrScrollTimeline.startOffset) {
        payload.viewOrScrollTimeline.startOffset /= devicePixelRatio;
      }
      if (payload.viewOrScrollTimeline.endOffset) {
        payload.viewOrScrollTimeline.endOffset /= devicePixelRatio;
      }
    }
    this.#payload = payload;
    if (this.#source && payload.source) {
      this.#source.setPayload(payload.source);
    } else if (!this.#source && payload.source) {
      this.#source = new AnimationEffect(this.#animationModel, payload.source);
    }
  }
  // `startTime` and `duration` is represented as the
  // percentage of the view timeline range that starts at `startOffset`px
  // from the scroll container and ends at `endOffset`px of the scroll container.
  // This takes a percentage of the timeline range and returns the absolute
  // pixels values as a scroll offset of the scroll container.
  percentageToPixels(percentage, viewOrScrollTimeline) {
    const { startOffset, endOffset } = viewOrScrollTimeline;
    if (startOffset === void 0 || endOffset === void 0) {
      throw new Error("startOffset or endOffset does not exist in viewOrScrollTimeline");
    }
    return (endOffset - startOffset) * (percentage / 100);
  }
  viewOrScrollTimeline() {
    return this.#payload.viewOrScrollTimeline;
  }
  id() {
    return this.#payload.id;
  }
  name() {
    return this.#payload.name;
  }
  paused() {
    return this.#payload.pausedState;
  }
  playState() {
    return this.#playState || this.#payload.playState;
  }
  playbackRate() {
    return this.#payload.playbackRate;
  }
  // For scroll driven animations, it returns the pixel offset in the scroll container
  // For time animations, it returns milliseconds.
  startTime() {
    const viewOrScrollTimeline = this.viewOrScrollTimeline();
    if (viewOrScrollTimeline) {
      return this.percentageToPixels(this.playbackRate() > 0 ? this.#payload.startTime : 100 - this.#payload.startTime, viewOrScrollTimeline) + (this.viewOrScrollTimeline()?.startOffset ?? 0);
    }
    return this.#payload.startTime;
  }
  // For scroll driven animations, it returns the duration in pixels (i.e. after how many pixels of scroll the animation is going to end)
  // For time animations, it returns milliseconds.
  iterationDuration() {
    const viewOrScrollTimeline = this.viewOrScrollTimeline();
    if (viewOrScrollTimeline) {
      return this.percentageToPixels(this.source().duration(), viewOrScrollTimeline);
    }
    return this.source().duration();
  }
  // For scroll driven animations, it returns the duration in pixels (i.e. after how many pixels of scroll the animation is going to end)
  // For time animations, it returns milliseconds.
  endTime() {
    if (!this.source().iterations) {
      return Infinity;
    }
    if (this.viewOrScrollTimeline()) {
      return this.startTime() + this.iterationDuration() * this.source().iterations();
    }
    return this.startTime() + this.source().delay() + this.source().duration() * this.source().iterations() + this.source().endDelay();
  }
  // For scroll driven animations, it returns the duration in pixels (i.e. after how many pixels of scroll the animation is going to end)
  // For time animations, it returns milliseconds.
  finiteDuration() {
    const iterations = Math.min(this.source().iterations(), 3);
    if (this.viewOrScrollTimeline()) {
      return this.iterationDuration() * iterations;
    }
    return this.source().delay() + this.source().duration() * iterations;
  }
  // For scroll driven animations, it returns the duration in pixels (i.e. after how many pixels of scroll the animation is going to end)
  // For time animations, it returns milliseconds.
  currentTime() {
    const viewOrScrollTimeline = this.viewOrScrollTimeline();
    if (viewOrScrollTimeline) {
      return this.percentageToPixels(this.#payload.currentTime, viewOrScrollTimeline);
    }
    return this.#payload.currentTime;
  }
  source() {
    return this.#source;
  }
  type() {
    return this.#payload.type;
  }
  overlaps(animation) {
    if (!this.source().iterations() || !animation.source().iterations()) {
      return true;
    }
    const firstAnimation = this.startTime() < animation.startTime() ? this : animation;
    const secondAnimation = firstAnimation === this ? animation : this;
    return firstAnimation.endTime() >= secondAnimation.startTime();
  }
  // Utility method for returning `delay` for time based animations
  // and `startTime` in pixels for scroll driven animations. It is used to
  // find the exact starting time of the first keyframe for both cases.
  delayOrStartTime() {
    if (this.viewOrScrollTimeline()) {
      return this.startTime();
    }
    return this.source().delay();
  }
  setTiming(duration, delay) {
    void this.#source.node().then((node) => {
      if (!node) {
        throw new Error("Unable to find node");
      }
      this.updateNodeStyle(duration, delay, node);
    });
    this.#source.durationInternal = duration;
    this.#source.delayInternal = delay;
    void this.#animationModel.agent.invoke_setTiming({ animationId: this.id(), duration, delay });
  }
  updateNodeStyle(duration, delay, node) {
    let animationPrefix;
    if (this.type() === "CSSTransition") {
      animationPrefix = "transition-";
    } else if (this.type() === "CSSAnimation") {
      animationPrefix = "animation-";
    } else {
      return;
    }
    if (!node.id) {
      throw new Error("Node has no id");
    }
    const cssModel = node.domModel().cssModel();
    cssModel.setEffectivePropertyValueForNode(node.id, animationPrefix + "duration", duration + "ms");
    cssModel.setEffectivePropertyValueForNode(node.id, animationPrefix + "delay", delay + "ms");
  }
  async remoteObjectPromise() {
    const payload = await this.#animationModel.agent.invoke_resolveAnimation({ animationId: this.id() });
    if (!payload) {
      return null;
    }
    return this.#animationModel.runtimeModel.createRemoteObject(payload.remoteObject);
  }
  cssId() {
    return this.#payload.cssId || "";
  }
};
var AnimationEffect = class {
  #animationModel;
  #payload;
  // Assertion is safe because `setPayload` call in `constructor` sets the value.
  delayInternal;
  // Assertion is safe because `setPayload` call in `constructor` sets the value.
  durationInternal;
  // Assertion is safe because `setPayload` call in `constructor` sets the value.
  #keyframesRule;
  #deferredNode;
  constructor(animationModel, payload) {
    this.#animationModel = animationModel;
    this.setPayload(payload);
  }
  setPayload(payload) {
    this.#payload = payload;
    if (!this.#keyframesRule && payload.keyframesRule) {
      this.#keyframesRule = new KeyframesRule(payload.keyframesRule);
    } else if (this.#keyframesRule && payload.keyframesRule) {
      this.#keyframesRule.setPayload(payload.keyframesRule);
    }
    this.delayInternal = payload.delay;
    this.durationInternal = payload.duration;
  }
  delay() {
    return this.delayInternal;
  }
  endDelay() {
    return this.#payload.endDelay;
  }
  iterations() {
    if (!this.delay() && !this.endDelay() && !this.duration()) {
      return 0;
    }
    return this.#payload.iterations || Infinity;
  }
  duration() {
    return this.durationInternal;
  }
  direction() {
    return this.#payload.direction;
  }
  fill() {
    return this.#payload.fill;
  }
  node() {
    if (!this.#deferredNode) {
      this.#deferredNode = new DeferredDOMNode(this.#animationModel.target(), this.backendNodeId());
    }
    return this.#deferredNode.resolvePromise();
  }
  deferredNode() {
    return new DeferredDOMNode(this.#animationModel.target(), this.backendNodeId());
  }
  backendNodeId() {
    return this.#payload.backendNodeId;
  }
  keyframesRule() {
    return this.#keyframesRule || null;
  }
  easing() {
    return this.#payload.easing;
  }
};
var KeyframesRule = class {
  #payload;
  // Assertion is safe because `setPayload` call in `constructor` sets the value.;
  #keyframes;
  // Assertion is safe because `setPayload` call in `constructor` sets the value.;
  constructor(payload) {
    this.setPayload(payload);
  }
  setPayload(payload) {
    this.#payload = payload;
    if (!this.#keyframes) {
      this.#keyframes = this.#payload.keyframes.map((keyframeStyle) => new KeyframeStyle(keyframeStyle));
    } else {
      this.#payload.keyframes.forEach((keyframeStyle, index) => {
        this.#keyframes[index]?.setPayload(keyframeStyle);
      });
    }
  }
  name() {
    return this.#payload.name;
  }
  keyframes() {
    return this.#keyframes;
  }
};
var KeyframeStyle = class {
  #payload;
  // Assertion is safe because `setPayload` call in `constructor` sets the value.
  #offset;
  // Assertion is safe because `setPayload` call in `constructor` sets the value.
  constructor(payload) {
    this.setPayload(payload);
  }
  setPayload(payload) {
    this.#payload = payload;
    this.#offset = payload.offset;
  }
  offset() {
    return this.#offset;
  }
  setOffset(offset) {
    this.#offset = offset * 100 + "%";
  }
  offsetAsNumber() {
    return parseFloat(this.#offset) / 100;
  }
  easing() {
    return this.#payload.easing;
  }
};
var AnimationGroup = class {
  #animationModel;
  #id;
  #scrollNode;
  #animations;
  #paused = false;
  constructor(animationModel, id, animations) {
    this.#animationModel = animationModel;
    this.#id = id;
    this.#animations = animations;
  }
  isScrollDriven() {
    return Boolean(this.#animations[0]?.viewOrScrollTimeline());
  }
  id() {
    return this.#id;
  }
  animations() {
    return this.#animations;
  }
  release() {
    this.#animationModel.animationGroups.delete(this.id());
    this.#animationModel.releaseAnimations(this.animationIds());
  }
  animationIds() {
    function extractId(animation) {
      return animation.id();
    }
    return this.#animations.map(extractId);
  }
  startTime() {
    return this.#animations[0].startTime();
  }
  // For scroll driven animations, it returns the duration in pixels (i.e. after how many pixels of scroll the animation is going to end)
  // For time animations, it returns milliseconds.
  groupDuration() {
    let duration = 0;
    for (const anim of this.#animations) {
      duration = Math.max(duration, anim.delayOrStartTime() + anim.iterationDuration());
    }
    return duration;
  }
  // For scroll driven animations, it returns the duration in pixels (i.e. after how many pixels of scroll the animation is going to end)
  // For time animations, it returns milliseconds.
  finiteDuration() {
    let maxDuration = 0;
    for (let i = 0; i < this.#animations.length; ++i) {
      maxDuration = Math.max(maxDuration, this.#animations[i].finiteDuration());
    }
    return maxDuration;
  }
  scrollOrientation() {
    const timeline = this.#animations[0]?.viewOrScrollTimeline();
    if (!timeline) {
      return null;
    }
    return timeline.axis;
  }
  async scrollNode() {
    if (this.#scrollNode) {
      return this.#scrollNode;
    }
    if (!this.isScrollDriven()) {
      return null;
    }
    const sourceNodeId = this.#animations[0]?.viewOrScrollTimeline()?.sourceNodeId;
    if (!sourceNodeId) {
      return null;
    }
    const deferredScrollNode = new DeferredDOMNode(this.#animationModel.target(), sourceNodeId);
    const scrollNode = await deferredScrollNode.resolvePromise();
    if (!scrollNode) {
      return null;
    }
    this.#scrollNode = new AnimationDOMNode(scrollNode);
    return this.#scrollNode;
  }
  seekTo(currentTime) {
    void this.#animationModel.agent.invoke_seekAnimations({ animations: this.animationIds(), currentTime });
  }
  paused() {
    return this.#paused;
  }
  togglePause(paused) {
    if (paused === this.#paused) {
      return;
    }
    this.#paused = paused;
    void this.#animationModel.agent.invoke_setPaused({ animations: this.animationIds(), paused });
  }
  currentTimePromise() {
    let longestAnim = null;
    for (const anim of this.#animations) {
      if (!longestAnim || anim.endTime() > longestAnim.endTime()) {
        longestAnim = anim;
      }
    }
    if (!longestAnim) {
      throw new Error("No longest animation found");
    }
    return this.#animationModel.agent.invoke_getCurrentTime({ id: longestAnim.id() }).then(({ currentTime }) => currentTime || 0);
  }
  matches(group) {
    function extractId(anim) {
      const timelineId = (anim.viewOrScrollTimeline()?.sourceNodeId ?? "") + (anim.viewOrScrollTimeline()?.axis ?? "");
      const regularId = anim.type() === "WebAnimation" ? anim.type() + anim.id() : anim.cssId();
      return regularId + timelineId;
    }
    if (this.#animations.length !== group.#animations.length) {
      return false;
    }
    const left = this.#animations.map(extractId).sort();
    const right = group.#animations.map(extractId).sort();
    for (let i = 0; i < left.length; i++) {
      if (left[i] !== right[i]) {
        return false;
      }
    }
    return true;
  }
  shouldInclude(group) {
    const [firstIncomingAnimation] = group.#animations;
    const [firstAnimation] = this.#animations;
    return shouldGroupAnimations(firstAnimation, firstIncomingAnimation);
  }
  appendAnimations(animations) {
    this.#animations.push(...animations);
  }
  rebaseTo(group) {
    this.#animationModel.releaseAnimations(this.animationIds());
    this.#animations = group.#animations;
    this.#scrollNode = void 0;
  }
};
var AnimationDispatcher = class {
  #animationModel;
  constructor(animationModel) {
    this.#animationModel = animationModel;
  }
  animationCreated(_event) {
  }
  animationCanceled({ id }) {
    this.#animationModel.animationCanceled(id);
  }
  animationStarted({ animation }) {
    void this.#animationModel.animationStarted(animation);
  }
  animationUpdated({ animation }) {
    void this.#animationModel.animationUpdated(animation);
  }
};
SDKModel.register(AnimationModel, { capabilities: 2, autostart: true });

// gen/front_end/core/sdk/AutofillModel.js
var AutofillModel_exports = {};
__export(AutofillModel_exports, {
  AutofillModel: () => AutofillModel
});
import * as Common29 from "./../common/common.js";
import * as Host7 from "./../host/host.js";
var AutofillModel = class extends SDKModel {
  agent;
  #enabled;
  #showTestAddressesInAutofillMenu;
  constructor(target) {
    super(target);
    this.agent = target.autofillAgent();
    this.#showTestAddressesInAutofillMenu = Common29.Settings.Settings.instance().createSetting("show-test-addresses-in-autofill-menu-on-event", false);
    this.#showTestAddressesInAutofillMenu.addChangeListener(this.#setTestAddresses, this);
    target.registerAutofillDispatcher(this);
    this.enable();
  }
  dispose() {
    this.#showTestAddressesInAutofillMenu.removeChangeListener(this.#setTestAddresses, this);
    super.dispose();
  }
  #setTestAddresses() {
    void this.agent.invoke_setAddresses({
      addresses: this.#showTestAddressesInAutofillMenu.get() ? [
        {
          fields: [
            { name: "ADDRESS_HOME_COUNTRY", value: "US" },
            { name: "NAME_FULL", value: "Jon Stewart Doe" },
            { name: "NAME_FIRST", value: "Jon" },
            { name: "NAME_MIDDLE", value: "Stewart" },
            { name: "NAME_LAST", value: "Doe" },
            { name: "COMPANY_NAME", value: "Fake Company" },
            { name: "ADDRESS_HOME_LINE1", value: "1600 Fake Street" },
            { name: "ADDRESS_HOME_LINE2", value: "Apartment 1" },
            { name: "ADDRESS_HOME_ZIP", value: "94043" },
            { name: "ADDRESS_HOME_CITY", value: "Mountain View" },
            { name: "ADDRESS_HOME_STATE", value: "CA" },
            { name: "EMAIL_ADDRESS", value: "test@example.us" },
            { name: "PHONE_HOME_WHOLE_NUMBER", value: "+16019521325" }
          ]
        },
        {
          fields: [
            { name: "ADDRESS_HOME_COUNTRY", value: "BR" },
            { name: "NAME_FULL", value: "Jo\xE3o Souza Silva" },
            { name: "NAME_FIRST", value: "Jo\xE3o" },
            { name: "NAME_LAST", value: "Souza Silva" },
            { name: "NAME_LAST_FIRST", value: "Souza" },
            { name: "NAME_LAST_SECOND", value: "Silva" },
            { name: "COMPANY_NAME", value: "Empresa Falsa" },
            { name: "ADDRESS_HOME_STREET_ADDRESS", value: "Rua Inexistente, 2000\nAndar 2, Apartamento 1" },
            { name: "ADDRESS_HOME_STREET_LOCATION", value: "Rua Inexistente, 2000" },
            { name: "ADDRESS_HOME_STREET_NAME", value: "Rua Inexistente" },
            { name: "ADDRESS_HOME_HOUSE_NUMBER", value: "2000" },
            { name: "ADDRESS_HOME_SUBPREMISE", value: "Andar 2, Apartamento 1" },
            { name: "ADDRESS_HOME_APT_NUM", value: "1" },
            { name: "ADDRESS_HOME_FLOOR", value: "2" },
            { name: "ADDRESS_HOME_APT", value: "Apartamento 1" },
            { name: "ADDRESS_HOME_APT_TYPE", value: "Apartamento" },
            { name: "ADDRESS_HOME_APT_NUM", value: "1" },
            { name: "ADDRESS_HOME_DEPENDENT_LOCALITY", value: "Santa Efig\xEAnia" },
            { name: "ADDRESS_HOME_LANDMARK", value: "Pr\xF3ximo \xE0 esta\xE7\xE3o Santa Efig\xEAnia" },
            { name: "ADDRESS_HOME_OVERFLOW", value: "Andar 2, Apartamento 1" },
            { name: "ADDRESS_HOME_ZIP", value: "30260-080" },
            { name: "ADDRESS_HOME_CITY", value: "Belo Horizonte" },
            { name: "ADDRESS_HOME_STATE", value: "MG" },
            { name: "EMAIL_ADDRESS", value: "teste@exemplo.us" },
            { name: "PHONE_HOME_WHOLE_NUMBER", value: "+553121286800" }
          ]
        },
        {
          fields: [
            { name: "ADDRESS_HOME_COUNTRY", value: "MX" },
            { name: "NAME_FULL", value: "Juan Francisco Garc\xEDa Flores" },
            { name: "NAME_FIRST", value: "Juan Francisco" },
            { name: "NAME_LAST", value: "Garc\xEDa Flores" },
            { name: "NAME_LAST_FIRST", value: "Garc\xEDa" },
            { name: "NAME_LAST_SECOND", value: "Flores" },
            { name: "COMPANY_NAME", value: "Empresa Falsa" },
            {
              name: "ADDRESS_HOME_STREET_ADDRESS",
              value: "C. Falsa 445\nPiso 2, Apartamento 1\nEntre calle Volc\xE1n y calle Montes Blancos, cerca de la estaci\xF3n de metro"
            },
            { name: "ADDRESS_HOME_STREET_LOCATION", value: "C. Falsa 445" },
            { name: "ADDRESS_HOME_STREET_NAME", value: "C. Falsa" },
            { name: "ADDRESS_HOME_HOUSE_NUMBER", value: "445" },
            { name: "ADDRESS_HOME_SUBPREMISE", value: "Piso 2, Apartamento 1" },
            { name: "ADDRESS_HOME_FLOOR", value: "2" },
            { name: "ADDRESS_HOME_APT", value: "Apartamento 1" },
            { name: "ADDRESS_HOME_APT_TYPE", value: "Apartamento" },
            { name: "ADDRESS_HOME_APT_NUM", value: "1" },
            { name: "ADDRESS_HOME_DEPENDENT_LOCALITY", value: "Lomas de Chapultepec" },
            {
              name: "ADDRESS_HOME_OVERFLOW",
              value: "Entre calle Volc\xE1n y calle Montes Celestes, cerca de la estaci\xF3n de metro"
            },
            {
              name: "ADDRESS_HOME_BETWEEN_STREETS_OR_LANDMARK",
              value: "Entre calle Volc\xE1n y calle Montes Blancos, cerca de la estaci\xF3n de metro"
            },
            { name: "ADDRESS_HOME_LANDMARK", value: "Cerca de la estaci\xF3n de metro" },
            { name: "ADDRESS_HOME_BETWEEN_STREETS", value: "Entre calle Volc\xE1n y calle Montes Blancos" },
            { name: "ADDRESS_HOME_BETWEEN_STREETS_1", value: "calle Volc\xE1n" },
            { name: "ADDRESS_HOME_BETWEEN_STREETS_2", value: "calle Montes Blancos" },
            { name: "ADDRESS_HOME_ADMIN_LEVEL2", value: "Miguel Hidalgo" },
            { name: "ADDRESS_HOME_ZIP", value: "11001" },
            { name: "ADDRESS_HOME_CITY", value: "Ciudad de M\xE9xico" },
            { name: "ADDRESS_HOME_STATE", value: "Distrito Federal" },
            { name: "EMAIL_ADDRESS", value: "ejemplo@ejemplo.mx" },
            { name: "PHONE_HOME_WHOLE_NUMBER", value: "+525553428400" }
          ]
        },
        {
          fields: [
            { name: "ADDRESS_HOME_COUNTRY", value: "DE" },
            { name: "NAME_FULL", value: "Gottfried Wilhelm Leibniz" },
            { name: "NAME_FIRST", value: "Gottfried" },
            { name: "NAME_MIDDLE", value: "Wilhelm" },
            { name: "NAME_LAST", value: "Leibniz" },
            { name: "COMPANY_NAME", value: "Erfundenes Unternehmen" },
            { name: "ADDRESS_HOME_LINE1", value: "Erfundene Stra\xDFe 33" },
            { name: "ADDRESS_HOME_LINE2", value: "Wohnung 1" },
            { name: "ADDRESS_HOME_ZIP", value: "80732" },
            { name: "ADDRESS_HOME_CITY", value: "M\xFCnchen" },
            { name: "EMAIL_ADDRESS", value: "test@beispiel.de" },
            { name: "PHONE_HOME_WHOLE_NUMBER", value: "+4930303986300" }
          ]
        }
      ] : []
    });
  }
  enable() {
    if (this.#enabled || Host7.InspectorFrontendHost.isUnderTest()) {
      return;
    }
    void this.agent.invoke_enable();
    this.#setTestAddresses();
    this.#enabled = true;
  }
  disable() {
    if (!this.#enabled || Host7.InspectorFrontendHost.isUnderTest()) {
      return;
    }
    this.#enabled = false;
    void this.agent.invoke_disable();
  }
  addressFormFilled(addressFormFilledEvent) {
    this.dispatchEventToListeners("AddressFormFilled", { autofillModel: this, event: addressFormFilledEvent });
  }
};
SDKModel.register(AutofillModel, { capabilities: 2, autostart: true });

// gen/front_end/core/sdk/CategorizedBreakpoint.js
var CategorizedBreakpoint_exports = {};
__export(CategorizedBreakpoint_exports, {
  CategorizedBreakpoint: () => CategorizedBreakpoint
});
var CategorizedBreakpoint = class {
  /**
   * The name of this breakpoint as passed to 'setInstrumentationBreakpoint',
   * 'setEventListenerBreakpoint' and 'setBreakOnCSPViolation'.
   *
   * Note that the backend adds a 'listener:' and 'instrumentation:' prefix
   * to this name in the 'Debugger.paused' CDP event.
   */
  name;
  #category;
  #enabled;
  constructor(category, name) {
    this.#category = category;
    this.name = name;
    this.#enabled = false;
  }
  category() {
    return this.#category;
  }
  enabled() {
    return this.#enabled;
  }
  setEnabled(enabled) {
    this.#enabled = enabled;
  }
};

// gen/front_end/core/sdk/ChildTargetManager.js
var ChildTargetManager_exports = {};
__export(ChildTargetManager_exports, {
  ChildTargetManager: () => ChildTargetManager
});
import * as i18n27 from "./../i18n/i18n.js";
import * as Common34 from "./../common/common.js";
import * as Host9 from "./../host/host.js";

// gen/front_end/core/sdk/Connections.js
var Connections_exports = {};
__export(Connections_exports, {
  MainConnection: () => MainConnection,
  ParallelConnection: () => ParallelConnection,
  StubConnection: () => StubConnection,
  WebSocketConnection: () => WebSocketConnection,
  initMainConnection: () => initMainConnection
});
import * as i18n25 from "./../i18n/i18n.js";
import * as Common33 from "./../common/common.js";
import * as Host8 from "./../host/host.js";
import * as ProtocolClient2 from "./../protocol_client/protocol_client.js";
import * as Root11 from "./../root/root.js";

// gen/front_end/core/sdk/RehydratingConnection.js
var RehydratingConnection_exports = {};
__export(RehydratingConnection_exports, {
  RehydratingConnection: () => RehydratingConnection,
  RehydratingSession: () => RehydratingSession
});
import * as Common32 from "./../common/common.js";
import * as i18n23 from "./../i18n/i18n.js";
import * as Root10 from "./../root/root.js";

// gen/front_end/core/sdk/EnhancedTracesParser.js
var EnhancedTracesParser_exports = {};
__export(EnhancedTracesParser_exports, {
  EnhancedTracesParser: () => EnhancedTracesParser
});
import * as Common30 from "./../common/common.js";
import { UserVisibleError } from "./../platform/platform.js";
var EnhancedTracesParser = class {
  #trace;
  #scriptRundownEvents = [];
  #scriptToV8Context = /* @__PURE__ */ new Map();
  #scriptToFrame = /* @__PURE__ */ new Map();
  #scriptToScriptSource = /* @__PURE__ */ new Map();
  #largeScriptToScriptSource = /* @__PURE__ */ new Map();
  #scriptToSourceLength = /* @__PURE__ */ new Map();
  #targets = [];
  #executionContexts = [];
  #scripts = [];
  #resources = [];
  static enhancedTraceVersion = 1;
  constructor(trace) {
    this.#trace = trace;
    try {
      this.parseEnhancedTrace();
    } catch (e) {
      throw new UserVisibleError.UserVisibleError(e);
    }
  }
  parseEnhancedTrace() {
    for (const event of this.#trace.traceEvents) {
      if (this.isTracingStartedInBrowser(event)) {
        const data = event.args?.data;
        for (const frame of data.frames) {
          if (frame.url === "about:blank") {
            continue;
          }
          if (!frame.isInPrimaryMainFrame) {
            continue;
          }
          const frameId = frame.frame;
          if (!this.#targets.find((target) => target.targetId === frameId)) {
            const frameType = frame.isOutermostMainFrame ? "page" : "iframe";
            this.#targets.push({
              targetId: frameId,
              type: frameType,
              pid: frame.processId,
              url: frame.url
            });
          }
        }
      } else if (this.isFunctionCallEvent(event)) {
        const data = event.args?.data;
        if (data.isolate) {
          this.#scriptToFrame.set(this.getScriptIsolateId(data.isolate, data.scriptId), data.frame);
        }
      } else if (this.isRundownScriptCompiled(event)) {
        const data = event.args?.data;
        this.#scriptToV8Context.set(this.getScriptIsolateId(data.isolate, data.scriptId), data.v8context);
        this.#scriptToFrame.set(this.getScriptIsolateId(data.isolate, data.scriptId), data.frame);
        const frameId = data.frame;
        if (!this.#targets.find((target) => target.targetId === frameId)) {
          this.#targets.push({
            targetId: frameId,
            type: data.frameType,
            isolate: String(data.isolate),
            pid: event.pid,
            url: data.url
          });
        }
        if (!this.#executionContexts.find((executionContext) => executionContext.v8Context === data.v8context)) {
          this.#executionContexts.push({
            id: -1,
            origin: data.origin,
            v8Context: data.v8context,
            auxData: {
              frameId: data.frame,
              isDefault: data.isDefault,
              type: data.contextType
            },
            isolate: String(data.isolate),
            name: data.origin,
            uniqueId: `${data.v8context}-${data.isolate}`
          });
        }
      } else if (this.isRundownScript(event)) {
        this.#scriptRundownEvents.push(event);
        const data = event.args.data;
        if (!this.#scripts.find((script) => script.scriptId === String(data.scriptId) && script.isolate === String(data.isolate))) {
          this.#scripts.push({
            scriptId: String(data.scriptId),
            isolate: String(data.isolate),
            buildId: "",
            executionContextId: data.executionContextId,
            startLine: data.startLine ?? 0,
            startColumn: data.startColumn ?? 0,
            endLine: data.endLine ?? 0,
            endColumn: data.endColumn ?? 0,
            hash: data.hash ?? "",
            isModule: data.isModule,
            url: data.url ?? "",
            hasSourceURL: data.hasSourceUrl,
            sourceURL: data.sourceUrl ?? "",
            sourceMapURL: data.sourceMapUrl,
            pid: event.pid
          });
        }
      } else if (this.isRundownScriptSource(event)) {
        const data = event.args.data;
        const scriptIsolateId = this.getScriptIsolateId(data.isolate, data.scriptId);
        if ("splitIndex" in data && "splitCount" in data) {
          if (!this.#largeScriptToScriptSource.has(scriptIsolateId)) {
            this.#largeScriptToScriptSource.set(scriptIsolateId, new Array(data.splitCount).fill(""));
          }
          const splittedSource = this.#largeScriptToScriptSource.get(scriptIsolateId);
          if (splittedSource && data.sourceText) {
            splittedSource[data.splitIndex] = data.sourceText;
          }
        } else {
          if (data.sourceText) {
            this.#scriptToScriptSource.set(scriptIsolateId, data.sourceText);
          }
          if (data.length) {
            this.#scriptToSourceLength.set(scriptIsolateId, data.length);
          }
        }
      }
    }
  }
  data() {
    const v8ContextToExecutionContextId = /* @__PURE__ */ new Map();
    this.#scriptRundownEvents.forEach((scriptRundownEvent) => {
      const data = scriptRundownEvent.args.data;
      const v8Context = this.#scriptToV8Context.get(this.getScriptIsolateId(data.isolate, data.scriptId));
      if (v8Context) {
        v8ContextToExecutionContextId.set(v8Context, data.executionContextId);
      }
    });
    this.#executionContexts.forEach((executionContext) => {
      if (executionContext.v8Context) {
        const id = v8ContextToExecutionContextId.get(executionContext.v8Context);
        if (id) {
          executionContext.id = id;
        }
      }
    });
    this.#scripts.forEach((script) => {
      const scriptIsolateId = this.getScriptIsolateId(script.isolate, script.scriptId);
      if (this.#scriptToScriptSource.has(scriptIsolateId)) {
        script.sourceText = this.#scriptToScriptSource.get(scriptIsolateId);
        script.length = this.#scriptToSourceLength.get(scriptIsolateId);
      } else if (this.#largeScriptToScriptSource.has(scriptIsolateId)) {
        const splittedSources = this.#largeScriptToScriptSource.get(scriptIsolateId);
        if (splittedSources) {
          script.sourceText = splittedSources.join("");
          script.length = script.sourceText.length;
        }
      }
      const linkedExecutionContext = this.#executionContexts.find((context) => context.id === script.executionContextId && context.isolate === script.isolate);
      if (linkedExecutionContext) {
        script.executionContextAuxData = linkedExecutionContext.auxData;
        if (script.executionContextAuxData?.frameId) {
          this.#scriptToFrame.set(scriptIsolateId, script.executionContextAuxData?.frameId);
        }
      }
    });
    for (const script of this.#scripts) {
      this.resolveSourceMap(script);
    }
    this.#resources = this.#trace.metadata.resources ?? [];
    return this.groupContextsAndScriptsUnderTarget(this.#targets, this.#executionContexts, this.#scripts, this.#resources);
  }
  resolveSourceMap(script) {
    if (script.sourceMapURL?.startsWith("data:")) {
      return;
    }
    const sourceMap = this.getSourceMapFromMetadata(script);
    if (!sourceMap) {
      return;
    }
    const payload = encodeURIComponent(JSON.stringify(sourceMap));
    script.sourceMapURL = `data:application/json;charset=utf-8,${payload}`;
  }
  getSourceMapFromMetadata(script) {
    const { hasSourceURL, sourceURL, url, sourceMapURL, isolate, scriptId } = script;
    if (!sourceMapURL || !this.#trace.metadata.sourceMaps) {
      return;
    }
    const frame = this.#scriptToFrame.get(this.getScriptIsolateId(isolate, scriptId));
    if (!frame) {
      return;
    }
    const target = this.#targets.find((t) => t.targetId === frame);
    if (!target) {
      return;
    }
    let resolvedSourceUrl = url;
    if (hasSourceURL && sourceURL) {
      const targetUrl = target.url;
      resolvedSourceUrl = Common30.ParsedURL.ParsedURL.completeURL(targetUrl, sourceURL) ?? sourceURL;
    }
    const resolvedSourceMapUrl = Common30.ParsedURL.ParsedURL.completeURL(resolvedSourceUrl, sourceMapURL);
    if (!resolvedSourceMapUrl) {
      return;
    }
    const { sourceMap } = this.#trace.metadata.sourceMaps.find((m) => m.sourceMapUrl === resolvedSourceMapUrl) ?? {};
    return sourceMap;
  }
  getScriptIsolateId(isolate, scriptId) {
    return `${scriptId}@${isolate}`;
  }
  getExecutionContextIsolateId(isolate, executionContextId) {
    return `${executionContextId}@${isolate}`;
  }
  isTraceEvent(event) {
    return "cat" in event && "pid" in event && "args" in event && "data" in event.args;
  }
  isRundownScriptCompiled(event) {
    return this.isTraceEvent(event) && event.cat === "disabled-by-default-devtools.target-rundown";
  }
  isRundownScript(event) {
    return this.isTraceEvent(event) && event.cat === "disabled-by-default-devtools.v8-source-rundown";
  }
  isRundownScriptSource(event) {
    return this.isTraceEvent(event) && event.cat === "disabled-by-default-devtools.v8-source-rundown-sources";
  }
  isTracingStartedInBrowser(event) {
    return this.isTraceEvent(event) && event.cat === "disabled-by-default-devtools.timeline" && event.name === "TracingStartedInBrowser";
  }
  isFunctionCallEvent(event) {
    return this.isTraceEvent(event) && event.cat === "devtools.timeline" && event.name === "FunctionCall";
  }
  groupContextsAndScriptsUnderTarget(targets, executionContexts, scripts, resources) {
    const data = [];
    const targetIds = /* @__PURE__ */ new Set();
    const targetToExecutionContexts = /* @__PURE__ */ new Map();
    const executionContextIsolateToTarget = /* @__PURE__ */ new Map();
    const targetToScripts = /* @__PURE__ */ new Map();
    const orphanScripts = [];
    const targetToResources = /* @__PURE__ */ new Map();
    for (const target of targets) {
      targetIds.add(target.targetId);
      targetToExecutionContexts.set(target.targetId, []);
      targetToScripts.set(target.targetId, []);
      targetToResources.set(target.targetId, []);
    }
    for (const executionContext of executionContexts) {
      const frameId = executionContext.auxData?.frameId;
      if (frameId && targetIds.has(frameId)) {
        targetToExecutionContexts.get(frameId)?.push(executionContext);
        executionContextIsolateToTarget.set(this.getExecutionContextIsolateId(executionContext.isolate, executionContext.id), frameId);
      } else {
        console.error("Execution context can't be linked to a target", executionContext);
      }
    }
    for (const script of scripts) {
      const scriptExecutionContextIsolateId = this.getExecutionContextIsolateId(script.isolate, script.executionContextId);
      const scriptFrameId = script.executionContextAuxData?.frameId;
      if (script.executionContextAuxData?.frameId && targetIds.has(scriptFrameId)) {
        targetToScripts.get(scriptFrameId)?.push(script);
        executionContextIsolateToTarget.set(scriptExecutionContextIsolateId, scriptFrameId);
      } else if (this.#scriptToFrame.has(this.getScriptIsolateId(script.isolate, script.scriptId))) {
        const targetId = this.#scriptToFrame.get(this.getScriptIsolateId(script.isolate, script.scriptId));
        if (targetId) {
          targetToScripts.get(targetId)?.push(script);
          executionContextIsolateToTarget.set(scriptExecutionContextIsolateId, targetId);
        }
      } else {
        orphanScripts.push(script);
      }
    }
    for (const orphanScript of orphanScripts) {
      const orphanScriptExecutionContextIsolateId = this.getExecutionContextIsolateId(orphanScript.isolate, orphanScript.executionContextId);
      const frameId = executionContextIsolateToTarget.get(orphanScriptExecutionContextIsolateId);
      if (frameId) {
        targetToScripts.get(frameId)?.push(orphanScript);
      } else if (orphanScript.pid) {
        const target = targets.find((target2) => target2.pid === orphanScript.pid);
        if (target) {
          targetToScripts.get(target.targetId)?.push(orphanScript);
        }
      } else {
        console.error("Script can't be linked to any target", orphanScript);
      }
    }
    for (const resource of resources) {
      const frameId = resource.frame;
      if (targetIds.has(frameId)) {
        targetToResources.get(frameId)?.push(resource);
      }
    }
    for (const target of targets) {
      const targetId = target.targetId;
      const executionContexts2 = targetToExecutionContexts.get(targetId) || [];
      const scripts2 = targetToScripts.get(targetId) || [];
      const resources2 = targetToResources.get(targetId) || [];
      for (const script of scripts2) {
        if (!executionContexts2.find((context) => context.id === script.executionContextId)) {
          const artificialContext = {
            id: script.executionContextId,
            origin: "",
            v8Context: "",
            name: "",
            auxData: {
              frameId: targetId,
              isDefault: false,
              type: "type"
            },
            isolate: script.isolate,
            uniqueId: `${targetId}-${script.isolate}`
          };
          executionContexts2.push(artificialContext);
        }
      }
      data.push({ target, executionContexts: executionContexts2, scripts: scripts2, resources: resources2 });
    }
    return data;
  }
};

// gen/front_end/core/sdk/TraceObject.js
var TraceObject_exports = {};
__export(TraceObject_exports, {
  RevealableEvent: () => RevealableEvent,
  RevealableNetworkRequest: () => RevealableNetworkRequest,
  TraceObject: () => TraceObject
});
import * as Common31 from "./../common/common.js";
var TraceObject = class {
  traceEvents;
  metadata;
  constructor(payload, meta) {
    if (Array.isArray(payload)) {
      this.traceEvents = payload;
      this.metadata = meta ?? {};
    } else {
      this.traceEvents = payload.traceEvents;
      this.metadata = payload.metadata;
    }
  }
};
var RevealableEvent = class {
  event;
  // Only Trace.Types.Events.Event are passed in, but we can't depend on that type from SDK
  /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
  constructor(event) {
    this.event = event;
  }
};
var RevealableNetworkRequest = class _RevealableNetworkRequest {
  networkRequest;
  constructor(networkRequest) {
    this.networkRequest = networkRequest;
  }
  // Only Trace.Types.Events.SyntheticNetworkRequest are passed in, but we can't depend on that type from SDK
  static create(event) {
    const syntheticNetworkRequest = event;
    const url = syntheticNetworkRequest.args.data.url;
    const urlWithoutHash = Common31.ParsedURL.ParsedURL.urlWithoutHash(url);
    const resource = ResourceTreeModel.resourceForURL(url) ?? ResourceTreeModel.resourceForURL(urlWithoutHash);
    const sdkNetworkRequest = resource?.request;
    return sdkNetworkRequest ? new _RevealableNetworkRequest(sdkNetworkRequest) : null;
  }
};

// gen/front_end/core/sdk/RehydratingConnection.js
var UIStrings10 = {
  /**
   * @description Text that appears when no source text is available for the given script
   */
  noSourceText: "No source text available",
  /**
   * @description Text to indicate rehydrating connection cannot find host window
   */
  noHostWindow: "Can not find host window",
  /**
   * @description Text to indicate that there is an error loading the log
   */
  errorLoadingLog: "Error loading log"
};
var str_10 = i18n23.i18n.registerUIStrings("core/sdk/RehydratingConnection.ts", UIStrings10);
var i18nString10 = i18n23.i18n.getLocalizedString.bind(void 0, str_10);
var RehydratingConnection = class {
  rehydratingConnectionState = 1;
  onDisconnect = null;
  onMessage = null;
  trace = null;
  sessions = /* @__PURE__ */ new Map();
  #onConnectionLost;
  #rehydratingWindow = window;
  #onReceiveHostWindowPayloadBound = this.onReceiveHostWindowPayload.bind(this);
  constructor(onConnectionLost) {
    this.#onConnectionLost = onConnectionLost;
    if (!this.#maybeHandleLoadingFromUrl()) {
      this.#setupMessagePassing();
    }
  }
  /** Returns true if found a trace URL. */
  #maybeHandleLoadingFromUrl() {
    let traceUrl = Root10.Runtime.Runtime.queryParam("traceURL");
    if (!traceUrl) {
      const timelineUrl = Root10.Runtime.Runtime.queryParam("loadTimelineFromURL");
      if (timelineUrl) {
        traceUrl = decodeURIComponent(timelineUrl);
      }
    }
    if (traceUrl) {
      void fetch(traceUrl).then((r) => r.arrayBuffer()).then((b) => Common32.Gzip.arrayBufferToString(b)).then((traceJson) => {
        const trace = new TraceObject(JSON.parse(traceJson));
        void this.startHydration(trace);
      });
      return true;
    }
    return false;
  }
  #setupMessagePassing() {
    this.#rehydratingWindow.addEventListener("message", this.#onReceiveHostWindowPayloadBound);
    if (this.#rehydratingWindow.opener) {
      this.#rehydratingWindow.opener.postMessage({ type: "REHYDRATING_WINDOW_READY" });
    } else if (this.#rehydratingWindow !== window.top) {
      this.#rehydratingWindow.parent.postMessage({ type: "REHYDRATING_IFRAME_READY" }, "*");
    } else {
      this.#onConnectionLost(i18nString10(UIStrings10.noHostWindow));
    }
  }
  /**
   * This is a callback for rehydrated session to receive payload from host window. Payload includes but not limited to
   * the trace event and all necessary data to power a rehydrated session.
   */
  onReceiveHostWindowPayload(event) {
    if (event.data.type === "REHYDRATING_TRACE_FILE") {
      const traceJson = event.data.traceJson;
      let trace;
      try {
        trace = new TraceObject(JSON.parse(traceJson));
      } catch {
        this.#onConnectionLost(i18nString10(UIStrings10.errorLoadingLog));
        return;
      }
      void this.startHydration(trace);
    }
    this.#rehydratingWindow.removeEventListener("message", this.#onReceiveHostWindowPayloadBound);
  }
  async startHydration(trace) {
    if (!this.onMessage || this.rehydratingConnectionState !== 2) {
      return false;
    }
    if (!("traceEvents" in trace)) {
      console.error("RehydratingConnection failed to initialize due to missing trace events in payload");
      return false;
    }
    this.trace = trace;
    const enhancedTracesParser = new EnhancedTracesParser(trace);
    const hydratingData = enhancedTracesParser.data();
    let sessionId = 0;
    this.sessions.set(sessionId, new RehydratingSessionBase(this));
    for (const hydratingDataPerTarget of hydratingData) {
      const target = hydratingDataPerTarget.target;
      const executionContexts = hydratingDataPerTarget.executionContexts;
      const scripts = hydratingDataPerTarget.scripts;
      const resources = hydratingDataPerTarget.resources;
      this.postToFrontend({
        method: "Target.targetCreated",
        params: {
          targetInfo: {
            targetId: target.targetId,
            type: target.type,
            title: target.url,
            url: target.url,
            attached: false,
            canAccessOpener: false
          }
        }
      });
      sessionId += 1;
      const session = new RehydratingSession(sessionId, target, executionContexts, scripts, resources, this);
      this.sessions.set(sessionId, session);
      session.declareSessionAttachedToTarget();
    }
    await this.#onRehydrated();
    return true;
  }
  async #onRehydrated() {
    if (!this.trace) {
      return;
    }
    this.rehydratingConnectionState = 3;
    await Common32.Revealer.reveal(this.trace);
  }
  setOnMessage(onMessage) {
    this.onMessage = onMessage;
    this.rehydratingConnectionState = 2;
  }
  setOnDisconnect(onDisconnect) {
    this.onDisconnect = onDisconnect;
  }
  // The function "sendRawMessage" is typically devtools front-end
  // sending message to the backend via CDP. In this case, given that Rehydrating
  // connection is an emulation of devtool back-end, sendRawMessage here
  // is in fact rehydrating connection directly handling and acting on the
  // receieved message.
  sendRawMessage(message) {
    if (typeof message === "string") {
      message = JSON.parse(message);
    }
    const data = message;
    if (typeof data.sessionId !== "undefined") {
      const session = this.sessions.get(data.sessionId);
      if (session) {
        session.handleFrontendMessageAsFakeCDPAgent(data);
      } else {
        console.error("Invalid SessionId: " + data.sessionId);
      }
    } else {
      this.sessions.get(0)?.handleFrontendMessageAsFakeCDPAgent(data);
    }
  }
  // Posting rehydrating connection's message/response
  // to devtools frontend through debugger protocol.
  postToFrontend(arg) {
    if (this.onMessage) {
      this.onMessage(arg);
    } else {
      console.error("onMessage was not initialized");
    }
  }
  disconnect() {
    return Promise.reject();
  }
};
var RehydratingSessionBase = class {
  connection = null;
  constructor(connection) {
    this.connection = connection;
  }
  sendMessageToFrontend(payload) {
    setTimeout(() => {
      this.connection?.postToFrontend(payload);
    });
  }
  handleFrontendMessageAsFakeCDPAgent(data) {
    this.sendMessageToFrontend({
      id: data.id,
      result: {}
    });
  }
};
var RehydratingSession = class extends RehydratingSessionBase {
  sessionId;
  target;
  executionContexts = [];
  scripts = [];
  resources = [];
  constructor(sessionId, target, executionContexts, scripts, resources, connection) {
    super(connection);
    this.sessionId = sessionId;
    this.target = target;
    this.executionContexts = executionContexts;
    this.scripts = scripts;
    this.resources = resources;
  }
  sendMessageToFrontend(payload, attachSessionId = true) {
    if (this.sessionId !== 0 && attachSessionId) {
      payload.sessionId = this.sessionId;
    }
    super.sendMessageToFrontend(payload);
  }
  handleFrontendMessageAsFakeCDPAgent(data) {
    switch (data.method) {
      case "Runtime.enable":
        this.handleRuntimeEnabled(data.id);
        break;
      case "Debugger.enable":
        this.handleDebuggerEnable(data.id);
        break;
      case "CSS.enable":
        this.sendMessageToFrontend({
          id: data.id,
          result: {}
        });
        break;
      case "Debugger.getScriptSource":
        if (data.params) {
          const params = data.params;
          this.handleDebuggerGetScriptSource(data.id, params.scriptId);
        }
        break;
      case "Page.getResourceTree":
        this.handleGetResourceTree(data.id);
        break;
      case "Page.getResourceContent": {
        const request = data.params;
        this.handleGetResourceContent(request.frameId, request.url, data.id);
        break;
      }
      case "CSS.getStyleSheetText": {
        const request = data.params;
        this.handleGetStyleSheetText(request.styleSheetId, data.id);
        break;
      }
      default:
        this.sendMessageToFrontend({
          id: data.id,
          result: {}
        });
        break;
    }
  }
  declareSessionAttachedToTarget() {
    this.sendMessageToFrontend(
      {
        method: "Target.attachedToTarget",
        params: {
          sessionId: this.sessionId,
          waitingForDebugger: false,
          targetInfo: {
            targetId: this.target.targetId,
            type: this.target.type,
            title: this.target.url,
            url: this.target.url,
            attached: true,
            canAccessOpener: false
          }
        }
      },
      /* attachSessionId */
      false
    );
  }
  // Runtime.Enable indicates that Runtime domain is flushing the event to communicate
  // the current state with the backend. In rehydrating connection, we made up the artificial
  // execution context to support the rehydrated session.
  handleRuntimeEnabled(id) {
    for (const executionContext of this.executionContexts) {
      executionContext.name = executionContext.origin;
      this.sendMessageToFrontend({
        method: "Runtime.executionContextCreated",
        params: {
          context: executionContext
        }
      });
    }
    this.sendMessageToFrontend({
      id,
      result: {}
    });
  }
  handleDebuggerGetScriptSource(id, scriptId) {
    const script = this.scripts.find((script2) => script2.scriptId === scriptId);
    if (!script) {
      console.error("No script for id: " + scriptId);
      return;
    }
    this.sendMessageToFrontend({
      id,
      result: {
        scriptSource: typeof script.sourceText === "undefined" ? i18nString10(UIStrings10.noSourceText) : script.sourceText
      }
    });
  }
  // Debugger.Enable indicates that Debugger domain is flushing the event to communicate
  // the current state with the backend. In rehydrating connection, we made up the artificial
  // script parsed event to communicate the current script state and respond with a mock
  // debugger id.
  handleDebuggerEnable(id) {
    const htmlResourceUrls = new Set(this.resources.filter((r) => r.mimeType === "text/html").map((r) => r.url));
    for (const script of this.scripts) {
      if (htmlResourceUrls.has(script.url)) {
        script.embedderName = script.url;
        script.startColumn = 1;
        script.startLine = 1;
        script.endColumn = 1;
        script.endLine = 1;
      }
      this.sendMessageToFrontend({
        method: "Debugger.scriptParsed",
        params: script
      });
    }
    const mockDebuggerId = "7777777777777777777.8888888888888888888";
    this.sendMessageToFrontend({
      id,
      result: {
        debuggerId: mockDebuggerId
      }
    });
  }
  handleGetResourceTree(id) {
    const resources = this.resources.filter((r) => r.mimeType === "text/html" || r.mimeType === "text/css");
    if (!resources.length) {
      return;
    }
    const frameTree = {
      frame: {
        id: this.target.targetId,
        url: this.target.url
      },
      childFrames: [],
      resources: resources.map((r) => ({
        url: r.url,
        type: r.mimeType === "text/html" ? "Document" : "Stylesheet",
        mimeType: r.mimeType,
        contentSize: r.content.length
      }))
    };
    this.sendMessageToFrontend({
      id,
      result: {
        frameTree
      }
    });
    const stylesheets = this.resources.filter((r) => r.mimeType === "text/css");
    for (const stylesheet of stylesheets) {
      this.sendMessageToFrontend({
        method: "CSS.styleSheetAdded",
        params: {
          header: {
            styleSheetId: `sheet.${stylesheet.frame}.${stylesheet.url}`,
            frameId: stylesheet.frame,
            sourceURL: stylesheet.url
          }
        }
      });
    }
  }
  handleGetResourceContent(frame, url, id) {
    const resource = this.resources.find((r) => r.frame === frame && r.url === url);
    if (!resource) {
      return;
    }
    this.sendMessageToFrontend({
      id,
      result: {
        content: resource.content,
        base64Encoded: false
      }
    });
  }
  handleGetStyleSheetText(stylesheetId, id) {
    const resource = this.resources.find((r) => `sheet.${r.frame}.${r.url}` === stylesheetId);
    if (!resource) {
      return;
    }
    this.sendMessageToFrontend({
      id,
      result: {
        text: resource.content
      }
    });
  }
};

// gen/front_end/core/sdk/Connections.js
var UIStrings11 = {
  /**
   * @description Text on the remote debugging window to indicate the connection is lost
   */
  websocketDisconnected: "WebSocket disconnected"
};
var str_11 = i18n25.i18n.registerUIStrings("core/sdk/Connections.ts", UIStrings11);
var i18nString11 = i18n25.i18n.getLocalizedString.bind(void 0, str_11);
var MainConnection = class {
  onMessage = null;
  #onDisconnect = null;
  #messageBuffer = "";
  #messageSize = 0;
  #eventListeners;
  constructor() {
    this.#eventListeners = [
      Host8.InspectorFrontendHost.InspectorFrontendHostInstance.events.addEventListener(Host8.InspectorFrontendHostAPI.Events.DispatchMessage, this.dispatchMessage, this),
      Host8.InspectorFrontendHost.InspectorFrontendHostInstance.events.addEventListener(Host8.InspectorFrontendHostAPI.Events.DispatchMessageChunk, this.dispatchMessageChunk, this)
    ];
  }
  setOnMessage(onMessage) {
    this.onMessage = onMessage;
  }
  setOnDisconnect(onDisconnect) {
    this.#onDisconnect = onDisconnect;
  }
  sendRawMessage(message) {
    if (this.onMessage) {
      Host8.InspectorFrontendHost.InspectorFrontendHostInstance.sendMessageToBackend(message);
    }
  }
  dispatchMessage(event) {
    if (this.onMessage) {
      this.onMessage.call(null, event.data);
    }
  }
  dispatchMessageChunk(event) {
    const { messageChunk, messageSize } = event.data;
    if (messageSize) {
      this.#messageBuffer = "";
      this.#messageSize = messageSize;
    }
    this.#messageBuffer += messageChunk;
    if (this.#messageBuffer.length === this.#messageSize && this.onMessage) {
      this.onMessage.call(null, this.#messageBuffer);
      this.#messageBuffer = "";
      this.#messageSize = 0;
    }
  }
  async disconnect() {
    const onDisconnect = this.#onDisconnect;
    Common33.EventTarget.removeEventListeners(this.#eventListeners);
    this.#onDisconnect = null;
    this.onMessage = null;
    if (onDisconnect) {
      onDisconnect.call(null, "force disconnect");
    }
  }
};
var WebSocketConnection = class {
  #socket;
  onMessage = null;
  #onDisconnect = null;
  #onWebSocketDisconnect;
  #connected = false;
  #messages = [];
  constructor(url, onWebSocketDisconnect) {
    this.#socket = new WebSocket(url);
    this.#socket.onerror = this.onError.bind(this);
    this.#socket.onopen = this.onOpen.bind(this);
    this.#socket.onmessage = (messageEvent) => {
      if (this.onMessage) {
        this.onMessage.call(null, messageEvent.data);
      }
    };
    this.#socket.onclose = this.onClose.bind(this);
    this.#onWebSocketDisconnect = onWebSocketDisconnect;
  }
  setOnMessage(onMessage) {
    this.onMessage = onMessage;
  }
  setOnDisconnect(onDisconnect) {
    this.#onDisconnect = onDisconnect;
  }
  onError() {
    if (this.#onWebSocketDisconnect) {
      this.#onWebSocketDisconnect.call(null, i18nString11(UIStrings11.websocketDisconnected));
    }
    if (this.#onDisconnect) {
      this.#onDisconnect.call(null, "connection failed");
    }
    this.close();
  }
  onOpen() {
    this.#connected = true;
    if (this.#socket) {
      this.#socket.onerror = console.error;
      for (const message of this.#messages) {
        this.#socket.send(message);
      }
    }
    this.#messages = [];
  }
  onClose() {
    if (this.#onWebSocketDisconnect) {
      this.#onWebSocketDisconnect.call(null, i18nString11(UIStrings11.websocketDisconnected));
    }
    if (this.#onDisconnect) {
      this.#onDisconnect.call(null, "websocket closed");
    }
    this.close();
  }
  close(callback) {
    if (this.#socket) {
      this.#socket.onerror = null;
      this.#socket.onopen = null;
      this.#socket.onclose = callback || null;
      this.#socket.onmessage = null;
      this.#socket.close();
      this.#socket = null;
    }
    this.#onWebSocketDisconnect = null;
  }
  sendRawMessage(message) {
    if (this.#connected && this.#socket) {
      this.#socket.send(message);
    } else {
      this.#messages.push(message);
    }
  }
  disconnect() {
    return new Promise((fulfill) => {
      this.close(() => {
        if (this.#onDisconnect) {
          this.#onDisconnect.call(null, "force disconnect");
        }
        fulfill();
      });
    });
  }
};
var StubConnection = class {
  onMessage = null;
  #onDisconnect = null;
  setOnMessage(onMessage) {
    this.onMessage = onMessage;
  }
  setOnDisconnect(onDisconnect) {
    this.#onDisconnect = onDisconnect;
  }
  sendRawMessage(message) {
    window.setTimeout(this.respondWithError.bind(this, message), 0);
  }
  respondWithError(message) {
    const messageObject = JSON.parse(message);
    const error = {
      message: "This is a stub connection, can't dispatch message.",
      code: ProtocolClient2.InspectorBackend.DevToolsStubErrorCode,
      data: messageObject
    };
    if (this.onMessage) {
      this.onMessage.call(null, { id: messageObject.id, error });
    }
  }
  async disconnect() {
    if (this.#onDisconnect) {
      this.#onDisconnect.call(null, "force disconnect");
    }
    this.#onDisconnect = null;
    this.onMessage = null;
  }
};
var ParallelConnection = class {
  #connection;
  #sessionId;
  onMessage = null;
  #onDisconnect = null;
  constructor(connection, sessionId) {
    this.#connection = connection;
    this.#sessionId = sessionId;
  }
  setOnMessage(onMessage) {
    this.onMessage = onMessage;
  }
  setOnDisconnect(onDisconnect) {
    this.#onDisconnect = onDisconnect;
  }
  getOnDisconnect() {
    return this.#onDisconnect;
  }
  sendRawMessage(message) {
    const messageObject = JSON.parse(message);
    if (!messageObject.sessionId) {
      messageObject.sessionId = this.#sessionId;
    }
    this.#connection.sendRawMessage(JSON.stringify(messageObject));
  }
  getSessionId() {
    return this.#sessionId;
  }
  async disconnect() {
    if (this.#onDisconnect) {
      this.#onDisconnect.call(null, "force disconnect");
    }
    this.#onDisconnect = null;
    this.onMessage = null;
  }
};
async function initMainConnection(createRootTarget, onConnectionLost) {
  ProtocolClient2.ConnectionTransport.ConnectionTransport.setFactory(createMainConnection.bind(null, onConnectionLost));
  await createRootTarget();
  Host8.InspectorFrontendHost.InspectorFrontendHostInstance.connectionReady();
}
function createMainConnection(onConnectionLost) {
  if (Root11.Runtime.Runtime.isTraceApp()) {
    return new RehydratingConnection(onConnectionLost);
  }
  const wsParam = Root11.Runtime.Runtime.queryParam("ws");
  const wssParam = Root11.Runtime.Runtime.queryParam("wss");
  if (wsParam || wssParam) {
    const ws = wsParam ? `ws://${wsParam}` : `wss://${wssParam}`;
    return new WebSocketConnection(ws, onConnectionLost);
  }
  const notEmbeddedOrWs = Host8.InspectorFrontendHost.InspectorFrontendHostInstance.isHostedMode();
  if (notEmbeddedOrWs) {
    return new StubConnection();
  }
  return new MainConnection();
}

// gen/front_end/core/sdk/ChildTargetManager.js
var UIStrings12 = {
  /**
   * @description Text that refers to the main target. The main target is the primary webpage that
   * DevTools is connected to. This text is used in various places in the UI as a label/name to inform
   * the user which target/webpage they are currently connected to, as DevTools may connect to multiple
   * targets at the same time in some scenarios.
   */
  main: "Main"
};
var str_12 = i18n27.i18n.registerUIStrings("core/sdk/ChildTargetManager.ts", UIStrings12);
var i18nString12 = i18n27.i18n.getLocalizedString.bind(void 0, str_12);
var ChildTargetManager = class _ChildTargetManager extends SDKModel {
  #targetManager;
  #parentTarget;
  #targetAgent;
  #targetInfos = /* @__PURE__ */ new Map();
  #childTargetsBySessionId = /* @__PURE__ */ new Map();
  #childTargetsById = /* @__PURE__ */ new Map();
  #parallelConnections = /* @__PURE__ */ new Map();
  #parentTargetId = null;
  constructor(parentTarget) {
    super(parentTarget);
    this.#targetManager = parentTarget.targetManager();
    this.#parentTarget = parentTarget;
    this.#targetAgent = parentTarget.targetAgent();
    parentTarget.registerTargetDispatcher(this);
    const browserTarget = this.#targetManager.browserTarget();
    if (browserTarget) {
      if (browserTarget !== parentTarget) {
        void browserTarget.targetAgent().invoke_autoAttachRelated({ targetId: parentTarget.id(), waitForDebuggerOnStart: true });
      }
    } else if (parentTarget.type() === Type.NODE) {
      void this.#targetAgent.invoke_setAutoAttach({ autoAttach: true, waitForDebuggerOnStart: true, flatten: false });
    } else {
      void this.#targetAgent.invoke_setAutoAttach({ autoAttach: true, waitForDebuggerOnStart: true, flatten: true });
    }
    if (parentTarget.parentTarget()?.type() !== Type.FRAME && !Host9.InspectorFrontendHost.isUnderTest()) {
      void this.#targetAgent.invoke_setDiscoverTargets({ discover: true });
      void this.#targetAgent.invoke_setRemoteLocations({ locations: [{ host: "localhost", port: 9229 }] });
    }
  }
  static install(attachCallback) {
    _ChildTargetManager.attachCallback = attachCallback;
    SDKModel.register(_ChildTargetManager, { capabilities: 32, autostart: true });
  }
  childTargets() {
    return Array.from(this.#childTargetsBySessionId.values());
  }
  async suspendModel() {
    await this.#targetAgent.invoke_setAutoAttach({ autoAttach: true, waitForDebuggerOnStart: false, flatten: true });
  }
  async resumeModel() {
    await this.#targetAgent.invoke_setAutoAttach({ autoAttach: true, waitForDebuggerOnStart: true, flatten: true });
  }
  dispose() {
    for (const sessionId of this.#childTargetsBySessionId.keys()) {
      this.detachedFromTarget({ sessionId, targetId: void 0 });
    }
  }
  targetCreated({ targetInfo }) {
    this.#targetInfos.set(targetInfo.targetId, targetInfo);
    this.fireAvailableTargetsChanged();
    this.dispatchEventToListeners("TargetCreated", targetInfo);
  }
  targetInfoChanged({ targetInfo }) {
    this.#targetInfos.set(targetInfo.targetId, targetInfo);
    const target = this.#childTargetsById.get(targetInfo.targetId);
    if (target) {
      void target.setHasCrashed(false);
      if (target.targetInfo()?.subtype === "prerender" && !targetInfo.subtype) {
        const resourceTreeModel = target.model(ResourceTreeModel);
        target.updateTargetInfo(targetInfo);
        if (resourceTreeModel?.mainFrame) {
          resourceTreeModel.primaryPageChanged(
            resourceTreeModel.mainFrame,
            "Activation"
            /* PrimaryPageChangeType.ACTIVATION */
          );
        }
        target.setName(i18nString12(UIStrings12.main));
      } else {
        target.updateTargetInfo(targetInfo);
      }
    }
    this.fireAvailableTargetsChanged();
    this.dispatchEventToListeners("TargetInfoChanged", targetInfo);
  }
  targetDestroyed({ targetId }) {
    this.#targetInfos.delete(targetId);
    this.fireAvailableTargetsChanged();
    this.dispatchEventToListeners("TargetDestroyed", targetId);
  }
  targetCrashed({ targetId }) {
    const target = this.#childTargetsById.get(targetId);
    if (target) {
      target.setHasCrashed(true);
    }
  }
  fireAvailableTargetsChanged() {
    TargetManager.instance().dispatchEventToListeners("AvailableTargetsChanged", [...this.#targetInfos.values()]);
  }
  async getParentTargetId() {
    if (!this.#parentTargetId) {
      this.#parentTargetId = (await this.#parentTarget.targetAgent().invoke_getTargetInfo({})).targetInfo.targetId;
    }
    return this.#parentTargetId;
  }
  async getTargetInfo() {
    return (await this.#parentTarget.targetAgent().invoke_getTargetInfo({})).targetInfo;
  }
  async attachedToTarget({ sessionId, targetInfo, waitingForDebugger }) {
    if (this.#parentTargetId === targetInfo.targetId) {
      return;
    }
    let type = Type.BROWSER;
    let targetName = "";
    if (targetInfo.type === "worker" && targetInfo.title && targetInfo.title !== targetInfo.url) {
      targetName = targetInfo.title;
    } else if (!["page", "iframe", "webview"].includes(targetInfo.type)) {
      const KNOWN_FRAME_PATTERNS = [
        "^chrome://print/$",
        "^chrome://file-manager/",
        "^chrome://feedback/",
        "^chrome://.*\\.top-chrome/$",
        "^chrome://view-cert/$",
        "^devtools://"
      ];
      if (KNOWN_FRAME_PATTERNS.some((p) => targetInfo.url.match(p))) {
        type = Type.FRAME;
      } else {
        const parsedURL = Common34.ParsedURL.ParsedURL.fromString(targetInfo.url);
        targetName = parsedURL ? parsedURL.lastPathComponentWithFragment() : "#" + ++_ChildTargetManager.lastAnonymousTargetId;
      }
    }
    if (targetInfo.type === "iframe" || targetInfo.type === "webview") {
      type = Type.FRAME;
    } else if (targetInfo.type === "background_page" || targetInfo.type === "app" || targetInfo.type === "popup_page") {
      type = Type.FRAME;
    } else if (targetInfo.type === "page") {
      type = Type.FRAME;
    } else if (targetInfo.type === "browser_ui") {
      type = Type.FRAME;
    } else if (targetInfo.type === "worker") {
      type = Type.Worker;
    } else if (targetInfo.type === "worklet") {
      type = Type.WORKLET;
    } else if (targetInfo.type === "shared_worker") {
      type = Type.SHARED_WORKER;
    } else if (targetInfo.type === "shared_storage_worklet") {
      type = Type.SHARED_STORAGE_WORKLET;
    } else if (targetInfo.type === "service_worker") {
      type = Type.ServiceWorker;
    } else if (targetInfo.type === "auction_worklet") {
      type = Type.AUCTION_WORKLET;
    } else if (targetInfo.type === "node_worker") {
      type = Type.NODE_WORKER;
    }
    const target = this.#targetManager.createTarget(targetInfo.targetId, targetName, type, this.#parentTarget, sessionId, void 0, void 0, targetInfo);
    this.#childTargetsBySessionId.set(sessionId, target);
    this.#childTargetsById.set(target.id(), target);
    if (_ChildTargetManager.attachCallback) {
      await _ChildTargetManager.attachCallback({ target, waitingForDebugger });
    }
    if (waitingForDebugger) {
      void target.runtimeAgent().invoke_runIfWaitingForDebugger();
    }
    if (type !== Type.FRAME && target.hasAllCapabilities(
      8192
      /* Capability.STORAGE */
    )) {
      await this.initializeStorage(target);
    }
  }
  async initializeStorage(target) {
    const storageAgent = target.storageAgent();
    const response = await storageAgent.invoke_getStorageKey({});
    const storageKey = response.storageKey;
    if (response.getError() || !storageKey) {
      console.error(`Failed to get storage key for target ${target.id()}: ${response.getError()}`);
      return;
    }
    const storageKeyManager = target.model(StorageKeyManager);
    if (storageKeyManager) {
      storageKeyManager.setMainStorageKey(storageKey);
      storageKeyManager.updateStorageKeys(/* @__PURE__ */ new Set([storageKey]));
    }
    const securityOriginManager = target.model(SecurityOriginManager);
    if (securityOriginManager) {
      const origin = new URL(storageKey).origin;
      securityOriginManager.setMainSecurityOrigin(origin, "");
      securityOriginManager.updateSecurityOrigins(/* @__PURE__ */ new Set([origin]));
    }
  }
  detachedFromTarget({ sessionId }) {
    if (this.#parallelConnections.has(sessionId)) {
      this.#parallelConnections.delete(sessionId);
    } else {
      const target = this.#childTargetsBySessionId.get(sessionId);
      if (target) {
        target.dispose("target terminated");
        this.#childTargetsBySessionId.delete(sessionId);
        this.#childTargetsById.delete(target.id());
      }
    }
  }
  receivedMessageFromTarget({}) {
  }
  async createParallelConnection(onMessage) {
    const targetId = await this.getParentTargetId();
    const { connection, sessionId } = await this.createParallelConnectionAndSessionForTarget(this.#parentTarget, targetId);
    connection.setOnMessage(onMessage);
    this.#parallelConnections.set(sessionId, connection);
    return { connection, sessionId };
  }
  async createParallelConnectionAndSessionForTarget(target, targetId) {
    const targetAgent = target.targetAgent();
    const targetRouter = target.router();
    const sessionId = (await targetAgent.invoke_attachToTarget({ targetId, flatten: true })).sessionId;
    const connection = new ParallelConnection(targetRouter.connection(), sessionId);
    targetRouter.registerSession(target, sessionId, connection);
    connection.setOnDisconnect(() => {
      targetRouter.unregisterSession(sessionId);
      void targetAgent.invoke_detachFromTarget({ sessionId });
    });
    return { connection, sessionId };
  }
  targetInfos() {
    return Array.from(this.#targetInfos.values());
  }
  static lastAnonymousTargetId = 0;
  static attachCallback;
};

// gen/front_end/core/sdk/CompilerSourceMappingContentProvider.js
var CompilerSourceMappingContentProvider_exports = {};
__export(CompilerSourceMappingContentProvider_exports, {
  CompilerSourceMappingContentProvider: () => CompilerSourceMappingContentProvider
});
import * as TextUtils25 from "./../../models/text_utils/text_utils.js";
import * as i18n29 from "./../i18n/i18n.js";
var UIStrings13 = {
  /**
   * @description Error message when failing to fetch a resource referenced in a source map
   * @example {https://example.com/sourcemap.map} PH1
   * @example {An error occurred} PH2
   */
  couldNotLoadContentForSS: "Could not load content for {PH1} ({PH2})"
};
var str_13 = i18n29.i18n.registerUIStrings("core/sdk/CompilerSourceMappingContentProvider.ts", UIStrings13);
var i18nString13 = i18n29.i18n.getLocalizedString.bind(void 0, str_13);
var CompilerSourceMappingContentProvider = class {
  #sourceURL;
  #contentType;
  #initiator;
  constructor(sourceURL, contentType, initiator) {
    this.#sourceURL = sourceURL;
    this.#contentType = contentType;
    this.#initiator = initiator;
  }
  contentURL() {
    return this.#sourceURL;
  }
  contentType() {
    return this.#contentType;
  }
  async requestContentData() {
    try {
      const { content } = await PageResourceLoader.instance().loadResource(this.#sourceURL, this.#initiator);
      return new TextUtils25.ContentData.ContentData(
        content,
        /* isBase64=*/
        false,
        this.#contentType.canonicalMimeType()
      );
    } catch (e) {
      const error = i18nString13(UIStrings13.couldNotLoadContentForSS, { PH1: this.#sourceURL, PH2: e.message });
      console.error(error);
      return { error };
    }
  }
  async searchInContent(query, caseSensitive, isRegex) {
    const contentData = await this.requestContentData();
    return TextUtils25.TextUtils.performSearchInContentData(contentData, query, caseSensitive, isRegex);
  }
};

// gen/front_end/core/sdk/ConsoleModel.js
var ConsoleModel_exports = {};
__export(ConsoleModel_exports, {
  ConsoleMessage: () => ConsoleMessage,
  ConsoleModel: () => ConsoleModel,
  Events: () => Events11,
  FrontendMessageType: () => FrontendMessageType,
  MessageSourceDisplayName: () => MessageSourceDisplayName
});
import * as Common35 from "./../common/common.js";
import * as Host11 from "./../host/host.js";
import * as i18n33 from "./../i18n/i18n.js";
import * as Platform19 from "./../platform/platform.js";

// gen/front_end/core/sdk/ConsoleModelTypes.js
var FrontendMessageType;
(function(FrontendMessageType2) {
  FrontendMessageType2["Result"] = "result";
  FrontendMessageType2["Command"] = "command";
  FrontendMessageType2["System"] = "system";
  FrontendMessageType2["QueryObjectResult"] = "queryObjectResult";
})(FrontendMessageType || (FrontendMessageType = {}));

// gen/front_end/core/sdk/CPUProfilerModel.js
var CPUProfilerModel_exports = {};
__export(CPUProfilerModel_exports, {
  CPUProfilerModel: () => CPUProfilerModel
});
import * as i18n31 from "./../i18n/i18n.js";
var UIStrings14 = {
  /**
   * @description Name of a profile. Placeholder is either a user-supplied name or a number automatically assigned to the profile.
   * @example {2} PH1
   */
  profileD: "Profile {PH1}"
};
var str_14 = i18n31.i18n.registerUIStrings("core/sdk/CPUProfilerModel.ts", UIStrings14);
var i18nString14 = i18n31.i18n.getLocalizedString.bind(void 0, str_14);
var CPUProfilerModel = class extends SDKModel {
  #nextAnonymousConsoleProfileNumber;
  #anonymousConsoleProfileIdToTitle;
  #profilerAgent;
  #preciseCoverageDeltaUpdateCallback;
  #debuggerModel;
  registeredConsoleProfileMessages = [];
  constructor(target) {
    super(target);
    this.#nextAnonymousConsoleProfileNumber = 1;
    this.#anonymousConsoleProfileIdToTitle = /* @__PURE__ */ new Map();
    this.#profilerAgent = target.profilerAgent();
    this.#preciseCoverageDeltaUpdateCallback = null;
    target.registerProfilerDispatcher(this);
    void this.#profilerAgent.invoke_enable();
    this.#debuggerModel = target.model(DebuggerModel);
  }
  runtimeModel() {
    return this.#debuggerModel.runtimeModel();
  }
  debuggerModel() {
    return this.#debuggerModel;
  }
  consoleProfileStarted({ id, location, title }) {
    if (!title) {
      title = i18nString14(UIStrings14.profileD, { PH1: this.#nextAnonymousConsoleProfileNumber++ });
      this.#anonymousConsoleProfileIdToTitle.set(id, title);
    }
    const eventData = this.createEventDataFrom(id, location, title);
    this.dispatchEventToListeners("ConsoleProfileStarted", eventData);
  }
  consoleProfileFinished({ id, location, profile, title }) {
    if (!title) {
      title = this.#anonymousConsoleProfileIdToTitle.get(id);
      this.#anonymousConsoleProfileIdToTitle.delete(id);
    }
    const eventData = {
      ...this.createEventDataFrom(id, location, title),
      cpuProfile: profile
    };
    this.registeredConsoleProfileMessages.push(eventData);
    this.dispatchEventToListeners("ConsoleProfileFinished", eventData);
  }
  createEventDataFrom(id, scriptLocation, title) {
    const debuggerLocation = Location.fromPayload(this.#debuggerModel, scriptLocation);
    const globalId = this.target().id() + "." + id;
    return {
      id: globalId,
      scriptLocation: debuggerLocation,
      title: title || "",
      cpuProfilerModel: this
    };
  }
  startRecording() {
    const intervalUs = 100;
    void this.#profilerAgent.invoke_setSamplingInterval({ interval: intervalUs });
    return this.#profilerAgent.invoke_start();
  }
  stopRecording() {
    return this.#profilerAgent.invoke_stop().then((response) => response.profile || null);
  }
  startPreciseCoverage(jsCoveragePerBlock, preciseCoverageDeltaUpdateCallback) {
    const callCount = false;
    this.#preciseCoverageDeltaUpdateCallback = preciseCoverageDeltaUpdateCallback;
    const allowUpdatesTriggeredByBackend = true;
    return this.#profilerAgent.invoke_startPreciseCoverage({ callCount, detailed: jsCoveragePerBlock, allowTriggeredUpdates: allowUpdatesTriggeredByBackend });
  }
  async takePreciseCoverage() {
    const r = await this.#profilerAgent.invoke_takePreciseCoverage();
    const timestamp = r?.timestamp || 0;
    const coverage = r?.result || [];
    return { timestamp, coverage };
  }
  stopPreciseCoverage() {
    this.#preciseCoverageDeltaUpdateCallback = null;
    return this.#profilerAgent.invoke_stopPreciseCoverage();
  }
  preciseCoverageDeltaUpdate({ timestamp, result }) {
    if (this.#preciseCoverageDeltaUpdateCallback) {
      void this.#preciseCoverageDeltaUpdateCallback(timestamp, result);
    }
  }
};
SDKModel.register(CPUProfilerModel, { capabilities: 4, autostart: true });

// gen/front_end/core/sdk/LogModel.js
var LogModel_exports = {};
__export(LogModel_exports, {
  LogModel: () => LogModel
});
import * as Host10 from "./../host/host.js";
var LogModel = class extends SDKModel {
  #logAgent;
  constructor(target) {
    super(target);
    target.registerLogDispatcher(this);
    this.#logAgent = target.logAgent();
    void this.#logAgent.invoke_enable();
    if (!Host10.InspectorFrontendHost.isUnderTest()) {
      void this.#logAgent.invoke_startViolationsReport({
        config: [
          { name: "longTask", threshold: 200 },
          { name: "longLayout", threshold: 30 },
          { name: "blockedEvent", threshold: 100 },
          { name: "blockedParser", threshold: -1 },
          { name: "handler", threshold: 150 },
          { name: "recurringHandler", threshold: 50 },
          { name: "discouragedAPIUse", threshold: -1 }
        ]
      });
    }
  }
  entryAdded({ entry }) {
    this.dispatchEventToListeners("EntryAdded", { logModel: this, entry });
  }
  requestClear() {
    void this.#logAgent.invoke_clear();
  }
};
SDKModel.register(LogModel, { capabilities: 8, autostart: true });

// gen/front_end/core/sdk/ConsoleModel.js
var UIStrings15 = {
  /**
   * @description Text shown when the main frame (page) of the website was navigated to a different URL.
   * @example {https://example.com} PH1
   */
  navigatedToS: "Navigated to {PH1}",
  /**
   * @description Text shown when the main frame (page) of the website was navigated to a different URL
   * and the page was restored from back/forward cache (https://web.dev/bfcache/).
   * @example {https://example.com} PH1
   */
  bfcacheNavigation: "Navigation to {PH1} was restored from back/forward cache (see https://web.dev/bfcache/)",
  /**
   * @description Text shown in the console when a performance profile (with the given name) was started.
   * @example {title} PH1
   */
  profileSStarted: "Profile ''{PH1}'' started.",
  /**
   * @description Text shown in the console when a performance profile (with the given name) was stopped.
   * @example {name} PH1
   */
  profileSFinished: "Profile ''{PH1}'' finished.",
  /**
   * @description Error message shown in the console after the user tries to save a JavaScript value to a temporary variable.
   */
  failedToSaveToTempVariable: "Failed to save to temp variable."
};
var str_15 = i18n33.i18n.registerUIStrings("core/sdk/ConsoleModel.ts", UIStrings15);
var i18nString15 = i18n33.i18n.getLocalizedString.bind(void 0, str_15);
var ConsoleModel = class _ConsoleModel extends SDKModel {
  #messages = [];
  #messagesByTimestamp = new Platform19.MapUtilities.Multimap();
  #messageByExceptionId = /* @__PURE__ */ new Map();
  #warnings = 0;
  #errors = 0;
  #violations = 0;
  #pageLoadSequenceNumber = 0;
  #targetListeners = /* @__PURE__ */ new WeakMap();
  constructor(target) {
    super(target);
    const resourceTreeModel = target.model(ResourceTreeModel);
    if (!resourceTreeModel || resourceTreeModel.cachedResourcesLoaded()) {
      this.initTarget(target);
      return;
    }
    const eventListener = resourceTreeModel.addEventListener(Events3.CachedResourcesLoaded, () => {
      Common35.EventTarget.removeEventListeners([eventListener]);
      this.initTarget(target);
    });
  }
  initTarget(target) {
    const eventListeners = [];
    const cpuProfilerModel = target.model(CPUProfilerModel);
    if (cpuProfilerModel) {
      eventListeners.push(cpuProfilerModel.addEventListener("ConsoleProfileStarted", this.consoleProfileStarted.bind(this, cpuProfilerModel)));
      eventListeners.push(cpuProfilerModel.addEventListener("ConsoleProfileFinished", this.consoleProfileFinished.bind(this, cpuProfilerModel)));
    }
    const resourceTreeModel = target.model(ResourceTreeModel);
    if (resourceTreeModel && target.parentTarget()?.type() !== Type.FRAME) {
      eventListeners.push(resourceTreeModel.addEventListener(Events3.PrimaryPageChanged, this.primaryPageChanged, this));
    }
    const runtimeModel = target.model(RuntimeModel);
    if (runtimeModel) {
      eventListeners.push(runtimeModel.addEventListener(Events6.ExceptionThrown, this.exceptionThrown.bind(this, runtimeModel)));
      eventListeners.push(runtimeModel.addEventListener(Events6.ExceptionRevoked, this.exceptionRevoked.bind(this, runtimeModel)));
      eventListeners.push(runtimeModel.addEventListener(Events6.ConsoleAPICalled, this.consoleAPICalled.bind(this, runtimeModel)));
      if (target.parentTarget()?.type() !== Type.FRAME) {
        eventListeners.push(runtimeModel.debuggerModel().addEventListener(Events7.GlobalObjectCleared, this.clearIfNecessary, this));
      }
      eventListeners.push(runtimeModel.addEventListener(Events6.QueryObjectRequested, this.queryObjectRequested.bind(this, runtimeModel)));
    }
    this.#targetListeners.set(target, eventListeners);
  }
  targetRemoved(target) {
    const runtimeModel = target.model(RuntimeModel);
    if (runtimeModel) {
      this.#messageByExceptionId.delete(runtimeModel);
    }
    Common35.EventTarget.removeEventListeners(this.#targetListeners.get(target) || []);
  }
  async evaluateCommandInConsole(executionContext, originatingMessage, expression, useCommandLineAPI) {
    const result = await executionContext.evaluate(
      {
        expression,
        objectGroup: "console",
        includeCommandLineAPI: useCommandLineAPI,
        silent: false,
        returnByValue: false,
        generatePreview: true,
        replMode: true,
        allowUnsafeEvalBlockedByCSP: false
      },
      Common35.Settings.Settings.instance().moduleSetting("console-user-activation-eval").get(),
      /* awaitPromise */
      false
    );
    Host11.userMetrics.actionTaken(Host11.UserMetrics.Action.ConsoleEvaluated);
    if ("error" in result) {
      return;
    }
    await Common35.Console.Console.instance().showPromise();
    this.dispatchEventToListeners(Events11.CommandEvaluated, { result: result.object, commandMessage: originatingMessage, exceptionDetails: result.exceptionDetails });
  }
  addCommandMessage(executionContext, text) {
    const commandMessage = new ConsoleMessage(executionContext.runtimeModel, "javascript", null, text, { type: FrontendMessageType.Command });
    commandMessage.setExecutionContextId(executionContext.id);
    this.addMessage(commandMessage);
    return commandMessage;
  }
  addMessage(msg) {
    msg.setPageLoadSequenceNumber(this.#pageLoadSequenceNumber);
    if (msg.source === Common35.Console.FrontendMessageSource.ConsoleAPI && msg.type === "clear") {
      this.clearIfNecessary();
    }
    this.#messages.push(msg);
    this.#messagesByTimestamp.set(msg.timestamp, msg);
    const runtimeModel = msg.runtimeModel();
    const exceptionId = msg.getExceptionId();
    if (exceptionId && runtimeModel) {
      let modelMap = this.#messageByExceptionId.get(runtimeModel);
      if (!modelMap) {
        modelMap = /* @__PURE__ */ new Map();
        this.#messageByExceptionId.set(runtimeModel, modelMap);
      }
      modelMap.set(exceptionId, msg);
    }
    this.incrementErrorWarningCount(msg);
    this.dispatchEventToListeners(Events11.MessageAdded, msg);
  }
  exceptionThrown(runtimeModel, event) {
    const exceptionWithTimestamp = event.data;
    const affectedResources = extractExceptionMetaData(exceptionWithTimestamp.details.exceptionMetaData);
    const consoleMessage = ConsoleMessage.fromException(runtimeModel, exceptionWithTimestamp.details, void 0, exceptionWithTimestamp.timestamp, void 0, affectedResources);
    consoleMessage.setExceptionId(exceptionWithTimestamp.details.exceptionId);
    this.addMessage(consoleMessage);
  }
  exceptionRevoked(runtimeModel, event) {
    const exceptionId = event.data;
    const modelMap = this.#messageByExceptionId.get(runtimeModel);
    const exceptionMessage = modelMap ? modelMap.get(exceptionId) : null;
    if (!exceptionMessage) {
      return;
    }
    this.#errors--;
    exceptionMessage.level = "verbose";
    this.dispatchEventToListeners(Events11.MessageUpdated, exceptionMessage);
  }
  consoleAPICalled(runtimeModel, event) {
    const call = event.data;
    let level = "info";
    if (call.type === "debug") {
      level = "verbose";
    } else if (call.type === "error" || call.type === "assert") {
      level = "error";
    } else if (call.type === "warning") {
      level = "warning";
    } else if (call.type === "info" || call.type === "log") {
      level = "info";
    }
    let message = "";
    if (call.args.length && call.args[0].unserializableValue) {
      message = call.args[0].unserializableValue;
    } else if (call.args.length && (typeof call.args[0].value !== "object" && typeof call.args[0].value !== "undefined" || call.args[0].value === null)) {
      message = String(call.args[0].value);
    } else if (call.args.length && call.args[0].description) {
      message = call.args[0].description;
    }
    const callFrame = call.stackTrace?.callFrames.length ? call.stackTrace.callFrames[0] : null;
    const details = {
      type: call.type,
      url: callFrame?.url,
      line: callFrame?.lineNumber,
      column: callFrame?.columnNumber,
      parameters: call.args,
      stackTrace: call.stackTrace,
      timestamp: call.timestamp,
      executionContextId: call.executionContextId,
      context: call.context
    };
    const consoleMessage = new ConsoleMessage(runtimeModel, Common35.Console.FrontendMessageSource.ConsoleAPI, level, message, details);
    for (const msg of this.#messagesByTimestamp.get(consoleMessage.timestamp).values()) {
      if (consoleMessage.isEqual(msg)) {
        return;
      }
    }
    this.addMessage(consoleMessage);
  }
  queryObjectRequested(runtimeModel, event) {
    const { objects, executionContextId } = event.data;
    const details = {
      type: FrontendMessageType.QueryObjectResult,
      parameters: [objects],
      executionContextId
    };
    const consoleMessage = new ConsoleMessage(runtimeModel, Common35.Console.FrontendMessageSource.ConsoleAPI, "info", "", details);
    this.addMessage(consoleMessage);
  }
  clearIfNecessary() {
    if (!Common35.Settings.Settings.instance().moduleSetting("preserve-console-log").get()) {
      this.clear();
    }
    ++this.#pageLoadSequenceNumber;
  }
  primaryPageChanged(event) {
    if (Common35.Settings.Settings.instance().moduleSetting("preserve-console-log").get()) {
      const { frame } = event.data;
      if (frame.backForwardCacheDetails.restoredFromCache) {
        Common35.Console.Console.instance().log(i18nString15(UIStrings15.bfcacheNavigation, { PH1: frame.url }));
      } else {
        Common35.Console.Console.instance().log(i18nString15(UIStrings15.navigatedToS, { PH1: frame.url }));
      }
    }
  }
  consoleProfileStarted(cpuProfilerModel, event) {
    const { data } = event;
    this.addConsoleProfileMessage(cpuProfilerModel, "profile", data.scriptLocation, i18nString15(UIStrings15.profileSStarted, { PH1: data.title }));
  }
  consoleProfileFinished(cpuProfilerModel, event) {
    const { data } = event;
    this.addConsoleProfileMessage(cpuProfilerModel, "profileEnd", data.scriptLocation, i18nString15(UIStrings15.profileSFinished, { PH1: data.title }));
  }
  addConsoleProfileMessage(cpuProfilerModel, type, scriptLocation, messageText) {
    const script = scriptLocation.script();
    const callFrames = [{
      functionName: "",
      scriptId: scriptLocation.scriptId,
      url: script ? script.contentURL() : "",
      lineNumber: scriptLocation.lineNumber,
      columnNumber: scriptLocation.columnNumber || 0
    }];
    this.addMessage(new ConsoleMessage(cpuProfilerModel.runtimeModel(), Common35.Console.FrontendMessageSource.ConsoleAPI, "info", messageText, { type, stackTrace: { callFrames } }));
  }
  incrementErrorWarningCount(msg) {
    if (msg.source === "violation") {
      this.#violations++;
      return;
    }
    switch (msg.level) {
      case "warning":
        this.#warnings++;
        break;
      case "error":
        this.#errors++;
        break;
    }
  }
  messages() {
    return this.#messages;
  }
  // messages[] are not ordered by timestamp.
  static allMessagesUnordered() {
    const messages = [];
    for (const target of TargetManager.instance().targets()) {
      const targetMessages = target.model(_ConsoleModel)?.messages() || [];
      messages.push(...targetMessages);
    }
    return messages;
  }
  static requestClearMessages() {
    for (const logModel of TargetManager.instance().models(LogModel)) {
      logModel.requestClear();
    }
    for (const runtimeModel of TargetManager.instance().models(RuntimeModel)) {
      runtimeModel.discardConsoleEntries();
      runtimeModel.releaseObjectGroup("live-expression");
    }
    for (const target of TargetManager.instance().targets()) {
      target.model(_ConsoleModel)?.clear();
    }
  }
  clear() {
    this.#messages = [];
    this.#messagesByTimestamp.clear();
    this.#messageByExceptionId.clear();
    this.#errors = 0;
    this.#warnings = 0;
    this.#violations = 0;
    this.dispatchEventToListeners(Events11.ConsoleCleared);
  }
  errors() {
    return this.#errors;
  }
  static allErrors() {
    let errors = 0;
    for (const target of TargetManager.instance().targets()) {
      errors += target.model(_ConsoleModel)?.errors() || 0;
    }
    return errors;
  }
  warnings() {
    return this.#warnings;
  }
  static allWarnings() {
    let warnings = 0;
    for (const target of TargetManager.instance().targets()) {
      warnings += target.model(_ConsoleModel)?.warnings() || 0;
    }
    return warnings;
  }
  violations() {
    return this.#violations;
  }
  async saveToTempVariable(currentExecutionContext, remoteObject) {
    if (!remoteObject || !currentExecutionContext) {
      failedToSave(null);
      return;
    }
    const executionContext = currentExecutionContext;
    const result = await executionContext.globalObject(
      /* objectGroup */
      "",
      /* generatePreview */
      false
    );
    if ("error" in result || Boolean(result.exceptionDetails) || !result.object) {
      failedToSave("object" in result && result.object || null);
      return;
    }
    const globalObject = result.object;
    const callFunctionResult = await globalObject.callFunction(saveVariable, [RemoteObject.toCallArgument(remoteObject)]);
    globalObject.release();
    if (callFunctionResult.wasThrown || !callFunctionResult.object || callFunctionResult.object.type !== "string") {
      failedToSave(callFunctionResult.object || null);
    } else {
      const text = callFunctionResult.object.value;
      const message = this.addCommandMessage(executionContext, text);
      void this.evaluateCommandInConsole(
        executionContext,
        message,
        text,
        /* useCommandLineAPI */
        false
      );
    }
    if (callFunctionResult.object) {
      callFunctionResult.object.release();
    }
    function saveVariable(value) {
      const prefix = "temp";
      let index = 1;
      while (prefix + index in this) {
        ++index;
      }
      const name = prefix + index;
      this[name] = value;
      return name;
    }
    function failedToSave(result2) {
      let message = i18nString15(UIStrings15.failedToSaveToTempVariable);
      if (result2) {
        message = message + " " + result2.description;
      }
      Common35.Console.Console.instance().error(message);
    }
  }
};
var Events11;
(function(Events12) {
  Events12["ConsoleCleared"] = "ConsoleCleared";
  Events12["MessageAdded"] = "MessageAdded";
  Events12["MessageUpdated"] = "MessageUpdated";
  Events12["CommandEvaluated"] = "CommandEvaluated";
})(Events11 || (Events11 = {}));
function extractExceptionMetaData(metaData) {
  if (!metaData) {
    return void 0;
  }
  return { requestId: metaData.requestId || void 0, issueId: metaData.issueId || void 0 };
}
function areAffectedResourcesEquivalent(a, b) {
  return a?.requestId === b?.requestId;
}
function areStackTracesEquivalent(stackTrace1, stackTrace2) {
  if (!stackTrace1 !== !stackTrace2) {
    return false;
  }
  if (!stackTrace1 || !stackTrace2) {
    return true;
  }
  const callFrames1 = stackTrace1.callFrames;
  const callFrames2 = stackTrace2.callFrames;
  if (callFrames1.length !== callFrames2.length) {
    return false;
  }
  for (let i = 0, n = callFrames1.length; i < n; ++i) {
    if (callFrames1[i].scriptId !== callFrames2[i].scriptId || callFrames1[i].functionName !== callFrames2[i].functionName || callFrames1[i].lineNumber !== callFrames2[i].lineNumber || callFrames1[i].columnNumber !== callFrames2[i].columnNumber) {
      return false;
    }
  }
  return areStackTracesEquivalent(stackTrace1.parent, stackTrace2.parent);
}
var ConsoleMessage = class _ConsoleMessage {
  #runtimeModel;
  source;
  level;
  messageText;
  type;
  url;
  line;
  column;
  parameters;
  stackTrace;
  timestamp;
  #executionContextId;
  scriptId;
  workerId;
  context;
  #originatingConsoleMessage = null;
  #pageLoadSequenceNumber = void 0;
  #exceptionId = void 0;
  #affectedResources;
  category;
  isCookieReportIssue = false;
  /**
   * The parent frame of the `console.log` call of logpoints or conditional breakpoints
   * if they called `console.*` explicitly. The parent frame is where V8 paused
   * and consequently where the logpoint is set.
   *
   * Is `null` for page console.logs, commands, command results, etc.
   */
  stackFrameWithBreakpoint = null;
  #originatingBreakpointType = null;
  constructor(runtimeModel, source, level, messageText, details) {
    this.#runtimeModel = runtimeModel;
    this.source = source;
    this.level = level;
    this.messageText = messageText;
    this.type = details?.type || "log";
    this.url = details?.url;
    this.line = details?.line || 0;
    this.column = details?.column || 0;
    this.parameters = details?.parameters;
    this.stackTrace = details?.stackTrace;
    this.timestamp = details?.timestamp || Date.now();
    this.#executionContextId = details?.executionContextId || 0;
    this.scriptId = details?.scriptId;
    this.workerId = details?.workerId;
    this.#affectedResources = details?.affectedResources;
    this.category = details?.category;
    this.isCookieReportIssue = Boolean(details?.isCookieReportIssue);
    if (!this.#executionContextId && this.#runtimeModel) {
      if (this.scriptId) {
        this.#executionContextId = this.#runtimeModel.executionContextIdForScriptId(this.scriptId);
      } else if (this.stackTrace) {
        this.#executionContextId = this.#runtimeModel.executionContextForStackTrace(this.stackTrace);
      }
    }
    if (details?.context) {
      const match = details?.context.match(/[^#]*/);
      this.context = match?.[0];
    }
    if (this.stackTrace) {
      const { callFrame, type } = _ConsoleMessage.#stackFrameWithBreakpoint(this.stackTrace);
      this.stackFrameWithBreakpoint = callFrame;
      this.#originatingBreakpointType = type;
    }
  }
  getAffectedResources() {
    return this.#affectedResources;
  }
  setPageLoadSequenceNumber(pageLoadSequenceNumber) {
    this.#pageLoadSequenceNumber = pageLoadSequenceNumber;
  }
  static fromException(runtimeModel, exceptionDetails, messageType, timestamp, forceUrl, affectedResources) {
    const details = {
      type: messageType,
      url: forceUrl || exceptionDetails.url,
      line: exceptionDetails.lineNumber,
      column: exceptionDetails.columnNumber,
      parameters: exceptionDetails.exception ? [RemoteObject.fromLocalObject(exceptionDetails.text), exceptionDetails.exception] : void 0,
      stackTrace: exceptionDetails.stackTrace,
      timestamp,
      executionContextId: exceptionDetails.executionContextId,
      scriptId: exceptionDetails.scriptId,
      affectedResources
    };
    return new _ConsoleMessage(runtimeModel, "javascript", "error", RuntimeModel.simpleTextFromException(exceptionDetails), details);
  }
  runtimeModel() {
    return this.#runtimeModel;
  }
  target() {
    return this.#runtimeModel ? this.#runtimeModel.target() : null;
  }
  setOriginatingMessage(originatingMessage) {
    this.#originatingConsoleMessage = originatingMessage;
    this.#executionContextId = originatingMessage.#executionContextId;
  }
  originatingMessage() {
    return this.#originatingConsoleMessage;
  }
  setExecutionContextId(executionContextId) {
    this.#executionContextId = executionContextId;
  }
  getExecutionContextId() {
    return this.#executionContextId;
  }
  getExceptionId() {
    return this.#exceptionId;
  }
  setExceptionId(exceptionId) {
    this.#exceptionId = exceptionId;
  }
  isGroupMessage() {
    return this.type === "startGroup" || this.type === "startGroupCollapsed" || this.type === "endGroup";
  }
  isGroupStartMessage() {
    return this.type === "startGroup" || this.type === "startGroupCollapsed";
  }
  isErrorOrWarning() {
    return this.level === "warning" || this.level === "error";
  }
  isGroupable() {
    const isUngroupableError = this.level === "error" && (this.source === "javascript" || this.source === "network");
    return this.source !== Common35.Console.FrontendMessageSource.ConsoleAPI && this.type !== FrontendMessageType.Command && this.type !== FrontendMessageType.Result && this.type !== FrontendMessageType.System && !isUngroupableError;
  }
  groupCategoryKey() {
    return [this.source, this.level, this.type, this.#pageLoadSequenceNumber].join(":");
  }
  isEqual(msg) {
    if (!msg) {
      return false;
    }
    if (this.parameters) {
      if (!msg.parameters || this.parameters.length !== msg.parameters.length) {
        return false;
      }
      for (let i = 0; i < msg.parameters.length; ++i) {
        const msgParam = msg.parameters[i];
        const param = this.parameters[i];
        if (typeof msgParam === "string" || typeof param === "string") {
          return false;
        }
        if (msgParam.type === "object" && msgParam.subtype !== "error") {
          if (!msgParam.objectId || msgParam.objectId !== param.objectId || msg.timestamp !== this.timestamp) {
            return false;
          }
        }
        if (param.type !== msgParam.type || param.value !== msgParam.value || param.description !== msgParam.description) {
          return false;
        }
      }
    }
    return this.runtimeModel() === msg.runtimeModel() && this.source === msg.source && this.type === msg.type && this.level === msg.level && this.line === msg.line && this.url === msg.url && this.scriptId === msg.scriptId && this.messageText === msg.messageText && this.#executionContextId === msg.#executionContextId && areAffectedResourcesEquivalent(this.#affectedResources, msg.#affectedResources) && areStackTracesEquivalent(this.stackTrace, msg.stackTrace);
  }
  get originatesFromLogpoint() {
    return this.#originatingBreakpointType === "LOGPOINT";
  }
  /** @returns true, iff this was a console.* call in a conditional breakpoint */
  get originatesFromConditionalBreakpoint() {
    return this.#originatingBreakpointType === "CONDITIONAL_BREAKPOINT";
  }
  static #stackFrameWithBreakpoint({ callFrames }) {
    const markerSourceUrls = [COND_BREAKPOINT_SOURCE_URL, LOGPOINT_SOURCE_URL];
    const lastBreakpointFrameIndex = callFrames.findLastIndex(({ url }) => markerSourceUrls.includes(url));
    if (lastBreakpointFrameIndex === -1 || lastBreakpointFrameIndex === callFrames.length - 1) {
      return { callFrame: null, type: null };
    }
    const type = callFrames[lastBreakpointFrameIndex].url === LOGPOINT_SOURCE_URL ? "LOGPOINT" : "CONDITIONAL_BREAKPOINT";
    return { callFrame: callFrames[lastBreakpointFrameIndex + 1], type };
  }
};
SDKModel.register(ConsoleModel, { capabilities: 4, autostart: true });
var MessageSourceDisplayName = /* @__PURE__ */ new Map([
  ["xml", "xml"],
  ["javascript", "javascript"],
  ["network", "network"],
  [Common35.Console.FrontendMessageSource.ConsoleAPI, "console-api"],
  ["storage", "storage"],
  ["appcache", "appcache"],
  ["rendering", "rendering"],
  [Common35.Console.FrontendMessageSource.CSS, "css"],
  ["security", "security"],
  ["deprecation", "deprecation"],
  ["worker", "worker"],
  ["violation", "violation"],
  ["intervention", "intervention"],
  ["recommendation", "recommendation"],
  ["other", "other"],
  [Common35.Console.FrontendMessageSource.ISSUE_PANEL, "issue-panel"]
]);

// gen/front_end/core/sdk/CPUThrottlingManager.js
var CPUThrottlingManager_exports = {};
__export(CPUThrottlingManager_exports, {
  CPUThrottlingManager: () => CPUThrottlingManager,
  CPUThrottlingRates: () => CPUThrottlingRates,
  CalibratedLowTierMobileThrottlingOption: () => CalibratedLowTierMobileThrottlingOption,
  CalibratedMidTierMobileThrottlingOption: () => CalibratedMidTierMobileThrottlingOption,
  CalibrationError: () => CalibrationError,
  ExtraSlowThrottlingOption: () => ExtraSlowThrottlingOption,
  LowTierThrottlingOption: () => LowTierThrottlingOption,
  MidTierThrottlingOption: () => MidTierThrottlingOption,
  NoThrottlingOption: () => NoThrottlingOption,
  calibrationErrorToString: () => calibrationErrorToString,
  throttlingManager: () => throttlingManager
});
import * as Common37 from "./../common/common.js";
import * as i18n35 from "./../i18n/i18n.js";

// gen/front_end/core/sdk/EmulationModel.js
var EmulationModel_exports = {};
__export(EmulationModel_exports, {
  DeviceOrientation: () => DeviceOrientation,
  EmulationModel: () => EmulationModel,
  Location: () => Location2
});
import * as Common36 from "./../common/common.js";
var EmulationModel = class extends SDKModel {
  #emulationAgent;
  #deviceOrientationAgent;
  #cssModel;
  #overlayModel;
  #mediaConfiguration;
  #cpuPressureEnabled;
  #touchEnabled;
  #touchMobile;
  #touchEmulationAllowed;
  #customTouchEnabled;
  #touchConfiguration;
  constructor(target) {
    super(target);
    this.#emulationAgent = target.emulationAgent();
    this.#deviceOrientationAgent = target.deviceOrientationAgent();
    this.#cssModel = target.model(CSSModel);
    this.#overlayModel = target.model(OverlayModel);
    if (this.#overlayModel) {
      this.#overlayModel.addEventListener("InspectModeWillBeToggled", () => {
        void this.updateTouch();
      }, this);
    }
    const disableJavascriptSetting = Common36.Settings.Settings.instance().moduleSetting("java-script-disabled");
    disableJavascriptSetting.addChangeListener(async () => await this.#emulationAgent.invoke_setScriptExecutionDisabled({ value: disableJavascriptSetting.get() }));
    if (disableJavascriptSetting.get()) {
      void this.#emulationAgent.invoke_setScriptExecutionDisabled({ value: true });
    }
    const touchSetting = Common36.Settings.Settings.instance().moduleSetting("emulation.touch");
    touchSetting.addChangeListener(() => {
      const settingValue = touchSetting.get();
      void this.overrideEmulateTouch(settingValue === "force");
    });
    const idleDetectionSetting = Common36.Settings.Settings.instance().moduleSetting("emulation.idle-detection");
    idleDetectionSetting.addChangeListener(async () => {
      const settingValue = idleDetectionSetting.get();
      if (settingValue === "none") {
        await this.clearIdleOverride();
        return;
      }
      const emulationParams = JSON.parse(settingValue);
      await this.setIdleOverride(emulationParams);
    });
    const cpuPressureDetectionSetting = Common36.Settings.Settings.instance().moduleSetting("emulation.cpu-pressure");
    cpuPressureDetectionSetting.addChangeListener(async () => {
      const settingValue = cpuPressureDetectionSetting.get();
      if (settingValue === "none") {
        await this.setPressureSourceOverrideEnabled(false);
        this.#cpuPressureEnabled = false;
        return;
      }
      if (!this.#cpuPressureEnabled) {
        this.#cpuPressureEnabled = true;
        await this.setPressureSourceOverrideEnabled(true);
      }
      await this.setPressureStateOverride(settingValue);
    });
    const mediaTypeSetting = Common36.Settings.Settings.instance().moduleSetting("emulated-css-media");
    const mediaFeatureColorGamutSetting = Common36.Settings.Settings.instance().moduleSetting("emulated-css-media-feature-color-gamut");
    const mediaFeaturePrefersColorSchemeSetting = Common36.Settings.Settings.instance().moduleSetting("emulated-css-media-feature-prefers-color-scheme");
    const mediaFeatureForcedColorsSetting = Common36.Settings.Settings.instance().moduleSetting("emulated-css-media-feature-forced-colors");
    const mediaFeaturePrefersContrastSetting = Common36.Settings.Settings.instance().moduleSetting("emulated-css-media-feature-prefers-contrast");
    const mediaFeaturePrefersReducedDataSetting = Common36.Settings.Settings.instance().moduleSetting("emulated-css-media-feature-prefers-reduced-data");
    const mediaFeaturePrefersReducedTransparencySetting = Common36.Settings.Settings.instance().moduleSetting("emulated-css-media-feature-prefers-reduced-transparency");
    const mediaFeaturePrefersReducedMotionSetting = Common36.Settings.Settings.instance().moduleSetting("emulated-css-media-feature-prefers-reduced-motion");
    this.#mediaConfiguration = /* @__PURE__ */ new Map([
      ["type", mediaTypeSetting.get()],
      ["color-gamut", mediaFeatureColorGamutSetting.get()],
      ["prefers-color-scheme", mediaFeaturePrefersColorSchemeSetting.get()],
      ["forced-colors", mediaFeatureForcedColorsSetting.get()],
      ["prefers-contrast", mediaFeaturePrefersContrastSetting.get()],
      ["prefers-reduced-data", mediaFeaturePrefersReducedDataSetting.get()],
      ["prefers-reduced-motion", mediaFeaturePrefersReducedMotionSetting.get()],
      ["prefers-reduced-transparency", mediaFeaturePrefersReducedTransparencySetting.get()]
    ]);
    mediaTypeSetting.addChangeListener(() => {
      this.#mediaConfiguration.set("type", mediaTypeSetting.get());
      void this.updateCssMedia();
    });
    mediaFeatureColorGamutSetting.addChangeListener(() => {
      this.#mediaConfiguration.set("color-gamut", mediaFeatureColorGamutSetting.get());
      void this.updateCssMedia();
    });
    mediaFeaturePrefersColorSchemeSetting.addChangeListener(() => {
      this.#mediaConfiguration.set("prefers-color-scheme", mediaFeaturePrefersColorSchemeSetting.get());
      void this.updateCssMedia();
    });
    mediaFeatureForcedColorsSetting.addChangeListener(() => {
      this.#mediaConfiguration.set("forced-colors", mediaFeatureForcedColorsSetting.get());
      void this.updateCssMedia();
    });
    mediaFeaturePrefersContrastSetting.addChangeListener(() => {
      this.#mediaConfiguration.set("prefers-contrast", mediaFeaturePrefersContrastSetting.get());
      void this.updateCssMedia();
    });
    mediaFeaturePrefersReducedDataSetting.addChangeListener(() => {
      this.#mediaConfiguration.set("prefers-reduced-data", mediaFeaturePrefersReducedDataSetting.get());
      void this.updateCssMedia();
    });
    mediaFeaturePrefersReducedMotionSetting.addChangeListener(() => {
      this.#mediaConfiguration.set("prefers-reduced-motion", mediaFeaturePrefersReducedMotionSetting.get());
      void this.updateCssMedia();
    });
    mediaFeaturePrefersReducedTransparencySetting.addChangeListener(() => {
      this.#mediaConfiguration.set("prefers-reduced-transparency", mediaFeaturePrefersReducedTransparencySetting.get());
      void this.updateCssMedia();
    });
    void this.updateCssMedia();
    const autoDarkModeSetting = Common36.Settings.Settings.instance().moduleSetting("emulate-auto-dark-mode");
    autoDarkModeSetting.addChangeListener(() => {
      const enabled = autoDarkModeSetting.get();
      mediaFeaturePrefersColorSchemeSetting.setDisabled(enabled);
      mediaFeaturePrefersColorSchemeSetting.set(enabled ? "dark" : "");
      void this.emulateAutoDarkMode(enabled);
    });
    if (autoDarkModeSetting.get()) {
      mediaFeaturePrefersColorSchemeSetting.setDisabled(true);
      mediaFeaturePrefersColorSchemeSetting.set("dark");
      void this.emulateAutoDarkMode(true);
    }
    const visionDeficiencySetting = Common36.Settings.Settings.instance().moduleSetting("emulated-vision-deficiency");
    visionDeficiencySetting.addChangeListener(() => this.emulateVisionDeficiency(visionDeficiencySetting.get()));
    if (visionDeficiencySetting.get()) {
      void this.emulateVisionDeficiency(visionDeficiencySetting.get());
    }
    const osTextScaleSetting = Common36.Settings.Settings.instance().moduleSetting("emulated-os-text-scale");
    osTextScaleSetting.addChangeListener(() => {
      void this.emulateOSTextScale(parseFloat(osTextScaleSetting.get()) || void 0);
    });
    if (osTextScaleSetting.get()) {
      void this.emulateOSTextScale(parseFloat(osTextScaleSetting.get()) || void 0);
    }
    const localFontsDisabledSetting = Common36.Settings.Settings.instance().moduleSetting("local-fonts-disabled");
    localFontsDisabledSetting.addChangeListener(() => this.setLocalFontsDisabled(localFontsDisabledSetting.get()));
    if (localFontsDisabledSetting.get()) {
      this.setLocalFontsDisabled(localFontsDisabledSetting.get());
    }
    const avifFormatDisabledSetting = Common36.Settings.Settings.instance().moduleSetting("avif-format-disabled");
    const webpFormatDisabledSetting = Common36.Settings.Settings.instance().moduleSetting("webp-format-disabled");
    const updateDisabledImageFormats = () => {
      const types = [];
      if (avifFormatDisabledSetting.get()) {
        types.push(
          "avif"
          /* Protocol.Emulation.DisabledImageType.Avif */
        );
      }
      if (webpFormatDisabledSetting.get()) {
        types.push(
          "webp"
          /* Protocol.Emulation.DisabledImageType.Webp */
        );
      }
      this.setDisabledImageTypes(types);
    };
    avifFormatDisabledSetting.addChangeListener(updateDisabledImageFormats);
    webpFormatDisabledSetting.addChangeListener(updateDisabledImageFormats);
    if (avifFormatDisabledSetting.get() || webpFormatDisabledSetting.get()) {
      updateDisabledImageFormats();
    }
    this.#cpuPressureEnabled = false;
    this.#touchEmulationAllowed = true;
    this.#touchEnabled = false;
    this.#touchMobile = false;
    this.#customTouchEnabled = false;
    this.#touchConfiguration = {
      enabled: false,
      configuration: "mobile"
    };
  }
  setTouchEmulationAllowed(touchEmulationAllowed) {
    this.#touchEmulationAllowed = touchEmulationAllowed;
  }
  supportsDeviceEmulation() {
    return this.target().hasAllCapabilities(
      4096
      /* Capability.DEVICE_EMULATION */
    );
  }
  async resetPageScaleFactor() {
    await this.#emulationAgent.invoke_resetPageScaleFactor();
  }
  async emulateDevice(metrics) {
    if (metrics) {
      await this.#emulationAgent.invoke_setDeviceMetricsOverride(metrics);
    } else {
      await this.#emulationAgent.invoke_clearDeviceMetricsOverride();
    }
  }
  overlayModel() {
    return this.#overlayModel;
  }
  async setPressureSourceOverrideEnabled(enabled) {
    await this.#emulationAgent.invoke_setPressureSourceOverrideEnabled({ source: "cpu", enabled });
  }
  async setPressureStateOverride(pressureState) {
    await this.#emulationAgent.invoke_setPressureStateOverride({
      source: "cpu",
      state: pressureState
    });
  }
  async emulateLocation(location) {
    if (!location) {
      await Promise.all([
        this.#emulationAgent.invoke_clearGeolocationOverride(),
        this.#emulationAgent.invoke_setTimezoneOverride({ timezoneId: "" }),
        this.#emulationAgent.invoke_setLocaleOverride({ locale: "" }),
        this.#emulationAgent.invoke_setUserAgentOverride({ userAgent: MultitargetNetworkManager.instance().currentUserAgent() })
      ]);
    } else if (location.unavailable) {
      await Promise.all([
        this.#emulationAgent.invoke_setGeolocationOverride({}),
        this.#emulationAgent.invoke_setTimezoneOverride({ timezoneId: "" }),
        this.#emulationAgent.invoke_setLocaleOverride({ locale: "" }),
        this.#emulationAgent.invoke_setUserAgentOverride({ userAgent: MultitargetNetworkManager.instance().currentUserAgent() })
      ]);
    } else {
      let processEmulationResult = function(errorType, result) {
        const errorMessage = result.getError();
        if (errorMessage) {
          return Promise.reject({
            type: errorType,
            message: errorMessage
          });
        }
        return Promise.resolve();
      };
      await Promise.all([
        this.#emulationAgent.invoke_setGeolocationOverride({
          latitude: location.latitude,
          longitude: location.longitude,
          accuracy: location.accuracy
        }).then((result) => processEmulationResult("emulation-set-location", result)),
        this.#emulationAgent.invoke_setTimezoneOverride({
          timezoneId: location.timezoneId
        }).then((result) => processEmulationResult("emulation-set-timezone", result)),
        this.#emulationAgent.invoke_setLocaleOverride({
          locale: location.locale
        }).then((result) => processEmulationResult("emulation-set-locale", result)),
        this.#emulationAgent.invoke_setUserAgentOverride({
          userAgent: MultitargetNetworkManager.instance().currentUserAgent(),
          acceptLanguage: location.locale
        }).then((result) => processEmulationResult("emulation-set-user-agent", result))
      ]);
    }
  }
  async emulateDeviceOrientation(deviceOrientation) {
    if (deviceOrientation) {
      await this.#deviceOrientationAgent.invoke_setDeviceOrientationOverride({ alpha: deviceOrientation.alpha, beta: deviceOrientation.beta, gamma: deviceOrientation.gamma });
    } else {
      await this.#deviceOrientationAgent.invoke_clearDeviceOrientationOverride();
    }
  }
  async setIdleOverride(emulationParams) {
    await this.#emulationAgent.invoke_setIdleOverride(emulationParams);
  }
  async clearIdleOverride() {
    await this.#emulationAgent.invoke_clearIdleOverride();
  }
  async emulateCSSMedia(type, features) {
    await this.#emulationAgent.invoke_setEmulatedMedia({ media: type, features });
    if (this.#cssModel) {
      this.#cssModel.mediaQueryResultChanged();
    }
  }
  async emulateAutoDarkMode(enabled) {
    if (enabled) {
      this.#mediaConfiguration.set("prefers-color-scheme", "dark");
      await this.updateCssMedia();
    }
    await this.#emulationAgent.invoke_setAutoDarkModeOverride({ enabled: enabled || void 0 });
  }
  async emulateVisionDeficiency(type) {
    await this.#emulationAgent.invoke_setEmulatedVisionDeficiency({ type });
  }
  async emulateOSTextScale(scale) {
    await this.#emulationAgent.invoke_setEmulatedOSTextScale({ scale: scale || void 0 });
  }
  setLocalFontsDisabled(disabled) {
    if (!this.#cssModel) {
      return;
    }
    void this.#cssModel.setLocalFontsEnabled(!disabled);
  }
  setDisabledImageTypes(imageTypes) {
    void this.#emulationAgent.invoke_setDisabledImageTypes({ imageTypes });
  }
  async setDataSaverOverride(dataSaverOverride) {
    const dataSaverEnabled = dataSaverOverride === "unset" ? void 0 : dataSaverOverride === "enabled" ? true : false;
    await this.#emulationAgent.invoke_setDataSaverOverride({ dataSaverEnabled });
  }
  async setCPUThrottlingRate(rate) {
    await this.#emulationAgent.invoke_setCPUThrottlingRate({ rate });
  }
  async setHardwareConcurrency(hardwareConcurrency) {
    if (hardwareConcurrency < 1) {
      throw new Error("hardwareConcurrency must be a positive value");
    }
    await this.#emulationAgent.invoke_setHardwareConcurrencyOverride({ hardwareConcurrency });
  }
  async emulateTouch(enabled, mobile) {
    this.#touchEnabled = enabled && this.#touchEmulationAllowed;
    this.#touchMobile = mobile && this.#touchEmulationAllowed;
    await this.updateTouch();
  }
  async overrideEmulateTouch(enabled) {
    this.#customTouchEnabled = enabled && this.#touchEmulationAllowed;
    await this.updateTouch();
  }
  async updateTouch() {
    let configuration = {
      enabled: this.#touchEnabled,
      configuration: this.#touchMobile ? "mobile" : "desktop"
    };
    if (this.#customTouchEnabled) {
      configuration = {
        enabled: true,
        configuration: "mobile"
      };
    }
    if (this.#overlayModel && this.#overlayModel.inspectModeEnabled()) {
      configuration = {
        enabled: false,
        configuration: "mobile"
      };
    }
    if (!this.#touchConfiguration.enabled && !configuration.enabled) {
      return;
    }
    if (this.#touchConfiguration.enabled && configuration.enabled && this.#touchConfiguration.configuration === configuration.configuration) {
      return;
    }
    this.#touchConfiguration = configuration;
    await this.#emulationAgent.invoke_setTouchEmulationEnabled({ enabled: configuration.enabled, maxTouchPoints: 1 });
    await this.#emulationAgent.invoke_setEmitTouchEventsForMouse({ enabled: configuration.enabled, configuration: configuration.configuration });
  }
  async updateCssMedia() {
    const type = this.#mediaConfiguration.get("type") ?? "";
    const features = [
      {
        name: "color-gamut",
        value: this.#mediaConfiguration.get("color-gamut") ?? ""
      },
      {
        name: "prefers-color-scheme",
        value: this.#mediaConfiguration.get("prefers-color-scheme") ?? ""
      },
      {
        name: "forced-colors",
        value: this.#mediaConfiguration.get("forced-colors") ?? ""
      },
      {
        name: "prefers-contrast",
        value: this.#mediaConfiguration.get("prefers-contrast") ?? ""
      },
      {
        name: "prefers-reduced-data",
        value: this.#mediaConfiguration.get("prefers-reduced-data") ?? ""
      },
      {
        name: "prefers-reduced-motion",
        value: this.#mediaConfiguration.get("prefers-reduced-motion") ?? ""
      },
      {
        name: "prefers-reduced-transparency",
        value: this.#mediaConfiguration.get("prefers-reduced-transparency") ?? ""
      }
    ];
    return await this.emulateCSSMedia(type, features);
  }
};
var Location2 = class _Location {
  static DEFAULT_ACCURACY = 150;
  latitude;
  longitude;
  timezoneId;
  locale;
  accuracy;
  unavailable;
  constructor(latitude, longitude, timezoneId, locale, accuracy, unavailable) {
    this.latitude = latitude;
    this.longitude = longitude;
    this.timezoneId = timezoneId;
    this.locale = locale;
    this.accuracy = accuracy;
    this.unavailable = unavailable;
  }
  static parseSetting(value) {
    if (value) {
      const [position, timezoneId, locale, unavailable, ...maybeAccuracy] = value.split(":");
      const accuracy = maybeAccuracy.length ? Number(maybeAccuracy[0]) : _Location.DEFAULT_ACCURACY;
      const [latitude, longitude] = position.split("@");
      return new _Location(parseFloat(latitude), parseFloat(longitude), timezoneId, locale, accuracy, Boolean(unavailable));
    }
    return new _Location(0, 0, "", "", _Location.DEFAULT_ACCURACY, false);
  }
  static parseUserInput(latitudeString, longitudeString, timezoneId, locale, accuracyString) {
    if (!latitudeString && !longitudeString && !accuracyString) {
      return null;
    }
    const isLatitudeValid = _Location.latitudeValidator(latitudeString);
    const isLongitudeValid = _Location.longitudeValidator(longitudeString);
    const { valid: isAccuracyValid } = _Location.accuracyValidator(accuracyString);
    if (!isLatitudeValid && !isLongitudeValid && !isAccuracyValid) {
      return null;
    }
    const latitude = isLatitudeValid ? parseFloat(latitudeString) : -1;
    const longitude = isLongitudeValid ? parseFloat(longitudeString) : -1;
    const accuracy = isAccuracyValid ? parseFloat(accuracyString) : _Location.DEFAULT_ACCURACY;
    return new _Location(latitude, longitude, timezoneId, locale, accuracy, false);
  }
  static latitudeValidator(value) {
    const numValue = parseFloat(value);
    return /^([+-]?[\d]+(\.\d+)?|[+-]?\.\d+)$/.test(value) && numValue >= -90 && numValue <= 90;
  }
  static longitudeValidator(value) {
    const numValue = parseFloat(value);
    return /^([+-]?[\d]+(\.\d+)?|[+-]?\.\d+)$/.test(value) && numValue >= -180 && numValue <= 180;
  }
  static timezoneIdValidator(value) {
    return value === "" || /[a-zA-Z]/.test(value);
  }
  static localeValidator(value) {
    return value === "" || /[a-zA-Z]{2}/.test(value);
  }
  static accuracyValidator(value) {
    if (!value) {
      return { valid: true, errorMessage: void 0 };
    }
    const numValue = parseFloat(value);
    const valid = /^([+-]?[\d]+(\.\d+)?|[+-]?\.\d+)$/.test(value) && numValue >= 0;
    return { valid, errorMessage: void 0 };
  }
  toSetting() {
    return `${this.latitude}@${this.longitude}:${this.timezoneId}:${this.locale}:${this.unavailable || ""}:${this.accuracy || ""}`;
  }
};
var DeviceOrientation = class _DeviceOrientation {
  alpha;
  beta;
  gamma;
  constructor(alpha, beta, gamma) {
    this.alpha = alpha;
    this.beta = beta;
    this.gamma = gamma;
  }
  static parseSetting(value) {
    if (value) {
      const jsonObject = JSON.parse(value);
      return new _DeviceOrientation(jsonObject.alpha, jsonObject.beta, jsonObject.gamma);
    }
    return new _DeviceOrientation(0, 0, 0);
  }
  static parseUserInput(alphaString, betaString, gammaString) {
    if (!alphaString && !betaString && !gammaString) {
      return null;
    }
    const isAlphaValid = _DeviceOrientation.alphaAngleValidator(alphaString);
    const isBetaValid = _DeviceOrientation.betaAngleValidator(betaString);
    const isGammaValid = _DeviceOrientation.gammaAngleValidator(gammaString);
    if (!isAlphaValid && !isBetaValid && !isGammaValid) {
      return null;
    }
    const alpha = isAlphaValid ? parseFloat(alphaString) : -1;
    const beta = isBetaValid ? parseFloat(betaString) : -1;
    const gamma = isGammaValid ? parseFloat(gammaString) : -1;
    return new _DeviceOrientation(alpha, beta, gamma);
  }
  static angleRangeValidator(value, interval) {
    const numValue = parseFloat(value);
    return /^([+-]?[\d]+(\.\d+)?|[+-]?\.\d+)$/.test(value) && numValue >= interval.minimum && numValue < interval.maximum;
  }
  static alphaAngleValidator(value) {
    return _DeviceOrientation.angleRangeValidator(value, { minimum: 0, maximum: 360 });
  }
  static betaAngleValidator(value) {
    return _DeviceOrientation.angleRangeValidator(value, { minimum: -180, maximum: 180 });
  }
  static gammaAngleValidator(value) {
    return _DeviceOrientation.angleRangeValidator(value, { minimum: -90, maximum: 90 });
  }
  toSetting() {
    return JSON.stringify(this);
  }
};
SDKModel.register(EmulationModel, { capabilities: 256, autostart: true });

// gen/front_end/core/sdk/CPUThrottlingManager.js
var UIStrings16 = {
  /**
   * @description Text label for a menu item indicating that no throttling is applied.
   */
  noThrottling: "No throttling",
  /**
   * @description Text label for a menu item indicating that a specific slowdown multiplier is applied.
   * @example {2} PH1
   */
  dSlowdown: "{PH1}\xD7 slowdown",
  /**
   * @description Text label for a menu item indicating an average mobile device.
   */
  calibratedMidTierMobile: "Mid-tier mobile",
  /**
   * @description Text label for a menu item indicating a below-average mobile device.
   */
  calibratedLowTierMobile: "Low-tier mobile",
  /**
   * @description Text label indicating why an option is not available, because the user's device is not fast enough to emulate a device.
   */
  calibrationErrorDeviceTooWeak: "Device is not powerful enough"
};
var str_16 = i18n35.i18n.registerUIStrings("core/sdk/CPUThrottlingManager.ts", UIStrings16);
var i18nString16 = i18n35.i18n.getLocalizedString.bind(void 0, str_16);
var i18nLazyString2 = i18n35.i18n.getLazilyComputedLocalizedString.bind(void 0, str_16);
var throttlingManagerInstance;
var CPUThrottlingManager = class _CPUThrottlingManager extends Common37.ObjectWrapper.ObjectWrapper {
  #cpuThrottlingOption;
  #calibratedThrottlingSetting;
  #hardwareConcurrency;
  #pendingMainTargetPromise;
  constructor() {
    super();
    this.#cpuThrottlingOption = NoThrottlingOption;
    this.#calibratedThrottlingSetting = Common37.Settings.Settings.instance().createSetting(
      "calibrated-cpu-throttling",
      {},
      "Global"
      /* Common.Settings.SettingStorageType.GLOBAL */
    );
    this.#calibratedThrottlingSetting.addChangeListener(this.#onCalibratedSettingChanged, this);
    TargetManager.instance().observeModels(EmulationModel, this);
  }
  static instance(opts = { forceNew: null }) {
    const { forceNew } = opts;
    if (!throttlingManagerInstance || forceNew) {
      throttlingManagerInstance = new _CPUThrottlingManager();
    }
    return throttlingManagerInstance;
  }
  cpuThrottlingRate() {
    return this.#cpuThrottlingOption.rate();
  }
  cpuThrottlingOption() {
    return this.#cpuThrottlingOption;
  }
  #onCalibratedSettingChanged() {
    const currentOption = this.#cpuThrottlingOption;
    if (!currentOption.calibratedDeviceType) {
      return;
    }
    const rate = this.#cpuThrottlingOption.rate();
    if (rate === 0) {
      this.setCPUThrottlingOption(NoThrottlingOption);
      return;
    }
    for (const emulationModel of TargetManager.instance().models(EmulationModel)) {
      void emulationModel.setCPUThrottlingRate(rate);
    }
    this.dispatchEventToListeners("RateChanged", rate);
  }
  setCPUThrottlingOption(option) {
    if (option === this.#cpuThrottlingOption) {
      return;
    }
    this.#cpuThrottlingOption = option;
    for (const emulationModel of TargetManager.instance().models(EmulationModel)) {
      void emulationModel.setCPUThrottlingRate(this.#cpuThrottlingOption.rate());
    }
    this.dispatchEventToListeners("RateChanged", this.#cpuThrottlingOption.rate());
  }
  setHardwareConcurrency(concurrency) {
    this.#hardwareConcurrency = concurrency;
    for (const emulationModel of TargetManager.instance().models(EmulationModel)) {
      void emulationModel.setHardwareConcurrency(concurrency);
    }
    this.dispatchEventToListeners("HardwareConcurrencyChanged", this.#hardwareConcurrency);
  }
  hasPrimaryPageTargetSet() {
    try {
      return TargetManager.instance().primaryPageTarget() !== null;
    } catch {
      return false;
    }
  }
  async getHardwareConcurrency() {
    const target = TargetManager.instance().primaryPageTarget();
    const existingCallback = this.#pendingMainTargetPromise;
    if (!target) {
      if (existingCallback) {
        return await new Promise((r) => {
          this.#pendingMainTargetPromise = (result2) => {
            r(result2);
            existingCallback(result2);
          };
        });
      }
      return await new Promise((r) => {
        this.#pendingMainTargetPromise = r;
      });
    }
    const evalResult = await target.runtimeAgent().invoke_evaluate({ expression: "navigator.hardwareConcurrency", returnByValue: true, silent: true, throwOnSideEffect: true });
    const error = evalResult.getError();
    if (error) {
      throw new Error(error);
    }
    const { result, exceptionDetails } = evalResult;
    if (exceptionDetails) {
      throw new Error(exceptionDetails.text);
    }
    return result.value;
  }
  modelAdded(emulationModel) {
    if (this.#cpuThrottlingOption !== NoThrottlingOption) {
      void emulationModel.setCPUThrottlingRate(this.#cpuThrottlingOption.rate());
    }
    if (this.#hardwareConcurrency !== void 0) {
      void emulationModel.setHardwareConcurrency(this.#hardwareConcurrency);
    }
    if (this.#pendingMainTargetPromise) {
      const existingCallback = this.#pendingMainTargetPromise;
      this.#pendingMainTargetPromise = void 0;
      void this.getHardwareConcurrency().then(existingCallback);
    }
  }
  modelRemoved(_emulationModel) {
  }
};
function throttlingManager() {
  return CPUThrottlingManager.instance();
}
var CPUThrottlingRates;
(function(CPUThrottlingRates2) {
  CPUThrottlingRates2[CPUThrottlingRates2["NO_THROTTLING"] = 1] = "NO_THROTTLING";
  CPUThrottlingRates2[CPUThrottlingRates2["MID_TIER_MOBILE"] = 4] = "MID_TIER_MOBILE";
  CPUThrottlingRates2[CPUThrottlingRates2["LOW_TIER_MOBILE"] = 6] = "LOW_TIER_MOBILE";
  CPUThrottlingRates2[CPUThrottlingRates2["EXTRA_SLOW"] = 20] = "EXTRA_SLOW";
  CPUThrottlingRates2[CPUThrottlingRates2["MidTierMobile"] = 4] = "MidTierMobile";
  CPUThrottlingRates2[CPUThrottlingRates2["LowEndMobile"] = 6] = "LowEndMobile";
})(CPUThrottlingRates || (CPUThrottlingRates = {}));
function makeFixedPresetThrottlingOption(rate) {
  return {
    title: rate === 1 ? i18nLazyString2(UIStrings16.noThrottling) : i18nLazyString2(UIStrings16.dSlowdown, { PH1: rate }),
    rate: () => rate,
    jslogContext: rate === 1 ? "cpu-no-throttling" : `cpu-throttled-${rate}`
  };
}
var NoThrottlingOption = makeFixedPresetThrottlingOption(CPUThrottlingRates.NO_THROTTLING);
var MidTierThrottlingOption = makeFixedPresetThrottlingOption(CPUThrottlingRates.MID_TIER_MOBILE);
var LowTierThrottlingOption = makeFixedPresetThrottlingOption(CPUThrottlingRates.LOW_TIER_MOBILE);
var ExtraSlowThrottlingOption = makeFixedPresetThrottlingOption(CPUThrottlingRates.EXTRA_SLOW);
function makeCalibratedThrottlingOption(calibratedDeviceType) {
  const getSettingValue = () => {
    const setting = Common37.Settings.Settings.instance().createSetting(
      "calibrated-cpu-throttling",
      {},
      "Global"
      /* Common.Settings.SettingStorageType.GLOBAL */
    );
    const value = setting.get();
    if (calibratedDeviceType === "low-tier-mobile") {
      return value.low ?? null;
    }
    if (calibratedDeviceType === "mid-tier-mobile") {
      return value.mid ?? null;
    }
    return null;
  };
  return {
    title() {
      const typeString = calibratedDeviceType === "low-tier-mobile" ? i18nString16(UIStrings16.calibratedLowTierMobile) : i18nString16(UIStrings16.calibratedMidTierMobile);
      const value = getSettingValue();
      if (typeof value === "number") {
        return `${typeString} \u2013 ${value.toFixed(1)}\xD7`;
      }
      return typeString;
    },
    rate() {
      const value = getSettingValue();
      if (typeof value === "number") {
        return value;
      }
      return 0;
    },
    calibratedDeviceType,
    jslogContext: `cpu-throttled-calibrated-${calibratedDeviceType}`
  };
}
var CalibratedLowTierMobileThrottlingOption = makeCalibratedThrottlingOption("low-tier-mobile");
var CalibratedMidTierMobileThrottlingOption = makeCalibratedThrottlingOption("mid-tier-mobile");
var CalibrationError;
(function(CalibrationError2) {
  CalibrationError2["DEVICE_TOO_WEAK"] = "DEVICE_TOO_WEAK";
})(CalibrationError || (CalibrationError = {}));
function calibrationErrorToString(error) {
  if (error === CalibrationError.DEVICE_TOO_WEAK) {
    return i18nString16(UIStrings16.calibrationErrorDeviceTooWeak);
  }
  return error;
}

// gen/front_end/core/sdk/DOMDebuggerModel.js
var DOMDebuggerModel_exports = {};
__export(DOMDebuggerModel_exports, {
  CSPViolationBreakpoint: () => CSPViolationBreakpoint,
  DOMBreakpoint: () => DOMBreakpoint,
  DOMDebuggerManager: () => DOMDebuggerManager,
  DOMDebuggerModel: () => DOMDebuggerModel,
  DOMEventListenerBreakpoint: () => DOMEventListenerBreakpoint,
  EventListener: () => EventListener
});
import * as Common38 from "./../common/common.js";
import * as Platform20 from "./../platform/platform.js";
var DOMDebuggerModel = class extends SDKModel {
  agent;
  #runtimeModel;
  #domModel;
  #domBreakpoints;
  #domBreakpointsSetting;
  suspended = false;
  constructor(target) {
    super(target);
    this.agent = target.domdebuggerAgent();
    this.#runtimeModel = target.model(RuntimeModel);
    this.#domModel = target.model(DOMModel);
    this.#domModel.addEventListener(Events8.DocumentUpdated, this.documentUpdated, this);
    this.#domModel.addEventListener(Events8.NodeRemoved, this.nodeRemoved, this);
    this.#domBreakpoints = [];
    this.#domBreakpointsSetting = Common38.Settings.Settings.instance().createLocalSetting("dom-breakpoints", []);
    if (this.#domModel.existingDocument()) {
      void this.documentUpdated();
    }
  }
  runtimeModel() {
    return this.#runtimeModel;
  }
  async suspendModel() {
    this.suspended = true;
  }
  async resumeModel() {
    this.suspended = false;
  }
  async eventListeners(remoteObject) {
    console.assert(remoteObject.runtimeModel() === this.#runtimeModel);
    if (!remoteObject.objectId) {
      return [];
    }
    const listeners = await this.agent.invoke_getEventListeners({ objectId: remoteObject.objectId });
    const eventListeners = [];
    for (const payload of listeners.listeners || []) {
      const location = this.#runtimeModel.debuggerModel().createRawLocationByScriptId(payload.scriptId, payload.lineNumber, payload.columnNumber);
      if (!location) {
        continue;
      }
      eventListeners.push(new EventListener(this, remoteObject, payload.type, payload.useCapture, payload.passive, payload.once, payload.handler ? this.#runtimeModel.createRemoteObject(payload.handler) : null, payload.originalHandler ? this.#runtimeModel.createRemoteObject(payload.originalHandler) : null, location, null));
    }
    return eventListeners;
  }
  retrieveDOMBreakpoints() {
    void this.#domModel.requestDocument();
  }
  domBreakpoints() {
    return this.#domBreakpoints.slice();
  }
  hasDOMBreakpoint(node, type) {
    return this.#domBreakpoints.some((breakpoint) => breakpoint.node === node && breakpoint.type === type);
  }
  setDOMBreakpoint(node, type) {
    for (const breakpoint2 of this.#domBreakpoints) {
      if (breakpoint2.node === node && breakpoint2.type === type) {
        this.toggleDOMBreakpoint(breakpoint2, true);
        return breakpoint2;
      }
    }
    const breakpoint = new DOMBreakpoint(this, node, type, true);
    this.#domBreakpoints.push(breakpoint);
    this.enableDOMBreakpoint(breakpoint);
    this.saveDOMBreakpoints();
    this.dispatchEventToListeners("DOMBreakpointAdded", breakpoint);
    return breakpoint;
  }
  removeDOMBreakpoint(node, type) {
    this.removeDOMBreakpoints((breakpoint) => breakpoint.node === node && breakpoint.type === type);
  }
  removeAllDOMBreakpoints() {
    this.removeDOMBreakpoints((_breakpoint) => true);
  }
  toggleDOMBreakpoint(breakpoint, enabled) {
    if (enabled === breakpoint.enabled) {
      return;
    }
    breakpoint.enabled = enabled;
    if (enabled) {
      this.enableDOMBreakpoint(breakpoint);
    } else {
      this.disableDOMBreakpoint(breakpoint);
    }
    this.saveDOMBreakpoints();
    this.dispatchEventToListeners("DOMBreakpointToggled", breakpoint);
  }
  enableDOMBreakpoint(breakpoint) {
    if (breakpoint.node.id) {
      void this.agent.invoke_setDOMBreakpoint({ nodeId: breakpoint.node.id, type: breakpoint.type });
      breakpoint.node.setMarker(Marker, true);
    }
  }
  disableDOMBreakpoint(breakpoint) {
    if (breakpoint.node.id) {
      void this.agent.invoke_removeDOMBreakpoint({ nodeId: breakpoint.node.id, type: breakpoint.type });
      breakpoint.node.setMarker(Marker, this.nodeHasBreakpoints(breakpoint.node) ? true : null);
    }
  }
  nodeHasBreakpoints(node) {
    for (const breakpoint of this.#domBreakpoints) {
      if (breakpoint.node === node && breakpoint.enabled) {
        return true;
      }
    }
    return false;
  }
  resolveDOMBreakpointData(auxData) {
    const type = auxData["type"];
    const node = this.#domModel.nodeForId(auxData["nodeId"]);
    if (!type || !node) {
      return null;
    }
    let targetNode = null;
    let insertion = false;
    if (type === "subtree-modified") {
      insertion = auxData["insertion"] || false;
      targetNode = this.#domModel.nodeForId(auxData["targetNodeId"]);
    }
    return { type, node, targetNode, insertion };
  }
  currentURL() {
    const domDocument = this.#domModel.existingDocument();
    return domDocument ? domDocument.documentURL : Platform20.DevToolsPath.EmptyUrlString;
  }
  async documentUpdated() {
    if (this.suspended) {
      return;
    }
    const removed = this.#domBreakpoints;
    this.#domBreakpoints = [];
    this.dispatchEventToListeners("DOMBreakpointsRemoved", removed);
    const document2 = await this.#domModel.requestDocument();
    const currentURL = document2 ? document2.documentURL : Platform20.DevToolsPath.EmptyUrlString;
    for (const breakpoint of this.#domBreakpointsSetting.get()) {
      if (breakpoint.url === currentURL) {
        void this.#domModel.pushNodeByPathToFrontend(breakpoint.path).then(appendBreakpoint.bind(this, breakpoint));
      }
    }
    function appendBreakpoint(breakpoint, nodeId) {
      const node = nodeId ? this.#domModel.nodeForId(nodeId) : null;
      if (!node) {
        return;
      }
      for (const existingBreakpoint of this.#domBreakpoints) {
        if (existingBreakpoint.node === node && existingBreakpoint.type === breakpoint.type) {
          return;
        }
      }
      const domBreakpoint = new DOMBreakpoint(this, node, breakpoint.type, breakpoint.enabled);
      this.#domBreakpoints.push(domBreakpoint);
      if (breakpoint.enabled) {
        this.enableDOMBreakpoint(domBreakpoint);
      }
      this.dispatchEventToListeners("DOMBreakpointAdded", domBreakpoint);
    }
  }
  removeDOMBreakpoints(filter) {
    const removed = [];
    const left = [];
    for (const breakpoint of this.#domBreakpoints) {
      if (filter(breakpoint)) {
        removed.push(breakpoint);
        if (breakpoint.enabled) {
          breakpoint.enabled = false;
          this.disableDOMBreakpoint(breakpoint);
        }
      } else {
        left.push(breakpoint);
      }
    }
    if (!removed.length) {
      return;
    }
    this.#domBreakpoints = left;
    this.saveDOMBreakpoints();
    this.dispatchEventToListeners("DOMBreakpointsRemoved", removed);
  }
  nodeRemoved(event) {
    if (this.suspended) {
      return;
    }
    const { node } = event.data;
    const children = node.children() || [];
    this.removeDOMBreakpoints((breakpoint) => breakpoint.node === node || children.indexOf(breakpoint.node) !== -1);
  }
  saveDOMBreakpoints() {
    const currentURL = this.currentURL();
    const breakpoints = this.#domBreakpointsSetting.get().filter((breakpoint) => breakpoint.url !== currentURL);
    for (const breakpoint of this.#domBreakpoints) {
      breakpoints.push({ url: currentURL, path: breakpoint.node.path(), type: breakpoint.type, enabled: breakpoint.enabled });
    }
    this.#domBreakpointsSetting.set(breakpoints);
  }
};
var Marker = "breakpoint-marker";
var DOMBreakpoint = class {
  domDebuggerModel;
  node;
  type;
  enabled;
  constructor(domDebuggerModel, node, type, enabled) {
    this.domDebuggerModel = domDebuggerModel;
    this.node = node;
    this.type = type;
    this.enabled = enabled;
  }
};
var EventListener = class {
  #domDebuggerModel;
  #eventTarget;
  #type;
  #useCapture;
  #passive;
  #once;
  #handler;
  #originalHandler;
  #location;
  #sourceURL;
  #customRemoveFunction;
  #origin;
  constructor(domDebuggerModel, eventTarget, type, useCapture, passive, once, handler, originalHandler, location, customRemoveFunction, origin) {
    this.#domDebuggerModel = domDebuggerModel;
    this.#eventTarget = eventTarget;
    this.#type = type;
    this.#useCapture = useCapture;
    this.#passive = passive;
    this.#once = once;
    this.#handler = handler;
    this.#originalHandler = originalHandler || handler;
    this.#location = location;
    const script = location.script();
    this.#sourceURL = script ? script.contentURL() : Platform20.DevToolsPath.EmptyUrlString;
    this.#customRemoveFunction = customRemoveFunction;
    this.#origin = origin || "Raw";
  }
  domDebuggerModel() {
    return this.#domDebuggerModel;
  }
  type() {
    return this.#type;
  }
  useCapture() {
    return this.#useCapture;
  }
  passive() {
    return this.#passive;
  }
  once() {
    return this.#once;
  }
  handler() {
    return this.#handler;
  }
  location() {
    return this.#location;
  }
  sourceURL() {
    return this.#sourceURL;
  }
  originalHandler() {
    return this.#originalHandler;
  }
  canRemove() {
    return Boolean(this.#customRemoveFunction) || this.#origin !== "FrameworkUser";
  }
  remove() {
    if (!this.canRemove()) {
      return Promise.resolve(void 0);
    }
    if (this.#origin !== "FrameworkUser") {
      let removeListener = function(type, listener, useCapture) {
        this.removeEventListener(type, listener, useCapture);
        if (this["on" + type]) {
          this["on" + type] = void 0;
        }
      };
      return this.#eventTarget.callFunction(removeListener, [
        RemoteObject.toCallArgument(this.#type),
        RemoteObject.toCallArgument(this.#originalHandler),
        RemoteObject.toCallArgument(this.#useCapture)
      ]).then(() => void 0);
    }
    if (this.#customRemoveFunction) {
      let callCustomRemove = function(type, listener, useCapture, passive) {
        this.call(null, type, listener, useCapture, passive);
      };
      return this.#customRemoveFunction.callFunction(callCustomRemove, [
        RemoteObject.toCallArgument(this.#type),
        RemoteObject.toCallArgument(this.#originalHandler),
        RemoteObject.toCallArgument(this.#useCapture),
        RemoteObject.toCallArgument(this.#passive)
      ]).then(() => void 0);
    }
    return Promise.resolve(void 0);
  }
  canTogglePassive() {
    return this.#origin !== "FrameworkUser";
  }
  togglePassive() {
    return this.#eventTarget.callFunction(callTogglePassive, [
      RemoteObject.toCallArgument(this.#type),
      RemoteObject.toCallArgument(this.#originalHandler),
      RemoteObject.toCallArgument(this.#useCapture),
      RemoteObject.toCallArgument(this.#passive)
    ]).then(() => void 0);
    function callTogglePassive(type, listener, useCapture, passive) {
      this.removeEventListener(type, listener, { capture: useCapture });
      this.addEventListener(type, listener, { capture: useCapture, passive: !passive });
    }
  }
  origin() {
    return this.#origin;
  }
  markAsFramework() {
    this.#origin = "Framework";
  }
  isScrollBlockingType() {
    return this.#type === "touchstart" || this.#type === "touchmove" || this.#type === "mousewheel" || this.#type === "wheel";
  }
};
var CSPViolationBreakpoint = class extends CategorizedBreakpoint {
  #type;
  constructor(category, type) {
    super(category, type);
    this.#type = type;
  }
  type() {
    return this.#type;
  }
};
var DOMEventListenerBreakpoint = class extends CategorizedBreakpoint {
  eventTargetNames;
  constructor(eventName, eventTargetNames, category) {
    super(category, eventName);
    this.eventTargetNames = eventTargetNames;
  }
  setEnabled(enabled) {
    if (this.enabled() === enabled) {
      return;
    }
    super.setEnabled(enabled);
    for (const model of TargetManager.instance().models(DOMDebuggerModel)) {
      this.updateOnModel(model);
    }
  }
  updateOnModel(model) {
    for (const eventTargetName of this.eventTargetNames) {
      if (this.enabled()) {
        void model.agent.invoke_setEventListenerBreakpoint({ eventName: this.name, targetName: eventTargetName });
      } else {
        void model.agent.invoke_removeEventListenerBreakpoint({ eventName: this.name, targetName: eventTargetName });
      }
    }
  }
  static listener = "listener:";
};
var domDebuggerManagerInstance;
var DOMDebuggerManager = class _DOMDebuggerManager {
  #xhrBreakpointsSetting;
  #xhrBreakpoints = /* @__PURE__ */ new Map();
  #cspViolationsToBreakOn = [];
  #eventListenerBreakpoints = [];
  constructor() {
    this.#xhrBreakpointsSetting = Common38.Settings.Settings.instance().createLocalSetting("xhr-breakpoints", []);
    for (const breakpoint of this.#xhrBreakpointsSetting.get()) {
      this.#xhrBreakpoints.set(breakpoint.url, breakpoint.enabled);
    }
    this.#cspViolationsToBreakOn.push(new CSPViolationBreakpoint(
      "trusted-type-violation",
      "trustedtype-sink-violation"
      /* Protocol.DOMDebugger.CSPViolationType.TrustedtypeSinkViolation */
    ));
    this.#cspViolationsToBreakOn.push(new CSPViolationBreakpoint(
      "trusted-type-violation",
      "trustedtype-policy-violation"
      /* Protocol.DOMDebugger.CSPViolationType.TrustedtypePolicyViolation */
    ));
    this.createEventListenerBreakpoints("media", [
      "play",
      "pause",
      "playing",
      "canplay",
      "canplaythrough",
      "seeking",
      "seeked",
      "timeupdate",
      "ended",
      "ratechange",
      "durationchange",
      "volumechange",
      "loadstart",
      "progress",
      "suspend",
      "abort",
      "error",
      "emptied",
      "stalled",
      "loadedmetadata",
      "loadeddata",
      "waiting"
    ], ["audio", "video"]);
    this.createEventListenerBreakpoints("picture-in-picture", ["enterpictureinpicture", "leavepictureinpicture"], ["video"]);
    this.createEventListenerBreakpoints("picture-in-picture", ["resize"], ["PictureInPictureWindow"]);
    this.createEventListenerBreakpoints("picture-in-picture", ["enter"], ["documentPictureInPicture"]);
    this.createEventListenerBreakpoints("clipboard", ["copy", "cut", "paste", "beforecopy", "beforecut", "beforepaste"], ["*"]);
    this.createEventListenerBreakpoints("control", [
      "resize",
      "scroll",
      "scrollend",
      "scrollsnapchange",
      "scrollsnapchanging",
      "zoom",
      "focus",
      "blur",
      "select",
      "change",
      "submit",
      "reset"
    ], ["*"]);
    this.createEventListenerBreakpoints("device", ["deviceorientation", "devicemotion"], ["*"]);
    this.createEventListenerBreakpoints("dom-mutation", [
      "DOMActivate",
      "DOMFocusIn",
      "DOMFocusOut",
      "DOMAttrModified",
      "DOMCharacterDataModified",
      "DOMNodeInserted",
      "DOMNodeInsertedIntoDocument",
      "DOMNodeRemoved",
      "DOMNodeRemovedFromDocument",
      "DOMSubtreeModified",
      "DOMContentLoaded"
    ], ["*"]);
    this.createEventListenerBreakpoints("drag-drop", ["drag", "dragstart", "dragend", "dragenter", "dragover", "dragleave", "drop"], ["*"]);
    this.createEventListenerBreakpoints("keyboard", ["keydown", "keyup", "keypress", "input"], ["*"]);
    this.createEventListenerBreakpoints("load", [
      "load",
      "beforeunload",
      "unload",
      "abort",
      "error",
      "hashchange",
      "popstate",
      "navigate",
      "navigatesuccess",
      "navigateerror",
      "currentchange",
      "navigateto",
      "navigatefrom",
      "finish",
      "dispose"
    ], ["*"]);
    this.createEventListenerBreakpoints("mouse", [
      "auxclick",
      "click",
      "dblclick",
      "mousedown",
      "mouseup",
      "mouseover",
      "mousemove",
      "mouseout",
      "mouseenter",
      "mouseleave",
      "mousewheel",
      "wheel",
      "contextmenu"
    ], ["*"]);
    this.createEventListenerBreakpoints("pointer", [
      "pointerover",
      "pointerout",
      "pointerenter",
      "pointerleave",
      "pointerdown",
      "pointerup",
      "pointermove",
      "pointercancel",
      "gotpointercapture",
      "lostpointercapture",
      "pointerrawupdate"
    ], ["*"]);
    this.createEventListenerBreakpoints("touch", ["touchstart", "touchmove", "touchend", "touchcancel"], ["*"]);
    this.createEventListenerBreakpoints("worker", ["message", "messageerror"], ["*"]);
    this.createEventListenerBreakpoints("xhr", ["readystatechange", "load", "loadstart", "loadend", "abort", "error", "progress", "timeout"], ["xmlhttprequest", "xmlhttprequestupload"]);
    TargetManager.instance().observeModels(DOMDebuggerModel, this);
  }
  static instance(opts = { forceNew: null }) {
    const { forceNew } = opts;
    if (!domDebuggerManagerInstance || forceNew) {
      domDebuggerManagerInstance = new _DOMDebuggerManager();
    }
    return domDebuggerManagerInstance;
  }
  cspViolationBreakpoints() {
    return this.#cspViolationsToBreakOn.slice();
  }
  createEventListenerBreakpoints(category, eventNames, eventTargetNames) {
    for (const eventName of eventNames) {
      this.#eventListenerBreakpoints.push(new DOMEventListenerBreakpoint(eventName, eventTargetNames, category));
    }
  }
  resolveEventListenerBreakpoint({ eventName, targetName }) {
    const listenerPrefix = "listener:";
    if (eventName.startsWith(listenerPrefix)) {
      eventName = eventName.substring(listenerPrefix.length);
    } else {
      return null;
    }
    targetName = (targetName || "*").toLowerCase();
    let result = null;
    for (const breakpoint of this.#eventListenerBreakpoints) {
      if (eventName && breakpoint.name === eventName && breakpoint.eventTargetNames.indexOf(targetName) !== -1) {
        result = breakpoint;
      }
      if (!result && eventName && breakpoint.name === eventName && breakpoint.eventTargetNames.indexOf("*") !== -1) {
        result = breakpoint;
      }
    }
    return result;
  }
  eventListenerBreakpoints() {
    return this.#eventListenerBreakpoints.slice();
  }
  updateCSPViolationBreakpoints() {
    const violationTypes = this.#cspViolationsToBreakOn.filter((v) => v.enabled()).map((v) => v.type());
    for (const model of TargetManager.instance().models(DOMDebuggerModel)) {
      this.updateCSPViolationBreakpointsForModel(model, violationTypes);
    }
  }
  updateCSPViolationBreakpointsForModel(model, violationTypes) {
    void model.agent.invoke_setBreakOnCSPViolation({ violationTypes });
  }
  xhrBreakpoints() {
    return this.#xhrBreakpoints;
  }
  saveXHRBreakpoints() {
    const breakpoints = [];
    for (const url of this.#xhrBreakpoints.keys()) {
      breakpoints.push({ url, enabled: this.#xhrBreakpoints.get(url) || false });
    }
    this.#xhrBreakpointsSetting.set(breakpoints);
  }
  addXHRBreakpoint(url, enabled) {
    this.#xhrBreakpoints.set(url, enabled);
    if (enabled) {
      for (const model of TargetManager.instance().models(DOMDebuggerModel)) {
        void model.agent.invoke_setXHRBreakpoint({ url });
      }
    }
    this.saveXHRBreakpoints();
  }
  removeXHRBreakpoint(url) {
    const enabled = this.#xhrBreakpoints.get(url);
    this.#xhrBreakpoints.delete(url);
    if (enabled) {
      for (const model of TargetManager.instance().models(DOMDebuggerModel)) {
        void model.agent.invoke_removeXHRBreakpoint({ url });
      }
    }
    this.saveXHRBreakpoints();
  }
  toggleXHRBreakpoint(url, enabled) {
    this.#xhrBreakpoints.set(url, enabled);
    for (const model of TargetManager.instance().models(DOMDebuggerModel)) {
      if (enabled) {
        void model.agent.invoke_setXHRBreakpoint({ url });
      } else {
        void model.agent.invoke_removeXHRBreakpoint({ url });
      }
    }
    this.saveXHRBreakpoints();
  }
  modelAdded(domDebuggerModel) {
    for (const url of this.#xhrBreakpoints.keys()) {
      if (this.#xhrBreakpoints.get(url)) {
        void domDebuggerModel.agent.invoke_setXHRBreakpoint({ url });
      }
    }
    for (const breakpoint of this.#eventListenerBreakpoints) {
      if (breakpoint.enabled()) {
        breakpoint.updateOnModel(domDebuggerModel);
      }
    }
    const violationTypes = this.#cspViolationsToBreakOn.filter((v) => v.enabled()).map((v) => v.type());
    this.updateCSPViolationBreakpointsForModel(domDebuggerModel, violationTypes);
  }
  modelRemoved(_domDebuggerModel) {
  }
};
SDKModel.register(DOMDebuggerModel, { capabilities: 2, autostart: false });

// gen/front_end/core/sdk/EventBreakpointsModel.js
var EventBreakpointsModel_exports = {};
__export(EventBreakpointsModel_exports, {
  EventBreakpointsManager: () => EventBreakpointsManager,
  EventBreakpointsModel: () => EventBreakpointsModel
});
var EventBreakpointsModel = class extends SDKModel {
  agent;
  constructor(target) {
    super(target);
    this.agent = target.eventBreakpointsAgent();
  }
};
var EventListenerBreakpoint = class extends CategorizedBreakpoint {
  setEnabled(enabled) {
    if (this.enabled() === enabled) {
      return;
    }
    super.setEnabled(enabled);
    for (const model of TargetManager.instance().models(EventBreakpointsModel)) {
      this.updateOnModel(model);
    }
  }
  updateOnModel(model) {
    if (this.enabled()) {
      void model.agent.invoke_setInstrumentationBreakpoint({ eventName: this.name });
    } else {
      void model.agent.invoke_removeInstrumentationBreakpoint({ eventName: this.name });
    }
  }
  static instrumentationPrefix = "instrumentation:";
};
var eventBreakpointManagerInstance;
var EventBreakpointsManager = class _EventBreakpointsManager {
  #eventListenerBreakpoints = [];
  constructor() {
    this.createInstrumentationBreakpoints("auction-worklet", [
      "beforeBidderWorkletBiddingStart",
      "beforeBidderWorkletReportingStart",
      "beforeSellerWorkletScoringStart",
      "beforeSellerWorkletReportingStart"
    ]);
    this.createInstrumentationBreakpoints("animation", [
      "requestAnimationFrame",
      "cancelAnimationFrame",
      "requestAnimationFrame.callback"
    ]);
    this.createInstrumentationBreakpoints("canvas", [
      "canvasContextCreated",
      "webglErrorFired",
      "webglWarningFired"
    ]);
    this.createInstrumentationBreakpoints("geolocation", [
      "Geolocation.getCurrentPosition",
      "Geolocation.watchPosition"
    ]);
    this.createInstrumentationBreakpoints("notification", [
      "Notification.requestPermission"
    ]);
    this.createInstrumentationBreakpoints("parse", [
      "Element.setInnerHTML",
      "Document.write"
    ]);
    this.createInstrumentationBreakpoints("script", [
      "scriptFirstStatement",
      "scriptBlockedByCSP"
    ]);
    this.createInstrumentationBreakpoints("shared-storage-worklet", [
      "sharedStorageWorkletScriptFirstStatement"
    ]);
    this.createInstrumentationBreakpoints("timer", [
      "setTimeout",
      "clearTimeout",
      "setTimeout.callback",
      "setInterval",
      "clearInterval",
      "setInterval.callback"
    ]);
    this.createInstrumentationBreakpoints("window", [
      "DOMWindow.close"
    ]);
    this.createInstrumentationBreakpoints("web-audio", [
      "audioContextCreated",
      "audioContextClosed",
      "audioContextResumed",
      "audioContextSuspended"
    ]);
    TargetManager.instance().observeModels(EventBreakpointsModel, this);
  }
  static instance(opts = { forceNew: null }) {
    const { forceNew } = opts;
    if (!eventBreakpointManagerInstance || forceNew) {
      eventBreakpointManagerInstance = new _EventBreakpointsManager();
    }
    return eventBreakpointManagerInstance;
  }
  createInstrumentationBreakpoints(category, instrumentationNames) {
    for (const instrumentationName of instrumentationNames) {
      this.#eventListenerBreakpoints.push(new EventListenerBreakpoint(category, instrumentationName));
    }
  }
  eventListenerBreakpoints() {
    return this.#eventListenerBreakpoints.slice();
  }
  resolveEventListenerBreakpoint({ eventName }) {
    if (!eventName.startsWith(EventListenerBreakpoint.instrumentationPrefix)) {
      return null;
    }
    const instrumentationName = eventName.substring(EventListenerBreakpoint.instrumentationPrefix.length);
    return this.#eventListenerBreakpoints.find((b) => b.name === instrumentationName) || null;
  }
  modelAdded(eventBreakpointModel) {
    for (const breakpoint of this.#eventListenerBreakpoints) {
      if (breakpoint.enabled()) {
        breakpoint.updateOnModel(eventBreakpointModel);
      }
    }
  }
  modelRemoved(_eventBreakpointModel) {
  }
};
SDKModel.register(EventBreakpointsModel, { capabilities: 524288, autostart: false });

// gen/front_end/core/sdk/FrameAssociated.js
var FrameAssociated_exports = {};

// gen/front_end/core/sdk/IsolateManager.js
var IsolateManager_exports = {};
__export(IsolateManager_exports, {
  Isolate: () => Isolate,
  IsolateManager: () => IsolateManager,
  MemoryTrend: () => MemoryTrend,
  MemoryTrendWindowMs: () => MemoryTrendWindowMs
});
import * as Common39 from "./../common/common.js";
var isolateManagerInstance;
var IsolateManager = class _IsolateManager extends Common39.ObjectWrapper.ObjectWrapper {
  #isolates = /* @__PURE__ */ new Map();
  /**
   * Contains null while the isolateId is being retrieved.
   */
  #isolateIdByModel = /* @__PURE__ */ new Map();
  #observers = /* @__PURE__ */ new Set();
  #pollId = 0;
  constructor() {
    super();
    TargetManager.instance().observeModels(RuntimeModel, this);
  }
  static instance({ forceNew } = { forceNew: false }) {
    if (!isolateManagerInstance || forceNew) {
      isolateManagerInstance = new _IsolateManager();
    }
    return isolateManagerInstance;
  }
  observeIsolates(observer) {
    if (this.#observers.has(observer)) {
      throw new Error("Observer can only be registered once");
    }
    if (!this.#observers.size) {
      void this.poll();
    }
    this.#observers.add(observer);
    for (const isolate of this.#isolates.values()) {
      observer.isolateAdded(isolate);
    }
  }
  modelAdded(model) {
    void this.#modelAdded(model);
  }
  async #modelAdded(model) {
    this.#isolateIdByModel.set(model, null);
    const isolateId = await model.isolateId();
    if (!this.#isolateIdByModel.has(model)) {
      return;
    }
    if (!isolateId) {
      this.#isolateIdByModel.delete(model);
      return;
    }
    this.#isolateIdByModel.set(model, isolateId);
    let isolate = this.#isolates.get(isolateId);
    if (!isolate) {
      isolate = new Isolate(isolateId);
      this.#isolates.set(isolateId, isolate);
    }
    isolate.models().add(model);
    if (isolate.models().size === 1) {
      for (const observer of this.#observers) {
        observer.isolateAdded(isolate);
      }
    } else {
      for (const observer of this.#observers) {
        observer.isolateChanged(isolate);
      }
    }
  }
  modelRemoved(model) {
    const isolateId = this.#isolateIdByModel.get(model);
    this.#isolateIdByModel.delete(model);
    if (!isolateId) {
      return;
    }
    const isolate = this.#isolates.get(isolateId);
    if (!isolate) {
      return;
    }
    isolate.models().delete(model);
    if (isolate.models().size) {
      for (const observer of this.#observers) {
        observer.isolateChanged(isolate);
      }
      return;
    }
    for (const observer of this.#observers) {
      observer.isolateRemoved(isolate);
    }
    this.#isolates.delete(isolateId);
  }
  isolateByModel(model) {
    return this.#isolates.get(this.#isolateIdByModel.get(model) || "") || null;
  }
  isolates() {
    return this.#isolates.values();
  }
  async poll() {
    const pollId = this.#pollId;
    while (pollId === this.#pollId) {
      await Promise.all(Array.from(this.isolates(), (isolate) => isolate.update()));
      await new Promise((r) => window.setTimeout(r, PollIntervalMs));
    }
  }
};
var MemoryTrendWindowMs = 12e4;
var PollIntervalMs = 2e3;
var Isolate = class {
  #id;
  #models;
  #usedHeapSize;
  #memoryTrend;
  constructor(id) {
    this.#id = id;
    this.#models = /* @__PURE__ */ new Set();
    this.#usedHeapSize = 0;
    const count = MemoryTrendWindowMs / PollIntervalMs;
    this.#memoryTrend = new MemoryTrend(count);
  }
  id() {
    return this.#id;
  }
  models() {
    return this.#models;
  }
  runtimeModel() {
    return this.#models.values().next().value || null;
  }
  heapProfilerModel() {
    const runtimeModel = this.runtimeModel();
    return runtimeModel?.heapProfilerModel() ?? null;
  }
  async update() {
    const model = this.runtimeModel();
    const usage = model && await model.heapUsage();
    if (!usage) {
      return;
    }
    this.#usedHeapSize = usage.usedSize + (usage.embedderHeapUsedSize ?? 0) + (usage.backingStorageSize ?? 0);
    this.#memoryTrend.add(this.#usedHeapSize);
    IsolateManager.instance().dispatchEventToListeners("MemoryChanged", this);
  }
  samplesCount() {
    return this.#memoryTrend.count();
  }
  usedHeapSize() {
    return this.#usedHeapSize;
  }
  /**
   * bytes per millisecond
   */
  usedHeapSizeGrowRate() {
    return this.#memoryTrend.fitSlope();
  }
};
var MemoryTrend = class {
  #maxCount;
  #base;
  #index;
  #x;
  #y;
  #sx;
  #sy;
  #sxx;
  #sxy;
  constructor(maxCount) {
    this.#maxCount = maxCount | 0;
    this.reset();
  }
  reset() {
    this.#base = Date.now();
    this.#index = 0;
    this.#x = [];
    this.#y = [];
    this.#sx = 0;
    this.#sy = 0;
    this.#sxx = 0;
    this.#sxy = 0;
  }
  count() {
    return this.#x.length;
  }
  add(heapSize, timestamp) {
    const x = typeof timestamp === "number" ? timestamp : Date.now() - this.#base;
    const y = heapSize;
    if (this.#x.length === this.#maxCount) {
      const x0 = this.#x[this.#index];
      const y0 = this.#y[this.#index];
      this.#sx -= x0;
      this.#sy -= y0;
      this.#sxx -= x0 * x0;
      this.#sxy -= x0 * y0;
    }
    this.#sx += x;
    this.#sy += y;
    this.#sxx += x * x;
    this.#sxy += x * y;
    this.#x[this.#index] = x;
    this.#y[this.#index] = y;
    this.#index = (this.#index + 1) % this.#maxCount;
  }
  fitSlope() {
    const n = this.count();
    return n < 2 ? 0 : (this.#sxy - this.#sx * this.#sy / n) / (this.#sxx - this.#sx * this.#sx / n);
  }
};

// gen/front_end/core/sdk/IssuesModel.js
var IssuesModel_exports = {};
__export(IssuesModel_exports, {
  IssuesModel: () => IssuesModel
});
var IssuesModel = class extends SDKModel {
  #disposed = false;
  #enabled = false;
  constructor(target) {
    super(target);
    void this.ensureEnabled();
  }
  async ensureEnabled() {
    if (this.#enabled) {
      return;
    }
    this.#enabled = true;
    this.target().registerAuditsDispatcher(this);
    const auditsAgent = this.target().auditsAgent();
    await auditsAgent.invoke_enable();
  }
  issueAdded(issueAddedEvent) {
    this.dispatchEventToListeners("IssueAdded", { issuesModel: this, inspectorIssue: issueAddedEvent.issue });
  }
  dispose() {
    super.dispose();
    this.#disposed = true;
  }
  getTargetIfNotDisposed() {
    if (!this.#disposed) {
      return this.target();
    }
    return null;
  }
};
SDKModel.register(IssuesModel, { capabilities: 32768, autostart: true });

// gen/front_end/core/sdk/LayerTreeBase.js
var LayerTreeBase_exports = {};
__export(LayerTreeBase_exports, {
  LayerTreeBase: () => LayerTreeBase,
  StickyPositionConstraint: () => StickyPositionConstraint
});
var StickyPositionConstraint = class {
  #stickyBoxRect;
  #containingBlockRect;
  #nearestLayerShiftingStickyBox;
  #nearestLayerShiftingContainingBlock;
  constructor(layerTree, constraint) {
    this.#stickyBoxRect = constraint.stickyBoxRect;
    this.#containingBlockRect = constraint.containingBlockRect;
    this.#nearestLayerShiftingStickyBox = null;
    if (layerTree && constraint.nearestLayerShiftingStickyBox) {
      this.#nearestLayerShiftingStickyBox = layerTree.layerById(constraint.nearestLayerShiftingStickyBox);
    }
    this.#nearestLayerShiftingContainingBlock = null;
    if (layerTree && constraint.nearestLayerShiftingContainingBlock) {
      this.#nearestLayerShiftingContainingBlock = layerTree.layerById(constraint.nearestLayerShiftingContainingBlock);
    }
  }
  stickyBoxRect() {
    return this.#stickyBoxRect;
  }
  containingBlockRect() {
    return this.#containingBlockRect;
  }
  nearestLayerShiftingStickyBox() {
    return this.#nearestLayerShiftingStickyBox;
  }
  nearestLayerShiftingContainingBlock() {
    return this.#nearestLayerShiftingContainingBlock;
  }
};
var LayerTreeBase = class {
  #target;
  #domModel;
  layersById = /* @__PURE__ */ new Map();
  #root = null;
  #contentRoot = null;
  #backendNodeIdToNode = /* @__PURE__ */ new Map();
  #viewportSize;
  constructor(target) {
    this.#target = target;
    this.#domModel = target ? target.model(DOMModel) : null;
  }
  target() {
    return this.#target;
  }
  root() {
    return this.#root;
  }
  setRoot(root) {
    this.#root = root;
  }
  contentRoot() {
    return this.#contentRoot;
  }
  setContentRoot(contentRoot) {
    this.#contentRoot = contentRoot;
  }
  forEachLayer(callback, root) {
    if (!root) {
      root = this.root();
      if (!root) {
        return false;
      }
    }
    return callback(root) || root.children().some(this.forEachLayer.bind(this, callback));
  }
  layerById(id) {
    return this.layersById.get(id) || null;
  }
  async resolveBackendNodeIds(requestedNodeIds) {
    if (!requestedNodeIds.size || !this.#domModel) {
      return;
    }
    const nodesMap = await this.#domModel.pushNodesByBackendIdsToFrontend(requestedNodeIds);
    if (!nodesMap) {
      return;
    }
    for (const nodeId of nodesMap.keys()) {
      this.#backendNodeIdToNode.set(nodeId, nodesMap.get(nodeId) || null);
    }
  }
  backendNodeIdToNode() {
    return this.#backendNodeIdToNode;
  }
  setViewportSize(viewportSize) {
    this.#viewportSize = viewportSize;
  }
  viewportSize() {
    return this.#viewportSize;
  }
};

// gen/front_end/core/sdk/PageLoad.js
var PageLoad_exports = {};
__export(PageLoad_exports, {
  PageLoad: () => PageLoad
});
var PageLoad = class _PageLoad {
  id;
  url;
  startTime;
  loadTime;
  contentLoadTime;
  mainRequest;
  constructor(mainRequest) {
    this.id = ++_PageLoad.lastIdentifier;
    this.url = mainRequest.url();
    this.startTime = mainRequest.startTime;
    this.mainRequest = mainRequest;
  }
  static forRequest(request) {
    return pageLoadForRequest.get(request) || null;
  }
  bindRequest(request) {
    pageLoadForRequest.set(request, this);
  }
  static lastIdentifier = 0;
};
var pageLoadForRequest = /* @__PURE__ */ new WeakMap();

// gen/front_end/core/sdk/PaintProfiler.js
var PaintProfiler_exports = {};
__export(PaintProfiler_exports, {
  PaintProfilerLogItem: () => PaintProfilerLogItem,
  PaintProfilerModel: () => PaintProfilerModel,
  PaintProfilerSnapshot: () => PaintProfilerSnapshot
});
var PaintProfilerModel = class extends SDKModel {
  layerTreeAgent;
  constructor(target) {
    super(target);
    this.layerTreeAgent = target.layerTreeAgent();
  }
  async loadSnapshotFromFragments(tiles) {
    const { snapshotId } = await this.layerTreeAgent.invoke_loadSnapshot({ tiles });
    return snapshotId ? new PaintProfilerSnapshot(this, snapshotId) : null;
  }
  loadSnapshot(encodedPicture) {
    const fragment = { x: 0, y: 0, picture: encodedPicture };
    return this.loadSnapshotFromFragments([fragment]);
  }
  async makeSnapshot(layerId) {
    const { snapshotId } = await this.layerTreeAgent.invoke_makeSnapshot({ layerId });
    return snapshotId ? new PaintProfilerSnapshot(this, snapshotId) : null;
  }
};
var PaintProfilerSnapshot = class {
  #paintProfilerModel;
  #id;
  #refCount;
  constructor(paintProfilerModel, snapshotId) {
    this.#paintProfilerModel = paintProfilerModel;
    this.#id = snapshotId;
    this.#refCount = 1;
  }
  release() {
    console.assert(this.#refCount > 0, "release is already called on the object");
    if (!--this.#refCount) {
      void this.#paintProfilerModel.layerTreeAgent.invoke_releaseSnapshot({ snapshotId: this.#id });
    }
  }
  addReference() {
    ++this.#refCount;
    console.assert(this.#refCount > 0, "Referencing a dead object");
  }
  async replay(scale, fromStep, toStep) {
    const response = await this.#paintProfilerModel.layerTreeAgent.invoke_replaySnapshot({ snapshotId: this.#id, fromStep, toStep, scale: scale || 1 });
    return response.dataURL;
  }
  async profile(clipRect) {
    const response = await this.#paintProfilerModel.layerTreeAgent.invoke_profileSnapshot({ snapshotId: this.#id, minRepeatCount: 5, minDuration: 1, clipRect: clipRect || void 0 });
    return response.timings;
  }
  async commandLog() {
    const response = await this.#paintProfilerModel.layerTreeAgent.invoke_snapshotCommandLog({ snapshotId: this.#id });
    return response.commandLog ? response.commandLog.map((entry, index) => new PaintProfilerLogItem(entry, index)) : null;
  }
};
var PaintProfilerLogItem = class {
  method;
  params;
  commandIndex;
  constructor(rawEntry, commandIndex) {
    this.method = rawEntry.method;
    this.params = rawEntry.params;
    this.commandIndex = commandIndex;
  }
};
SDKModel.register(PaintProfilerModel, { capabilities: 2, autostart: false });

// gen/front_end/core/sdk/PerformanceMetricsModel.js
var PerformanceMetricsModel_exports = {};
__export(PerformanceMetricsModel_exports, {
  PerformanceMetricsModel: () => PerformanceMetricsModel
});
import * as Platform21 from "./../platform/platform.js";
var PerformanceMetricsModel = class extends SDKModel {
  #agent;
  #metricModes = /* @__PURE__ */ new Map([
    [
      "TaskDuration",
      "CumulativeTime"
      /* MetricMode.CUMULATIVE_TIME */
    ],
    [
      "ScriptDuration",
      "CumulativeTime"
      /* MetricMode.CUMULATIVE_TIME */
    ],
    [
      "LayoutDuration",
      "CumulativeTime"
      /* MetricMode.CUMULATIVE_TIME */
    ],
    [
      "RecalcStyleDuration",
      "CumulativeTime"
      /* MetricMode.CUMULATIVE_TIME */
    ],
    [
      "LayoutCount",
      "CumulativeCount"
      /* MetricMode.CUMULATIVE_COUNT */
    ],
    [
      "RecalcStyleCount",
      "CumulativeCount"
      /* MetricMode.CUMULATIVE_COUNT */
    ]
  ]);
  #metricData = /* @__PURE__ */ new Map();
  constructor(target) {
    super(target);
    this.#agent = target.performanceAgent();
  }
  enable() {
    return this.#agent.invoke_enable({});
  }
  disable() {
    return this.#agent.invoke_disable();
  }
  async requestMetrics() {
    const rawMetrics = await this.#agent.invoke_getMetrics() || [];
    const metrics = /* @__PURE__ */ new Map();
    const timestamp = performance.now();
    for (const metric of rawMetrics.metrics) {
      let data = this.#metricData.get(metric.name);
      if (!data) {
        data = { lastValue: void 0, lastTimestamp: void 0 };
        this.#metricData.set(metric.name, data);
      }
      let value;
      switch (this.#metricModes.get(metric.name)) {
        case "CumulativeTime":
          value = data.lastTimestamp && data.lastValue ? Platform21.NumberUtilities.clamp((metric.value - data.lastValue) * 1e3 / (timestamp - data.lastTimestamp), 0, 1) : 0;
          data.lastValue = metric.value;
          data.lastTimestamp = timestamp;
          break;
        case "CumulativeCount":
          value = data.lastTimestamp && data.lastValue ? Math.max(0, (metric.value - data.lastValue) * 1e3 / (timestamp - data.lastTimestamp)) : 0;
          data.lastValue = metric.value;
          data.lastTimestamp = timestamp;
          break;
        default:
          value = metric.value;
          break;
      }
      metrics.set(metric.name, value);
    }
    return { metrics, timestamp };
  }
};
SDKModel.register(PerformanceMetricsModel, { capabilities: 2, autostart: false });

// gen/front_end/core/sdk/PreloadingModel.js
var PreloadingModel_exports = {};
__export(PreloadingModel_exports, {
  PreloadPipeline: () => PreloadPipeline,
  PreloadingModel: () => PreloadingModel
});

// gen/front_end/core/common/MapWithDefault.js
var MapWithDefault = class extends Map {
  getOrInsert(key, defaultValue) {
    if (!this.has(key)) {
      this.set(key, defaultValue);
    }
    return this.get(key);
  }
  getOrInsertComputed(key, callbackFunction) {
    if (!this.has(key)) {
      this.set(key, callbackFunction(key));
    }
    return this.get(key);
  }
};

// gen/front_end/core/sdk/PreloadingModel.js
import { assertNotNullOrUndefined as assertNotNullOrUndefined3 } from "./../platform/platform.js";
var PreloadingModel = class _PreloadingModel extends SDKModel {
  agent;
  loaderIds = [];
  targetJustAttached = true;
  lastPrimaryPageModel = null;
  documents = /* @__PURE__ */ new Map();
  constructor(target) {
    super(target);
    target.registerPreloadDispatcher(new PreloadDispatcher(this));
    this.agent = target.preloadAgent();
    void this.agent.invoke_enable();
    const targetInfo = target.targetInfo();
    if (targetInfo !== void 0 && targetInfo.subtype === "prerender") {
      this.lastPrimaryPageModel = TargetManager.instance().primaryPageTarget()?.model(_PreloadingModel) || null;
    }
    TargetManager.instance().addModelListener(ResourceTreeModel, Events3.PrimaryPageChanged, this.onPrimaryPageChanged, this);
  }
  dispose() {
    super.dispose();
    TargetManager.instance().removeModelListener(ResourceTreeModel, Events3.PrimaryPageChanged, this.onPrimaryPageChanged, this);
    void this.agent.invoke_disable();
  }
  ensureDocumentPreloadingData(loaderId) {
    if (this.documents.get(loaderId) === void 0) {
      this.documents.set(loaderId, new DocumentPreloadingData());
    }
  }
  currentLoaderId() {
    if (this.targetJustAttached) {
      return null;
    }
    if (this.loaderIds.length === 0) {
      throw new Error("unreachable");
    }
    return this.loaderIds[this.loaderIds.length - 1];
  }
  currentDocument() {
    const loaderId = this.currentLoaderId();
    return loaderId === null ? null : this.documents.get(loaderId) || null;
  }
  // Returns a rule set of the current page.
  //
  // Returns reference. Don't save returned values.
  // Returned value may or may not be updated as the time grows.
  getRuleSetById(id) {
    return this.currentDocument()?.ruleSets.getById(id) || null;
  }
  // Returns rule sets of the current page.
  //
  // Returns array of pairs of id and reference. Don't save returned references.
  // Returned values may or may not be updated as the time grows.
  getAllRuleSets() {
    return this.currentDocument()?.ruleSets.getAll() || [];
  }
  getPreloadCountsByRuleSetId() {
    const countsByRuleSetId = /* @__PURE__ */ new Map();
    for (const { value } of this.getRepresentativePreloadingAttempts(null)) {
      for (const ruleSetId of [null, ...value.ruleSetIds]) {
        if (countsByRuleSetId.get(ruleSetId) === void 0) {
          countsByRuleSetId.set(ruleSetId, /* @__PURE__ */ new Map());
        }
        const countsByStatus = countsByRuleSetId.get(ruleSetId);
        assertNotNullOrUndefined3(countsByStatus);
        const i = countsByStatus.get(value.status) || 0;
        countsByStatus.set(value.status, i + 1);
      }
    }
    return countsByRuleSetId;
  }
  // Returns a preloading attempt of the current page.
  //
  // Returns reference. Don't save returned values.
  // Returned value may or may not be updated as the time grows.
  getPreloadingAttemptById(id) {
    const document2 = this.currentDocument();
    if (document2 === null) {
      return null;
    }
    return document2.preloadingAttempts.getById(id, document2.sources) || null;
  }
  // Returs preloading attempts of the current page that triggered by the rule set with `ruleSetId`.
  // `ruleSetId === null` means "do not filter".
  //
  // Returns array of pairs of id and reference. Don't save returned references.
  // Returned values may or may not be updated as the time grows.
  getRepresentativePreloadingAttempts(ruleSetId) {
    const document2 = this.currentDocument();
    if (document2 === null) {
      return [];
    }
    return document2.preloadingAttempts.getAllRepresentative(ruleSetId, document2.sources);
  }
  // Returs preloading attempts of the previousPgae.
  //
  // Returns array of pairs of id and reference. Don't save returned references.
  // Returned values may or may not be updated as the time grows.
  getRepresentativePreloadingAttemptsOfPreviousPage() {
    if (this.loaderIds.length <= 1) {
      return [];
    }
    const document2 = this.documents.get(this.loaderIds[this.loaderIds.length - 2]);
    if (document2 === void 0) {
      return [];
    }
    return document2.preloadingAttempts.getAllRepresentative(null, document2.sources);
  }
  // Precondition: `pipelineId` should exists.
  // Postcondition: The return value is not empty.
  getPipelineById(pipelineId) {
    const document2 = this.currentDocument();
    if (document2 === null) {
      return null;
    }
    return document2.preloadingAttempts.getPipeline(pipelineId, document2.sources);
  }
  // Returns attemtps that are sit in the same preload pipeline.
  getPipeline(attempt) {
    let pipelineNullable = null;
    if (attempt.pipelineId !== null) {
      pipelineNullable = this.getPipelineById(attempt.pipelineId);
    }
    if (pipelineNullable === null) {
      const pipeline = /* @__PURE__ */ new Map();
      pipeline.set(attempt.action, attempt);
      return new PreloadPipeline(pipeline);
    }
    return new PreloadPipeline(pipelineNullable);
  }
  onPrimaryPageChanged(event) {
    const { frame, type } = event.data;
    if (this.lastPrimaryPageModel === null && type === "Activation") {
      return;
    }
    if (this.lastPrimaryPageModel !== null && type !== "Activation") {
      return;
    }
    if (this.lastPrimaryPageModel !== null && type === "Activation") {
      this.loaderIds = this.lastPrimaryPageModel.loaderIds;
      for (const [loaderId, prev] of this.lastPrimaryPageModel.documents.entries()) {
        this.ensureDocumentPreloadingData(loaderId);
        this.documents.get(loaderId)?.mergePrevious(prev);
      }
    }
    this.lastPrimaryPageModel = null;
    const currentLoaderId = frame.loaderId;
    this.loaderIds.push(currentLoaderId);
    this.loaderIds = this.loaderIds.slice(-2);
    this.ensureDocumentPreloadingData(currentLoaderId);
    for (const loaderId of this.documents.keys()) {
      if (!this.loaderIds.includes(loaderId)) {
        this.documents.delete(loaderId);
      }
    }
    this.dispatchEventToListeners(
      "ModelUpdated"
      /* Events.MODEL_UPDATED */
    );
  }
  onRuleSetUpdated(event) {
    const ruleSet = event.ruleSet;
    const loaderId = ruleSet.loaderId;
    if (this.currentLoaderId() === null) {
      this.loaderIds = [loaderId];
      this.targetJustAttached = false;
    }
    this.ensureDocumentPreloadingData(loaderId);
    this.documents.get(loaderId)?.ruleSets.upsert(ruleSet);
    this.dispatchEventToListeners(
      "ModelUpdated"
      /* Events.MODEL_UPDATED */
    );
  }
  onRuleSetRemoved(event) {
    const id = event.id;
    for (const document2 of this.documents.values()) {
      document2.ruleSets.delete(id);
    }
    this.dispatchEventToListeners(
      "ModelUpdated"
      /* Events.MODEL_UPDATED */
    );
  }
  onPreloadingAttemptSourcesUpdated(event) {
    const loaderId = event.loaderId;
    this.ensureDocumentPreloadingData(loaderId);
    const document2 = this.documents.get(loaderId);
    if (document2 === void 0) {
      return;
    }
    document2.sources.update(event.preloadingAttemptSources);
    document2.preloadingAttempts.maybeRegisterNotTriggered(document2.sources);
    document2.preloadingAttempts.cleanUpRemovedAttempts(document2.sources);
    this.dispatchEventToListeners(
      "ModelUpdated"
      /* Events.MODEL_UPDATED */
    );
  }
  onPrefetchStatusUpdated(event) {
    if (event.prefetchStatus === "PrefetchEvictedAfterCandidateRemoved") {
      return;
    }
    const loaderId = event.key.loaderId;
    this.ensureDocumentPreloadingData(loaderId);
    const attempt = {
      action: "Prefetch",
      key: event.key,
      pipelineId: event.pipelineId,
      status: convertPreloadingStatus(event.status),
      prefetchStatus: event.prefetchStatus || null,
      requestId: event.requestId
    };
    this.documents.get(loaderId)?.preloadingAttempts.upsert(attempt);
    this.dispatchEventToListeners(
      "ModelUpdated"
      /* Events.MODEL_UPDATED */
    );
  }
  onPrerenderStatusUpdated(event) {
    const loaderId = event.key.loaderId;
    this.ensureDocumentPreloadingData(loaderId);
    let attempt;
    switch (event.key.action) {
      case "Prerender":
        attempt = {
          action: event.key.action,
          key: event.key,
          pipelineId: event.pipelineId,
          status: convertPreloadingStatus(event.status),
          prerenderStatus: event.prerenderStatus || null,
          disallowedMojoInterface: event.disallowedMojoInterface || null,
          mismatchedHeaders: event.mismatchedHeaders || null
        };
        break;
      case "PrerenderUntilScript":
        attempt = {
          action: event.key.action,
          key: event.key,
          pipelineId: event.pipelineId,
          status: convertPreloadingStatus(event.status),
          prerenderStatus: event.prerenderStatus || null,
          disallowedMojoInterface: event.disallowedMojoInterface || null,
          mismatchedHeaders: event.mismatchedHeaders || null
        };
        break;
      default:
        throw new Error(`unreachable: event.key.action: ${event.key.action}`);
    }
    this.documents.get(loaderId)?.preloadingAttempts.upsert(attempt);
    this.dispatchEventToListeners(
      "ModelUpdated"
      /* Events.MODEL_UPDATED */
    );
  }
  onPreloadEnabledStateUpdated(event) {
    this.dispatchEventToListeners("WarningsUpdated", event);
  }
};
SDKModel.register(PreloadingModel, { capabilities: 2, autostart: false });
var PreloadDispatcher = class {
  model;
  constructor(model) {
    this.model = model;
  }
  ruleSetUpdated(event) {
    this.model.onRuleSetUpdated(event);
  }
  ruleSetRemoved(event) {
    this.model.onRuleSetRemoved(event);
  }
  preloadingAttemptSourcesUpdated(event) {
    this.model.onPreloadingAttemptSourcesUpdated(event);
  }
  prefetchStatusUpdated(event) {
    this.model.onPrefetchStatusUpdated(event);
  }
  prerenderStatusUpdated(event) {
    this.model.onPrerenderStatusUpdated(event);
  }
  preloadEnabledStateUpdated(event) {
    void this.model.onPreloadEnabledStateUpdated(event);
  }
};
var DocumentPreloadingData = class {
  ruleSets = new RuleSetRegistry();
  preloadingAttempts = new PreloadingAttemptRegistry();
  sources = new SourceRegistry();
  mergePrevious(prev) {
    if (!this.ruleSets.isEmpty() || !this.sources.isEmpty()) {
      throw new Error("unreachable");
    }
    this.ruleSets = prev.ruleSets;
    this.preloadingAttempts.mergePrevious(prev.preloadingAttempts);
    this.sources = prev.sources;
  }
};
var RuleSetRegistry = class {
  map = /* @__PURE__ */ new Map();
  isEmpty() {
    return this.map.size === 0;
  }
  // Returns reference. Don't save returned values.
  // Returned values may or may not be updated as the time grows.
  getById(id) {
    return this.map.get(id) || null;
  }
  // Returns reference. Don't save returned values.
  // Returned values may or may not be updated as the time grows.
  getAll() {
    return Array.from(this.map.entries()).map(([id, value]) => ({ id, value }));
  }
  upsert(ruleSet) {
    this.map.set(ruleSet.id, ruleSet);
  }
  delete(id) {
    this.map.delete(id);
  }
};
function convertPreloadingStatus(status) {
  switch (status) {
    case "Pending":
      return "Pending";
    case "Running":
      return "Running";
    case "Ready":
      return "Ready";
    case "Success":
      return "Success";
    case "Failure":
      return "Failure";
    case "NotSupported":
      return "NotSupported";
  }
  throw new Error("unreachable");
}
function makePreloadingAttemptId(key) {
  let action;
  switch (key.action) {
    case "Prefetch":
      action = "Prefetch";
      break;
    case "Prerender":
      action = "Prerender";
      break;
    case "PrerenderUntilScript":
      action = "PrerenderUntilScript";
      break;
  }
  let targetHint;
  switch (key.targetHint) {
    case void 0:
      targetHint = "undefined";
      break;
    case "Blank":
      targetHint = "Blank";
      break;
    case "Self":
      targetHint = "Self";
      break;
  }
  return `${key.loaderId}:${action}:${key.url}:${targetHint}`;
}
var PreloadPipeline = class _PreloadPipeline {
  inner;
  constructor(inner) {
    if (inner.size === 0) {
      throw new Error("unreachable");
    }
    this.inner = inner;
  }
  static newFromAttemptsForTesting(attempts) {
    const inner = /* @__PURE__ */ new Map();
    for (const attempt of attempts) {
      inner.set(attempt.action, attempt);
    }
    return new _PreloadPipeline(inner);
  }
  getOriginallyTriggered() {
    const attempt = this.getPrerender() || this.getPrerenderUntilScript() || this.getPrefetch();
    assertNotNullOrUndefined3(attempt);
    return attempt;
  }
  getPrefetch() {
    return this.inner.get(
      "Prefetch"
      /* Protocol.Preload.SpeculationAction.Prefetch */
    ) || null;
  }
  getPrerender() {
    return this.inner.get(
      "Prerender"
      /* Protocol.Preload.SpeculationAction.Prerender */
    ) || null;
  }
  getPrerenderUntilScript() {
    return this.inner.get(
      "PrerenderUntilScript"
      /* Protocol.Preload.SpeculationAction.PrerenderUntilScript */
    ) || null;
  }
  // Returns attempts in the order: prefetch < prerender_until_script < prerender.
  // Currently unused.
  getAttempts() {
    const ret = [];
    const prefetch = this.getPrefetch();
    if (prefetch !== null) {
      ret.push(prefetch);
    }
    const prerender = this.getPrerender();
    if (prerender !== null) {
      ret.push(prerender);
    }
    const prerenderUntilScript = this.getPrerenderUntilScript();
    if (prerenderUntilScript !== null) {
      ret.push(prerenderUntilScript);
    }
    if (ret.length === 0) {
      throw new Error("unreachable");
    }
    return ret;
  }
};
var PreloadingAttemptRegistry = class {
  map = /* @__PURE__ */ new Map();
  pipelines = new MapWithDefault();
  enrich(attempt, source) {
    let ruleSetIds = [];
    let nodeIds = [];
    if (source !== null) {
      ruleSetIds = source.ruleSetIds;
      nodeIds = source.nodeIds;
    }
    return {
      ...attempt,
      ruleSetIds,
      nodeIds
    };
  }
  // Returns true iff the attempt is triggered by a SpecRules, not automatically derived.
  //
  // In some cases, browsers automatically triggers preloads. For example, Chrome triggers prefetch
  // ahead of prerender to prevent multiple fetches in case that the prerender failed due to, e.g.
  // use of forbidden mojo APIs. Also, a prerender-until-script attempt triggers prefetch as well,
  // and can upgrade to prerender. Such prefetch, prerender-until-script, and prerender sit in the
  // same preload pipeline.
  //
  // We regard them as not representative and only show the representative ones to represent
  // pipelines.
  isAttemptRepresentative(attempt) {
    function getSortKey(action) {
      switch (action) {
        case "Prefetch":
          return 0;
        case "PrerenderUntilScript":
          return 1;
        case "Prerender":
          return 2;
      }
    }
    if (attempt.pipelineId === null) {
      return true;
    }
    const pipeline = this.pipelines.get(attempt.pipelineId);
    assertNotNullOrUndefined3(pipeline);
    if (pipeline.size === 0) {
      throw new Error("unreachable");
    }
    return [...pipeline.keys()].every((action) => getSortKey(action) <= getSortKey(attempt.action));
  }
  // Returns reference. Don't save returned values.
  // Returned values may or may not be updated as the time grows.
  getById(id, sources) {
    const attempt = this.map.get(id) || null;
    if (attempt === null) {
      return null;
    }
    return this.enrich(attempt, sources.getById(id));
  }
  // Returns representative preloading attempts that triggered by the rule set with `ruleSetId`.
  // `ruleSetId === null` means "do not filter".
  //
  // Returns reference. Don't save returned values.
  // Returned values may or may not be updated as the time grows.
  getAllRepresentative(ruleSetId, sources) {
    return [...this.map.entries()].map(([id, value]) => ({ id, value: this.enrich(value, sources.getById(id)) })).filter(({ value }) => !ruleSetId || value.ruleSetIds.includes(ruleSetId)).filter(({ value }) => this.isAttemptRepresentative(value));
  }
  getPipeline(pipelineId, sources) {
    const pipeline = this.pipelines.get(pipelineId);
    if (pipeline === void 0 || pipeline.size === 0) {
      return null;
    }
    const map = {};
    for (const [id, attempt] of this.map.entries()) {
      map[id] = attempt;
    }
    return new Map(pipeline.entries().map(([action, id]) => {
      const attempt = this.getById(id, sources);
      assertNotNullOrUndefined3(attempt);
      return [action, attempt];
    }));
  }
  upsert(attempt) {
    const id = makePreloadingAttemptId(attempt.key);
    this.map.set(id, attempt);
    if (attempt.pipelineId !== null) {
      this.pipelines.getOrInsertComputed(attempt.pipelineId, () => /* @__PURE__ */ new Map()).set(attempt.action, id);
    }
  }
  reconstructPipelines() {
    this.pipelines.clear();
    for (const [id, attempt] of this.map.entries()) {
      if (attempt.pipelineId === null) {
        continue;
      }
      const pipeline = this.pipelines.getOrInsertComputed(attempt.pipelineId, () => /* @__PURE__ */ new Map());
      pipeline.set(attempt.action, id);
    }
  }
  // Speculation rules emits a CDP event Preload.preloadingAttemptSourcesUpdated
  // and an IPC SpeculationHost::UpdateSpeculationCandidates. The latter emits
  // Preload.prefetch/prerenderAttemptUpdated for each preload attempt triggered.
  // In general, "Not triggered to triggered" period is short (resp. long) for
  // eager (resp. non-eager) preloads. For not yet emitted ones, we fill
  // "Not triggered" preload attempts and show them.
  maybeRegisterNotTriggered(sources) {
    for (const [id, { key }] of sources.entries()) {
      if (this.map.get(id) !== void 0) {
        continue;
      }
      let attempt;
      switch (key.action) {
        case "Prefetch":
          attempt = {
            action: "Prefetch",
            key,
            pipelineId: null,
            status: "NotTriggered",
            prefetchStatus: null,
            // Fill invalid request id.
            requestId: ""
          };
          break;
        case "Prerender":
          attempt = {
            action: "Prerender",
            key,
            pipelineId: null,
            status: "NotTriggered",
            prerenderStatus: null,
            disallowedMojoInterface: null,
            mismatchedHeaders: null
          };
          break;
        case "PrerenderUntilScript":
          attempt = {
            action: "PrerenderUntilScript",
            key,
            pipelineId: null,
            status: "NotTriggered",
            prerenderStatus: null,
            disallowedMojoInterface: null,
            mismatchedHeaders: null
          };
          break;
      }
      this.map.set(id, attempt);
    }
  }
  // Removes keys in `this.map` that are not in `sources`. This is used to
  // remove attempts that no longer have a matching speculation rule.
  cleanUpRemovedAttempts(sources) {
    const keysToRemove = Array.from(this.map.keys()).filter((key) => !sources.getById(key));
    for (const key of keysToRemove) {
      this.map.delete(key);
    }
    this.reconstructPipelines();
  }
  mergePrevious(prev) {
    for (const [id, attempt] of this.map.entries()) {
      prev.map.set(id, attempt);
    }
    this.map = prev.map;
    this.reconstructPipelines();
  }
};
var SourceRegistry = class {
  map = /* @__PURE__ */ new Map();
  entries() {
    return this.map.entries();
  }
  isEmpty() {
    return this.map.size === 0;
  }
  getById(id) {
    return this.map.get(id) || null;
  }
  update(sources) {
    this.map = new Map(sources.map((s) => [makePreloadingAttemptId(s.key), s]));
  }
};

// gen/front_end/core/sdk/ScreenCaptureModel.js
var ScreenCaptureModel_exports = {};
__export(ScreenCaptureModel_exports, {
  ScreenCaptureModel: () => ScreenCaptureModel
});
var ScreenCaptureModel = class extends SDKModel {
  #agent;
  #nextScreencastOperationId = 1;
  #screencastOperations = [];
  constructor(target) {
    super(target);
    this.#agent = target.pageAgent();
    target.registerPageDispatcher(this);
  }
  async startScreencast(format, quality, maxWidth, maxHeight, everyNthFrame, onFrame, onVisibilityChanged) {
    const currentRequest = this.#screencastOperations.at(-1);
    if (currentRequest) {
      await this.#agent.invoke_stopScreencast();
    }
    const operation = {
      id: this.#nextScreencastOperationId++,
      request: {
        format,
        quality,
        maxWidth,
        maxHeight,
        everyNthFrame
      },
      callbacks: {
        onScreencastFrame: onFrame,
        onScreencastVisibilityChanged: onVisibilityChanged
      }
    };
    this.#screencastOperations.push(operation);
    void this.#agent.invoke_startScreencast({ format, quality, maxWidth, maxHeight, everyNthFrame });
    return operation.id;
  }
  stopScreencast(id) {
    const operationToStop = this.#screencastOperations.pop();
    if (!operationToStop) {
      throw new Error("There is no screencast operation to stop.");
    }
    if (operationToStop.id !== id) {
      throw new Error("Trying to stop a screencast operation that is not being served right now.");
    }
    void this.#agent.invoke_stopScreencast();
    const nextOperation = this.#screencastOperations.at(-1);
    if (nextOperation) {
      void this.#agent.invoke_startScreencast({
        format: nextOperation.request.format,
        quality: nextOperation.request.quality,
        maxWidth: nextOperation.request.maxWidth,
        maxHeight: nextOperation.request.maxHeight,
        everyNthFrame: nextOperation.request.everyNthFrame
      });
    }
  }
  async captureScreenshot(format, quality, mode, clip) {
    const properties = {
      format,
      quality,
      fromSurface: true
    };
    switch (mode) {
      case "fromClip":
        properties.captureBeyondViewport = true;
        properties.clip = clip;
        break;
      case "fullpage":
        properties.captureBeyondViewport = true;
        break;
      case "fromViewport":
        properties.captureBeyondViewport = false;
        break;
      default:
        throw new Error("Unexpected or unspecified screnshotMode");
    }
    await OverlayModel.muteHighlight();
    const result = await this.#agent.invoke_captureScreenshot(properties);
    await OverlayModel.unmuteHighlight();
    return result.data;
  }
  screencastFrame({ data, metadata, sessionId }) {
    void this.#agent.invoke_screencastFrameAck({ sessionId });
    const currentRequest = this.#screencastOperations.at(-1);
    if (currentRequest) {
      currentRequest.callbacks.onScreencastFrame.call(null, data, metadata);
    }
  }
  screencastVisibilityChanged({ visible }) {
    const currentRequest = this.#screencastOperations.at(-1);
    if (currentRequest) {
      currentRequest.callbacks.onScreencastVisibilityChanged.call(null, visible);
    }
  }
  backForwardCacheNotUsed(_params) {
  }
  domContentEventFired(_params) {
  }
  loadEventFired(_params) {
  }
  lifecycleEvent(_params) {
  }
  navigatedWithinDocument(_params) {
  }
  frameAttached(_params) {
  }
  frameNavigated(_params) {
  }
  documentOpened(_params) {
  }
  frameDetached(_params) {
  }
  frameStartedLoading(_params) {
  }
  frameStoppedLoading(_params) {
  }
  frameRequestedNavigation(_params) {
  }
  frameStartedNavigating(_params) {
  }
  frameSubtreeWillBeDetached(_params) {
  }
  frameScheduledNavigation(_params) {
  }
  frameClearedScheduledNavigation(_params) {
  }
  frameResized() {
  }
  javascriptDialogOpening(_params) {
  }
  javascriptDialogClosed(_params) {
  }
  interstitialShown() {
  }
  interstitialHidden() {
  }
  windowOpen(_params) {
  }
  fileChooserOpened(_params) {
  }
  compilationCacheProduced(_params) {
  }
  downloadWillBegin(_params) {
  }
  downloadProgress() {
  }
  prefetchStatusUpdated(_params) {
  }
  prerenderStatusUpdated(_params) {
  }
};
SDKModel.register(ScreenCaptureModel, { capabilities: 64, autostart: false });

// gen/front_end/core/sdk/ServiceWorkerCacheModel.js
var ServiceWorkerCacheModel_exports = {};
__export(ServiceWorkerCacheModel_exports, {
  Cache: () => Cache,
  ServiceWorkerCacheModel: () => ServiceWorkerCacheModel
});
import * as Common40 from "./../common/common.js";
import * as i18n37 from "./../i18n/i18n.js";

// gen/front_end/core/sdk/StorageBucketsModel.js
var StorageBucketsModel_exports = {};
__export(StorageBucketsModel_exports, {
  StorageBucketsModel: () => StorageBucketsModel
});
var StorageBucketsModel = class extends SDKModel {
  enabled = false;
  storageAgent;
  storageKeyManager;
  bucketsById = /* @__PURE__ */ new Map();
  trackedStorageKeys = /* @__PURE__ */ new Set();
  constructor(target) {
    super(target);
    target.registerStorageDispatcher(this);
    this.storageAgent = target.storageAgent();
    this.storageKeyManager = target.model(StorageKeyManager);
  }
  getBuckets() {
    return new Set(this.bucketsById.values());
  }
  getBucketsForStorageKey(storageKey) {
    const buckets = [...this.bucketsById.values()];
    return new Set(buckets.filter(({ bucket }) => bucket.storageKey === storageKey));
  }
  getDefaultBucketForStorageKey(storageKey) {
    const buckets = [...this.bucketsById.values()];
    return buckets.find(({ bucket }) => bucket.storageKey === storageKey && bucket.name === void 0) ?? null;
  }
  getBucketById(bucketId) {
    return this.bucketsById.get(bucketId) ?? null;
  }
  getBucketByName(storageKey, bucketName) {
    if (!bucketName) {
      return this.getDefaultBucketForStorageKey(storageKey);
    }
    const buckets = [...this.bucketsById.values()];
    return buckets.find(({ bucket }) => bucket.storageKey === storageKey && bucket.name === bucketName) ?? null;
  }
  deleteBucket(bucket) {
    void this.storageAgent.invoke_deleteStorageBucket({ bucket });
  }
  enable() {
    if (this.enabled) {
      return;
    }
    if (this.storageKeyManager) {
      this.storageKeyManager.addEventListener("StorageKeyAdded", this.storageKeyAdded, this);
      this.storageKeyManager.addEventListener("StorageKeyRemoved", this.storageKeyRemoved, this);
      for (const storageKey of this.storageKeyManager.storageKeys()) {
        this.addStorageKey(storageKey);
      }
    }
    this.enabled = true;
  }
  storageKeyAdded(event) {
    this.addStorageKey(event.data);
  }
  storageKeyRemoved(event) {
    this.removeStorageKey(event.data);
  }
  addStorageKey(storageKey) {
    if (this.trackedStorageKeys.has(storageKey)) {
      throw new Error("Can't call addStorageKey for a storage key if it has already been added.");
    }
    this.trackedStorageKeys.add(storageKey);
    void this.storageAgent.invoke_setStorageBucketTracking({ storageKey, enable: true });
  }
  removeStorageKey(storageKey) {
    if (!this.trackedStorageKeys.has(storageKey)) {
      throw new Error("Can't call removeStorageKey for a storage key if it hasn't already been added.");
    }
    const bucketsForStorageKey = this.getBucketsForStorageKey(storageKey);
    for (const bucket of bucketsForStorageKey) {
      this.bucketRemoved(bucket);
    }
    this.trackedStorageKeys.delete(storageKey);
    void this.storageAgent.invoke_setStorageBucketTracking({ storageKey, enable: false });
  }
  bucketAdded(bucketInfo) {
    this.bucketsById.set(bucketInfo.id, bucketInfo);
    this.dispatchEventToListeners("BucketAdded", { model: this, bucketInfo });
  }
  bucketRemoved(bucketInfo) {
    this.bucketsById.delete(bucketInfo.id);
    this.dispatchEventToListeners("BucketRemoved", { model: this, bucketInfo });
  }
  bucketChanged(bucketInfo) {
    this.dispatchEventToListeners("BucketChanged", { model: this, bucketInfo });
  }
  bucketInfosAreEqual(bucketInfo1, bucketInfo2) {
    return bucketInfo1.bucket.storageKey === bucketInfo2.bucket.storageKey && bucketInfo1.id === bucketInfo2.id && bucketInfo1.bucket.name === bucketInfo2.bucket.name && bucketInfo1.expiration === bucketInfo2.expiration && bucketInfo1.quota === bucketInfo2.quota && bucketInfo1.persistent === bucketInfo2.persistent && bucketInfo1.durability === bucketInfo2.durability;
  }
  storageBucketCreatedOrUpdated({ bucketInfo }) {
    const curBucket = this.getBucketById(bucketInfo.id);
    if (curBucket) {
      if (!this.bucketInfosAreEqual(curBucket, bucketInfo)) {
        this.bucketChanged(bucketInfo);
      }
    } else {
      this.bucketAdded(bucketInfo);
    }
  }
  storageBucketDeleted({ bucketId }) {
    const curBucket = this.getBucketById(bucketId);
    if (curBucket) {
      this.bucketRemoved(curBucket);
    } else {
      throw new Error(`Received an event that Storage Bucket '${bucketId}' was deleted, but it wasn't in the StorageBucketsModel.`);
    }
  }
  attributionReportingTriggerRegistered(_event) {
  }
  interestGroupAccessed(_event) {
  }
  interestGroupAuctionEventOccurred(_event) {
  }
  interestGroupAuctionNetworkRequestCreated(_event) {
  }
  indexedDBListUpdated(_event) {
  }
  indexedDBContentUpdated(_event) {
  }
  cacheStorageListUpdated(_event) {
  }
  cacheStorageContentUpdated(_event) {
  }
  sharedStorageAccessed(_event) {
  }
  sharedStorageWorkletOperationExecutionFinished(_event) {
  }
  attributionReportingSourceRegistered(_event) {
  }
  attributionReportingReportSent(_event) {
  }
  attributionReportingVerboseDebugReportSent(_event) {
  }
};
SDKModel.register(StorageBucketsModel, { capabilities: 8192, autostart: false });

// gen/front_end/core/sdk/ServiceWorkerCacheModel.js
var UIStrings17 = {
  /**
   * @description Text in Service Worker Cache Model
   * @example {https://cache} PH1
   * @example {error message} PH2
   */
  serviceworkercacheagentError: "`ServiceWorkerCacheAgent` error deleting cache entry {PH1} in cache: {PH2}"
};
var str_17 = i18n37.i18n.registerUIStrings("core/sdk/ServiceWorkerCacheModel.ts", UIStrings17);
var i18nString17 = i18n37.i18n.getLocalizedString.bind(void 0, str_17);
var ServiceWorkerCacheModel = class extends SDKModel {
  cacheAgent;
  #storageAgent;
  #storageBucketModel;
  #caches = /* @__PURE__ */ new Map();
  #storageKeysTracked = /* @__PURE__ */ new Set();
  #storageBucketsUpdated = /* @__PURE__ */ new Set();
  #throttler = new Common40.Throttler.Throttler(2e3);
  #enabled = false;
  // Used by tests to remove the Throttler timeout.
  #scheduleAsSoonAsPossible = false;
  /**
   * Invariant: This #model can only be constructed on a ServiceWorker target.
   */
  constructor(target) {
    super(target);
    target.registerStorageDispatcher(this);
    this.cacheAgent = target.cacheStorageAgent();
    this.#storageAgent = target.storageAgent();
    this.#storageBucketModel = target.model(StorageBucketsModel);
  }
  enable() {
    if (this.#enabled) {
      return;
    }
    this.#storageBucketModel.addEventListener("BucketAdded", this.storageBucketAdded, this);
    this.#storageBucketModel.addEventListener("BucketRemoved", this.storageBucketRemoved, this);
    for (const storageBucket of this.#storageBucketModel.getBuckets()) {
      this.addStorageBucket(storageBucket.bucket);
    }
    this.#enabled = true;
  }
  clearForStorageKey(storageKey) {
    for (const [opaqueId, cache] of this.#caches.entries()) {
      if (cache.storageKey === storageKey) {
        this.#caches.delete(opaqueId);
        this.cacheRemoved(cache);
      }
    }
    for (const storageBucket of this.#storageBucketModel.getBucketsForStorageKey(storageKey)) {
      void this.loadCacheNames(storageBucket.bucket);
    }
  }
  refreshCacheNames() {
    for (const cache of this.#caches.values()) {
      this.cacheRemoved(cache);
    }
    this.#caches.clear();
    const storageBuckets = this.#storageBucketModel.getBuckets();
    for (const storageBucket of storageBuckets) {
      void this.loadCacheNames(storageBucket.bucket);
    }
  }
  async deleteCache(cache) {
    const response = await this.cacheAgent.invoke_deleteCache({ cacheId: cache.cacheId });
    if (response.getError()) {
      console.error(`ServiceWorkerCacheAgent error deleting cache ${cache.toString()}: ${response.getError()}`);
      return;
    }
    this.#caches.delete(cache.cacheId);
    this.cacheRemoved(cache);
  }
  async deleteCacheEntry(cache, request) {
    const response = await this.cacheAgent.invoke_deleteEntry({ cacheId: cache.cacheId, request });
    if (response.getError()) {
      Common40.Console.Console.instance().error(i18nString17(UIStrings17.serviceworkercacheagentError, { PH1: cache.toString(), PH2: String(response.getError()) }));
      return;
    }
  }
  loadCacheData(cache, skipCount, pageSize, pathFilter, callback) {
    void this.requestEntries(cache, skipCount, pageSize, pathFilter, callback);
  }
  loadAllCacheData(cache, pathFilter, callback) {
    void this.requestAllEntries(cache, pathFilter, callback);
  }
  caches() {
    return [...this.#caches.values()];
  }
  dispose() {
    for (const cache of this.#caches.values()) {
      this.cacheRemoved(cache);
    }
    this.#caches.clear();
    if (this.#enabled) {
      this.#storageBucketModel.removeEventListener("BucketAdded", this.storageBucketAdded, this);
      this.#storageBucketModel.removeEventListener("BucketRemoved", this.storageBucketRemoved, this);
    }
  }
  addStorageBucket(storageBucket) {
    void this.loadCacheNames(storageBucket);
    if (!this.#storageKeysTracked.has(storageBucket.storageKey)) {
      this.#storageKeysTracked.add(storageBucket.storageKey);
      void this.#storageAgent.invoke_trackCacheStorageForStorageKey({ storageKey: storageBucket.storageKey });
    }
  }
  removeStorageBucket(storageBucket) {
    let storageKeyCount = 0;
    for (const [opaqueId, cache] of this.#caches.entries()) {
      if (storageBucket.storageKey === cache.storageKey) {
        storageKeyCount++;
      }
      if (cache.inBucket(storageBucket)) {
        storageKeyCount--;
        this.#caches.delete(opaqueId);
        this.cacheRemoved(cache);
      }
    }
    if (storageKeyCount === 0) {
      this.#storageKeysTracked.delete(storageBucket.storageKey);
      void this.#storageAgent.invoke_untrackCacheStorageForStorageKey({ storageKey: storageBucket.storageKey });
    }
  }
  async loadCacheNames(storageBucket) {
    const response = await this.cacheAgent.invoke_requestCacheNames({ storageBucket });
    if (response.getError()) {
      return;
    }
    this.updateCacheNames(storageBucket, response.caches);
  }
  updateCacheNames(storageBucket, cachesJson) {
    function deleteAndSaveOldCaches(cache) {
      if (cache.inBucket(storageBucket) && !updatingCachesIds.has(cache.cacheId)) {
        oldCaches.set(cache.cacheId, cache);
        this.#caches.delete(cache.cacheId);
      }
    }
    const updatingCachesIds = /* @__PURE__ */ new Set();
    const newCaches = /* @__PURE__ */ new Map();
    const oldCaches = /* @__PURE__ */ new Map();
    for (const cacheJson of cachesJson) {
      const storageBucket2 = cacheJson.storageBucket ?? this.#storageBucketModel.getDefaultBucketForStorageKey(cacheJson.storageKey)?.bucket;
      if (!storageBucket2) {
        continue;
      }
      const cache = new Cache(this, storageBucket2, cacheJson.cacheName, cacheJson.cacheId);
      updatingCachesIds.add(cache.cacheId);
      if (this.#caches.has(cache.cacheId)) {
        continue;
      }
      newCaches.set(cache.cacheId, cache);
      this.#caches.set(cache.cacheId, cache);
    }
    this.#caches.forEach(deleteAndSaveOldCaches, this);
    newCaches.forEach(this.cacheAdded, this);
    oldCaches.forEach(this.cacheRemoved, this);
  }
  storageBucketAdded({ data: { bucketInfo: { bucket } } }) {
    this.addStorageBucket(bucket);
  }
  storageBucketRemoved({ data: { bucketInfo: { bucket } } }) {
    this.removeStorageBucket(bucket);
  }
  cacheAdded(cache) {
    this.dispatchEventToListeners("CacheAdded", { model: this, cache });
  }
  cacheRemoved(cache) {
    this.dispatchEventToListeners("CacheRemoved", { model: this, cache });
  }
  async requestEntries(cache, skipCount, pageSize, pathFilter, callback) {
    const response = await this.cacheAgent.invoke_requestEntries({ cacheId: cache.cacheId, skipCount, pageSize, pathFilter });
    if (response.getError()) {
      console.error("ServiceWorkerCacheAgent error while requesting entries: ", response.getError());
      return;
    }
    callback(response.cacheDataEntries, response.returnCount);
  }
  async requestAllEntries(cache, pathFilter, callback) {
    const response = await this.cacheAgent.invoke_requestEntries({ cacheId: cache.cacheId, pathFilter });
    if (response.getError()) {
      console.error("ServiceWorkerCacheAgent error while requesting entries: ", response.getError());
      return;
    }
    callback(response.cacheDataEntries, response.returnCount);
  }
  cacheStorageListUpdated({ bucketId }) {
    const storageBucket = this.#storageBucketModel.getBucketById(bucketId)?.bucket;
    if (storageBucket) {
      this.#storageBucketsUpdated.add(storageBucket);
      void this.#throttler.schedule(
        () => {
          const promises = Array.from(this.#storageBucketsUpdated, (storageBucket2) => this.loadCacheNames(storageBucket2));
          this.#storageBucketsUpdated.clear();
          return Promise.all(promises);
        },
        this.#scheduleAsSoonAsPossible ? "AsSoonAsPossible" : "Default"
        /* Common.Throttler.Scheduling.DEFAULT */
      );
    }
  }
  cacheStorageContentUpdated({ bucketId, cacheName }) {
    const storageBucket = this.#storageBucketModel.getBucketById(bucketId)?.bucket;
    if (storageBucket) {
      this.dispatchEventToListeners("CacheStorageContentUpdated", { storageBucket, cacheName });
    }
  }
  attributionReportingTriggerRegistered(_event) {
  }
  indexedDBListUpdated(_event) {
  }
  indexedDBContentUpdated(_event) {
  }
  interestGroupAuctionEventOccurred(_event) {
  }
  interestGroupAccessed(_event) {
  }
  interestGroupAuctionNetworkRequestCreated(_event) {
  }
  sharedStorageAccessed(_event) {
  }
  sharedStorageWorkletOperationExecutionFinished(_event) {
  }
  storageBucketCreatedOrUpdated(_event) {
  }
  storageBucketDeleted(_event) {
  }
  setThrottlerSchedulesAsSoonAsPossibleForTest() {
    this.#scheduleAsSoonAsPossible = true;
  }
  attributionReportingSourceRegistered(_event) {
  }
  attributionReportingReportSent(_event) {
  }
  attributionReportingVerboseDebugReportSent(_event) {
  }
};
var Cache = class {
  #model;
  storageKey;
  storageBucket;
  cacheName;
  cacheId;
  constructor(model, storageBucket, cacheName, cacheId) {
    this.#model = model;
    this.storageBucket = storageBucket;
    this.storageKey = storageBucket.storageKey;
    this.cacheName = cacheName;
    this.cacheId = cacheId;
  }
  inBucket(storageBucket) {
    return this.storageKey === storageBucket.storageKey && this.storageBucket.name === storageBucket.name;
  }
  equals(cache) {
    return this.cacheId === cache.cacheId;
  }
  toString() {
    return this.storageKey + this.cacheName;
  }
  async requestCachedResponse(url, requestHeaders) {
    const response = await this.#model.cacheAgent.invoke_requestCachedResponse({ cacheId: this.cacheId, requestURL: url, requestHeaders });
    if (response.getError()) {
      return null;
    }
    return response.response;
  }
};
SDKModel.register(ServiceWorkerCacheModel, { capabilities: 8192, autostart: false });

// gen/front_end/core/sdk/ServiceWorkerManager.js
var ServiceWorkerManager_exports = {};
__export(ServiceWorkerManager_exports, {
  ServiceWorkerManager: () => ServiceWorkerManager,
  ServiceWorkerRegistration: () => ServiceWorkerRegistration,
  ServiceWorkerRouterRule: () => ServiceWorkerRouterRule,
  ServiceWorkerVersion: () => ServiceWorkerVersion,
  ServiceWorkerVersionState: () => ServiceWorkerVersionState
});
import * as Common41 from "./../common/common.js";
import * as i18n39 from "./../i18n/i18n.js";
var UIStrings18 = {
  /**
   * @description Service worker running status displayed in the Service Workers view in the Application panel
   */
  running: "running",
  /**
   * @description Service worker running status displayed in the Service Workers view in the Application panel
   */
  starting: "starting",
  /**
   * @description Service worker running status displayed in the Service Workers view in the Application panel
   */
  stopped: "stopped",
  /**
   * @description Service worker running status displayed in the Service Workers view in the Application panel
   */
  stopping: "stopping",
  /**
   * @description Service worker version status displayed in the Threads view of the Debugging side pane in the Sources panel
   */
  activated: "activated",
  /**
   * @description Service worker version status displayed in the Threads view of the Debugging side pane in the Sources panel
   */
  activating: "activating",
  /**
   * @description Service worker version status displayed in the Threads view of the Debugging side pane in the Sources panel
   */
  installed: "installed",
  /**
   * @description Service worker version status displayed in the Threads view of the Debugging side pane in the Sources panel
   */
  installing: "installing",
  /**
   * @description Service worker version status displayed in the Threads view of the Debugging side pane in the Sources panel
   */
  new: "new",
  /**
   * @description Service worker version status displayed in the Threads view of the Debugging side pane in the Sources panel
   */
  redundant: "redundant",
  /**
   * @description Service worker version status displayed in the Threads view of the Debugging side pane in the Sources panel
   * @example {sw.js} PH1
   * @example {117} PH2
   * @example {activated} PH3
   */
  sSS: "{PH1} #{PH2} ({PH3})"
};
var str_18 = i18n39.i18n.registerUIStrings("core/sdk/ServiceWorkerManager.ts", UIStrings18);
var i18nString18 = i18n39.i18n.getLocalizedString.bind(void 0, str_18);
var i18nLazyString3 = i18n39.i18n.getLazilyComputedLocalizedString.bind(void 0, str_18);
var ServiceWorkerManager = class extends SDKModel {
  #agent;
  #registrations = /* @__PURE__ */ new Map();
  #enabled = false;
  #forceUpdateSetting;
  constructor(target) {
    super(target);
    target.registerServiceWorkerDispatcher(new ServiceWorkerDispatcher(this));
    this.#agent = target.serviceWorkerAgent();
    void this.enable();
    this.#forceUpdateSetting = Common41.Settings.Settings.instance().createSetting("service-worker-update-on-reload", false);
    if (this.#forceUpdateSetting.get()) {
      this.forceUpdateSettingChanged();
    }
    this.#forceUpdateSetting.addChangeListener(this.forceUpdateSettingChanged, this);
    new ServiceWorkerContextNamer(target, this);
  }
  async enable() {
    if (this.#enabled) {
      return;
    }
    this.#enabled = true;
    await this.#agent.invoke_enable();
  }
  async disable() {
    if (!this.#enabled) {
      return;
    }
    this.#enabled = false;
    this.#registrations.clear();
    await this.#agent.invoke_enable();
  }
  registrations() {
    return this.#registrations;
  }
  findVersion(versionId) {
    for (const registration of this.registrations().values()) {
      const version = registration.versions.get(versionId);
      if (version) {
        return version;
      }
    }
    return null;
  }
  deleteRegistration(registrationId) {
    const registration = this.#registrations.get(registrationId);
    if (!registration) {
      return;
    }
    if (registration.isRedundant()) {
      this.#registrations.delete(registrationId);
      this.dispatchEventToListeners("RegistrationDeleted", registration);
      return;
    }
    registration.deleting = true;
    for (const version of registration.versions.values()) {
      void this.stopWorker(version.id);
    }
    void this.unregister(registration.scopeURL);
  }
  async updateRegistration(registrationId) {
    const registration = this.#registrations.get(registrationId);
    if (!registration) {
      return;
    }
    await this.#agent.invoke_updateRegistration({ scopeURL: registration.scopeURL });
  }
  async deliverPushMessage(registrationId, data) {
    const registration = this.#registrations.get(registrationId);
    if (!registration) {
      return;
    }
    const origin = Common41.ParsedURL.ParsedURL.extractOrigin(registration.scopeURL);
    await this.#agent.invoke_deliverPushMessage({ origin, registrationId, data });
  }
  async dispatchSyncEvent(registrationId, tag, lastChance) {
    const registration = this.#registrations.get(registrationId);
    if (!registration) {
      return;
    }
    const origin = Common41.ParsedURL.ParsedURL.extractOrigin(registration.scopeURL);
    await this.#agent.invoke_dispatchSyncEvent({ origin, registrationId, tag, lastChance });
  }
  async dispatchPeriodicSyncEvent(registrationId, tag) {
    const registration = this.#registrations.get(registrationId);
    if (!registration) {
      return;
    }
    const origin = Common41.ParsedURL.ParsedURL.extractOrigin(registration.scopeURL);
    await this.#agent.invoke_dispatchPeriodicSyncEvent({ origin, registrationId, tag });
  }
  async unregister(scopeURL) {
    await this.#agent.invoke_unregister({ scopeURL });
  }
  async startWorker(scopeURL) {
    await this.#agent.invoke_startWorker({ scopeURL });
  }
  async skipWaiting(scopeURL) {
    await this.#agent.invoke_skipWaiting({ scopeURL });
  }
  async stopWorker(versionId) {
    await this.#agent.invoke_stopWorker({ versionId });
  }
  workerRegistrationUpdated(registrations) {
    for (const payload of registrations) {
      let registration = this.#registrations.get(payload.registrationId);
      if (!registration) {
        registration = new ServiceWorkerRegistration(payload);
        this.#registrations.set(payload.registrationId, registration);
        this.dispatchEventToListeners("RegistrationUpdated", registration);
        continue;
      }
      registration.update(payload);
      if (registration.shouldBeRemoved()) {
        this.#registrations.delete(registration.id);
        this.dispatchEventToListeners("RegistrationDeleted", registration);
      } else {
        this.dispatchEventToListeners("RegistrationUpdated", registration);
      }
    }
  }
  workerVersionUpdated(versions) {
    const registrations = /* @__PURE__ */ new Set();
    for (const payload of versions) {
      const registration = this.#registrations.get(payload.registrationId);
      if (!registration) {
        continue;
      }
      registration.updateVersion(payload);
      registrations.add(registration);
    }
    for (const registration of registrations) {
      if (registration.shouldBeRemoved()) {
        this.#registrations.delete(registration.id);
        this.dispatchEventToListeners("RegistrationDeleted", registration);
      } else {
        this.dispatchEventToListeners("RegistrationUpdated", registration);
      }
    }
  }
  workerErrorReported(payload) {
    const registration = this.#registrations.get(payload.registrationId);
    if (!registration) {
      return;
    }
    registration.errors.push(payload);
    this.dispatchEventToListeners("RegistrationErrorAdded", { registration, error: payload });
  }
  forceUpdateSettingChanged() {
    const forceUpdateOnPageLoad = this.#forceUpdateSetting.get();
    void this.#agent.invoke_setForceUpdateOnPageLoad({ forceUpdateOnPageLoad });
  }
};
var ServiceWorkerDispatcher = class {
  #manager;
  constructor(manager) {
    this.#manager = manager;
  }
  workerRegistrationUpdated({ registrations }) {
    this.#manager.workerRegistrationUpdated(registrations);
  }
  workerVersionUpdated({ versions }) {
    this.#manager.workerVersionUpdated(versions);
  }
  workerErrorReported({ errorMessage }) {
    this.#manager.workerErrorReported(errorMessage);
  }
};
var ServiceWorkerVersionState = class {
  runningStatus;
  status;
  lastUpdatedTimestamp;
  previousState;
  constructor(runningStatus, status, previousState, timestamp) {
    this.runningStatus = runningStatus;
    this.status = status;
    this.lastUpdatedTimestamp = timestamp;
    this.previousState = previousState;
  }
};
var ServiceWorkerRouterRule = class {
  condition;
  source;
  id;
  constructor(condition, source, id) {
    this.condition = condition;
    this.source = source;
    this.id = id;
  }
};
var ServiceWorkerVersion = class {
  id;
  scriptURL;
  parsedURL;
  securityOrigin;
  scriptLastModified;
  scriptResponseTime;
  controlledClients;
  targetId;
  routerRules;
  currentState;
  registration;
  constructor(registration, payload) {
    this.registration = registration;
    this.update(payload);
  }
  update(payload) {
    this.id = payload.versionId;
    this.scriptURL = payload.scriptURL;
    const parsedURL = new Common41.ParsedURL.ParsedURL(payload.scriptURL);
    this.securityOrigin = parsedURL.securityOrigin();
    this.currentState = new ServiceWorkerVersionState(payload.runningStatus, payload.status, this.currentState, Date.now());
    this.scriptLastModified = payload.scriptLastModified;
    this.scriptResponseTime = payload.scriptResponseTime;
    if (payload.controlledClients) {
      this.controlledClients = payload.controlledClients.slice();
    } else {
      this.controlledClients = [];
    }
    this.targetId = payload.targetId || null;
    this.routerRules = null;
    if (payload.routerRules) {
      this.routerRules = this.parseJSONRules(payload.routerRules);
    }
  }
  isStartable() {
    return !this.registration.isDeleted && this.isActivated() && this.isStopped();
  }
  isStoppedAndRedundant() {
    return this.runningStatus === "stopped" && this.status === "redundant";
  }
  isStopped() {
    return this.runningStatus === "stopped";
  }
  isStarting() {
    return this.runningStatus === "starting";
  }
  isRunning() {
    return this.runningStatus === "running";
  }
  isStopping() {
    return this.runningStatus === "stopping";
  }
  isNew() {
    return this.status === "new";
  }
  isInstalling() {
    return this.status === "installing";
  }
  isInstalled() {
    return this.status === "installed";
  }
  isActivating() {
    return this.status === "activating";
  }
  isActivated() {
    return this.status === "activated";
  }
  isRedundant() {
    return this.status === "redundant";
  }
  get status() {
    return this.currentState.status;
  }
  get runningStatus() {
    return this.currentState.runningStatus;
  }
  mode() {
    if (this.isNew() || this.isInstalling()) {
      return "installing";
    }
    if (this.isInstalled()) {
      return "waiting";
    }
    if (this.isActivating() || this.isActivated()) {
      return "active";
    }
    return "redundant";
  }
  parseJSONRules(input) {
    try {
      const parsedObject = JSON.parse(input);
      if (!Array.isArray(parsedObject)) {
        console.error("Parse error: `routerRules` in ServiceWorkerVersion should be an array");
        return null;
      }
      const routerRules = [];
      for (const parsedRule of parsedObject) {
        const { condition, source, id } = parsedRule;
        if (condition === void 0 || source === void 0 || id === void 0) {
          console.error("Parse error: Missing some fields of `routerRules` in ServiceWorkerVersion");
          return null;
        }
        routerRules.push(new ServiceWorkerRouterRule(JSON.stringify(condition), JSON.stringify(source), id));
      }
      return routerRules;
    } catch {
      console.error("Parse error: Invalid `routerRules` in ServiceWorkerVersion");
      return null;
    }
  }
};
(function(ServiceWorkerVersion2) {
  ServiceWorkerVersion2.RunningStatus = {
    [
      "running"
      /* Protocol.ServiceWorker.ServiceWorkerVersionRunningStatus.Running */
    ]: i18nLazyString3(UIStrings18.running),
    [
      "starting"
      /* Protocol.ServiceWorker.ServiceWorkerVersionRunningStatus.Starting */
    ]: i18nLazyString3(UIStrings18.starting),
    [
      "stopped"
      /* Protocol.ServiceWorker.ServiceWorkerVersionRunningStatus.Stopped */
    ]: i18nLazyString3(UIStrings18.stopped),
    [
      "stopping"
      /* Protocol.ServiceWorker.ServiceWorkerVersionRunningStatus.Stopping */
    ]: i18nLazyString3(UIStrings18.stopping)
  };
  ServiceWorkerVersion2.Status = {
    [
      "activated"
      /* Protocol.ServiceWorker.ServiceWorkerVersionStatus.Activated */
    ]: i18nLazyString3(UIStrings18.activated),
    [
      "activating"
      /* Protocol.ServiceWorker.ServiceWorkerVersionStatus.Activating */
    ]: i18nLazyString3(UIStrings18.activating),
    [
      "installed"
      /* Protocol.ServiceWorker.ServiceWorkerVersionStatus.Installed */
    ]: i18nLazyString3(UIStrings18.installed),
    [
      "installing"
      /* Protocol.ServiceWorker.ServiceWorkerVersionStatus.Installing */
    ]: i18nLazyString3(UIStrings18.installing),
    [
      "new"
      /* Protocol.ServiceWorker.ServiceWorkerVersionStatus.New */
    ]: i18nLazyString3(UIStrings18.new),
    [
      "redundant"
      /* Protocol.ServiceWorker.ServiceWorkerVersionStatus.Redundant */
    ]: i18nLazyString3(UIStrings18.redundant)
  };
})(ServiceWorkerVersion || (ServiceWorkerVersion = {}));
var ServiceWorkerRegistration = class {
  #fingerprint;
  id;
  scopeURL;
  securityOrigin;
  isDeleted;
  versions = /* @__PURE__ */ new Map();
  deleting = false;
  errors = [];
  constructor(payload) {
    this.update(payload);
  }
  update(payload) {
    this.#fingerprint = Symbol("fingerprint");
    this.id = payload.registrationId;
    this.scopeURL = payload.scopeURL;
    const parsedURL = new Common41.ParsedURL.ParsedURL(payload.scopeURL);
    this.securityOrigin = parsedURL.securityOrigin();
    this.isDeleted = payload.isDeleted;
  }
  fingerprint() {
    return this.#fingerprint;
  }
  versionsByMode() {
    const result = /* @__PURE__ */ new Map();
    for (const version of this.versions.values()) {
      result.set(version.mode(), version);
    }
    return result;
  }
  updateVersion(payload) {
    this.#fingerprint = Symbol("fingerprint");
    let version = this.versions.get(payload.versionId);
    if (!version) {
      version = new ServiceWorkerVersion(this, payload);
      this.versions.set(payload.versionId, version);
      return version;
    }
    version.update(payload);
    return version;
  }
  isRedundant() {
    for (const version of this.versions.values()) {
      if (!version.isStoppedAndRedundant()) {
        return false;
      }
    }
    return true;
  }
  shouldBeRemoved() {
    return this.isRedundant() && (!this.errors.length || this.deleting);
  }
  canBeRemoved() {
    return this.isDeleted || this.deleting;
  }
};
var ServiceWorkerContextNamer = class {
  #target;
  #serviceWorkerManager;
  #versionByTargetId = /* @__PURE__ */ new Map();
  constructor(target, serviceWorkerManager) {
    this.#target = target;
    this.#serviceWorkerManager = serviceWorkerManager;
    serviceWorkerManager.addEventListener("RegistrationUpdated", this.registrationsUpdated, this);
    serviceWorkerManager.addEventListener("RegistrationDeleted", this.registrationsUpdated, this);
    TargetManager.instance().addModelListener(RuntimeModel, Events6.ExecutionContextCreated, this.executionContextCreated, this);
  }
  registrationsUpdated() {
    this.#versionByTargetId.clear();
    const registrations = this.#serviceWorkerManager.registrations().values();
    for (const registration of registrations) {
      for (const version of registration.versions.values()) {
        if (version.targetId) {
          this.#versionByTargetId.set(version.targetId, version);
        }
      }
    }
    this.updateAllContextLabels();
  }
  executionContextCreated(event) {
    const executionContext = event.data;
    const serviceWorkerTargetId = this.serviceWorkerTargetId(executionContext.target());
    if (!serviceWorkerTargetId) {
      return;
    }
    this.updateContextLabel(executionContext, this.#versionByTargetId.get(serviceWorkerTargetId) || null);
  }
  serviceWorkerTargetId(target) {
    if (target.parentTarget() !== this.#target || target.type() !== Type.ServiceWorker) {
      return null;
    }
    return target.id();
  }
  updateAllContextLabels() {
    for (const target of TargetManager.instance().targets()) {
      const serviceWorkerTargetId = this.serviceWorkerTargetId(target);
      if (!serviceWorkerTargetId) {
        continue;
      }
      const version = this.#versionByTargetId.get(serviceWorkerTargetId) || null;
      const runtimeModel = target.model(RuntimeModel);
      const executionContexts = runtimeModel ? runtimeModel.executionContexts() : [];
      for (const context of executionContexts) {
        this.updateContextLabel(context, version);
      }
    }
  }
  updateContextLabel(context, version) {
    if (!version) {
      context.setLabel("");
      return;
    }
    const parsedUrl = Common41.ParsedURL.ParsedURL.fromString(context.origin);
    const label = parsedUrl ? parsedUrl.lastPathComponentWithFragment() : context.name;
    const localizedStatus = ServiceWorkerVersion.Status[version.status];
    context.setLabel(i18nString18(UIStrings18.sSS, { PH1: label, PH2: version.id, PH3: localizedStatus() }));
  }
};
SDKModel.register(ServiceWorkerManager, { capabilities: 16384, autostart: true });

// gen/front_end/core/sdk/WebAuthnModel.js
var WebAuthnModel_exports = {};
__export(WebAuthnModel_exports, {
  WebAuthnModel: () => WebAuthnModel
});
var WebAuthnModel = class extends SDKModel {
  #agent;
  constructor(target) {
    super(target);
    this.#agent = target.webAuthnAgent();
    target.registerWebAuthnDispatcher(new WebAuthnDispatcher(this));
  }
  setVirtualAuthEnvEnabled(enable) {
    if (enable) {
      return this.#agent.invoke_enable({ enableUI: true });
    }
    return this.#agent.invoke_disable();
  }
  async addAuthenticator(options) {
    const response = await this.#agent.invoke_addVirtualAuthenticator({ options });
    return response.authenticatorId;
  }
  async removeAuthenticator(authenticatorId) {
    await this.#agent.invoke_removeVirtualAuthenticator({ authenticatorId });
  }
  async setAutomaticPresenceSimulation(authenticatorId, enabled) {
    await this.#agent.invoke_setAutomaticPresenceSimulation({ authenticatorId, enabled });
  }
  async getCredentials(authenticatorId) {
    const response = await this.#agent.invoke_getCredentials({ authenticatorId });
    return response.credentials;
  }
  async removeCredential(authenticatorId, credentialId) {
    await this.#agent.invoke_removeCredential({ authenticatorId, credentialId });
  }
  credentialAdded(params) {
    this.dispatchEventToListeners("CredentialAdded", params);
  }
  credentialAsserted(params) {
    this.dispatchEventToListeners("CredentialAsserted", params);
  }
  credentialDeleted(params) {
    this.dispatchEventToListeners("CredentialDeleted", params);
  }
  credentialUpdated(params) {
    this.dispatchEventToListeners("CredentialUpdated", params);
  }
};
var WebAuthnDispatcher = class {
  #model;
  constructor(model) {
    this.#model = model;
  }
  credentialAdded(params) {
    this.#model.credentialAdded(params);
  }
  credentialAsserted(params) {
    this.#model.credentialAsserted(params);
  }
  credentialDeleted(params) {
    this.#model.credentialDeleted(params);
  }
  credentialUpdated(params) {
    this.#model.credentialUpdated(params);
  }
};
SDKModel.register(WebAuthnModel, { capabilities: 65536, autostart: false });
export {
  AccessibilityModel_exports as AccessibilityModel,
  AnimationModel_exports as AnimationModel,
  AutofillModel_exports as AutofillModel,
  CPUProfilerModel_exports as CPUProfilerModel,
  CPUThrottlingManager_exports as CPUThrottlingManager,
  CSSContainerQuery_exports as CSSContainerQuery,
  CSSFontFace_exports as CSSFontFace,
  CSSLayer_exports as CSSLayer,
  CSSMatchedStyles_exports as CSSMatchedStyles,
  CSSMedia_exports as CSSMedia,
  CSSMetadata_exports as CSSMetadata,
  CSSModel_exports as CSSModel,
  CSSProperty_exports as CSSProperty,
  CSSPropertyParser_exports as CSSPropertyParser,
  CSSPropertyParserMatchers_exports as CSSPropertyParserMatchers,
  CSSQuery_exports as CSSQuery,
  CSSRule_exports as CSSRule,
  CSSScope_exports as CSSScope,
  CSSStartingStyle_exports as CSSStartingStyle,
  CSSStyleDeclaration_exports as CSSStyleDeclaration,
  CSSStyleSheetHeader_exports as CSSStyleSheetHeader,
  CSSSupports_exports as CSSSupports,
  CategorizedBreakpoint_exports as CategorizedBreakpoint,
  ChildTargetManager_exports as ChildTargetManager,
  CompilerSourceMappingContentProvider_exports as CompilerSourceMappingContentProvider,
  Connections_exports as Connections,
  ConsoleModel_exports as ConsoleModel,
  Cookie_exports as Cookie,
  CookieModel_exports as CookieModel,
  CookieParser_exports as CookieParser,
  DOMDebuggerModel_exports as DOMDebuggerModel,
  DOMModel_exports as DOMModel,
  DebuggerModel_exports as DebuggerModel,
  EmulationModel_exports as EmulationModel,
  EnhancedTracesParser_exports as EnhancedTracesParser,
  EventBreakpointsModel_exports as EventBreakpointsModel,
  FrameAssociated_exports as FrameAssociated,
  FrameManager_exports as FrameManager,
  HeapProfilerModel_exports as HeapProfilerModel,
  IOModel_exports as IOModel,
  IsolateManager_exports as IsolateManager,
  IssuesModel_exports as IssuesModel,
  LayerTreeBase_exports as LayerTreeBase,
  LogModel_exports as LogModel,
  NetworkManager_exports as NetworkManager,
  NetworkRequest_exports as NetworkRequest,
  OverlayColorGenerator_exports as OverlayColorGenerator,
  OverlayModel_exports as OverlayModel,
  OverlayPersistentHighlighter_exports as OverlayPersistentHighlighter,
  PageLoad_exports as PageLoad,
  PageResourceLoader_exports as PageResourceLoader,
  PaintProfiler_exports as PaintProfiler,
  PerformanceMetricsModel_exports as PerformanceMetricsModel,
  PreloadingModel_exports as PreloadingModel,
  RehydratingConnection_exports as RehydratingConnection,
  RemoteObject_exports as RemoteObject,
  Resource_exports as Resource,
  ResourceTreeModel_exports as ResourceTreeModel,
  RuntimeModel_exports as RuntimeModel,
  SDKModel_exports as SDKModel,
  ScopeTreeCache_exports as ScopeTreeCache,
  ScreenCaptureModel_exports as ScreenCaptureModel,
  Script_exports as Script,
  SecurityOriginManager_exports as SecurityOriginManager,
  ServerSentEventsProtocol_exports as ServerSentEventProtocol,
  ServerTiming_exports as ServerTiming,
  ServiceWorkerCacheModel_exports as ServiceWorkerCacheModel,
  ServiceWorkerManager_exports as ServiceWorkerManager,
  SourceMap_exports as SourceMap,
  SourceMapCache_exports as SourceMapCache,
  SourceMapFunctionRanges_exports as SourceMapFunctionRanges,
  SourceMapManager_exports as SourceMapManager,
  SourceMapScopeChainEntry_exports as SourceMapScopeChainEntry,
  SourceMapScopesInfo_exports as SourceMapScopesInfo,
  StorageBucketsModel_exports as StorageBucketsModel,
  StorageKeyManager_exports as StorageKeyManager,
  Target_exports as Target,
  TargetManager_exports as TargetManager,
  TraceObject_exports as TraceObject,
  WebAuthnModel_exports as WebAuthnModel
};
//# sourceMappingURL=sdk.js.map
