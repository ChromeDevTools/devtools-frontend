{"version":3,"file":"Substitute.js","sourceRoot":"","sources":["../../../../../../front_end/entrypoints/formatter_worker/Substitute.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2022 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Acorn from '../../third_party/acorn/acorn.js';\n\nimport {ECMA_VERSION} from './AcornTokenizer.js';\nimport {DefinitionKind} from './FormatterActions.js';\nimport {ScopeVariableAnalysis} from './ScopeParser.js';\n\nexport function substituteExpression(expression: string, nameMap: Map<string, string|null>): string {\n  const replacements = computeSubstitution(expression, nameMap);\n  return applySubstitution(expression, replacements);\n}\n\ninterface Replacement {\n  from: string;\n  to: string;\n  offset: number;\n  isShorthandAssignmentProperty: boolean;\n}\n\n/**\n * Given an |expression| and a mapping from names to new names, the |computeSubstitution|\n * function returns a list of replacements sorted by the offset. The function throws if\n * it cannot parse the expression or the substitution is impossible to perform (for example\n * if the substitution target is 'this' within a function, it would become bound there).\n **/\nfunction computeSubstitution(expression: string, nameMap: Map<string, string|null>): Replacement[] {\n  // Parse the expression and find variables and scopes.\n  const root = Acorn.parse(expression, {\n    ecmaVersion: ECMA_VERSION,\n    allowAwaitOutsideFunction: true,\n    allowImportExportEverywhere: true,\n    checkPrivateFields: false,\n    ranges: false,\n  } as acorn.Options) as Acorn.ESTree.Node;\n  const scopeVariables = new ScopeVariableAnalysis(root);\n  scopeVariables.run();\n  const freeVariables = scopeVariables.getFreeVariables();\n  const result: Replacement[] = [];\n\n  // Prepare the machinery for generating fresh names (to avoid variable captures).\n  const allNames = scopeVariables.getAllNames();\n  for (const rename of nameMap.values()) {\n    if (rename) {\n      allNames.add(rename);\n    }\n  }\n  function getNewName(base: string): string {\n    let i = 1;\n    while (allNames.has(`${base}_${i}`)) {\n      i++;\n    }\n    const newName = `${base}_${i}`;\n    allNames.add(newName);\n    return newName;\n  }\n\n  // Perform the substitutions.\n  for (const [name, rename] of nameMap.entries()) {\n    const defUse = freeVariables.get(name);\n    if (!defUse) {\n      continue;\n    }\n\n    if (rename === null) {\n      throw new Error(`Cannot substitute '${name}' as the underlying variable '${rename}' is unavailable`);\n    }\n\n    const binders = [];\n    for (const use of defUse) {\n      result.push({\n        from: name,\n        to: rename,\n        offset: use.offset,\n        isShorthandAssignmentProperty: use.isShorthandAssignmentProperty,\n      });\n      binders.push(...use.scope.findBinders(rename));\n    }\n    // If there is a capturing binder, rename the bound variable.\n    for (const binder of binders) {\n      if (binder.definitionKind === DefinitionKind.FIXED) {\n        // If the identifier is bound to a fixed name, such as 'this',\n        // then refuse to do the substitution.\n        throw new Error(`Cannot avoid capture of '${rename}'`);\n      }\n      const newName = getNewName(rename);\n      for (const use of binder.uses) {\n        result.push({\n          from: rename,\n          to: newName,\n          offset: use.offset,\n          isShorthandAssignmentProperty: use.isShorthandAssignmentProperty,\n        });\n      }\n    }\n  }\n  result.sort((l, r) => l.offset - r.offset);\n  return result;\n}\n\nfunction applySubstitution(expression: string, replacements: Replacement[]): string {\n  const accumulator = [];\n  let last = 0;\n  for (const r of replacements) {\n    accumulator.push(expression.slice(last, r.offset));\n    let replacement = r.to;\n    if (r.isShorthandAssignmentProperty) {\n      // Let us expand the shorthand to full assignment.\n      replacement = `${r.from}: ${r.to}`;\n    }\n    accumulator.push(replacement);\n    last = r.offset + r.from.length;\n  }\n  accumulator.push(expression.slice(last));\n  return accumulator.join('');\n}\n"]}