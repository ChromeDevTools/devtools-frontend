{"version":3,"file":"AiHistoryStorage.js","sourceRoot":"","sources":["../../../../../../front_end/models/ai_assistance/AiHistoryStorage.ts"],"names":[],"mappings":"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","sourcesContent":["\n// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\n\nimport {ResponseType, type SerializedResponseData} from './agents/AiAgent.js';\n\nexport const enum ConversationType {\n  STYLING = 'freestyler',\n  FILE = 'drjones-file',\n  NETWORK = 'drjones-network-request',\n  PERFORMANCE = 'drjones-performance-full',\n}\n\nexport interface SerializedConversation {\n  id: string;\n  type: ConversationType;\n  history: SerializedResponseData[];\n  isExternal: boolean;\n}\n\nexport interface SerializedImage {\n  id: string;\n  // The IANA standard MIME type of the source data.\n  // Currently supported types are: image/png, image/jpeg.\n  // Format: base64-encoded\n  // For reference: google3/google/x/pitchfork/aida/v1/content.proto\n  mimeType: string;\n  data: string;\n}\n\nlet instance: AiHistoryStorage|null = null;\n\nconst DEFAULT_MAX_STORAGE_SIZE = 50 * 1024 * 1024;\n\nexport const enum Events {\n  HISTORY_DELETED = 'AiHistoryDeleted',\n}\n\nexport interface EventTypes {\n  [Events.HISTORY_DELETED]: void;\n}\n\nexport class AiHistoryStorage extends Common.ObjectWrapper.ObjectWrapper<EventTypes> {\n  #historySetting: Common.Settings.Setting<SerializedConversation[]>;\n  #imageHistorySettings: Common.Settings.Setting<SerializedImage[]>;\n  #mutex = new Common.Mutex.Mutex();\n  #maxStorageSize: number;\n\n  constructor(maxStorageSize = DEFAULT_MAX_STORAGE_SIZE) {\n    super();\n    this.#historySetting = Common.Settings.Settings.instance().createSetting('ai-assistance-history-entries', []);\n    this.#imageHistorySettings = Common.Settings.Settings.instance().createSetting(\n        'ai-assistance-history-images',\n        [],\n    );\n    this.#maxStorageSize = maxStorageSize;\n  }\n\n  clearForTest(): void {\n    this.#historySetting.set([]);\n    this.#imageHistorySettings.set([]);\n  }\n\n  async upsertHistoryEntry(agentEntry: SerializedConversation): Promise<void> {\n    const release = await this.#mutex.acquire();\n    try {\n      const history = structuredClone(await this.#historySetting.forceGet());\n      const historyEntryIndex = history.findIndex(entry => entry.id === agentEntry.id);\n      if (historyEntryIndex !== -1) {\n        history[historyEntryIndex] = agentEntry;\n      } else {\n        history.push(agentEntry);\n      }\n      this.#historySetting.set(history);\n    } finally {\n      release();\n    }\n  }\n\n  async upsertImage(image: SerializedImage): Promise<void> {\n    const release = await this.#mutex.acquire();\n    try {\n      const imageHistory = structuredClone(await this.#imageHistorySettings.forceGet());\n      const imageHistoryEntryIndex = imageHistory.findIndex(entry => entry.id === image.id);\n      if (imageHistoryEntryIndex !== -1) {\n        imageHistory[imageHistoryEntryIndex] = image;\n      } else {\n        imageHistory.push(image);\n      }\n\n      const imagesToBeStored: SerializedImage[] = [];\n      let currentStorageSize = 0;\n\n      for (const [, serializedImage] of Array\n               .from(\n                   imageHistory.entries(),\n                   )\n               .reverse()) {\n        if (currentStorageSize >= this.#maxStorageSize) {\n          break;\n        }\n        currentStorageSize += serializedImage.data.length;\n        imagesToBeStored.push(serializedImage);\n      }\n\n      this.#imageHistorySettings.set(imagesToBeStored.reverse());\n    } finally {\n      release();\n    }\n  }\n\n  async deleteHistoryEntry(id: string): Promise<void> {\n    const release = await this.#mutex.acquire();\n    try {\n      const history = structuredClone(await this.#historySetting.forceGet());\n      const imageIdsForDeletion = history.find(entry => entry.id === id)\n                                      ?.history\n                                      .map(item => {\n                                        if (item.type === ResponseType.USER_QUERY && item.imageId) {\n                                          return item.imageId;\n                                        }\n                                        return undefined;\n                                      })\n                                      .filter(item => !!item);\n      this.#historySetting.set(\n          history.filter(entry => entry.id !== id),\n      );\n      const images = structuredClone(await this.#imageHistorySettings.forceGet());\n      this.#imageHistorySettings.set(\n          // Filter images for which ids are not present in deletion list\n          images.filter(entry => !Boolean(imageIdsForDeletion?.find(id => id === entry.id))));\n    } finally {\n      release();\n    }\n  }\n\n  async deleteAll(): Promise<void> {\n    const release = await this.#mutex.acquire();\n    try {\n      this.#historySetting.set([]);\n      this.#imageHistorySettings.set([]);\n    } finally {\n      release();\n      this.dispatchEventToListeners(Events.HISTORY_DELETED);\n    }\n  }\n\n  getHistory(): SerializedConversation[] {\n    return structuredClone(this.#historySetting.get());\n  }\n\n  getImageHistory(): SerializedImage[] {\n    return structuredClone(this.#imageHistorySettings.get());\n  }\n\n  static instance(\n      opts: {\n        forceNew: boolean,\n        maxStorageSize?: number,\n      } = {forceNew: false, maxStorageSize: DEFAULT_MAX_STORAGE_SIZE},\n      ): AiHistoryStorage {\n    const {forceNew, maxStorageSize} = opts;\n    if (!instance || forceNew) {\n      instance = new AiHistoryStorage(maxStorageSize);\n    }\n    return instance;\n  }\n}\n"]}