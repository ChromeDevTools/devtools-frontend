{"version":3,"file":"AICallTree.js","sourceRoot":"","sources":["../../../../../../../front_end/models/ai_assistance/performance/AICallTree.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Trace from '../../../models/trace/trace.js';\nimport * as SourceMapsResolver from '../../../models/trace_source_maps_resolver/trace_source_maps_resolver.js';\n\n/** Iterates from a node down through its descendents. If the callback returns true, the loop stops. */\nfunction depthFirstWalk(\n    nodes: MapIterator<Trace.Extras.TraceTree.Node>, callback: (arg0: Trace.Extras.TraceTree.Node) => void|true): void {\n  for (const node of nodes) {\n    if (callback?.(node)) {\n      break;\n    }\n    depthFirstWalk(node.children().values(), callback);  // Go deeper.\n  }\n}\n\nexport interface FromTimeOnThreadOptions {\n  thread: {pid: Trace.Types.Events.ProcessID, tid: Trace.Types.Events.ThreadID};\n  parsedTrace: Trace.TraceModel.ParsedTrace;\n  bounds: Trace.Types.Timing.TraceWindowMicro;\n}\n\nexport class AICallTree {\n  // Note: ideally this is passed in (or lived on ParsedTrace), but this class is\n  // stateless (mostly, there's a cache for some stuff) so it doesn't match much.\n  #eventsSerializer = new Trace.EventsSerializer.EventsSerializer();\n\n  constructor(\n      public selectedNode: Trace.Extras.TraceTree.Node|null,\n      public rootNode: Trace.Extras.TraceTree.TopDownRootNode,\n      public parsedTrace: Trace.TraceModel.ParsedTrace,\n  ) {\n  }\n\n  static findEventsForThread({thread, parsedTrace, bounds}: FromTimeOnThreadOptions): Trace.Types.Events.Event[]|null {\n    const threadEvents = parsedTrace.data.Renderer.processes.get(thread.pid)?.threads.get(thread.tid)?.entries;\n    if (!threadEvents) {\n      return null;\n    }\n\n    return threadEvents.filter(e => Trace.Helpers.Timing.eventIsInBounds(e, bounds));\n  }\n\n  static findMainThreadTasks({thread, parsedTrace, bounds}: FromTimeOnThreadOptions):\n      Trace.Types.Events.RunTask[]|null {\n    const threadEvents = parsedTrace.data.Renderer.processes.get(thread.pid)?.threads.get(thread.tid)?.entries;\n    if (!threadEvents) {\n      return null;\n    }\n\n    return threadEvents.filter(Trace.Types.Events.isRunTask)\n        .filter(e => Trace.Helpers.Timing.eventIsInBounds(e, bounds));\n  }\n\n  /**\n   * Builds a call tree representing all calls within the given timeframe for\n   * the provided thread.\n   * Events that are less than 0.05% of the range duration are removed.\n   */\n  static fromTimeOnThread({thread, parsedTrace, bounds}: FromTimeOnThreadOptions): AICallTree|null {\n    const overlappingEvents = this.findEventsForThread({thread, parsedTrace, bounds});\n    if (!overlappingEvents) {\n      return null;\n    }\n\n    const visibleEventsFilter = new Trace.Extras.TraceFilter.VisibleEventsFilter(Trace.Styles.visibleTypes());\n\n    // By default, we remove events whose duration is less than 0.5% of the total\n    // range. So if the range is 10s, an event must be 0.05s+ to be included.\n    // This does risk eliminating useful data when we pass it to the LLM, but\n    // we are trying to balance context window sizes and not using it up too\n    // eagerly. We will experiment with this filter and likely make it smarter\n    // or tweak it based on range size rather than using a blanket value. Or we\n    // could consider limiting the depth when we serialize. Or some\n    // combination!\n    const minDuration = Trace.Types.Timing.Micro(bounds.range * 0.005);\n    const minDurationFilter = new MinDurationFilter(minDuration);\n    const compileCodeFilter = new ExcludeCompileCodeFilter();\n    // Build a tree bounded by the selected event's timestamps, and our other filters applied\n    const rootNode = new Trace.Extras.TraceTree.TopDownRootNode(overlappingEvents, {\n      filters: [minDurationFilter, compileCodeFilter, visibleEventsFilter],\n      startTime: Trace.Helpers.Timing.microToMilli(bounds.min),\n      endTime: Trace.Helpers.Timing.microToMilli(bounds.max),\n      doNotAggregate: true,\n      includeInstantEvents: true,\n    });\n\n    const instance = new AICallTree(null /* no selected node*/, rootNode, parsedTrace);\n    return instance;\n  }\n  /**\n   * Attempts to build an AICallTree from a given selected event. It also\n   * validates that this event is one that we support being used with the AI\n   * Assistance panel, which [as of January 2025] means:\n   * 1. It is on the main thread.\n   * 2. It exists in either the Renderer or Sample handler's entryToNode map.\n   * This filters out other events we make such as SyntheticLayoutShifts which are not valid\n   * If the event is not valid, or there is an unexpected error building the tree, `null` is returned.\n   */\n  static fromEvent(selectedEvent: Trace.Types.Events.Event, parsedTrace: Trace.TraceModel.ParsedTrace): AICallTree\n      |null {\n    // Special case: performance.mark events are shown on the main thread\n    // technically, but because they are instant events they are shown with a\n    // tiny duration. Because they are instant, they also don't have any\n    // children or a call tree, and so if the user has selected a performance\n    // mark in the timings track, we do not want to attempt to build a call\n    // tree. Context: crbug.com/418223469\n    // Note that we do not have to repeat this check for performance.measure\n    // events because those are synthetic, and therefore the check\n    // further down about if this event is known to the RenderHandler\n    // deals with this.\n    if (Trace.Types.Events.isPerformanceMark(selectedEvent)) {\n      return null;\n    }\n\n    // First: check that the selected event is on the thread we have identified as the main thread.\n    const threads = Trace.Handlers.Threads.threadsInTrace(parsedTrace.data);\n    const thread = threads.find(t => t.pid === selectedEvent.pid && t.tid === selectedEvent.tid);\n    if (!thread) {\n      return null;\n    }\n    // We allow two thread types to deal with the NodeJS use case.\n    // MAIN_THREAD is used when a trace has been generated through Chrome\n    //   tracing on a website (and we have a renderer)\n    // CPU_PROFILE is used only when we have received a CPUProfile - in this\n    //   case all the threads are CPU_PROFILE so we allow those. If we only allow\n    //   MAIN_THREAD then we wouldn't ever allow NodeJS users to use the AI\n    //   integration.\n    if (thread.type !== Trace.Handlers.Threads.ThreadType.MAIN_THREAD &&\n        thread.type !== Trace.Handlers.Threads.ThreadType.CPU_PROFILE) {\n      return null;\n    }\n\n    // Ensure that the event is known to either the Renderer or Samples\n    // handler. This helps exclude synthetic events we build up for other\n    // information such as Layout Shift clusters.\n    // We check Renderer + Samples to ensure we support CPU Profiles (which do\n    // not populate the Renderer Handler)\n    const data = parsedTrace.data;\n    if (!data.Renderer.entryToNode.has(selectedEvent) && !data.Samples.entryToNode.has(selectedEvent)) {\n      return null;\n    }\n\n    const showAllEvents = parsedTrace.data.Meta.config.showAllEvents;\n    const {startTime, endTime} = Trace.Helpers.Timing.eventTimingsMilliSeconds(selectedEvent);\n    const selectedEventBounds = Trace.Helpers.Timing.traceWindowFromMicroSeconds(\n        Trace.Helpers.Timing.milliToMicro(startTime), Trace.Helpers.Timing.milliToMicro(endTime));\n    let threadEvents = data.Renderer.processes.get(selectedEvent.pid)?.threads.get(selectedEvent.tid)?.entries;\n    if (!threadEvents) {\n      // None from the renderer: try the samples handler, this might be a CPU trace.\n      threadEvents = data.Samples.profilesInProcess.get(selectedEvent.pid)?.get(selectedEvent.tid)?.profileCalls;\n    }\n\n    if (!threadEvents) {\n      console.warn(`AICallTree: could not find thread for selected entry: ${selectedEvent}`);\n      return null;\n    }\n    const overlappingEvents = threadEvents.filter(e => Trace.Helpers.Timing.eventIsInBounds(e, selectedEventBounds));\n\n    const filters: Trace.Extras.TraceFilter.TraceFilter[] =\n        [new SelectedEventDurationFilter(selectedEvent), new ExcludeCompileCodeFilter(selectedEvent)];\n\n    // If the \"Show all events\" experiment is on, we don't filter out any\n    // events here, otherwise the generated call tree will not match what the\n    // user is seeing.\n    if (!showAllEvents) {\n      filters.push(new Trace.Extras.TraceFilter.VisibleEventsFilter(Trace.Styles.visibleTypes()));\n    }\n\n    // Build a tree bounded by the selected event's timestamps, and our other filters applied\n    const rootNode = new Trace.Extras.TraceTree.TopDownRootNode(overlappingEvents, {\n      filters,\n      startTime,\n      endTime,\n      includeInstantEvents: true,\n    });\n\n    // Walk the tree to find selectedNode\n    let selectedNode: Trace.Extras.TraceTree.Node|null = null;\n    depthFirstWalk([rootNode].values(), node => {\n      if (node.event === selectedEvent) {\n        selectedNode = node;\n        return true;\n      }\n      return;\n    });\n\n    if (selectedNode === null) {\n      console.warn(`Selected event ${selectedEvent} not found within its own tree.`);\n      return null;\n    }\n    const instance = new AICallTree(selectedNode, rootNode, parsedTrace);\n    // instance.logDebug();\n    return instance;\n  }\n\n  /**\n   * Iterates through nodes level by level using a Breadth-First Search (BFS) algorithm.\n   * BFS is important here because the serialization process assumes that direct child nodes\n   * will have consecutive IDs (horizontally across each depth).\n   *\n   * Example tree with IDs:\n   *\n   *             1\n   *            / \\\n   *           2   3\n   *        / / /   \\\n   *      4  5 6     7\n   *\n   * Here, node with an ID 2 has consecutive children in the 4-6 range.\n   *\n   * To optimize for space, the provided `callback` function is called to serialize\n   * each node as it's visited during the BFS traversal.\n   *\n   * When serializing a node, the callback receives:\n   * 1. The current node being visited.\n   * 2. The ID assigned to this current node (a simple incrementing index based on visit order).\n   * 3. The predicted starting ID for the children of this current node.\n   *\n   * A serialized node needs to know the ID range of its children. However,\n   * child node IDs are only assigned when those children are themselves visited.\n   * To handle this, we predict the starting ID for a node's children. This prediction\n   * is based on a running count of all nodes that have ever been added to the BFS queue.\n   * Since IDs are assigned consecutively as nodes are processed from the queue, and a\n   * node's children are added to the end of the queue when the parent is visited,\n   * their eventual IDs will follow this running count.\n   */\n  breadthFirstWalk(\n      nodes: MapIterator<Trace.Extras.TraceTree.Node>,\n      serializeNodeCallback:\n          (currentNode: Trace.Extras.TraceTree.Node, nodeId: number, childrenStartingId?: number) => void): void {\n    const queue: Trace.Extras.TraceTree.Node[] = Array.from(nodes);\n    let nodeIndex = 1;\n    // To predict the visited children indexes\n    let nodesAddedToQueueCount = queue.length;\n\n    let currentNode = queue.shift();\n\n    while (currentNode) {\n      if (currentNode.children().size > 0) {\n        serializeNodeCallback(currentNode, nodeIndex, nodesAddedToQueueCount + 1);\n      } else {\n        serializeNodeCallback(currentNode, nodeIndex);\n      }\n\n      queue.push(...Array.from(currentNode.children().values()));\n      nodesAddedToQueueCount += currentNode.children().size;\n\n      currentNode = queue.shift();\n      nodeIndex++;\n    }\n  }\n\n  serialize(headerLevel = 1): string {\n    const header = '#'.repeat(headerLevel);\n\n    // Keep a map of URLs. We'll output a LUT to keep size down.\n    const allUrls: string[] = [];\n\n    let nodesStr = '';\n    this.breadthFirstWalk(this.rootNode.children().values(), (node, nodeId, childStartingNode) => {\n      nodesStr +=\n          '\\n' + this.stringifyNode(node, nodeId, this.parsedTrace, this.selectedNode, allUrls, childStartingNode);\n    });\n\n    let output = '';\n    if (allUrls.length) {\n      // Output lookup table of URLs within this tree\n      output += `\\n${header} All URLs:\\n\\n` + allUrls.map((url, index) => `  * ${index}: ${url}`).join('\\n');\n    }\n    output += `\\n\\n${header} Call tree:\\n${nodesStr}`;\n    return output;\n  }\n\n  /*\n  * Each node is serialized into a single line to minimize token usage in the context window.\n  * The format is a semicolon-separated string with the following fields:\n  * Format: `id;name;duration;selfTime;urlIndex;childRange;[S]\n  *\n  *   1. `id`: A unique numerical identifier for the node assigned by BFS.\n  *   2. `name`: The name of the event represented by the node.\n  *   3. `duration`: The total duration of the event in milliseconds, rounded to one decimal place.\n  *   4. `selfTime`: The self time of the event in milliseconds, rounded to one decimal place.\n  *   5. `urlIndex`: An index referencing a URL in the `allUrls` array. If no URL is present, this is an empty string.\n  *   6. `childRange`: A string indicating the range of IDs for the node's children. Children should always have consecutive IDs.\n  *                    If there is only one child, it's a single ID.\n  *   7. `[line]`: An optional field for a call frame's line number.\n  *   8. `[column]`: An optional field for a call frame's column number.\n  *   9. `[S]`: An optional marker indicating that this node is the selected node.\n  *\n  * Example:\n  *   `1;Parse HTML;2.5;0.3;0;2-5;10;11;S`\n  *   This represents:\n  *     - Node ID 1\n  *     - Name \"Parse HTML\"\n  *     - Total duration of 2.5ms\n  *     - Self time of 0.3ms\n  *     - URL index 0 (meaning the URL is the first one in the `allUrls` array)\n  *     - Child range of IDs 2 to 5\n  *     - Line, column is 10:11\n  *     - This node is the selected node (S marker)\n  */\n  stringifyNode(\n      node: Trace.Extras.TraceTree.Node, nodeId: number, parsedTrace: Trace.TraceModel.ParsedTrace,\n      selectedNode: Trace.Extras.TraceTree.Node|null, allUrls: string[], childStartingNodeIndex?: number): string {\n    const event = node.event;\n    if (!event) {\n      throw new Error('Event required');\n    }\n\n    // 1. ID\n    const idStr = String(nodeId);\n\n    // 2. eventKey\n    const eventKey = this.#eventsSerializer.keyForEvent(node.event);\n\n    // 3. Name\n    const name = Trace.Name.forEntry(event, parsedTrace);\n\n    // Round milliseconds to one decimal place, return empty string if zero/undefined\n    const roundToTenths = (num: number|undefined): string => {\n      if (!num) {\n        return '';\n      }\n      return String(Math.round(num * 10) / 10);\n    };\n\n    // 4. Duration\n    const durationStr = roundToTenths(node.totalTime);\n\n    // 5. Self Time\n    const selfTimeStr = roundToTenths(node.selfTime);\n\n    // 6. URL Index\n    const location = SourceMapsResolver.SourceMapsResolver.codeLocationForEntry(parsedTrace, event);\n    const url = location?.url;\n    let urlIndexStr = '';\n    if (url) {\n      const existingIndex = allUrls.indexOf(url);\n      if (existingIndex === -1) {\n        urlIndexStr = String(allUrls.push(url) - 1);\n      } else {\n        urlIndexStr = String(existingIndex);\n      }\n    }\n\n    // 7. Child Range\n    const children = Array.from(node.children().values());\n    let childRangeStr = '';\n    if (childStartingNodeIndex) {\n      childRangeStr = (children.length === 1) ? String(childStartingNodeIndex) :\n                                                `${childStartingNodeIndex}-${childStartingNodeIndex + children.length}`;\n    }\n\n    // 8. Selected Marker\n    const selectedMarker = selectedNode?.event === node.event ? 'S' : '';\n\n    // Combine fields\n    let line = idStr;\n    line += ';' + eventKey;\n    line += ';' + name;\n    line += ';' + durationStr;\n    line += ';' + selfTimeStr;\n    line += ';' + urlIndexStr;\n    line += ';' + childRangeStr;\n    line += ';' + (location?.line ?? '');\n    line += ';' + (location?.column ?? '');\n\n    if (selectedMarker) {\n      line += ';' + selectedMarker;\n    }\n\n    return line;\n  }\n\n  // Only used for debugging.\n  logDebug(): void {\n    const str = this.serialize();\n    // eslint-disable-next-line no-console\n    console.log('ðŸŽ†', str);\n    if (str.length > 45_000) {\n      // Manual testing shows 45k fits. 50k doesn't.\n      // Max is 32k _tokens_, but tokens to bytes is wishywashy, so... hard to know for sure.\n      console.warn('Output will likely not fit in the context window. Expect an AIDA error.');\n    }\n  }\n}\n\n/**\n * These events are very noisy and take up room in the context window for no real benefit.\n */\nexport class ExcludeCompileCodeFilter extends Trace.Extras.TraceFilter.TraceFilter {\n  #selectedEvent: Trace.Types.Events.Event|null = null;\n  constructor(selectedEvent?: Trace.Types.Events.Event) {\n    super();\n    this.#selectedEvent = selectedEvent ?? null;\n  }\n\n  accept(event: Trace.Types.Events.Event): boolean {\n    if (this.#selectedEvent && event === this.#selectedEvent) {\n      // If the user selects this event, we should accept it, else the\n      // behaviour is confusing when the selected event is not used.\n      return true;\n    }\n    return event.name !== Trace.Types.Events.Name.COMPILE_CODE;\n  }\n}\n\nexport class SelectedEventDurationFilter extends Trace.Extras.TraceFilter.TraceFilter {\n  #minDuration: Trace.Types.Timing.Micro;\n  #selectedEvent: Trace.Types.Events.Event;\n  constructor(selectedEvent: Trace.Types.Events.Event) {\n    super();\n    // The larger the selected event is, the less small ones matter. We'll exclude items under Â½% of the selected event's size\n    this.#minDuration = Trace.Types.Timing.Micro((selectedEvent.dur ?? 1) * 0.005);\n    this.#selectedEvent = selectedEvent;\n  }\n  accept(event: Trace.Types.Events.Event): boolean {\n    if (event === this.#selectedEvent) {\n      return true;\n    }\n    return event.dur ? event.dur >= this.#minDuration : false;\n  }\n}\n\nexport class MinDurationFilter extends Trace.Extras.TraceFilter.TraceFilter {\n  #minDuration: Trace.Types.Timing.Micro;\n\n  constructor(minDuration: Trace.Types.Timing.Micro) {\n    super();\n    this.#minDuration = minDuration;\n  }\n\n  accept(event: Trace.Types.Events.Event): boolean {\n    return event.dur ? event.dur >= this.#minDuration : false;\n  }\n}\n"]}