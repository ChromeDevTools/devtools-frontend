{
  "version": 3,
  "sources": ["../../../../../../front_end/models/breakpoints/BreakpointManager.ts"],
  "sourcesContent": ["// Copyright 2011 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport type * as Platform from '../../core/platform/platform.js';\nimport {assertNotNullOrUndefined} from '../../core/platform/platform.js';\nimport * as Root from '../../core/root/root.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport * as Protocol from '../../generated/protocol.js';\nimport * as Bindings from '../bindings/bindings.js';\nimport * as Formatter from '../formatter/formatter.js';\nimport * as SourceMapScopes from '../source_map_scopes/source_map_scopes.js';\nimport type * as TextUtils from '../text_utils/text_utils.js';\nimport * as Workspace from '../workspace/workspace.js';\n\nlet breakpointManagerInstance: BreakpointManager;\nconst INITIAL_RESTORE_BREAKPOINT_COUNT = 100;\n\nexport class BreakpointManager extends Common.ObjectWrapper.ObjectWrapper<EventTypes> implements\n    SDK.TargetManager.SDKModelObserver<SDK.DebuggerModel.DebuggerModel> {\n  readonly storage = new Storage();\n  readonly #workspace: Workspace.Workspace.WorkspaceImpl;\n  readonly targetManager: SDK.TargetManager.TargetManager;\n  readonly debuggerWorkspaceBinding: Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding;\n  // For each source code, we remember the list or breakpoints that refer to that UI source code as\n  // their home UI source code. This is necessary to correctly remove the UI source code from\n  // breakpoints upon receiving the UISourceCodeRemoved event.\n  readonly #breakpointsForHomeUISourceCode = new Map<Workspace.UISourceCode.UISourceCode, Set<Breakpoint>>();\n  // Mapping of UI source codes to all the current breakpoint UI locations. For bound breakpoints,\n  // this is all the locations where the breakpoints was bound. For the unbound breakpoints,\n  // this is the default locations in the home UI source codes.\n  readonly #breakpointsForUISourceCode =\n      new Map<Workspace.UISourceCode.UISourceCode, Map<string, BreakpointLocation>>();\n  readonly #breakpointByStorageId = new Map<string, Breakpoint>();\n  #updateBindingsCallbacks: Array<(uiSourceCode: Workspace.UISourceCode.UISourceCode) => Promise<void>> = [];\n\n  private constructor(\n      targetManager: SDK.TargetManager.TargetManager, workspace: Workspace.Workspace.WorkspaceImpl,\n      debuggerWorkspaceBinding: Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding,\n      restoreInitialBreakpointCount?: number) {\n    super();\n    this.#workspace = workspace;\n    this.targetManager = targetManager;\n    this.debuggerWorkspaceBinding = debuggerWorkspaceBinding;\n\n    this.storage.mute();\n    this.#setInitialBreakpoints(restoreInitialBreakpointCount ?? INITIAL_RESTORE_BREAKPOINT_COUNT);\n    this.storage.unmute();\n\n    this.#workspace.addEventListener(Workspace.Workspace.Events.UISourceCodeAdded, this.uiSourceCodeAdded, this);\n    this.#workspace.addEventListener(Workspace.Workspace.Events.UISourceCodeRemoved, this.uiSourceCodeRemoved, this);\n    this.#workspace.addEventListener(Workspace.Workspace.Events.ProjectRemoved, this.projectRemoved, this);\n\n    this.targetManager.observeModels(SDK.DebuggerModel.DebuggerModel, this);\n  }\n\n  #setInitialBreakpoints(restoreInitialBreakpointCount: number): void {\n    let breakpointsToSkip = this.storage.breakpoints.size - restoreInitialBreakpointCount;\n    for (const storageState of this.storage.breakpoints.values()) {\n      if (breakpointsToSkip > 0) {\n        breakpointsToSkip--;\n        continue;\n      }\n      const storageId = Storage.computeId(storageState);\n      const breakpoint = new Breakpoint(this, null, storageState, BreakpointOrigin.OTHER);\n      this.#breakpointByStorageId.set(storageId, breakpoint);\n    }\n  }\n\n  static instance(opts: {\n    forceNew: boolean|null,\n    targetManager: SDK.TargetManager.TargetManager|null,\n    workspace: Workspace.Workspace.WorkspaceImpl|null,\n    debuggerWorkspaceBinding: Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding|null,\n    restoreInitialBreakpointCount?: number,\n  } = {forceNew: null, targetManager: null, workspace: null, debuggerWorkspaceBinding: null}): BreakpointManager {\n    const {forceNew, targetManager, workspace, debuggerWorkspaceBinding, restoreInitialBreakpointCount} = opts;\n    if (!breakpointManagerInstance || forceNew) {\n      if (!targetManager || !workspace || !debuggerWorkspaceBinding) {\n        throw new Error(\n            `Unable to create settings: targetManager, workspace, and debuggerWorkspaceBinding must be provided: ${\n                new Error().stack}`);\n      }\n\n      breakpointManagerInstance =\n          new BreakpointManager(targetManager, workspace, debuggerWorkspaceBinding, restoreInitialBreakpointCount);\n    }\n\n    return breakpointManagerInstance;\n  }\n\n  modelAdded(debuggerModel: SDK.DebuggerModel.DebuggerModel): void {\n    if (Root.Runtime.experiments.isEnabled(Root.Runtime.ExperimentName.INSTRUMENTATION_BREAKPOINTS)) {\n      debuggerModel.setSynchronizeBreakpointsCallback(this.restoreBreakpointsForScript.bind(this));\n    }\n  }\n\n  modelRemoved(debuggerModel: SDK.DebuggerModel.DebuggerModel): void {\n    debuggerModel.setSynchronizeBreakpointsCallback(null);\n  }\n\n  addUpdateBindingsCallback(callback: ((uiSourceCode: Workspace.UISourceCode.UISourceCode) => Promise<void>)): void {\n    this.#updateBindingsCallbacks.push(callback);\n  }\n\n  async copyBreakpoints(\n      fromSourceCode: Workspace.UISourceCode.UISourceCode,\n      toSourceCode: Workspace.UISourceCode.UISourceCode): Promise<void> {\n    const toSourceCodeIsRemoved = toSourceCode.project().uiSourceCodeForURL(toSourceCode.url()) !== toSourceCode ||\n        this.#workspace.project(toSourceCode.project().id()) !== toSourceCode.project();\n    const breakpointItems = this.storage.breakpointItems(fromSourceCode.url(), fromSourceCode.contentType().name());\n    for (const item of breakpointItems) {\n      if (toSourceCodeIsRemoved) {\n        // If the target source code has been detached from the workspace, then no breakpoint should refer\n        // to that source code. Let us only update the storage, so that the breakpoints appear once\n        // the user binds the file system again.\n        this.storage.updateBreakpoint(\n            {...item, url: toSourceCode.url(), resourceTypeName: toSourceCode.contentType().name()});\n      } else {\n        await this.setBreakpoint(\n            toSourceCode, item.lineNumber, item.columnNumber, item.condition, item.enabled, item.isLogpoint,\n            BreakpointOrigin.OTHER);\n      }\n    }\n  }\n\n  // This method explicitly awaits the source map (if necessary) and the uiSourceCodes\n  // required to set all breakpoints that are related to this script.\n  async restoreBreakpointsForScript(script: SDK.Script.Script): Promise<void> {\n    if (!Root.Runtime.experiments.isEnabled(Root.Runtime.ExperimentName.INSTRUMENTATION_BREAKPOINTS)) {\n      return;\n    }\n    if (!script.sourceURL) {\n      return;\n    }\n\n    const uiSourceCode = await this.getUISourceCodeWithUpdatedBreakpointInfo(script);\n    if (this.#hasBreakpointsForUrl(script.sourceURL)) {\n      await this.#restoreBreakpointsForUrl(uiSourceCode);\n    }\n\n    const debuggerModel = script.debuggerModel;\n    // Handle source maps and the original sources.\n    const sourceMap = await debuggerModel.sourceMapManager().sourceMapForClientPromise(script);\n    if (sourceMap) {\n      for (const sourceURL of sourceMap.sourceURLs()) {\n        if (this.#hasBreakpointsForUrl(sourceURL)) {\n          const uiSourceCode = await this.debuggerWorkspaceBinding.uiSourceCodeForSourceMapSourceURLPromise(\n              debuggerModel, sourceURL, script.isContentScript());\n          await this.#restoreBreakpointsForUrl(uiSourceCode);\n        }\n      }\n    }\n\n    // Handle language plugins\n    const {pluginManager} = this.debuggerWorkspaceBinding;\n    const sourceUrls = await pluginManager.getSourcesForScript(script);\n    if (Array.isArray(sourceUrls)) {\n      for (const sourceURL of sourceUrls) {\n        if (this.#hasBreakpointsForUrl(sourceURL)) {\n          const uiSourceCode =\n              await this.debuggerWorkspaceBinding.uiSourceCodeForDebuggerLanguagePluginSourceURLPromise(\n                  debuggerModel, sourceURL);\n          assertNotNullOrUndefined(uiSourceCode);\n          await this.#restoreBreakpointsForUrl(uiSourceCode);\n        }\n      }\n    }\n  }\n\n  async getUISourceCodeWithUpdatedBreakpointInfo(script: SDK.Script.Script):\n      Promise<Workspace.UISourceCode.UISourceCode> {\n    const uiSourceCode = this.debuggerWorkspaceBinding.uiSourceCodeForScript(script);\n    assertNotNullOrUndefined(uiSourceCode);\n    await this.#updateBindings(uiSourceCode);\n    return uiSourceCode;\n  }\n\n  async #updateBindings(uiSourceCode: Workspace.UISourceCode.UISourceCode): Promise<void> {\n    if (this.#updateBindingsCallbacks.length > 0) {\n      // It's possible to set breakpoints on files on the file system, and to have them\n      // hit whenever we navigate to a page that serves that file.\n      // To make sure that we have all breakpoint information moved from the file system\n      // to the served file, we need to update the bindings and await it. This will\n      // move the breakpoints from the FileSystem UISourceCode to the Network UiSourceCode.\n      const promises = [];\n      for (const callback of this.#updateBindingsCallbacks) {\n        promises.push(callback(uiSourceCode));\n      }\n      await Promise.all(promises);\n    }\n  }\n\n  async #restoreBreakpointsForUrl(uiSourceCode: Workspace.UISourceCode.UISourceCode): Promise<void> {\n    this.restoreBreakpoints(uiSourceCode);\n    const breakpoints = this.#breakpointByStorageId.values();\n    const affectedBreakpoints = Array.from(breakpoints).filter(x => x.uiSourceCodes.has(uiSourceCode));\n    // Make sure to properly await their updates\n    await Promise.all(affectedBreakpoints.map(bp => bp.updateBreakpoint()));\n  }\n\n  #hasBreakpointsForUrl(url: Platform.DevToolsPath.UrlString): boolean {\n    // We intentionally don't specify a resource type here, but just check\n    // generally whether there's any breakpoint matching the given `url`.\n    const breakpointItems = this.storage.breakpointItems(url);\n    return breakpointItems.length > 0;\n  }\n\n  static getScriptForInlineUiSourceCode(uiSourceCode: Workspace.UISourceCode.UISourceCode): SDK.Script.Script|null {\n    const script = Bindings.DefaultScriptMapping.DefaultScriptMapping.scriptForUISourceCode(uiSourceCode);\n    if (script && script.isInlineScript() && !script.hasSourceURL) {\n      return script;\n    }\n    return null;\n  }\n\n  // For inline scripts, this function translates the line-column coordinates into the coordinates\n  // of the embedding document. For other scripts, it just returns unchanged line-column.\n  static breakpointLocationFromUiLocation(uiLocation: Workspace.UISourceCode.UILocation):\n      {lineNumber: number, columnNumber: number|undefined} {\n    const uiSourceCode = uiLocation.uiSourceCode;\n    const script = BreakpointManager.getScriptForInlineUiSourceCode(uiSourceCode);\n    const {lineNumber, columnNumber} = script ? script.relativeLocationToRawLocation(uiLocation) : uiLocation;\n    return {lineNumber, columnNumber};\n  }\n\n  // For inline scripts, this function translates the line-column coordinates of the embedding\n  // document into the coordinates of the script. Other UI source code coordinated are not\n  // affected.\n  static uiLocationFromBreakpointLocation(\n      uiSourceCode: Workspace.UISourceCode.UISourceCode, lineNumber: number,\n      columnNumber: number|undefined): Workspace.UISourceCode.UILocation {\n    const script = BreakpointManager.getScriptForInlineUiSourceCode(uiSourceCode);\n    if (script) {\n      ({lineNumber, columnNumber} = script.rawLocationToRelativeLocation({lineNumber, columnNumber}));\n    }\n    return uiSourceCode.uiLocation(lineNumber, columnNumber);\n  }\n\n  // Returns true for if the given (raw) position is within the script or if the script\n  // is null. This is used to filter breakpoints if a script is known.\n  static isValidPositionInScript(lineNumber: number, columnNumber: number|undefined, script: SDK.Script.Script|null):\n      boolean {\n    if (!script) {\n      return true;\n    }\n    if (lineNumber < script.lineOffset || lineNumber > script.endLine) {\n      return false;\n    }\n    if (lineNumber === script.lineOffset && columnNumber && columnNumber < script.columnOffset) {\n      return false;\n    }\n    if (lineNumber === script.endLine && (!columnNumber || columnNumber >= script.endColumn)) {\n      return false;\n    }\n    return true;\n  }\n\n  private restoreBreakpoints(uiSourceCode: Workspace.UISourceCode.UISourceCode): void {\n    const script = BreakpointManager.getScriptForInlineUiSourceCode(uiSourceCode);\n    const url = script?.sourceURL ?? uiSourceCode.url();\n    if (!url) {\n      return;\n    }\n    const contentType = uiSourceCode.contentType();\n\n    this.storage.mute();\n    const breakpoints = this.storage.breakpointItems(url, contentType.name());\n    for (const breakpoint of breakpoints) {\n      const {lineNumber, columnNumber} = breakpoint;\n      if (!BreakpointManager.isValidPositionInScript(lineNumber, columnNumber, script)) {\n        continue;\n      }\n      this.#setBreakpoint(\n          uiSourceCode, lineNumber, columnNumber, breakpoint.condition, breakpoint.enabled, breakpoint.isLogpoint,\n          BreakpointOrigin.OTHER);\n    }\n    this.storage.unmute();\n  }\n\n  private uiSourceCodeAdded(event: Common.EventTarget.EventTargetEvent<Workspace.UISourceCode.UISourceCode>): void {\n    const uiSourceCode = event.data;\n    this.restoreBreakpoints(uiSourceCode);\n  }\n\n  private uiSourceCodeRemoved(event: Common.EventTarget.EventTargetEvent<Workspace.UISourceCode.UISourceCode>): void {\n    const uiSourceCode = event.data;\n    this.removeUISourceCode(uiSourceCode);\n  }\n\n  private projectRemoved(event: Common.EventTarget.EventTargetEvent<Workspace.Workspace.Project>): void {\n    const project = event.data;\n    for (const uiSourceCode of project.uiSourceCodes()) {\n      this.removeUISourceCode(uiSourceCode);\n    }\n  }\n\n  private removeUISourceCode(uiSourceCode: Workspace.UISourceCode.UISourceCode): void {\n    const breakpoints = this.#getAllBreakpointsForUISourceCode(uiSourceCode);\n    breakpoints.forEach(bp => bp.removeUISourceCode(uiSourceCode));\n  }\n\n  async setBreakpoint(\n      uiSourceCode: Workspace.UISourceCode.UISourceCode, lineNumber: number, columnNumber: number|undefined,\n      condition: UserCondition, enabled: boolean, isLogpoint: boolean,\n      origin: BreakpointOrigin): Promise<Breakpoint|undefined> {\n    // As part of de-duplication, we always only show one uiSourceCode, but we may\n    // have several uiSourceCodes that correspond to the same\n    // file (but are attached to different targets), so set a breakpoint on all of them.\n    const compatibleUiSourceCodes = this.#workspace.findCompatibleUISourceCodes(uiSourceCode);\n\n    let primaryBreakpoint: Breakpoint|undefined;\n    for (const compatibleUiSourceCode of compatibleUiSourceCodes) {\n      const uiLocation = new Workspace.UISourceCode.UILocation(compatibleUiSourceCode, lineNumber, columnNumber);\n      const normalizedLocation = await this.debuggerWorkspaceBinding.normalizeUILocation(uiLocation);\n      const breakpointLocation = BreakpointManager.breakpointLocationFromUiLocation(normalizedLocation);\n\n      const breakpoint = this.#setBreakpoint(\n          normalizedLocation.uiSourceCode, breakpointLocation.lineNumber, breakpointLocation.columnNumber, condition,\n          enabled, isLogpoint, origin);\n\n      if (uiSourceCode === compatibleUiSourceCode) {\n        if (normalizedLocation.id() !== uiLocation.id()) {\n          // Only call this on the uiSourceCode that was initially selected for breakpoint setting.\n          void Common.Revealer.reveal(normalizedLocation);\n        }\n        primaryBreakpoint = breakpoint;\n      }\n    }\n\n    console.assert(primaryBreakpoint !== undefined, 'The passed uiSourceCode is expected to be a valid uiSourceCode');\n    return primaryBreakpoint;\n  }\n\n  #setBreakpoint(\n      uiSourceCode: Workspace.UISourceCode.UISourceCode, lineNumber: number, columnNumber: number|undefined,\n      condition: UserCondition, enabled: boolean, isLogpoint: boolean, origin: BreakpointOrigin): Breakpoint {\n    const url = BreakpointManager.getScriptForInlineUiSourceCode(uiSourceCode)?.sourceURL ?? uiSourceCode.url();\n    const resourceTypeName = uiSourceCode.contentType().name();\n    const storageState = {url, resourceTypeName, lineNumber, columnNumber, condition, enabled, isLogpoint};\n    const storageId = Storage.computeId(storageState);\n    let breakpoint = this.#breakpointByStorageId.get(storageId);\n    if (breakpoint) {\n      breakpoint.updateState(storageState);\n      breakpoint.addUISourceCode(uiSourceCode);\n      void breakpoint.updateBreakpoint();\n      return breakpoint;\n    }\n    breakpoint = new Breakpoint(this, uiSourceCode, storageState, origin);\n    this.#breakpointByStorageId.set(storageId, breakpoint);\n    return breakpoint;\n  }\n\n  findBreakpoint(uiLocation: Workspace.UISourceCode.UILocation): BreakpointLocation|null {\n    const breakpoints = this.#breakpointsForUISourceCode.get(uiLocation.uiSourceCode);\n    return breakpoints ? (breakpoints.get(uiLocation.id())) || null : null;\n  }\n\n  addHomeUISourceCode(uiSourceCode: Workspace.UISourceCode.UISourceCode, breakpoint: Breakpoint): void {\n    let breakpoints = this.#breakpointsForHomeUISourceCode.get(uiSourceCode);\n    if (!breakpoints) {\n      breakpoints = new Set();\n      this.#breakpointsForHomeUISourceCode.set(uiSourceCode, breakpoints);\n    }\n    breakpoints.add(breakpoint);\n  }\n\n  removeHomeUISourceCode(uiSourceCode: Workspace.UISourceCode.UISourceCode, breakpoint: Breakpoint): void {\n    const breakpoints = this.#breakpointsForHomeUISourceCode.get(uiSourceCode);\n    if (!breakpoints) {\n      return;\n    }\n    breakpoints.delete(breakpoint);\n    if (breakpoints.size === 0) {\n      this.#breakpointsForHomeUISourceCode.delete(uiSourceCode);\n    }\n  }\n\n  async possibleBreakpoints(\n      uiSourceCode: Workspace.UISourceCode.UISourceCode,\n      textRange: TextUtils.TextRange.TextRange): Promise<Workspace.UISourceCode.UILocation[]> {\n    const rawLocationRanges =\n        await this.debuggerWorkspaceBinding.uiLocationRangeToRawLocationRanges(uiSourceCode, textRange);\n    const breakLocationLists = await Promise.all(rawLocationRanges.map(\n        ({start, end}) => start.debuggerModel.getPossibleBreakpoints(start, end, /* restrictToFunction */ false)));\n    const breakLocations = breakLocationLists.flat();\n\n    const uiLocations = new Map<string, Workspace.UISourceCode.UILocation>();\n    await Promise.all(breakLocations.map(async breakLocation => {\n      const uiLocation = await this.debuggerWorkspaceBinding.rawLocationToUILocation(breakLocation);\n      if (uiLocation === null) {\n        return;\n      }\n\n      // The \"canonical\" UI locations don't need to be in our `uiSourceCode`.\n      if (uiLocation.uiSourceCode !== uiSourceCode) {\n        return;\n      }\n\n      // Since we ask for all overlapping ranges above, we might also get breakable locations\n      // outside of the `textRange`.\n      if (!textRange.containsLocation(uiLocation.lineNumber, uiLocation.columnNumber ?? 0)) {\n        return;\n      }\n\n      uiLocations.set(uiLocation.id(), uiLocation);\n    }));\n    return [...uiLocations.values()];\n  }\n\n  breakpointLocationsForUISourceCode(uiSourceCode: Workspace.UISourceCode.UISourceCode): BreakpointLocation[] {\n    const breakpoints = this.#breakpointsForUISourceCode.get(uiSourceCode);\n    return breakpoints ? Array.from(breakpoints.values()) : [];\n  }\n\n  #getAllBreakpointsForUISourceCode(uiSourceCode: Workspace.UISourceCode.UISourceCode): Breakpoint[] {\n    const uiBreakpoints = this.breakpointLocationsForUISourceCode(uiSourceCode).map(b => b.breakpoint);\n    return uiBreakpoints.concat(Array.from(this.#breakpointsForHomeUISourceCode.get(uiSourceCode) ?? []));\n  }\n\n  allBreakpointLocations(): BreakpointLocation[] {\n    const result = [];\n    for (const breakpoints of this.#breakpointsForUISourceCode.values()) {\n      result.push(...breakpoints.values());\n    }\n    return result;\n  }\n\n  removeBreakpoint(breakpoint: Breakpoint, removeFromStorage: boolean): void {\n    const storageId = breakpoint.breakpointStorageId();\n    if (removeFromStorage) {\n      this.storage.removeBreakpoint(storageId);\n    }\n    this.#breakpointByStorageId.delete(storageId);\n  }\n\n  uiLocationAdded(breakpoint: Breakpoint, uiLocation: Workspace.UISourceCode.UILocation): void {\n    let breakpoints = this.#breakpointsForUISourceCode.get(uiLocation.uiSourceCode);\n    if (!breakpoints) {\n      breakpoints = new Map();\n      this.#breakpointsForUISourceCode.set(uiLocation.uiSourceCode, breakpoints);\n    }\n    const breakpointLocation = new BreakpointLocation(breakpoint, uiLocation);\n    breakpoints.set(uiLocation.id(), breakpointLocation);\n    this.dispatchEventToListeners(Events.BreakpointAdded, breakpointLocation);\n  }\n\n  uiLocationRemoved(uiLocation: Workspace.UISourceCode.UILocation): void {\n    const breakpoints = this.#breakpointsForUISourceCode.get(uiLocation.uiSourceCode);\n    if (!breakpoints) {\n      return;\n    }\n    const breakpointLocation = breakpoints.get(uiLocation.id()) || null;\n    if (!breakpointLocation) {\n      return;\n    }\n    breakpoints.delete(uiLocation.id());\n    if (breakpoints.size === 0) {\n      this.#breakpointsForUISourceCode.delete(uiLocation.uiSourceCode);\n    }\n    this.dispatchEventToListeners(Events.BreakpointRemoved, breakpointLocation);\n  }\n\n  supportsConditionalBreakpoints(uiSourceCode: Workspace.UISourceCode.UISourceCode): boolean {\n    return this.debuggerWorkspaceBinding.supportsConditionalBreakpoints(uiSourceCode);\n  }\n}\n\nexport enum Events {\n  /* eslint-disable @typescript-eslint/naming-convention -- Used by web_tests. */\n  BreakpointAdded = 'breakpoint-added',\n  BreakpointRemoved = 'breakpoint-removed',\n  /* eslint-enable @typescript-eslint/naming-convention */\n}\n\nexport interface EventTypes {\n  [Events.BreakpointAdded]: BreakpointLocation;\n  [Events.BreakpointRemoved]: BreakpointLocation;\n}\n\nexport const enum DebuggerUpdateResult {\n  OK = 'OK',\n  ERROR_BREAKPOINT_CLASH = 'ERROR_BREAKPOINT_CLASH',\n  ERROR_BACKEND = 'ERROR_BACKEND',\n\n  // PENDING implies that the current update requires another re-run.\n  PENDING = 'PENDING',\n}\n\nexport type ScheduleUpdateResult =\n    DebuggerUpdateResult.OK|DebuggerUpdateResult.ERROR_BACKEND|DebuggerUpdateResult.ERROR_BREAKPOINT_CLASH;\n\nconst enum ResolveLocationResult {\n  OK = 'OK',\n  ERROR = 'ERROR',\n}\n\nexport class Breakpoint implements SDK.TargetManager.SDKModelObserver<SDK.DebuggerModel.DebuggerModel> {\n  readonly breakpointManager: BreakpointManager;\n  /** Bound locations */\n  readonly #uiLocations = new Set<Workspace.UISourceCode.UILocation>();\n  /** All known UISourceCodes with this url. This also includes UISourceCodes for the inline scripts embedded in a resource with this URL. */\n  readonly uiSourceCodes = new Set<Workspace.UISourceCode.UISourceCode>();\n  #storageState!: BreakpointStorageState;\n  #origin: BreakpointOrigin;\n  isRemoved = false;\n  /**\n   * Fallback positions in case a target doesn't have a script where this breakpoint would fit.\n   * The `ModelBreakpoint` sends this optimistically to a target in case a matching script is\n   * loaded later.\n   *\n   * Since every `ModelBreakpoint` can read/write this variable, it's slightly arbitrary. In\n   * general `lastResolvedState` contains the state of the last `ModelBreakpoint` that attempted\n   * to update the breakpoint(s) in the backend.\n   *\n   * The state gets populated from the storage if/when we set all breakpoints eagerly\n   * on debugger startup so that the backend sets the breakpoints as soon as possible\n   * (crbug.com/1442232, under a flag).\n   */\n  #lastResolvedState: Breakpoint.State|null = null;\n  readonly #modelBreakpoints = new Map<SDK.DebuggerModel.DebuggerModel, ModelBreakpoint>();\n\n  constructor(\n      breakpointManager: BreakpointManager, primaryUISourceCode: Workspace.UISourceCode.UISourceCode|null,\n      storageState: BreakpointStorageState, origin: BreakpointOrigin) {\n    this.breakpointManager = breakpointManager;\n    this.#origin = origin;\n\n    this.updateState(storageState);\n    if (primaryUISourceCode) {\n      // User is setting the breakpoint in an existing source.\n      console.assert(primaryUISourceCode.contentType().name() === storageState.resourceTypeName);\n      this.addUISourceCode(primaryUISourceCode);\n    } else {\n      // We are setting the breakpoint from storage.\n      this.#setLastResolvedStateFromStorage(storageState);\n    }\n\n    this.breakpointManager.targetManager.observeModels(SDK.DebuggerModel.DebuggerModel, this);\n  }\n\n  #setLastResolvedStateFromStorage(storageState: BreakpointStorageState): void {\n    if (storageState.resolvedState) {\n      this.#lastResolvedState = storageState.resolvedState.map(s => ({...s, scriptHash: ''}));\n    } else if (storageState.resourceTypeName === Common.ResourceType.resourceTypes.Script.name()) {\n      // If we are setting the breakpoint from storage (i.e., primaryUISourceCode is null),\n      // and the location is not source mapped, then set the last known state to\n      // the state from storage so that the breakpoints are pre-set into the backend eagerly.\n      this.#lastResolvedState = [{\n        url: storageState.url,\n        lineNumber: storageState.lineNumber,\n        columnNumber: storageState.columnNumber,\n        scriptHash: '',\n        condition: this.backendCondition(),\n      }];\n    }\n  }\n\n  getLastResolvedState(): Breakpoint.State|null {\n    return this.#lastResolvedState;\n  }\n\n  updateLastResolvedState(locations: Position[]|null): void {\n    this.#lastResolvedState = locations;\n\n    let locationsOrUndefined: ScriptBreakpointLocation[]|undefined = undefined;\n    if (locations) {\n      locationsOrUndefined = locations.map(\n          p => ({url: p.url, lineNumber: p.lineNumber, columnNumber: p.columnNumber, condition: p.condition}));\n    }\n\n    if (resolvedStateEqual(this.#storageState.resolvedState, locationsOrUndefined)) {\n      return;\n    }\n    this.#storageState = {...this.#storageState, resolvedState: locationsOrUndefined};\n    this.breakpointManager.storage.updateBreakpoint(this.#storageState);\n  }\n\n  get origin(): BreakpointOrigin {\n    return this.#origin;\n  }\n\n  async refreshInDebugger(): Promise<void> {\n    if (!this.isRemoved) {\n      const modelBreakpoints = Array.from(this.#modelBreakpoints.values());\n      await Promise.all(modelBreakpoints.map(async modelBreakpoint => {\n        await modelBreakpoint.resetBreakpoint();\n        return await this.#updateModel(modelBreakpoint);\n      }));\n    }\n  }\n\n  modelAdded(debuggerModel: SDK.DebuggerModel.DebuggerModel): void {\n    const debuggerWorkspaceBinding = this.breakpointManager.debuggerWorkspaceBinding;\n    const modelBreakpoint = new ModelBreakpoint(debuggerModel, this, debuggerWorkspaceBinding);\n    this.#modelBreakpoints.set(debuggerModel, modelBreakpoint);\n    void this.#updateModel(modelBreakpoint);\n\n    debuggerModel.addEventListener(SDK.DebuggerModel.Events.DebuggerWasEnabled, this.#onDebuggerEnabled, this);\n    debuggerModel.addEventListener(SDK.DebuggerModel.Events.DebuggerWasDisabled, this.#onDebuggerDisabled, this);\n    debuggerModel.addEventListener(SDK.DebuggerModel.Events.ScriptSourceWasEdited, this.#onScriptWasEdited, this);\n  }\n\n  modelRemoved(debuggerModel: SDK.DebuggerModel.DebuggerModel): void {\n    const modelBreakpoint = this.#modelBreakpoints.get(debuggerModel);\n    modelBreakpoint?.cleanUpAfterDebuggerIsGone();\n    this.#modelBreakpoints.delete(debuggerModel);\n\n    this.#removeDebuggerModelListeners(debuggerModel);\n  }\n\n  #removeDebuggerModelListeners(debuggerModel: SDK.DebuggerModel.DebuggerModel): void {\n    debuggerModel.removeEventListener(SDK.DebuggerModel.Events.DebuggerWasEnabled, this.#onDebuggerEnabled, this);\n    debuggerModel.removeEventListener(SDK.DebuggerModel.Events.DebuggerWasDisabled, this.#onDebuggerDisabled, this);\n    debuggerModel.removeEventListener(SDK.DebuggerModel.Events.ScriptSourceWasEdited, this.#onScriptWasEdited, this);\n  }\n\n  #onDebuggerEnabled(event: Common.EventTarget.EventTargetEvent<SDK.DebuggerModel.DebuggerModel>): void {\n    const debuggerModel = event.data;\n    const model = this.#modelBreakpoints.get(debuggerModel);\n    if (model) {\n      void this.#updateModel(model);\n    }\n  }\n\n  #onDebuggerDisabled(event: Common.EventTarget.EventTargetEvent<SDK.DebuggerModel.DebuggerModel>): void {\n    const debuggerModel = event.data;\n    const model = this.#modelBreakpoints.get(debuggerModel);\n    model?.cleanUpAfterDebuggerIsGone();\n  }\n\n  async #onScriptWasEdited(\n      event: Common.EventTarget\n          .EventTargetEvent<{script: SDK.Script.Script, status: Protocol.Debugger.SetScriptSourceResponseStatus}>):\n      Promise<void> {\n    const {source: debuggerModel, data: {script, status}} = event;\n    if (status !== Protocol.Debugger.SetScriptSourceResponseStatus.Ok) {\n      return;\n    }\n\n    // V8 throws away breakpoints on all functions in a live edited script. Here we attempt to re-set them again at the\n    // same position. This is because we don't know what was edited and how the breakpoint should move, e.g. if the file\n    // was originally changed on the filesystem (via workspace).\n    // If the live edit originated in DevTools (in CodeMirror), then the `DebuggerPlugin` will remove the breakpoint\n    // wholesale and re-apply based on the diff.\n\n    console.assert(debuggerModel instanceof SDK.DebuggerModel.DebuggerModel);\n    const model = this.#modelBreakpoints.get(debuggerModel as SDK.DebuggerModel.DebuggerModel);\n    if (model?.wasSetIn(script.scriptId)) {\n      await model.resetBreakpoint();\n      void this.#updateModel(model);\n    }\n  }\n\n  modelBreakpoint(debuggerModel: SDK.DebuggerModel.DebuggerModel): ModelBreakpoint|undefined {\n    return this.#modelBreakpoints.get(debuggerModel);\n  }\n\n  addUISourceCode(uiSourceCode: Workspace.UISourceCode.UISourceCode): void {\n    if (!this.uiSourceCodes.has(uiSourceCode)) {\n      this.uiSourceCodes.add(uiSourceCode);\n      this.breakpointManager.addHomeUISourceCode(uiSourceCode, this);\n      if (!this.bound()) {\n        this.breakpointManager.uiLocationAdded(this, this.defaultUILocation(uiSourceCode));\n      }\n    }\n  }\n\n  clearUISourceCodes(): void {\n    if (!this.bound()) {\n      this.removeAllUnboundLocations();\n    }\n    for (const uiSourceCode of this.uiSourceCodes) {\n      this.removeUISourceCode(uiSourceCode);\n    }\n  }\n\n  removeUISourceCode(uiSourceCode: Workspace.UISourceCode.UISourceCode): void {\n    if (this.uiSourceCodes.has(uiSourceCode)) {\n      this.uiSourceCodes.delete(uiSourceCode);\n      this.breakpointManager.removeHomeUISourceCode(uiSourceCode, this);\n      if (!this.bound()) {\n        this.breakpointManager.uiLocationRemoved(this.defaultUILocation(uiSourceCode));\n      }\n    }\n\n    // Do we need to do this? Not sure if bound locations will leak...\n    if (this.bound()) {\n      for (const uiLocation of this.#uiLocations) {\n        if (uiLocation.uiSourceCode === uiSourceCode) {\n          this.#uiLocations.delete(uiLocation);\n          this.breakpointManager.uiLocationRemoved(uiLocation);\n        }\n      }\n\n      if (!this.bound() && !this.isRemoved) {\n        // Switch to unbound locations\n        this.addAllUnboundLocations();\n      }\n    }\n  }\n\n  url(): Platform.DevToolsPath.UrlString {\n    return this.#storageState.url;\n  }\n\n  lineNumber(): number {\n    return this.#storageState.lineNumber;\n  }\n\n  columnNumber(): number|undefined {\n    return this.#storageState.columnNumber;\n  }\n\n  uiLocationAdded(uiLocation: Workspace.UISourceCode.UILocation): void {\n    if (this.isRemoved) {\n      return;\n    }\n    if (!this.bound()) {\n      // This is our first bound location; remove all unbound locations\n      this.removeAllUnboundLocations();\n    }\n    this.#uiLocations.add(uiLocation);\n    this.breakpointManager.uiLocationAdded(this, uiLocation);\n  }\n\n  uiLocationRemoved(uiLocation: Workspace.UISourceCode.UILocation): void {\n    if (this.#uiLocations.has(uiLocation)) {\n      this.#uiLocations.delete(uiLocation);\n      this.breakpointManager.uiLocationRemoved(uiLocation);\n      if (!this.bound() && !this.isRemoved) {\n        this.addAllUnboundLocations();\n      }\n    }\n  }\n\n  enabled(): boolean {\n    return this.#storageState.enabled;\n  }\n\n  bound(): boolean {\n    return this.#uiLocations.size !== 0;\n  }\n\n  setEnabled(enabled: boolean): void {\n    this.updateState({...this.#storageState, enabled});\n  }\n\n  /**\n   * The breakpoint condition as entered by the user.\n   */\n  condition(): UserCondition {\n    return this.#storageState.condition;\n  }\n\n  /**\n   * The breakpoint condition as it is sent to V8.\n   */\n  backendCondition(): SDK.DebuggerModel.BackendCondition;\n  backendCondition(location: SDK.DebuggerModel.Location): Promise<SDK.DebuggerModel.BackendCondition>;\n  backendCondition(location?: SDK.DebuggerModel.Location): SDK.DebuggerModel.BackendCondition\n      |Promise<SDK.DebuggerModel.BackendCondition> {\n    const condition: string = this.condition();\n    if (condition === '') {\n      return '' as SDK.DebuggerModel.BackendCondition;\n    }\n\n    const addSourceUrl = (condition: string): SDK.DebuggerModel.BackendCondition => {\n      let sourceUrl = SDK.DebuggerModel.COND_BREAKPOINT_SOURCE_URL;\n      if (this.isLogpoint()) {\n        condition = `${LOGPOINT_PREFIX}${condition}${LOGPOINT_SUFFIX}`;\n        sourceUrl = SDK.DebuggerModel.LOGPOINT_SOURCE_URL;\n      }\n      return `${condition}\\n\\n//# sourceURL=${sourceUrl}` as SDK.DebuggerModel.BackendCondition;\n    };\n\n    if (location) {\n      return SourceMapScopes.NamesResolver.allVariablesAtPosition(location)\n          .then(nameMap => Formatter.FormatterWorkerPool.formatterWorkerPool().javaScriptSubstitute(condition, nameMap))\n          .catch(() => condition)\n          .then(subsitutedCondition => addSourceUrl(subsitutedCondition), () => addSourceUrl(condition));\n    }\n    return addSourceUrl(condition);\n  }\n\n  setCondition(condition: UserCondition, isLogpoint: boolean): void {\n    this.updateState({...this.#storageState, condition, isLogpoint});\n  }\n\n  isLogpoint(): boolean {\n    return this.#storageState.isLogpoint;\n  }\n\n  get storageState(): BreakpointStorageState {\n    return this.#storageState;\n  }\n\n  updateState(newState: BreakpointStorageState): void {\n    // Only 'enabled', 'condition' and 'isLogpoint' can change (except during initialization).\n    if (this.#storageState &&\n        (this.#storageState.url !== newState.url || this.#storageState.lineNumber !== newState.lineNumber ||\n         this.#storageState.columnNumber !== newState.columnNumber)) {\n      throw new Error('Invalid breakpoint state update');\n    }\n    if (this.#storageState?.enabled === newState.enabled && this.#storageState?.condition === newState.condition &&\n        this.#storageState?.isLogpoint === newState.isLogpoint) {\n      return;\n    }\n    this.#storageState = newState;\n    this.breakpointManager.storage.updateBreakpoint(this.#storageState);\n    void this.updateBreakpoint();\n  }\n\n  async updateBreakpoint(): Promise<void> {\n    if (!this.bound()) {\n      this.removeAllUnboundLocations();\n      if (!this.isRemoved) {\n        this.addAllUnboundLocations();\n      }\n    }\n    return await this.#updateModels();\n  }\n\n  async remove(keepInStorage: boolean): Promise<void> {\n    if (this.getIsRemoved()) {\n      return;\n    }\n    this.isRemoved = true;\n    const removeFromStorage = !keepInStorage;\n\n    for (const debuggerModel of this.#modelBreakpoints.keys()) {\n      this.#removeDebuggerModelListeners(debuggerModel);\n    }\n    await this.#updateModels();\n\n    this.breakpointManager.removeBreakpoint(this, removeFromStorage);\n    this.breakpointManager.targetManager.unobserveModels(SDK.DebuggerModel.DebuggerModel, this);\n    this.clearUISourceCodes();\n  }\n\n  breakpointStorageId(): string {\n    return Storage.computeId(this.#storageState);\n  }\n\n  private defaultUILocation(uiSourceCode: Workspace.UISourceCode.UISourceCode): Workspace.UISourceCode.UILocation {\n    return BreakpointManager.uiLocationFromBreakpointLocation(\n        uiSourceCode, this.#storageState.lineNumber, this.#storageState.columnNumber);\n  }\n\n  private removeAllUnboundLocations(): void {\n    for (const uiSourceCode of this.uiSourceCodes) {\n      this.breakpointManager.uiLocationRemoved(this.defaultUILocation(uiSourceCode));\n    }\n  }\n\n  private addAllUnboundLocations(): void {\n    for (const uiSourceCode of this.uiSourceCodes) {\n      this.breakpointManager.uiLocationAdded(this, this.defaultUILocation(uiSourceCode));\n    }\n  }\n\n  getUiSourceCodes(): Set<Workspace.UISourceCode.UISourceCode> {\n    return this.uiSourceCodes;\n  }\n\n  getIsRemoved(): boolean {\n    return this.isRemoved;\n  }\n\n  async #updateModels(): Promise<void> {\n    await Promise.all(Array.from(this.#modelBreakpoints.values()).map(model => this.#updateModel(model)));\n  }\n\n  async #updateModel(model: ModelBreakpoint): Promise<void> {\n    const result = await model.scheduleUpdateInDebugger();\n    if (result === DebuggerUpdateResult.ERROR_BACKEND) {\n      await this.remove(true /* keepInStorage */);\n    } else if (result === DebuggerUpdateResult.ERROR_BREAKPOINT_CLASH) {\n      await this.remove(false /* keepInStorage */);\n    }\n  }\n}\n\n/**\n * Represents a single `Breakpoint` for a specific target.\n *\n * The `BreakpointManager` unconditionally creates a `ModelBreakpoint` instance\n * for each target since any target could load a matching script after the fact.\n *\n * Each `ModelBreakpoint` can represent multiple actual breakpoints in V8. E.g.\n * inlining in WASM or multiple bundles containing the same utility function.\n *\n * This means each `Modelbreakpoint` represents 0 to n actual breakpoints in\n * for it's specific target.\n */\nexport class ModelBreakpoint {\n  #debuggerModel: SDK.DebuggerModel.DebuggerModel;\n  #breakpoint: Breakpoint;\n  readonly #debuggerWorkspaceBinding: Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding;\n  readonly #liveLocations = new Bindings.LiveLocation.LiveLocationPool();\n  readonly #uiLocations = new Map<Bindings.LiveLocation.LiveLocation, Workspace.UISourceCode.UILocation>();\n  #updateMutex = new Common.Mutex.Mutex();\n  #cancelCallback = false;\n  #currentState: Breakpoint.State|null = null;\n  #breakpointIds: Protocol.Debugger.BreakpointId[] = [];\n  /**\n   * We track all the script IDs this ModelBreakpoint was actually set in. This allows us\n   * to properly reset this ModelBreakpoint after a script was live edited.\n   */\n  #resolvedScriptIds = new Set<Protocol.Runtime.ScriptId>();\n\n  constructor(\n      debuggerModel: SDK.DebuggerModel.DebuggerModel, breakpoint: Breakpoint,\n      debuggerWorkspaceBinding: Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding) {\n    this.#debuggerModel = debuggerModel;\n    this.#breakpoint = breakpoint;\n    this.#debuggerWorkspaceBinding = debuggerWorkspaceBinding;\n  }\n\n  get currentState(): Breakpoint.State|null {\n    return this.#currentState;\n  }\n\n  resetLocations(): void {\n    for (const uiLocation of this.#uiLocations.values()) {\n      this.#breakpoint.uiLocationRemoved(uiLocation);\n    }\n\n    this.#uiLocations.clear();\n    this.#liveLocations.disposeAll();\n    this.#resolvedScriptIds.clear();\n  }\n\n  async scheduleUpdateInDebugger(): Promise<ScheduleUpdateResult> {\n    if (!this.#debuggerModel.debuggerEnabled()) {\n      return DebuggerUpdateResult.OK;\n    }\n\n    const release = await this.#updateMutex.acquire();\n    let result = DebuggerUpdateResult.PENDING;\n    while (result === DebuggerUpdateResult.PENDING) {\n      result = await this.#updateInDebugger();\n\n      // TODO(crbug.com/1229541): This is a mirror to the quickfix\n      // in #updateInDebugger. If the model didn't enable yet, instead of\n      // spamming the \"setBreakpoint\" call to the backend, we'll wait for\n      // it to finish enabling.\n      if (this.#debuggerModel.debuggerEnabled() && !this.#debuggerModel.isReadyToPause()) {\n        await this.#debuggerModel.once(SDK.DebuggerModel.Events.DebuggerIsReadyToPause);\n        if (!this.#debuggerModel.debuggerEnabled()) {\n          // If the model failed to enable, we won't try to set the breakpoint.\n          result = DebuggerUpdateResult.OK;\n          break;\n        }\n      }\n    }\n    release();\n    return result;\n  }\n\n  private scriptDiverged(): boolean {\n    for (const uiSourceCode of this.#breakpoint.getUiSourceCodes()) {\n      const scriptFile = this.#debuggerWorkspaceBinding.scriptFile(uiSourceCode, this.#debuggerModel);\n      if (scriptFile?.hasDivergedFromVM()) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  async #updateInDebugger(): Promise<DebuggerUpdateResult> {\n    if (this.#debuggerModel.target().isDisposed()) {\n      this.cleanUpAfterDebuggerIsGone();\n      return DebuggerUpdateResult.OK;\n    }\n    const lineNumber = this.#breakpoint.lineNumber();\n    const columnNumber = this.#breakpoint.columnNumber();\n    const condition = this.#breakpoint.backendCondition();\n\n    // Calculate the new state.\n    let newState: Breakpoint.State|null = null;\n    if (!this.#breakpoint.getIsRemoved() && this.#breakpoint.enabled() && !this.scriptDiverged()) {\n      let debuggerLocations: SDK.DebuggerModel.Location[] = [];\n      for (const uiSourceCode of this.#breakpoint.getUiSourceCodes()) {\n        const {lineNumber: uiLineNumber, columnNumber: uiColumnNumber} =\n            BreakpointManager.uiLocationFromBreakpointLocation(uiSourceCode, lineNumber, columnNumber);\n        const locations =\n            await Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding.instance().uiLocationToRawLocations(\n                uiSourceCode, uiLineNumber, uiColumnNumber);\n        debuggerLocations = locations.filter(location => location.debuggerModel === this.#debuggerModel);\n        if (debuggerLocations.length) {\n          break;\n        }\n      }\n      if (debuggerLocations.length && debuggerLocations.every(loc => loc.script())) {\n        const positions = await Promise.all(debuggerLocations.map(async loc => {\n          const script = loc.script() as SDK.Script.Script;\n          const condition = await this.#breakpoint.backendCondition(loc);\n          return {\n            url: script.sourceURL,\n            scriptHash: script.hash,\n            lineNumber: loc.lineNumber,\n            columnNumber: loc.columnNumber,\n            condition,\n          };\n        }));\n        newState = positions.slice(0);  // Create a copy\n      } else if (!Root.Runtime.experiments.isEnabled(Root.Runtime.ExperimentName.INSTRUMENTATION_BREAKPOINTS)) {\n        // Use this fallback if we do not have instrumentation breakpoints enabled yet. This currently makes\n        // sure that v8 knows about the breakpoint and is able to restore it whenever the script is parsed.\n        const lastResolvedState = this.#breakpoint.getLastResolvedState();\n        if (lastResolvedState) {\n          // Re-use position information from fallback but use up-to-date condition.\n          newState = lastResolvedState.map(position => ({...position, condition}));\n        } else {\n          // TODO(bmeurer): This fallback doesn't make a whole lot of sense, we should\n          // at least signal a warning to the developer that this #breakpoint wasn't\n          // really resolved.\n          const position = {\n            url: this.#breakpoint.url(),\n            scriptHash: '',\n            lineNumber,\n            columnNumber,\n            condition,\n          };\n          newState = [position];\n        }\n      }\n    }\n    const hasBackendState = this.#breakpointIds.length;\n\n    // Case 1: Back-end has some breakpoints and the new state is a proper subset\n    // of the back-end state (in particular the new state contains at least a single\n    // position, meaning we're not removing the breakpoint completely).\n    if (hasBackendState && Breakpoint.State.subset(newState, this.#currentState)) {\n      return DebuggerUpdateResult.OK;\n    }\n\n    this.#breakpoint.updateLastResolvedState(newState);\n\n    // Case 2: State has changed, and the back-end has outdated information on old\n    // breakpoints.\n    if (hasBackendState) {\n      // Reset the current state.\n      await this.resetBreakpoint();\n      // Schedule another run of updates, to finally update to the new state.\n      return DebuggerUpdateResult.PENDING;\n    }\n\n    // Case 3: State is null (no breakpoints to set), and back-end is up to date\n    // (no info on breakpoints).\n    if (!newState) {\n      return DebuggerUpdateResult.OK;\n    }\n\n    // Case 4: State is not null, so we have breakpoints to set and the back-end\n    // has no information on breakpoints yet. Set the breakpoints.\n    const {breakpointIds, locations, serverError} = await this.#setBreakpointOnBackend(newState);\n\n    const maybeRescheduleUpdate =\n        serverError && this.#debuggerModel.debuggerEnabled() && !this.#debuggerModel.isReadyToPause();\n    if (!breakpointIds.length && maybeRescheduleUpdate) {\n      // TODO(crbug.com/1229541): This is a quickfix to prevent #breakpoints from\n      // disappearing if the Debugger is actually not enabled\n      // yet. This quickfix should be removed as soon as we have a solution\n      // to correctly synchronize the front-end with the inspector back-end.\n      return DebuggerUpdateResult.PENDING;\n    }\n\n    this.#currentState = newState;\n    if (this.#cancelCallback) {\n      this.#cancelCallback = false;\n      return DebuggerUpdateResult.OK;\n    }\n\n    // Something went wrong: we expect to have a non-null state, but have not received any\n    // breakpointIds from the back-end.\n    if (!breakpointIds.length) {\n      return DebuggerUpdateResult.ERROR_BACKEND;\n    }\n\n    this.#breakpointIds = breakpointIds;\n    this.#breakpointIds.forEach(\n        breakpointId => this.#debuggerModel.addBreakpointListener(breakpointId, this.breakpointResolved, this));\n    const resolvedResults = await Promise.all(locations.map(location => this.addResolvedLocation(location)));\n\n    // Breakpoint clash: the resolved location resolves to a different breakpoint, report an error.\n    if (resolvedResults.includes(ResolveLocationResult.ERROR)) {\n      return DebuggerUpdateResult.ERROR_BREAKPOINT_CLASH;\n    }\n    return DebuggerUpdateResult.OK;\n  }\n\n  async #setBreakpointOnBackend(positions: Breakpoint.State): Promise<{\n    breakpointIds: Protocol.Debugger.BreakpointId[],\n    locations: SDK.DebuggerModel.Location[],\n    serverError: boolean,\n  }> {\n    const results = await Promise.all(positions.map(pos => {\n      if (pos.url) {\n        return this.#debuggerModel.setBreakpointByURL(pos.url, pos.lineNumber, pos.columnNumber, pos.condition);\n      }\n      return this.#debuggerModel.setBreakpointInAnonymousScript(\n          pos.scriptHash, pos.lineNumber, pos.columnNumber, pos.condition);\n    }));\n    const breakpointIds: Protocol.Debugger.BreakpointId[] = [];\n    let locations: SDK.DebuggerModel.Location[] = [];\n    let serverError = false;\n    for (const result of results) {\n      if (result.breakpointId) {\n        breakpointIds.push(result.breakpointId);\n        locations = locations.concat(result.locations);\n      } else {\n        serverError = true;\n      }\n    }\n    return {breakpointIds, locations, serverError};\n  }\n\n  async resetBreakpoint(): Promise<void> {\n    if (!this.#breakpointIds.length) {\n      return;\n    }\n    this.resetLocations();\n    await Promise.all(this.#breakpointIds.map(id => this.#debuggerModel.removeBreakpoint(id)));\n    this.didRemoveFromDebugger();\n    this.#currentState = null;\n  }\n\n  private didRemoveFromDebugger(): void {\n    if (this.#cancelCallback) {\n      this.#cancelCallback = false;\n      return;\n    }\n\n    this.resetLocations();\n    this.#breakpointIds.forEach(\n        breakpointId => this.#debuggerModel.removeBreakpointListener(breakpointId, this.breakpointResolved, this));\n    this.#breakpointIds = [];\n  }\n\n  private async breakpointResolved({data: location}: Common.EventTarget.EventTargetEvent<SDK.DebuggerModel.Location>):\n      Promise<void> {\n    const result = await this.addResolvedLocation(location);\n    if (result === ResolveLocationResult.ERROR) {\n      await this.#breakpoint.remove(false /* keepInStorage */);\n    }\n  }\n\n  private async locationUpdated(liveLocation: Bindings.LiveLocation.LiveLocation): Promise<void> {\n    const oldUILocation = this.#uiLocations.get(liveLocation);\n    const uiLocation = await liveLocation.uiLocation();\n\n    if (oldUILocation) {\n      this.#breakpoint.uiLocationRemoved(oldUILocation);\n    }\n\n    if (uiLocation) {\n      this.#uiLocations.set(liveLocation, uiLocation);\n      this.#breakpoint.uiLocationAdded(uiLocation);\n    } else {\n      this.#uiLocations.delete(liveLocation);\n    }\n  }\n\n  private async addResolvedLocation(location: SDK.DebuggerModel.Location): Promise<ResolveLocationResult> {\n    this.#resolvedScriptIds.add(location.scriptId);\n    const uiLocation = await this.#debuggerWorkspaceBinding.rawLocationToUILocation(location);\n    if (!uiLocation) {\n      return ResolveLocationResult.OK;\n    }\n    const breakpointLocation = this.#breakpoint.breakpointManager.findBreakpoint(uiLocation);\n    if (breakpointLocation && breakpointLocation.breakpoint !== this.#breakpoint) {\n      // location clash\n      return ResolveLocationResult.ERROR;\n    }\n    await this.#debuggerWorkspaceBinding.createLiveLocation(\n        location, this.locationUpdated.bind(this), this.#liveLocations);\n    return ResolveLocationResult.OK;\n  }\n\n  cleanUpAfterDebuggerIsGone(): void {\n    this.#cancelCallback = true;\n    this.resetLocations();\n    this.#currentState = null;\n    if (this.#breakpointIds.length) {\n      this.didRemoveFromDebugger();\n    }\n  }\n\n  /** @returns true, iff this `ModelBreakpoint` was set (at some point) in `scriptId` */\n  wasSetIn(scriptId: Protocol.Runtime.ScriptId): boolean {\n    return this.#resolvedScriptIds.has(scriptId);\n  }\n}\n\n/**\n * A concrete breakpoint position in a specific target. Each `ModelBreakpoint`\n * consists of multiple of these.\n *\n * Note that a `Position` only denotes where we *want* to set a breakpoint, not\n * where it was actually set by V8 after the fact.\n */\ninterface Position {\n  url: Platform.DevToolsPath.UrlString;\n  scriptHash: string;\n  lineNumber: number;\n  columnNumber?: number;\n  condition: SDK.DebuggerModel.BackendCondition;\n}\n\nexport const enum BreakpointOrigin {\n  USER_ACTION = 'USER_ACTION',\n  OTHER = 'RESTORED',\n}\n\nexport namespace Breakpoint {\n\n  export type State = Position[];\n  export namespace State {\n    export function subset(stateA?: State|null, stateB?: State|null): boolean {\n      if (stateA === stateB) {\n        return true;\n      }\n      if (!stateA || !stateB) {\n        return false;\n      }\n      if (stateA.length === 0) {\n        return false;\n      }\n      for (const positionA of stateA) {\n        if (stateB.find(\n                positionB => positionA.url === positionB.url && positionA.scriptHash === positionB.scriptHash &&\n                    positionA.lineNumber === positionB.lineNumber &&\n                    positionA.columnNumber === positionB.columnNumber &&\n                    positionA.condition === positionB.condition) === undefined) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }\n}\n\nclass Storage {\n  readonly setting: Common.Settings.Setting<BreakpointStorageState[]>;\n  readonly breakpoints: Map<string, BreakpointStorageState>;\n  #muted: boolean;\n\n  constructor() {\n    this.setting = Common.Settings.Settings.instance().createLocalSetting('breakpoints', []);\n    this.breakpoints = new Map();\n    this.#muted = false;\n    for (const breakpoint of this.setting.get()) {\n      this.breakpoints.set(Storage.computeId(breakpoint), breakpoint);\n    }\n  }\n\n  mute(): void {\n    this.#muted = true;\n  }\n\n  unmute(): void {\n    this.#muted = false;\n  }\n\n  breakpointItems(url: Platform.DevToolsPath.UrlString, resourceTypeName?: string): BreakpointStorageState[] {\n    const breakpoints = [];\n    for (const breakpoint of this.breakpoints.values()) {\n      if (breakpoint.url !== url) {\n        continue;\n      }\n      if (breakpoint.resourceTypeName !== resourceTypeName && resourceTypeName !== undefined) {\n        continue;\n      }\n      breakpoints.push(breakpoint);\n    }\n    return breakpoints;\n  }\n\n  updateBreakpoint(storageState: BreakpointStorageState): void {\n    if (this.#muted) {\n      return;\n    }\n    const storageId = Storage.computeId(storageState);\n    if (!storageId) {\n      return;\n    }\n    // Delete the breakpoint and re-insert it so that it is moved to the last position in the iteration order.\n    this.breakpoints.delete(storageId);\n    this.breakpoints.set(storageId, storageState);\n    this.save();\n  }\n\n  removeBreakpoint(storageId: string): void {\n    if (this.#muted) {\n      return;\n    }\n    this.breakpoints.delete(storageId);\n    this.save();\n  }\n\n  private save(): void {\n    this.setting.set(Array.from(this.breakpoints.values()));\n  }\n\n  static computeId({url, resourceTypeName, lineNumber, columnNumber}: BreakpointStorageState): string {\n    if (!url) {\n      return '';\n    }\n    let id = `${url}:${resourceTypeName}:${lineNumber}`;\n    if (columnNumber !== undefined) {\n      id += `:${columnNumber}`;\n    }\n    return id;\n  }\n}\n\nfunction resolvedStateEqual(\n    lhs: ScriptBreakpointLocation[]|undefined, rhs: ScriptBreakpointLocation[]|undefined): boolean {\n  if (lhs === rhs) {\n    return true;\n  }\n  if (!lhs || !rhs || lhs.length !== rhs.length) {\n    return false;\n  }\n  for (let i = 0; i < lhs.length; i++) {\n    const lhsLoc = lhs[i];\n    const rhsLoc = rhs[i];\n    if (lhsLoc.url !== rhsLoc.url || lhsLoc.lineNumber !== rhsLoc.lineNumber ||\n        lhsLoc.columnNumber !== rhsLoc.columnNumber || lhsLoc.condition !== rhsLoc.condition) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * A breakpoint condition as entered by the user. We use the type to\n * distinguish from {@link SDK.DebuggerModel.BackendCondition}.\n */\nexport type UserCondition = Platform.Brand.Brand<string, 'UserCondition'>;\nexport const EMPTY_BREAKPOINT_CONDITION = '' as UserCondition;\nexport const NEVER_PAUSE_HERE_CONDITION = 'false' as UserCondition;\n\nexport interface ScriptBreakpointLocation {\n  readonly url: Platform.DevToolsPath.UrlString;\n  readonly lineNumber: number;\n  readonly columnNumber?: number;\n  readonly condition: SDK.DebuggerModel.BackendCondition;\n}\n\n/**\n * All the data for a single `Breakpoint` thats stored in the settings.\n * Whenever any of these change, we need to update the settings.\n */\nexport interface BreakpointStorageState {\n  readonly url: Platform.DevToolsPath.UrlString;\n  readonly resourceTypeName: string;\n  readonly lineNumber: number;\n  readonly columnNumber?: number;\n  readonly condition: UserCondition;\n  readonly enabled: boolean;\n  readonly isLogpoint: boolean;\n  readonly resolvedState?: ScriptBreakpointLocation[];\n}\n\nexport class BreakpointLocation {\n  readonly breakpoint: Breakpoint;\n  readonly uiLocation: Workspace.UISourceCode.UILocation;\n\n  constructor(breakpoint: Breakpoint, uiLocation: Workspace.UISourceCode.UILocation) {\n    this.breakpoint = breakpoint;\n    this.uiLocation = uiLocation;\n  }\n}\n\nconst LOGPOINT_PREFIX = '/** DEVTOOLS_LOGPOINT */ console.log(';\nconst LOGPOINT_SUFFIX = ')';\n"],
  "mappings": "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",
  "names": ["uiSourceCode", "Events", "condition", "locations", "Breakpoint", "State"]
}
