{
  "version": 3,
  "sources": ["../../../../../../front_end/models/live-metrics/LiveMetrics.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport * as Host from '../../core/host/host.js';\nimport * as i18n from '../../core/i18n/i18n.js';\nimport * as Platform from '../../core/platform/platform.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport type * as Protocol from '../../generated/protocol.js';\nimport * as EmulationModel from '../../models/emulation/emulation.js';\n\nimport * as Spec from './web-vitals-injected/spec/spec.js';\n\nconst UIStrings = {\n  /**\n   * @description Warning text indicating that the Largest Contentful Paint (LCP) performance metric was affected by the user changing the simulated device.\n   */\n  lcpEmulationWarning:\n      'Simulating a new device after the page loads can affect LCP. Reload the page after simulating a new device for accurate LCP data.',\n  /**\n   * @description Warning text indicating that the Largest Contentful Paint (LCP) performance metric was affected by the page loading in the background.\n   */\n  lcpVisibilityWarning: 'LCP value may be inflated because the page started loading in the background.',\n} as const;\n\nconst str_ = i18n.i18n.registerUIStrings('models/live-metrics/LiveMetrics.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\nconst LIVE_METRICS_WORLD_NAME = 'DevTools Performance Metrics';\n\nlet liveMetricsInstance: LiveMetrics;\n\nclass InjectedScript {\n  static #injectedScript?: string;\n  static async get(): Promise<string> {\n    if (!this.#injectedScript) {\n      const url = new URL('./web-vitals-injected/web-vitals-injected.generated.js', import.meta.url);\n      const result = await fetch(url);\n      this.#injectedScript = await result.text();\n    }\n    return this.#injectedScript;\n  }\n}\n\nexport type InteractionMap = Map<InteractionId, Interaction>;\n\nexport class LiveMetrics extends Common.ObjectWrapper.ObjectWrapper<EventTypes> implements SDK.TargetManager.Observer {\n  #enabled = false;\n  #target?: SDK.Target.Target;\n  #scriptIdentifier?: Protocol.Page.ScriptIdentifier;\n  #lastResetContextId?: Protocol.Runtime.ExecutionContextId;\n  #lcpValue?: LcpValue;\n  #clsValue?: ClsValue;\n  #inpValue?: InpValue;\n  #interactions: InteractionMap = new Map();\n  #interactionsByGroupId = new Map<Spec.InteractionEntryGroupId, Interaction[]>();\n  #layoutShifts: LayoutShift[] = [];\n  #lastEmulationChangeTime?: number;\n  #mutex = new Common.Mutex.Mutex();\n  #deviceModeModel = EmulationModel.DeviceModeModel.DeviceModeModel.tryInstance();\n\n  private constructor() {\n    super();\n    SDK.TargetManager.TargetManager.instance().observeTargets(this);\n  }\n\n  static instance(opts: {forceNew?: boolean} = {forceNew: false}): LiveMetrics {\n    const {forceNew} = opts;\n    if (!liveMetricsInstance || forceNew) {\n      liveMetricsInstance = new LiveMetrics();\n    }\n\n    return liveMetricsInstance;\n  }\n\n  get lcpValue(): LcpValue|undefined {\n    return this.#lcpValue;\n  }\n\n  get clsValue(): ClsValue|undefined {\n    return this.#clsValue;\n  }\n\n  get inpValue(): InpValue|undefined {\n    return this.#inpValue;\n  }\n\n  get interactions(): InteractionMap {\n    return this.#interactions;\n  }\n\n  get layoutShifts(): LayoutShift[] {\n    return this.#layoutShifts;\n  }\n\n  /**\n   * Will create a log message describing the interaction's LoAF scripts.\n   * Returns true if the message is successfully logged.\n   */\n  async logInteractionScripts(interaction: Interaction): Promise<boolean> {\n    if (!this.#target) {\n      return false;\n    }\n\n    const executionContextId = this.#lastResetContextId;\n    if (!executionContextId) {\n      return false;\n    }\n\n    const scriptsTable = [];\n    for (const loaf of interaction.longAnimationFrameTimings) {\n      for (const script of loaf.scripts) {\n        const scriptEndTime = script.startTime + script.duration;\n        if (scriptEndTime < interaction.startTime) {\n          continue;\n        }\n\n        const blockingDuration = Math.round(scriptEndTime - Math.max(interaction.startTime, script.startTime));\n\n        // TODO: Use translated strings for the table\n        scriptsTable.push({\n          'Blocking duration': blockingDuration,\n          'Invoker type': script.invokerType || null,\n          Invoker: script.invoker || null,\n          Function: script.sourceFunctionName || null,\n          Source: script.sourceURL || null,\n          'Char position': script.sourceCharPosition || null,\n        });\n      }\n    }\n\n    try {\n      const scriptsLimit = Spec.LOAF_LIMIT * Spec.SCRIPTS_PER_LOAF_LIMIT;\n      const scriptLimitText = scriptsTable.length === scriptsLimit ? ` (limited to ${scriptsLimit})` : '';\n      const loafLimitText = interaction.longAnimationFrameTimings.length === Spec.LOAF_LIMIT ?\n          ` (limited to last ${Spec.LOAF_LIMIT})` :\n          '';\n      await this.#target.runtimeAgent().invoke_evaluate({\n        expression: `\n          console.group('[DevTools] Long animation frames for ${interaction.duration}ms ${\n            interaction.interactionType} interaction');\n          console.log('Scripts${scriptLimitText}:');\n          console.table(${JSON.stringify(scriptsTable)});\n          console.log('Intersecting long animation frame events${loafLimitText}:', ${\n            JSON.stringify(interaction.longAnimationFrameTimings)});\n          console.groupEnd();\n        `,\n        contextId: executionContextId,\n      });\n    } catch {\n      return false;\n    }\n\n    return true;\n  }\n\n  #onEmulationChanged(): void {\n    this.#lastEmulationChangeTime = Date.now();\n  }\n\n  /**\n   * DOM nodes can't be sent over a runtime binding, so we have to retrieve\n   * them separately.\n   */\n  async #resolveNodeRef(index: number, executionContextId: Protocol.Runtime.ExecutionContextId):\n      Promise<SDK.DOMModel.DOMNode|null> {\n    if (!this.#target) {\n      return null;\n    }\n\n    const runtimeModel = this.#target.model(SDK.RuntimeModel.RuntimeModel);\n    if (!runtimeModel) {\n      return null;\n    }\n\n    const domModel = this.#target.model(SDK.DOMModel.DOMModel);\n    if (!domModel) {\n      return null;\n    }\n\n    const {result} = await this.#target.runtimeAgent().invoke_evaluate({\n      expression: `window.getNodeForIndex(${index})`,\n      contextId: executionContextId,\n    });\n\n    if (!result) {\n      return null;\n    }\n\n    let remoteObject;\n    try {\n      remoteObject = runtimeModel.createRemoteObject(result);\n      const node = await domModel.pushObjectAsNodeToFrontend(remoteObject);\n      if (!node) {\n        return null;\n      }\n\n      return node;\n    } catch {\n      return null;\n    } finally {\n      remoteObject?.release();\n    }\n  }\n\n  #sendStatusUpdate(): void {\n    this.dispatchEventToListeners(Events.STATUS, {\n      lcp: this.#lcpValue,\n      cls: this.#clsValue,\n      inp: this.#inpValue,\n      interactions: this.#interactions,\n      layoutShifts: this.#layoutShifts,\n    });\n  }\n\n  setStatusForTesting(status: StatusEvent): void {\n    this.#lcpValue = status.lcp;\n    this.#clsValue = status.cls;\n    this.#inpValue = status.inp;\n    this.#interactions = status.interactions;\n    this.#layoutShifts = status.layoutShifts;\n    this.#sendStatusUpdate();\n  }\n\n  /**\n   * If there is a document update then any node handles we have already resolved will be invalid.\n   * This function should re-resolve any relevant DOM nodes after a document update.\n   */\n  async #onDocumentUpdate(event: Common.EventTarget.EventTargetEvent<SDK.DOMModel.DOMModel>): Promise<void> {\n    const domModel = event.data;\n\n    const toRefresh = [\n      this.#lcpValue?.nodeRef,\n      ...this.#interactions.values().map(i => i.nodeRef),\n      ...this.#layoutShifts.flatMap(shift => shift.affectedNodeRefs),\n    ].filter(nodeRef => !!nodeRef);\n\n    const idsToRefresh = new Set(toRefresh.map(nodeRef => nodeRef.backendNodeId()));\n    const nodes = await domModel.pushNodesByBackendIdsToFrontend(idsToRefresh);\n    if (!nodes) {\n      return;\n    }\n\n    for (let i = 0; i < toRefresh.length; i++) {\n      const refreshedNode = nodes.get(toRefresh[i].backendNodeId());\n\n      // It is possible for the refreshed node to be undefined even though it was defined previously.\n      // We should keep the affected nodes consistent from the user perspective, so we will just keep the stale node instead of removing it.\n      if (!refreshedNode) {\n        continue;\n      }\n\n      toRefresh[i] = refreshedNode;\n    }\n\n    this.#sendStatusUpdate();\n  }\n\n  async #handleWebVitalsEvent(\n      webVitalsEvent: Spec.WebVitalsEvent, executionContextId: Protocol.Runtime.ExecutionContextId): Promise<void> {\n    switch (webVitalsEvent.name) {\n      case 'LCP': {\n        const warnings: string[] = [];\n        const lcpEvent: LcpValue = {\n          value: webVitalsEvent.value,\n          phases: webVitalsEvent.phases,\n          warnings,\n        };\n        if (webVitalsEvent.nodeIndex !== undefined) {\n          const nodeRef = await this.#resolveNodeRef(webVitalsEvent.nodeIndex, executionContextId);\n          if (nodeRef) {\n            lcpEvent.nodeRef = nodeRef;\n          }\n        }\n\n        if (this.#lastEmulationChangeTime && Date.now() - this.#lastEmulationChangeTime < 500) {\n          warnings.push(i18nString(UIStrings.lcpEmulationWarning));\n        }\n\n        if (webVitalsEvent.startedHidden) {\n          warnings.push(i18nString(UIStrings.lcpVisibilityWarning));\n        }\n\n        this.#lcpValue = lcpEvent;\n        break;\n      }\n      case 'CLS': {\n        const event: ClsValue = {\n          value: webVitalsEvent.value,\n          clusterShiftIds: webVitalsEvent.clusterShiftIds,\n        };\n        this.#clsValue = event;\n        break;\n      }\n      case 'INP': {\n        const inpEvent: InpValue = {\n          value: webVitalsEvent.value,\n          phases: webVitalsEvent.phases,\n          interactionId: `interaction-${webVitalsEvent.entryGroupId}-${webVitalsEvent.startTime}`,\n        };\n        this.#inpValue = inpEvent;\n        break;\n      }\n      case 'InteractionEntry': {\n        const groupInteractions =\n            Platform.MapUtilities.getWithDefault(this.#interactionsByGroupId, webVitalsEvent.entryGroupId, () => []);\n\n        // `nextPaintTime` uses the event duration which is rounded to the nearest 8ms. The best we can do\n        // is check if the `nextPaintTime`s are within 8ms.\n        // https://developer.mozilla.org/en-US/docs/Web/API/PerformanceEntry/duration#event\n        let interaction = groupInteractions.find(\n            interaction => Math.abs(interaction.nextPaintTime - webVitalsEvent.nextPaintTime) < 8);\n\n        if (!interaction) {\n          interaction = {\n            interactionId: `interaction-${webVitalsEvent.entryGroupId}-${webVitalsEvent.startTime}`,\n            interactionType: webVitalsEvent.interactionType,\n            duration: webVitalsEvent.duration,\n            eventNames: [],\n            phases: webVitalsEvent.phases,\n            startTime: webVitalsEvent.startTime,\n            nextPaintTime: webVitalsEvent.nextPaintTime,\n            longAnimationFrameTimings: webVitalsEvent.longAnimationFrameEntries,\n          };\n\n          groupInteractions.push(interaction);\n          this.#interactions.set(interaction.interactionId, interaction);\n        }\n\n        // We can get multiple instances of the first input interaction since web-vitals.js installs\n        // an extra listener for events of type `first-input`. This is a simple way to de-dupe those\n        // events without adding complexity to the injected code.\n        if (!interaction.eventNames.includes(webVitalsEvent.eventName)) {\n          interaction.eventNames.push(webVitalsEvent.eventName);\n        }\n\n        if (webVitalsEvent.nodeIndex !== undefined) {\n          const node = await this.#resolveNodeRef(webVitalsEvent.nodeIndex, executionContextId);\n          if (node) {\n            interaction.nodeRef = node;\n          }\n        }\n        break;\n      }\n      case 'LayoutShift': {\n        const nodePromises = webVitalsEvent.affectedNodeIndices.map(nodeIndex => {\n          return this.#resolveNodeRef(nodeIndex, executionContextId);\n        });\n\n        const affectedNodes = (await Promise.all(nodePromises)).filter(nodeRef => !!nodeRef);\n\n        const layoutShift: LayoutShift = {\n          score: webVitalsEvent.score,\n          uniqueLayoutShiftId: webVitalsEvent.uniqueLayoutShiftId,\n          affectedNodeRefs: affectedNodes,\n        };\n        this.#layoutShifts.push(layoutShift);\n        break;\n      }\n      case 'reset': {\n        this.#lcpValue = undefined;\n        this.#clsValue = undefined;\n        this.#inpValue = undefined;\n        this.#interactions.clear();\n        this.#layoutShifts = [];\n        break;\n      }\n    }\n\n    this.#sendStatusUpdate();\n  }\n\n  async #getFrameForExecutionContextId(executionContextId: Protocol.Runtime.ExecutionContextId):\n      Promise<SDK.ResourceTreeModel.ResourceTreeFrame|null> {\n    if (!this.#target) {\n      return null;\n    }\n\n    const runtimeModel = this.#target.model(SDK.RuntimeModel.RuntimeModel);\n    if (!runtimeModel) {\n      return null;\n    }\n\n    const executionContext = runtimeModel.executionContext(executionContextId);\n    if (!executionContext) {\n      return null;\n    }\n\n    const frameId = executionContext.frameId;\n    if (!frameId) {\n      return null;\n    }\n\n    const frameManager = SDK.FrameManager.FrameManager.instance();\n    return await frameManager.getOrWaitForFrame(frameId);\n  }\n\n  async #onBindingCalled(event: {data: Protocol.Runtime.BindingCalledEvent}): Promise<void> {\n    const {data} = event;\n    if (data.name !== Spec.EVENT_BINDING_NAME) {\n      return;\n    }\n\n    // Async tasks can be performed while handling an event (e.g. resolving DOM node)\n    // Use a mutex here to ensure the events are handled in the order they are received.\n    await this.#mutex.run(async () => {\n      const webVitalsEvent = JSON.parse(data.payload) as Spec.WebVitalsEvent;\n\n      // This ensures that `#lastResetContextId` will always be an execution context on the\n      // primary frame. If we receive events from this execution context then we automatically\n      // know that they are for the primary frame.\n      if (this.#lastResetContextId !== data.executionContextId) {\n        if (webVitalsEvent.name !== 'reset') {\n          return;\n        }\n\n        // We should avoid calling this function for every event.\n        // If an interaction triggers a pre-rendered navigation then the old primary frame could\n        // be removed before we reach this point, and then it will hang forever.\n        const frame = await this.#getFrameForExecutionContextId(data.executionContextId);\n        if (!frame?.isPrimaryFrame()) {\n          return;\n        }\n\n        this.#lastResetContextId = data.executionContextId;\n      }\n\n      await this.#handleWebVitalsEvent(webVitalsEvent, data.executionContextId);\n    });\n  }\n\n  async #killAllLiveMetricContexts(): Promise<void> {\n    const target = this.#target;\n    if (!target) {\n      return;\n    }\n\n    const runtimeModel = target.model(SDK.RuntimeModel.RuntimeModel);\n    if (!runtimeModel) {\n      return;\n    }\n\n    const killPromises = runtimeModel.executionContexts()\n                             .filter(e => e.name === LIVE_METRICS_WORLD_NAME && !e.isDefault)\n                             .map(e => target.runtimeAgent().invoke_evaluate({\n                               // On the off chance something else creates execution contexts with the exact same name\n                               // this expression should just be a noop.\n                               expression: `window?.${Spec.INTERNAL_KILL_SWITCH}?.()`,\n                               contextId: e.id,\n                             }));\n\n    await Promise.all(killPromises);\n  }\n\n  clearInteractions(): void {\n    this.#interactions.clear();\n    this.#sendStatusUpdate();\n  }\n\n  clearLayoutShifts(): void {\n    this.#layoutShifts = [];\n    this.#sendStatusUpdate();\n  }\n\n  async targetAdded(target: SDK.Target.Target): Promise<void> {\n    if (target !== SDK.TargetManager.TargetManager.instance().primaryPageTarget()) {\n      return;\n    }\n    this.#target = target;\n    await this.enable();\n  }\n\n  async targetRemoved(target: SDK.Target.Target): Promise<void> {\n    if (target !== this.#target) {\n      return;\n    }\n    await this.disable();\n    this.#target = undefined;\n\n    // If the user navigates to a page that was pre-rendered then the primary page target\n    // will be swapped and the old target will be removed. We should ensure live metrics\n    // remain enabled on the new primary page target.\n    const primaryPageTarget = SDK.TargetManager.TargetManager.instance().primaryPageTarget();\n    if (primaryPageTarget) {\n      this.#target = primaryPageTarget;\n      await this.enable();\n    }\n  }\n\n  async enable(): Promise<void> {\n    if (Host.InspectorFrontendHost.isUnderTest()) {\n      // Enabling this impacts a lot of layout tests; we will work on fixing\n      // them but for now it is easier to not run this page in layout tests.\n      // b/360064852\n      return;\n    }\n\n    if (!this.#target || this.#enabled) {\n      return;\n    }\n\n    // Only frame targets will actually give us CWV\n    if (this.#target.type() !== SDK.Target.Type.FRAME) {\n      return;\n    }\n\n    const domModel = this.#target.model(SDK.DOMModel.DOMModel);\n    if (!domModel) {\n      return;\n    }\n\n    domModel.addEventListener(SDK.DOMModel.Events.DocumentUpdated, this.#onDocumentUpdate, this);\n\n    const runtimeModel = this.#target.model(SDK.RuntimeModel.RuntimeModel);\n    if (!runtimeModel) {\n      return;\n    }\n\n    runtimeModel.addEventListener(SDK.RuntimeModel.Events.BindingCalled, this.#onBindingCalled, this);\n\n    await runtimeModel.addBinding({\n      name: Spec.EVENT_BINDING_NAME,\n      executionContextName: LIVE_METRICS_WORLD_NAME,\n    });\n\n    // If DevTools is closed and reopened, the live metrics context from the previous\n    // session will persist. We should ensure any old live metrics contexts are killed\n    // before starting a new one.\n    await this.#killAllLiveMetricContexts();\n\n    const source = await InjectedScript.get();\n\n    // Extra check in case the target was removed while we were initializing.\n    // It's possible to be halfway-through enabling when the target is removed\n    // eg try loading 'devtools://devtools/bundled/devtools_app.html?ws=127.0.0.1:99/blah'\n    if (!this.#target) {\n      return;\n    }\n    const {identifier} = await this.#target?.pageAgent().invoke_addScriptToEvaluateOnNewDocument({\n      source,\n      worldName: LIVE_METRICS_WORLD_NAME,\n      runImmediately: true,\n    });\n    this.#scriptIdentifier = identifier;\n\n    this.#deviceModeModel?.addEventListener(\n        EmulationModel.DeviceModeModel.Events.UPDATED, this.#onEmulationChanged, this);\n\n    this.#enabled = true;\n  }\n\n  async disable(): Promise<void> {\n    if (!this.#target || !this.#enabled) {\n      return;\n    }\n\n    await this.#killAllLiveMetricContexts();\n\n    const runtimeModel = this.#target.model(SDK.RuntimeModel.RuntimeModel);\n    if (runtimeModel) {\n      await runtimeModel.removeBinding({\n        name: Spec.EVENT_BINDING_NAME,\n      });\n\n      runtimeModel.removeEventListener(SDK.RuntimeModel.Events.BindingCalled, this.#onBindingCalled, this);\n    }\n\n    const domModel = this.#target.model(SDK.DOMModel.DOMModel);\n    if (domModel) {\n      domModel.removeEventListener(SDK.DOMModel.Events.DocumentUpdated, this.#onDocumentUpdate, this);\n    }\n\n    if (this.#scriptIdentifier) {\n      await this.#target.pageAgent().invoke_removeScriptToEvaluateOnNewDocument({\n        identifier: this.#scriptIdentifier,\n      });\n    }\n    this.#scriptIdentifier = undefined;\n\n    this.#deviceModeModel?.removeEventListener(\n        EmulationModel.DeviceModeModel.Events.UPDATED, this.#onEmulationChanged, this);\n\n    this.#enabled = false;\n  }\n}\n\nexport const enum Events {\n  STATUS = 'status',\n}\n\nexport type InteractionId = `interaction-${number}-${number}`;\n\nexport interface MetricValue {\n  value: number;\n  warnings?: string[];\n}\n\nexport interface LcpValue extends MetricValue {\n  phases: Spec.LcpPhases;\n  nodeRef?: SDK.DOMModel.DOMNode;\n}\n\nexport interface InpValue extends MetricValue {\n  phases: Spec.InpPhases;\n  interactionId: InteractionId;\n}\n\nexport interface ClsValue extends MetricValue {\n  clusterShiftIds: Spec.UniqueLayoutShiftId[];\n}\n\nexport interface LayoutShift {\n  score: number;\n  uniqueLayoutShiftId: Spec.UniqueLayoutShiftId;\n  affectedNodeRefs: SDK.DOMModel.DOMNode[];\n}\n\nexport interface Interaction {\n  interactionId: InteractionId;\n  interactionType: Spec.InteractionEntryEvent['interactionType'];\n  eventNames: string[];\n  duration: number;\n  startTime: number;\n  nextPaintTime: number;\n  phases: Spec.InpPhases;\n  longAnimationFrameTimings: Spec.PerformanceLongAnimationFrameTimingJSON[];\n  nodeRef?: SDK.DOMModel.DOMNode;\n}\n\nexport interface StatusEvent {\n  lcp?: LcpValue;\n  cls?: ClsValue;\n  inp?: InpValue;\n  interactions: InteractionMap;\n  layoutShifts: LayoutShift[];\n}\n\ninterface EventTypes {\n  [Events.STATUS]: StatusEvent;\n}\n"],
  "mappings": "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",
  "names": ["interaction"]
}
