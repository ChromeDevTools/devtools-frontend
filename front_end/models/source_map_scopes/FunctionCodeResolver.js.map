{"version":3,"file":"FunctionCodeResolver.js","sourceRoot":"","sources":["../../../../../../front_end/models/source_map_scopes/FunctionCodeResolver.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2025 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Platform from '../../core/platform/platform.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport * as Bindings from '../bindings/bindings.js';\nimport * as Formatter from '../formatter/formatter.js';\nimport * as TextUtils from '../text_utils/text_utils.js';\nimport * as Workspace from '../workspace/workspace.js';\n\n/** Represents the source code for a given function, including additional context of surrounding lines. */\nexport interface FunctionCode {\n  functionBounds: Workspace.UISourceCode.UIFunctionBounds;\n  /** The text of `uiSourceCode`. */\n  text: TextUtils.Text.Text;\n  /** The function text. */\n  code: string;\n  /** The range of `code` within `text`. */\n  range: TextUtils.TextRange.TextRange;\n  /** The function text, plus some additional context before and after. The actual function is wrapped in <FUNCTION_START>...<FUNCTION_END> */\n  codeWithContext: string;\n  /** The range of `codeWithContext` within `text`. */\n  rangeWithContext: TextUtils.TextRange.TextRange;\n}\n\nexport interface CreateFunctionCodeOptions {\n  /** Number of characters to include before and after the function. Stacks with `contextLineLength`. */\n  contextLength?: number;\n  /** Number of lines to include before and after the function. Stacks with `contextLength`. */\n  contextLineLength?: number;\n  /** If true, appends profile data from the trace at the end of every line of the function in `codeWithContext`. This should match what is seen in the formatted view in the Sources panel. */\n  appendProfileData?: boolean;\n}\n\ninterface InputData {\n  text: TextUtils.Text.Text;\n  formattedContent: Formatter.ScriptFormatter.FormattedContent|null;\n  performanceData: Workspace.UISourceCode.LineColumnProfileMap|undefined;\n}\n\nconst inputCache = new WeakMap<Workspace.UISourceCode.UISourceCode, Promise<InputData>>();\n\nasync function prepareInput(uiSourceCode: Workspace.UISourceCode.UISourceCode, content: string): Promise<InputData> {\n  const formattedContent = await format(uiSourceCode, content);\n  const text = new TextUtils.Text.Text(formattedContent ? formattedContent.formattedContent : content);\n  let performanceData = uiSourceCode.getDecorationData(Workspace.UISourceCode.DecoratorType.PERFORMANCE) as\n          Workspace.UISourceCode.LineColumnProfileMap |\n      undefined;\n\n  // Map profile data to the formatted view of the text.\n  if (formattedContent && performanceData) {\n    performanceData = Workspace.UISourceCode.createMappedProfileData(performanceData, (line, column) => {\n      return formattedContent.formattedMapping.originalToFormatted(line, column);\n    });\n  }\n\n  return {text, formattedContent, performanceData};\n}\n\n/** Formatting and parsing line endings for Text is expensive, so cache it. */\nasync function prepareInputAndCache(\n    uiSourceCode: Workspace.UISourceCode.UISourceCode, content: string): Promise<InputData> {\n  let cachedPromise = inputCache.get(uiSourceCode);\n  if (cachedPromise) {\n    return await cachedPromise;\n  }\n\n  cachedPromise = prepareInput(uiSourceCode, content);\n  inputCache.set(uiSourceCode, cachedPromise);\n  return await cachedPromise;\n}\n\nfunction extractPerformanceDataByLine(\n    textRange: TextUtils.TextRange.TextRange, performanceData: Workspace.UISourceCode.LineColumnProfileMap): number[] {\n  const {startLine, startColumn, endLine, endColumn} = textRange;\n  const byLine = new Array(endLine - startLine + 1).fill(0);\n\n  for (let line = startLine; line <= endLine; line++) {\n    const lineData = performanceData.get(line + 1);\n    if (!lineData) {\n      continue;\n    }\n\n    // Fast-path for when the entire line's data is relevant.\n    if (line !== startLine && line !== endLine) {\n      byLine[line - startLine] = lineData.values().reduce((acc, cur) => acc + cur);\n      continue;\n    }\n\n    const column0 = line === startLine ? startColumn + 1 : 0;\n    const column1 = line === endLine ? endColumn + 1 : Number.POSITIVE_INFINITY;\n\n    let totalData = 0;\n    for (const [column, data] of lineData) {\n      if (column >= column0 && column <= column1) {\n        totalData += data;\n      }\n    }\n\n    byLine[line - startLine] = totalData;\n  }\n\n  return byLine.map(data => Math.round(data * 10) / 10);\n}\n\nfunction createFunctionCode(\n    inputData: InputData, functionBounds: Workspace.UISourceCode.UIFunctionBounds,\n    options?: CreateFunctionCodeOptions): FunctionCode {\n  let {startLine, startColumn, endLine, endColumn} = functionBounds.range;\n  if (inputData.formattedContent) {\n    const startMapped = inputData.formattedContent.formattedMapping.originalToFormatted(startLine, startColumn);\n    startLine = startMapped[0];\n    startColumn = startMapped[1];\n\n    const endMapped = inputData.formattedContent.formattedMapping.originalToFormatted(endLine, endColumn);\n    endLine = endMapped[0];\n    endColumn = endMapped[1];\n  }\n\n  const text = inputData.text;\n  const content = text.value();\n\n  // Define two ranges - the first is just the function bounds, the second includes\n  // that plus some surrounding context as dictated by the options.\n  const range = new TextUtils.TextRange.TextRange(startLine, startColumn, endLine, endColumn);\n\n  const functionStartOffset = text.offsetFromPosition(startLine, startColumn);\n  const functionEndOffset = text.offsetFromPosition(endLine, endColumn);\n\n  let contextStartOffset = 0;\n  if (options?.contextLength !== undefined) {\n    const contextLength = options.contextLength;\n    contextStartOffset = Math.max(contextStartOffset, functionStartOffset - contextLength);\n  }\n  if (options?.contextLineLength !== undefined) {\n    const contextLineLength = options.contextLineLength;\n    const position = text.offsetFromPosition(Math.max(startLine - contextLineLength, 0), 0);\n    contextStartOffset = Math.max(contextStartOffset, position);\n  }\n\n  let contextEndOffset = content.length;\n  if (options?.contextLength !== undefined) {\n    const contextLength = options.contextLength;\n    contextEndOffset = Math.min(contextEndOffset, functionEndOffset + contextLength);\n  }\n  if (options?.contextLineLength !== undefined) {\n    const contextLineLength = options.contextLineLength;\n    const position =\n        text.offsetFromPosition(Math.min(endLine + contextLineLength, text.lineCount() - 1), Number.POSITIVE_INFINITY);\n    contextEndOffset = Math.min(contextEndOffset, position);\n  }\n\n  const contextStart = text.positionFromOffset(contextStartOffset);\n  const contextEnd = text.positionFromOffset(contextEndOffset);\n  const rangeWithContext = new TextUtils.TextRange.TextRange(\n      contextStart.lineNumber, contextStart.columnNumber, contextEnd.lineNumber, contextEnd.columnNumber);\n\n  // Grab substrings for the function range, and for the context range.\n  const code = content.substring(functionStartOffset, functionEndOffset);\n  const before = content.substring(contextStartOffset, functionStartOffset);\n  const after = content.substring(functionEndOffset, contextEndOffset);\n\n  let codeWithContext;\n  if (options?.appendProfileData && inputData.performanceData) {\n    const performanceDataByLine = extractPerformanceDataByLine(range, inputData.performanceData);\n    const lines = performanceDataByLine.map((data, i) => {\n      let line = text.lineAt(startLine + i);\n\n      const isLastLine = i === performanceDataByLine.length - 1;\n      if (i === 0) {\n        if (isLastLine) {\n          line = line.substring(startColumn, endColumn);\n        } else {\n          line = line.substring(startColumn);\n        }\n      } else if (isLastLine) {\n        line = line.substring(0, endColumn);\n      }\n\n      if (isLastLine) {\n        // Don't ever annotate the last line - it could make the rest of the code on\n        // that line get commented out.\n        data = 0;\n      }\n\n      return data ? `${line} // ${data} ms` : line;\n    });\n    const annotatedCode = lines.join('\\n');\n    codeWithContext = before + `<FUNCTION_START>${annotatedCode}<FUNCTION_END>` + after;\n  } else {\n    codeWithContext = before + `<FUNCTION_START>${code}<FUNCTION_END>` + after;\n  }\n\n  return {\n    functionBounds,\n    text,\n    code,\n    range,\n    codeWithContext,\n    rangeWithContext,\n  };\n}\n\n/**\n * The input location may be a source mapped location or a raw location.\n */\nexport async function getFunctionCodeFromLocation(\n    target: SDK.Target.Target, url: Platform.DevToolsPath.UrlString, line: number, column: number,\n    options?: CreateFunctionCodeOptions): Promise<FunctionCode|null> {\n  const debuggerModel = target.model(SDK.DebuggerModel.DebuggerModel);\n  if (!debuggerModel) {\n    throw new Error('missing debugger model');\n  }\n\n  let uiSourceCode;\n  const debuggerWorkspaceBinding = Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding.instance();\n  const projects = debuggerWorkspaceBinding.workspace.projectsForType(Workspace.Workspace.projectTypes.Network);\n  for (const project of projects) {\n    uiSourceCode = project.uiSourceCodeForURL(url);\n    if (uiSourceCode) {\n      break;\n    }\n  }\n\n  if (!uiSourceCode) {\n    return null;\n  }\n\n  const rawLocations = await debuggerWorkspaceBinding.uiLocationToRawLocations(uiSourceCode, line, column);\n  const rawLocation = rawLocations.at(-1);\n  if (!rawLocation) {\n    return null;\n  }\n\n  return await getFunctionCodeFromRawLocation(rawLocation, options);\n}\n\nasync function format(uiSourceCode: Workspace.UISourceCode.UISourceCode, content: string):\n    Promise<Formatter.ScriptFormatter.FormattedContent|null> {\n  const contentType = uiSourceCode.contentType();\n  const shouldFormat = !contentType.isFromSourceMap() && (contentType.isDocument() || contentType.isScript()) &&\n      TextUtils.TextUtils.isMinified(content);\n  if (!shouldFormat) {\n    return null;\n  }\n\n  return await Formatter.ScriptFormatter.formatScriptContent(contentType.canonicalMimeType(), content, '\\t');\n}\n\n/**\n * Returns a {@link FunctionCode} for the given raw location.\n */\nexport async function getFunctionCodeFromRawLocation(\n    rawLocation: SDK.DebuggerModel.Location, options?: CreateFunctionCodeOptions): Promise<FunctionCode|null> {\n  const debuggerWorkspaceBinding = Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding.instance();\n  const functionBounds = await debuggerWorkspaceBinding.functionBoundsAtRawLocation(rawLocation);\n  if (!functionBounds) {\n    return null;\n  }\n\n  await functionBounds.uiSourceCode.requestContentData();\n  const content = functionBounds.uiSourceCode.content();\n  if (!content) {\n    return null;\n  }\n\n  const inputData = await prepareInputAndCache(functionBounds.uiSourceCode, content);\n  return createFunctionCode(inputData, functionBounds, options);\n}\n"]}