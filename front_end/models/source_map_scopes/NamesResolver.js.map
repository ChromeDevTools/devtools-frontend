{"version":3,"file":"NamesResolver.js","sourceRoot":"","sources":["../../../../../../front_end/models/source_map_scopes/NamesResolver.ts"],"names":[],"mappings":"AAAA,sCAAsC;AACtC,yEAAyE;AACzE,6BAA6B;AAE7B,OAAO,KAAK,MAAM,MAAM,6BAA6B,CAAC;AACtD,OAAO,KAAK,IAAI,MAAM,yBAAyB,CAAC;AAChD,OAAO,KAAK,GAAG,MAAM,uBAAuB,CAAC;AAE7C,OAAO,KAAK,QAAQ,MAAM,yBAAyB,CAAC;AACpD,OAAO,KAAK,SAAS,MAAM,2BAA2B,CAAC;AACvD,OAAO,KAAK,SAAS,MAAM,6BAA6B,CAAC;AAOzD,MAAM,2BAA2B,GAAG,IAAI,OAAO,EAA+D,CAAC;AAC/G,MAAM,oBAAoB,GAAG,IAAI,OAAO,EAAyD,CAAC;AAElG,MAAM,CAAC,KAAK,UAAU,UAAU,CAAC,eAA0D;IAEzF,MAAM,WAAW,GAAG,MAAM,eAAe,CAAC,kBAAkB,EAAE,CAAC;IAC/D,IAAI,SAAS,CAAC,WAAW,CAAC,WAAW,CAAC,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,WAAW,CAAC,aAAa,EAAE,CAAC;QACzF,OAAO,IAAI,CAAC;IACd,CAAC;IACD,OAAO,WAAW,CAAC,OAAO,CAAC;AAC7B,CAAC;AAED,MAAM,OAAO,mBAAmB;IAC9B,IAAI,CAAS;IACb,SAAS,CAAoD;IAE7D,YAAY,IAAY,EAAE,YAA+D,EAAE;QACzF,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;IAC7B,CAAC;IAED,WAAW,CAAC,UAAkB,EAAE,YAAoB;QAClD,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,EAAC,UAAU,EAAE,YAAY,EAAC,CAAC,CAAC;IAClD,CAAC;CACF;AAED,MAAM,gBAAgB,GAAG,KAAK,WAAU,MAAyB;IAI/D,IAAI,CAAC,MAAM,CAAC,YAAY,EAAE,CAAC;QACzB,OAAO,IAAI,CAAC;IACd,CAAC;IAED,OAAO,MAAM,GAAG,CAAC,cAAc,CAAC,kBAAkB,CAAC,MAAM,CAAC,CAAC;AAC7D,CAAC,CAAC;AAEF;;;GAGG;AACH,MAAM,cAAc,GAAG,UACI,SAAsD,EACtD,WAAyC;IAClE,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,WAAW,CAAC,EAAE,CAAC;QACtC,OAAO,EAAE,CAAC;IACZ,CAAC;IAED,kDAAkD;IAClD,IAAI,eAAe,GAAG,SAAS,CAAC;IAChC,MAAM,UAAU,GAAG,CAAC,SAAS,CAAC,CAAC;IAC/B,OAAO,IAAI,EAAE,CAAC;QACZ,IAAI,UAAU,GAAG,KAAK,CAAC;QACvB,KAAK,MAAM,KAAK,IAAI,eAAe,CAAC,QAAQ,EAAE,CAAC;YAC7C,IAAI,QAAQ,CAAC,KAAK,EAAE,WAAW,CAAC,EAAE,CAAC;gBACjC,kEAAkE;gBAClE,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBACvB,eAAe,GAAG,KAAK,CAAC;gBACxB,UAAU,GAAG,IAAI,CAAC;gBAClB,MAAM;YACR,CAAC;YACD,oFAAoF;YACpF,6EAA6E;YAC7E,sEAAsE;YACtE,IAAI,CAAC,QAAQ,CAAC,WAAW,EAAE,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,WAAW,EAAE,KAAK,CAAC,EAAE,CAAC;gBACnE,OAAO,CAAC,KAAK,CAAC,yBAAyB,CAAC,CAAC;gBACzC,OAAO,EAAE,CAAC;YACZ,CAAC;QACH,CAAC;QACD,IAAI,CAAC,UAAU,EAAE,CAAC;YAChB,8EAA8E;YAC9E,MAAM;QACR,CAAC;IACH,CAAC;IAED,OAAO,UAAU,CAAC;IAElB,SAAS,QAAQ,CAAC,KAAmC,EAAE,SAAuC;QAC5F,OAAO,CAAC,KAAK,CAAC,KAAK,IAAI,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,IAAI,SAAS,CAAC,GAAG,CAAC,CAAC;IAC1E,CAAC;IACD,SAAS,QAAQ,CAAC,KAAmC,EAAE,KAAmC;QACxF,OAAO,CAAC,KAAK,CAAC,GAAG,IAAI,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,IAAI,KAAK,CAAC,KAAK,CAAC,CAAC;IAClE,CAAC;AACH,CAAC,CAAC;AAEF,MAAM,CAAC,KAAK,UAAU,8BAA8B,CAAC,KAAwC;IAE3F,MAAM,aAAa,GAAG,KAAK,CAAC,KAAK,EAAE,EAAE,KAAK,CAAC;IAC3C,MAAM,WAAW,GAAG,KAAK,CAAC,KAAK,EAAE,EAAE,GAAG,CAAC;IACvC,IAAI,CAAC,aAAa,IAAI,CAAC,WAAW,EAAE,CAAC;QACnC,OAAO,EAAE,CAAC;IACZ,CAAC;IAED,MAAM,MAAM,GAAG,aAAa,CAAC,MAAM,EAAE,CAAC;IACtC,IAAI,CAAC,MAAM,EAAE,CAAC;QACZ,OAAO,EAAE,CAAC;IACZ,CAAC;IAED,MAAM,gBAAgB,GAAG,MAAM,gBAAgB,CAAC,MAAM,CAAC,CAAC;IACxD,IAAI,CAAC,gBAAgB,EAAE,CAAC;QACtB,OAAO,EAAE,CAAC;IACZ,CAAC;IACD,MAAM,EAAC,SAAS,EAAE,IAAI,EAAC,GAAG,gBAAgB,CAAC;IAE3C,6DAA6D;IAC7D,MAAM,YAAY,GAAG;QACnB,KAAK,EAAE,IAAI,CAAC,kBAAkB,CAAC,aAAa,CAAC,UAAU,EAAE,aAAa,CAAC,YAAY,CAAC;QACpF,GAAG,EAAE,IAAI,CAAC,kBAAkB,CAAC,WAAW,CAAC,UAAU,EAAE,WAAW,CAAC,YAAY,CAAC;KAC/E,CAAC;IAEF,OAAO,cAAc,CAAC,SAAS,EAAE,YAAY,CAAC,CAAC;AACjD,CAAC;AAED,MAAM,CAAC,MAAM,gBAAgB,GAAG,KAAK,WACjC,MAAyB,EAAE,KAAkD,EAC7E,cAA6D;IAI/D,MAAM,IAAI,GAAG,MAAM,UAAU,CAAC,MAAM,CAAC,CAAC;IACtC,IAAI,CAAC,IAAI,EAAE,CAAC;QACV,OAAO,IAAI,CAAC;IACd,CAAC;IAED,iEAAiE;IACjE,MAAM,cAAc,GAAG,EAAE,CAAC;IAC1B,MAAM,MAAM,GAAG,IAAI,SAAS,CAAC,UAAU,CAAC,UAAU,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,CAAC;IACvE,KAAK,MAAM,QAAQ,IAAI,KAAK,CAAC,SAAS,EAAE,CAAC;QACvC,iGAAiG;QACjG,oBAAoB;QACpB,IAAI,QAAQ,CAAC,IAAI,+DAAuD,IAAI,QAAQ,CAAC,OAAO,CAAC,MAAM,IAAI,CAAC,EAAE,CAAC;YACzG,SAAS;QACX,CAAC;QAED,MAAM,UAAU,GAAG,IAAI,mBAAmB,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;QAC1D,KAAK,MAAM,MAAM,IAAI,QAAQ,CAAC,OAAO,EAAE,CAAC;YACtC,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;YACvB,UAAU,CAAC,WAAW,CAAC,MAAM,CAAC,UAAU,EAAE,EAAE,MAAM,CAAC,YAAY,EAAE,CAAC,CAAC;QACrE,CAAC;QACD,cAAc,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;IAClC,CAAC;IAED,sGAAsG;IACtG,MAAM,aAAa,GAAG,EAAE,CAAC;IACzB,KAAK,MAAM,QAAQ,IAAI,cAAc,EAAE,CAAC;QACtC,KAAK,MAAM,gBAAgB,IAAI,QAAQ,CAAC,SAAS,EAAE,CAAC;YAClD,IAAI,UAAU,GAAG,IAAI,CAAC;YACtB,KAAK,MAAM,MAAM,IAAI,gBAAgB,CAAC,OAAO,EAAE,CAAC;gBAC9C,IAAI,MAAM,IAAI,KAAK,CAAC,KAAK,IAAI,MAAM,GAAG,KAAK,CAAC,GAAG,EAAE,CAAC;oBAChD,IAAI,CAAC,UAAU,EAAE,CAAC;wBAChB,UAAU,GAAG,IAAI,mBAAmB,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;oBAC9D,CAAC;oBACD,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;oBACvB,UAAU,CAAC,WAAW,CAAC,MAAM,CAAC,UAAU,EAAE,EAAE,MAAM,CAAC,YAAY,EAAE,CAAC,CAAC;gBACrE,CAAC;YACH,CAAC;YACD,IAAI,UAAU,EAAE,CAAC;gBACf,aAAa,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;YACjC,CAAC;QACH,CAAC;IACH,CAAC;IACD,OAAO,EAAC,cAAc,EAAE,aAAa,EAAC,CAAC;AACzC,CAAC,CAAC;AAEF,MAAM,8BAA8B,GAAG,gDAAgD,CAAC;AAUxF,MAAM,oBAAoB,GAAG,KAAK,EAAC,KAAwC,EACK,EAAE;IAC5E,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC,aAAa,CAAC,wBAAwB,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC;QACvF,OAAO,EAAC,eAAe,EAAE,IAAI,GAAG,EAAE,EAAE,WAAW,EAAE,IAAI,EAAC,CAAC;IACzD,CAAC;IACD,MAAM,MAAM,GAAG,KAAK,CAAC,SAAS,EAAE,CAAC,MAAM,CAAC;IACxC,MAAM,UAAU,GAAG,MAAM,8BAA8B,CAAC,KAAK,CAAC,CAAC;IAC/D,OAAO,MAAM,YAAY,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;AAChD,CAAC,CAAC;AAEN,MAAM,YAAY,GAAG,KAAK,EAAC,MAAyB,EAAE,UAAyD,EAC/B,EAAE;IAC5E,MAAM,WAAW,GAAG,UAAU,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IACtD,IAAI,CAAC,WAAW,EAAE,CAAC;QACjB,OAAO,EAAC,eAAe,EAAE,IAAI,GAAG,EAAkB,EAAE,WAAW,EAAE,IAAI,EAAC,CAAC;IACzE,CAAC;IACD,IAAI,cAAc,GAAG,2BAA2B,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;IAClE,MAAM,SAAS,GAAG,MAAM,CAAC,SAAS,EAAE,CAAC;IAErC,IAAI,CAAC,cAAc,IAAI,cAAc,CAAC,SAAS,KAAK,SAAS,EAAE,CAAC;QAC9D,MAAM,kBAAkB,GACpB,CAAC,KAAK,IAAI,EAAE;YACV,MAAM,eAAe,GAAG,IAAI,GAAG,EAAkB,CAAC;YAClD,IAAI,WAAW,GAAG,IAAI,CAAC;YAEvB,IAAI,CAAC,SAAS,EAAE,CAAC;gBACf,OAAO,EAAC,eAAe,EAAE,WAAW,EAAC,CAAC;YACxC,CAAC;YACD,yDAAyD;YACzD,kDAAkD;YAClD,MAAM,QAAQ,GAAyB,EAAE,CAAC;YAE1C,MAAM,YAAY,GAAG,CAAC,EAAuB,EAAE,OAAqC,EAAQ,EAAE;gBAC5F,0EAA0E;gBAC1E,KAAK,MAAM,QAAQ,IAAI,EAAE,CAAC,SAAS,EAAE,CAAC;oBACpC,MAAM,KAAK,GAAG,SAAS,CAAC,SAAS,CAAC,QAAQ,CAAC,UAAU,EAAE,QAAQ,CAAC,YAAY,CAAC,CAAC;oBAC9E,IAAI,KAAK,EAAE,IAAI,EAAE,CAAC;wBAChB,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;wBACpB,OAAO;oBACT,CAAC;gBACH,CAAC;gBACD,kGAAkG;gBAClG,KAAK,UAAU,eAAe;oBAC5B,IAAI,CAAC,SAAS,EAAE,CAAC;wBACf,OAAO;oBACT,CAAC;oBACD,qFAAqF;oBACrF,gFAAgF;oBAChF,iFAAiF;oBACjF,uEAAuE;oBACvE,KAAK,MAAM,QAAQ,IAAI,EAAE,CAAC,SAAS,EAAE,CAAC;wBACpC,MAAM,UAAU,GAAG,MAAM,iBAAiB,CAAC,MAAM,EAAE,SAAS,EAAE,EAAE,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;wBACjF,IAAI,UAAU,EAAE,CAAC;4BACf,OAAO,CAAC,UAAU,CAAC,CAAC;4BACpB,OAAO;wBACT,CAAC;oBACH,CAAC;gBACH,CAAC;gBACD,QAAQ,CAAC,IAAI,CAAC,eAAe,EAAE,CAAC,CAAC;YACnC,CAAC,CAAC;YAEF,MAAM,eAAe,GAAG,MAAM,gBAAgB,CAAC,MAAM,EAAE,WAAW,EAAE,UAAU,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;YAC7F,IAAI,CAAC,eAAe,EAAE,CAAC;gBACrB,OAAO,EAAC,eAAe,EAAE,WAAW,EAAC,CAAC;YACxC,CAAC;YACD,KAAK,MAAM,EAAE,IAAI,eAAe,CAAC,cAAc,EAAE,CAAC;gBAChD,YAAY,CAAC,EAAE,EAAE,UAAU,CAAC,EAAE;oBAC5B,iEAAiE;oBACjE,IAAI,UAAU,KAAK,MAAM,EAAE,CAAC;wBAC1B,eAAe,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC;oBAC3C,CAAC;gBACH,CAAC,CAAC,CAAC;YACL,CAAC;YACD,KAAK,MAAM,EAAE,IAAI,eAAe,CAAC,aAAa,EAAE,CAAC;gBAC/C,YAAY,CAAC,EAAE,EAAE,UAAU,CAAC,EAAE;oBAC5B,IAAI,UAAU,KAAK,MAAM,EAAE,CAAC;wBAC1B,WAAW,GAAG,EAAE,CAAC,IAAI,CAAC;oBACxB,CAAC;gBACH,CAAC,CAAC,CAAC;YACL,CAAC;YACD,MAAM,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,uBAAuB,EAAE,CAAC,CAAC;YAC5D,OAAO,EAAC,eAAe,EAAE,WAAW,EAAC,CAAC;QACxC,CAAC,CAAC,EAAE,CAAC;QACT,cAAc,GAAG,EAAC,SAAS,EAAE,cAAc,EAAE,kBAAkB,EAAC,CAAC;QACjE,2BAA2B,CAAC,GAAG,CAAC,WAAW,EAAE,EAAC,SAAS,EAAE,cAAc,EAAE,kBAAkB,EAAC,CAAC,CAAC;IAChG,CAAC;IACD,OAAO,MAAM,cAAc,CAAC,cAAc,CAAC;IAE3C,KAAK,UAAU,iBAAiB,CAC5B,MAAyB,EAAE,SAAkC,EAAE,IAAY,EAC3E,QAAoD;QACtD,MAAM,MAAM,GAAG,SAAS,CAAC,eAAe,CAAC,QAAQ,CAAC,UAAU,EAAE,QAAQ,CAAC,YAAY,CAAC,CAAC;QACrF,IAAI,CAAC,MAAM,EAAE,CAAC;YACZ,OAAO,IAAI,CAAC;QACd,CAAC;QACD,gFAAgF;QAChF,wCAAwC;QACxC,MAAM,YAAY,GACd,QAAQ,CAAC,wBAAwB,CAAC,wBAAwB,CAAC,QAAQ,EAAE,CAAC,iCAAiC,CACnG,MAAM,CAAC,aAAa,EAAE,MAAM,CAAC,SAAS,EAAE,MAAM,CAAC,eAAe,EAAE,CAAC,CAAC;QAC1E,IAAI,CAAC,YAAY,EAAE,CAAC;YAClB,OAAO,IAAI,CAAC;QACd,CAAC;QACD,MAAM,YAAY,GAAG,MAAM,UAAU,CAAC,MAAM,CAAC,CAAC;QAC9C,IAAI,CAAC,YAAY,EAAE,CAAC;YAClB,OAAO,IAAI,CAAC;QACd,CAAC;QACD,MAAM,aAAa,GAAG,YAAY,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QACzD,MAAM,mBAAmB,GAAG,iBAAiB,CAAC,aAAa,CAAC,CAAC;QAC7D,IAAI,CAAC,mBAAmB,EAAE,CAAC;YACzB,OAAO,IAAI,CAAC;QACd,CAAC;QACD,MAAM,EAAC,IAAI,EAAE,YAAY,EAAE,WAAW,EAAE,mBAAmB,EAAC,GAAG,mBAAmB,CAAC;QACnF,IAAI,YAAY,KAAK,IAAI,EAAE,CAAC;YAC1B,OAAO,IAAI,CAAC;QACd,CAAC;QAED,qFAAqF;QACrF,0CAA0C;QAC1C,MAAM,UAAU,GAAG,MAAM,UAAU,CAAC,YAAY,CAAC,CAAC;QAClD,IAAI,CAAC,UAAU,EAAE,CAAC;YAChB,OAAO,IAAI,CAAC;QACd,CAAC;QACD,MAAM,WAAW,GAAG,UAAU,CAAC,OAAO,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;QAC3D,MAAM,iBAAiB,GAAG,iBAAiB,CAAC,WAAW,CAAC,CAAC;QACzD,IAAI,CAAC,iBAAiB,EAAE,CAAC;YACvB,OAAO,IAAI,CAAC;QACd,CAAC;QACD,MAAM,EAAC,IAAI,EAAE,UAAU,EAAE,WAAW,EAAE,iBAAiB,EAAC,GAAG,iBAAiB,CAAC;QAC7E,oEAAoE;QACpE,IAAI,mBAAmB,KAAK,iBAAiB,EAAE,CAAC;YAC9C,OAAO,UAAU,CAAC;QACpB,CAAC;QACD,qFAAqF;QACrF,IAAI,mBAAmB,oCAAsB,IAAI,iBAAiB,4CAA0B,EAAE,CAAC;YAC7F,OAAO,UAAU,CAAC;QACpB,CAAC;QAED,OAAO,IAAI,CAAC;QAEZ,SAAS,iBAAiB,CAAC,KAAa;YACtC,MAAM,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,8BAA8B,CAAC,CAAC;YAC1D,IAAI,CAAC,KAAK,EAAE,CAAC;gBACX,OAAO,IAAI,CAAC;YACd,CAAC;YAED,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YACtB,IAAI,WAAW,GAAqB,IAAI,CAAC;YACzC,QAAQ,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC;gBACjB,KAAK,GAAG;oBACN,WAAW,8BAAkB,CAAC;oBAC9B,MAAM;gBACR,KAAK,GAAG;oBACN,WAAW,kCAAoB,CAAC;oBAChC,MAAM;gBACR,KAAK,GAAG;oBACN,WAAW,0CAAwB,CAAC;oBACpC,MAAM;gBACR,KAAK,GAAG;oBACN,WAAW,oCAAqB,CAAC;oBACjC,MAAM;gBACR,KAAK,EAAE;oBACL,WAAW,gCAAmB,CAAC;oBAC/B,MAAM;gBACR;oBACE,OAAO,CAAC,KAAK,CAAC,+CAA+C,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;oBAC1E,OAAO,IAAI,CAAC;YAChB,CAAC;YAED,OAAO,EAAC,IAAI,EAAE,WAAW,EAAC,CAAC;QAC7B,CAAC;IACH,CAAC;AACH,CAAC,CAAC;AAEN,MAAM,CAAC,MAAM,iBAAiB,GAC1B,KAAK,WAAU,SAAsC;IACvD,MAAM,EAAC,aAAa,EAAC,GAAG,QAAQ,CAAC,wBAAwB,CAAC,wBAAwB,CAAC,QAAQ,EAAE,CAAC;IAC9F,IAAI,UAAU,GAAuD,MAAM,aAAa,CAAC,iBAAiB,CAAC,SAAS,CAAC,CAAC;IACtH,IAAI,UAAU,EAAE,CAAC;QACf,OAAO,UAAU,CAAC;IACpB,CAAC;IAED,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,SAAS,iFAAmD,CAAC,CAAC;QAChG,SAAS,CAAC,MAAM,CAAC,SAAS,EAAE,EAAE,iBAAiB,CAAC,SAAS,CAAC,CAAC,CAAC;QAC5D,IAAI,CAAC;IACT,IAAI,UAAU,EAAE,CAAC;QACf,OAAO,UAAU,CAAC;IACpB,CAAC;IAED,IAAI,SAAS,CAAC,MAAM,CAAC,MAAM,EAAE,EAAE,CAAC;QAC9B,OAAO,SAAS,CAAC,UAAU,EAAE,CAAC;IAChC,CAAC;IACD,MAAM,UAAU,GAAG,MAAM,iBAAiB,CAAC,SAAS,CAAC,CAAC;IACtD,OAAO,SAAS,CAAC,UAAU,EAAE,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,8BAA8B,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC,CAAC;AACpG,CAAC,CAAC;AAEF;;;GAGG;AACH,MAAM,CAAC,MAAM,uBAAuB,GAChC,KAAK,EAAC,SAAsC,EAAqC,EAAE;IACrF,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC,aAAa,CAAC,wBAAwB,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC;QACvF,OAAO,IAAI,GAAG,EAAuB,CAAC;IACxC,CAAC;IACD,MAAM,SAAS,GAAG,oBAAoB,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;IACtD,IAAI,SAAS,EAAE,CAAC;QACd,OAAO,SAAS,CAAC;IACnB,CAAC;IAED,MAAM,UAAU,GAAG,SAAS,CAAC,UAAU,EAAE,CAAC;IAC1C,MAAM,YAAY,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,GAAG,CAAC,oBAAoB,CAAC,CAAC,CAAC;IAC7E,MAAM,cAAc,GAAG,IAAI,GAAG,EAAuB,CAAC;IACtD,MAAM,aAAa,GAAG,IAAI,GAAG,EAAU,CAAC;IACxC,KAAK,MAAM,EAAC,eAAe,EAAC,IAAI,YAAY,EAAE,CAAC;QAC7C,KAAK,MAAM,CAAC,YAAY,EAAE,YAAY,CAAC,IAAI,eAAe,EAAE,CAAC;YAC3D,IAAI,CAAC,YAAY,EAAE,CAAC;gBAClB,SAAS;YACX,CAAC;YACD,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,YAAY,CAAC,EAAE,CAAC;gBACtC,4FAA4F;gBAC5F,MAAM,kBAAkB,GAAG,aAAa,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,YAAY,CAAC;gBACjF,cAAc,CAAC,GAAG,CAAC,YAAY,EAAE,kBAAkB,CAAC,CAAC;YACvD,CAAC;YACD,aAAa,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;QAClC,CAAC;IACH,CAAC;IACD,oBAAoB,CAAC,GAAG,CAAC,SAAS,EAAE,cAAc,CAAC,CAAC;IACpD,OAAO,cAAc,CAAC;AACxB,CAAC,CAAC;AAEF;;;GAGG;AACH,MAAM,CAAC,MAAM,sBAAsB,GAC/B,KAAK,EAAC,QAAoC,EAAqC,EAAE;IACnF,MAAM,cAAc,GAAG,IAAI,GAAG,EAAuB,CAAC;IACtD,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC,aAAa,CAAC,wBAAwB,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC;QACvF,OAAO,cAAc,CAAC;IACxB,CAAC;IACD,MAAM,MAAM,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC;IACjC,IAAI,CAAC,MAAM,EAAE,CAAC;QACZ,OAAO,cAAc,CAAC;IACxB,CAAC;IAED,MAAM,gBAAgB,GAAG,MAAM,gBAAgB,CAAC,MAAM,CAAC,CAAC;IACxD,IAAI,CAAC,gBAAgB,EAAE,CAAC;QACtB,OAAO,cAAc,CAAC;IACxB,CAAC;IAED,MAAM,EAAC,SAAS,EAAE,IAAI,EAAC,GAAG,gBAAgB,CAAC;IAC3C,MAAM,cAAc,GAAG,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,UAAU,EAAE,QAAQ,CAAC,YAAY,CAAC,CAAC;IAC3F,MAAM,UAAU,GAAG,cAAc,CAAC,SAAS,EAAE,EAAC,KAAK,EAAE,cAAc,EAAE,GAAG,EAAE,cAAc,EAAC,CAAC,CAAC;IAC3F,MAAM,aAAa,GAAG,IAAI,GAAG,EAAU,CAAC;IAExC,OAAO,UAAU,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;QAC7B,MAAM,EAAC,eAAe,EAAC,GAAG,MAAM,YAAY,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;QACjE,KAAK,MAAM,CAAC,YAAY,EAAE,YAAY,CAAC,IAAI,eAAe,EAAE,CAAC;YAC3D,IAAI,CAAC,YAAY,EAAE,CAAC;gBAClB,SAAS;YACX,CAAC;YACD,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,YAAY,CAAC,EAAE,CAAC;gBACtC,4FAA4F;gBAC5F,MAAM,kBAAkB,GAAG,aAAa,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,YAAY,CAAC;gBACjF,cAAc,CAAC,GAAG,CAAC,YAAY,EAAE,kBAAkB,CAAC,CAAC;YACvD,CAAC;YACD,aAAa,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;QAClC,CAAC;QACD,UAAU,CAAC,GAAG,EAAE,CAAC;IACnB,CAAC;IACD,OAAO,cAAc,CAAC;AACxB,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,iBAAiB,GAC1B,KAAK,EAAC,SAAsC,EAA+C,EAAE;IAC/F,MAAM,UAAU,GAAG,SAAS,CAAC,UAAU,EAAE,CAAC;IAC1C,IAAI,UAAU,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QAC5B,OAAO,SAAS,CAAC,UAAU,EAAE,CAAC;IAChC,CAAC;IAED,MAAM,EAAC,WAAW,EAAC,GAAG,MAAM,oBAAoB,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;IAChE,IAAI,CAAC,WAAW,EAAE,CAAC;QACjB,OAAO,SAAS,CAAC,UAAU,EAAE,CAAC;IAChC,CAAC;IAED,MAAM,MAAM,GAAG,MAAM,SAAS,CAAC,QAAQ,CAAC,CAAC;QACvC,UAAU,EAAE,WAAW;QACvB,WAAW,EAAE,WAAW;QACxB,qBAAqB,EAAE,KAAK;QAC5B,MAAM,EAAE,IAAI;QACZ,aAAa,EAAE,KAAK;QACpB,eAAe,EAAE,IAAI;KACtB,CAAC,CAAC,CAAC;IACJ,IAAI,kBAAkB,IAAI,MAAM,EAAE,CAAC;QACjC,OAAO,CAAC,MAAM,CAAC,gBAAgB,IAAI,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,SAAS,CAAC,UAAU,EAAE,CAAC;IAC5F,CAAC;IACD,OAAO,IAAI,CAAC;AACd,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,oBAAoB,GAAG,UAAS,KAAwC;IACnF,MAAM,WAAW,GAAG,KAAK,CAAC,KAAK,EAAE,EAAE,GAAG,CAAC;IACvC,MAAM,mBAAmB,GAAG,KAAK,CAAC,KAAK,EAAE,EAAE,KAAK,CAAC,MAAM,EAAE,IAAI,IAAI,CAAC;IAElE,IAAI,KAAK,CAAC,IAAI,EAAE,sDAAuC,IAAI,CAAC,mBAAmB,IAAI,CAAC,WAAW;QAC3F,CAAC,mBAAmB,CAAC,YAAY,EAAE,CAAC;QACtC,OAAO,KAAK,CAAC,MAAM,EAAE,CAAC;IACxB,CAAC;IAED,OAAO,IAAI,YAAY,CAAC,KAAK,CAAC,CAAC;AACjC,CAAC,CAAC;AAEF;;;;;;GAMG;AACH,MAAM,8BAA8B;IACzB,cAAc,CAAoC;IAC3D,oDAAoD;IAC3C,WAAW,CAAqC;IAEzD,YAAY,KAAwC,EAAE,UAA8C;QAClG,IAAI,CAAC,cAAc,GAAG,KAAK,CAAC;QAC5B,IAAI,CAAC,WAAW,GAAG,UAAU,CAAC;IAChC,CAAC;IAED,SAAS;QACP,OAAO,IAAI,CAAC,cAAc,CAAC,SAAS,EAAE,CAAC;IACzC,CAAC;IAED,IAAI;QACF,OAAO,IAAI,CAAC,cAAc,CAAC,IAAI,EAAE,CAAC;IACpC,CAAC;IAED,QAAQ;QACN,OAAO,IAAI,CAAC,cAAc,CAAC,QAAQ,EAAE,CAAC;IACxC,CAAC;IAED,IAAI;QACF,OAAO,IAAI,CAAC,cAAc,CAAC,IAAI,EAAE,CAAC;IACpC,CAAC;IAED,KAAK;QACH,OAAO,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE,CAAC;IACrC,CAAC;IAED,MAAM;QACJ,OAAO,oBAAoB,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;IACnD,CAAC;IAED,WAAW;QACT,OAAO,IAAI,CAAC,cAAc,CAAC,WAAW,EAAE,CAAC;IAC3C,CAAC;IAED,IAAI;QACF,OAAO,IAAI,CAAC,cAAc,CAAC,IAAI,EAAE,CAAC;IACpC,CAAC;IAED,eAAe;QACb,MAAM,eAAe,GAAG,IAAI,CAAC,cAAc,CAAC,eAAe,EAAE,CAAC;QAC9D,IAAI,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,IAAI,EAAE,oDAAsC,EAAE,CAAC;YAC1E,eAAe,CAAC,OAAO,CAAC,IAAI,GAAG,CAAC,YAAY,CAAC,oBAAoB,CAC7D,MAAM,EAAE,IAAI,CAAC,WAAW,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,eAAe,CAAC,IAAI,CAAC,CAAC,CAAC;QAC9G,CAAC;QACD,OAAO,eAAe,CAAC;IACzB,CAAC;CACF;AAED,MAAM,OAAO,YAAa,SAAQ,GAAG,CAAC,YAAY,CAAC,YAAY;IAC5C,KAAK,CAAoC;IACzC,MAAM,CAAgC;IACvD,YAAY,KAAwC;QAClD,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC;IAC/B,CAAC;IAEQ,aAAa;QACpB,OAAO,IAAI,CAAC,MAAM,CAAC,aAAa,EAAE,CAAC;IACrC,CAAC;IAED,IAAa,QAAQ;QACnB,OAAO,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC;IAC9B,CAAC;IAED,IAAa,IAAI;QACf,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;IAC1B,CAAC;IAED,IAAa,OAAO;QAClB,OAAO,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC;IAC7B,CAAC;IAED,IAAa,KAAK;QAChB,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC;IAC3B,CAAC;IAED,IAAa,WAAW;QACtB,OAAO,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC;IACjC,CAAC;IAED,IAAa,WAAW;QACtB,OAAO,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC;IACjC,CAAC;IAED,IAAa,OAAO;QAClB,OAAO,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC;IAC7B,CAAC;IAEQ,WAAW;QAClB,OAAO,IAAI,CAAC,MAAM,CAAC,WAAW,EAAE,CAAC;IACnC,CAAC;IAEQ,gBAAgB,CAAC,eAAwB;QAChD,OAAO,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,eAAe,CAAC,CAAC;IACvD,CAAC;IAEQ,KAAK,CAAC,gBAAgB,CAAC,sBAA+B,EAAE,eAAwB;QAEvF,MAAM,aAAa,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,sBAAsB,EAAE,eAAe,CAAC,CAAC;QAClG,MAAM,EAAC,eAAe,EAAC,GAAG,MAAM,oBAAoB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAEjE,MAAM,UAAU,GAAG,aAAa,CAAC,UAAU,CAAC;QAC5C,MAAM,kBAAkB,GAAG,aAAa,CAAC,kBAAkB,CAAC;QAC5D,MAAM,aAAa,GAAG,UAAU,EAAE,GAAG,CAAC,QAAQ,CAAC,EAAE;YAC/C,MAAM,IAAI,GAAG,eAAe,CAAC,GAAG,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;YAChD,OAAO,IAAI,KAAK,SAAS,CAAC,CAAC,CAAC,QAAQ,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC;QACzE,CAAC,CAAC,CAAC;QACH,OAAO,EAAC,UAAU,EAAE,aAAa,IAAI,EAAE,EAAE,kBAAkB,EAAC,CAAC;IAC/D,CAAC;IAEQ,KAAK,CAAC,gBAAgB,CAAC,YAAkD,EAAE,KAAa;QAE/F,MAAM,EAAC,eAAe,EAAC,GAAG,MAAM,oBAAoB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAEjE,IAAI,IAAI,CAAC;QACT,IAAI,OAAO,YAAY,KAAK,QAAQ,EAAE,CAAC;YACrC,IAAI,GAAG,YAAY,CAAC;QACtB,CAAC;aAAM,CAAC;YACN,IAAI,GAAI,YAAY,CAAC,KAAgB,CAAC;QACxC,CAAC;QAED,IAAI,UAAU,GAAW,IAAI,CAAC;QAC9B,KAAK,MAAM,YAAY,IAAI,eAAe,CAAC,IAAI,EAAE,EAAE,CAAC;YAClD,IAAI,eAAe,CAAC,GAAG,CAAC,YAAY,CAAC,KAAK,IAAI,EAAE,CAAC;gBAC/C,UAAU,GAAG,YAAY,CAAC;gBAC1B,MAAM;YACR,CAAC;QACH,CAAC;QACD,OAAO,MAAM,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;IAC/D,CAAC;IAEQ,KAAK,CAAC,cAAc,CAAC,IAAmC;QAC/D,OAAO,MAAM,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;IAChD,CAAC;IAEQ,YAAY,CACjB,mBAAmD,EACnD,IAAsC;QACxC,OAAO,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,mBAAmB,EAAE,IAAI,CAAC,CAAC;IAC7D,CAAC;IAEQ,gBAAgB,CACrB,mBAAmD,EAAE,IAAsC;QAC7F,OAAO,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,mBAAmB,EAAE,IAAI,CAAC,CAAC;IACjE,CAAC;IAEQ,OAAO;QACd,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,CAAC;IACxB,CAAC;IAEQ,aAAa;QACpB,OAAO,IAAI,CAAC,MAAM,CAAC,aAAa,EAAE,CAAC;IACrC,CAAC;IAEQ,YAAY;QACnB,OAAO,IAAI,CAAC,MAAM,CAAC,YAAY,EAAE,CAAC;IACpC,CAAC;IAEQ,MAAM;QACb,OAAO,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC;IAC9B,CAAC;CACF;AAED;;;;;IAKI;AACJ,KAAK,UAAU,6BAA6B,CACxC,MAAyB,EAAE,UAAkB,EAAE,YAAoB;IACrE,sDAAsD;IACtD,uDAAuD;IACvD,wDAAwD;IACxD,MAAM,SAAS,GAAG,MAAM,CAAC,SAAS,EAAE,CAAC;IACrC,IAAI,CAAC,SAAS,EAAE,CAAC;QACf,OAAO,IAAI,CAAC;IACd,CAAC;IAED,MAAM,SAAS,GAAG,SAAS,CAAC,wBAAwB,CAAC,EAAC,IAAI,EAAE,UAAU,EAAE,MAAM,EAAE,YAAY,EAAC,CAAC,CAAC;IAC/F,IAAI,SAAS,KAAK,IAAI,EAAE,CAAC;QACvB,OAAO,SAAS,CAAC;IACnB,CAAC;IAED,MAAM,YAAY,GAAG,SAAS,CAAC,SAAS,CAAC,UAAU,EAAE,YAAY,CAAC,CAAC;IACnE,IAAI,CAAC,YAAY,EAAE,SAAS,EAAE,CAAC;QAC7B,OAAO,IAAI,CAAC;IACd,CAAC;IAED,MAAM,IAAI,GAAG,YAAY,CAAC,IAAI,CAAC;IAC/B,IAAI,CAAC,IAAI,EAAE,CAAC;QACV,OAAO,IAAI,CAAC;IACd,CAAC;IAED,MAAM,IAAI,GAAG,MAAM,UAAU,CAAC,MAAM,CAAC,CAAC;IACtC,IAAI,CAAC,IAAI,EAAE,CAAC;QACV,OAAO,IAAI,CAAC;IACd,CAAC;IAED,MAAM,SAAS,GAAG,IAAI,SAAS,CAAC,SAAS,CAAC,SAAS,CAAC,UAAU,EAAE,YAAY,EAAE,UAAU,EAAE,YAAY,GAAG,CAAC,CAAC,CAAC;IAE5G,IAAI,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,KAAK,GAAG,EAAE,CAAC;QACpC,OAAO,IAAI,CAAC;IACd,CAAC;IAED,OAAO,IAAI,CAAC;AACd,CAAC;AAED,MAAM,CAAC,KAAK,UAAU,gCAAgC,CAAC,KAAkC;IACvF,MAAM,aAAa,GAAG,KAAK,CAAC,UAAU,EAAE,EAAE,KAAK,EAAE,EAAE,KAAK,CAAC;IACzD,IAAI,CAAC,aAAa,EAAE,CAAC;QACnB,OAAO,IAAI,CAAC;IACd,CAAC;IACD,OAAO,MAAM,6BAA6B,CAAC,KAAK,CAAC,MAAM,EAAE,aAAa,CAAC,UAAU,EAAE,aAAa,CAAC,YAAY,CAAC,CAAC;AACjH,CAAC;AAED,MAAM,CAAC,KAAK,UAAU,+BAA+B,CACjD,EAAC,QAAQ,EAAE,UAAU,EAAE,YAAY,EAAsC,EACzE,MAA8B;IAChC,IAAI,CAAC,MAAM,IAAI,UAAU,KAAK,SAAS,IAAI,YAAY,KAAK,SAAS,IAAI,QAAQ,KAAK,SAAS,EAAE,CAAC;QAChG,OAAO,IAAI,CAAC;IACd,CAAC;IACD,MAAM,aAAa,GAAG,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,aAAa,CAAC,aAAa,CAAC,CAAC;IACpE,MAAM,MAAM,GAAG,aAAa,EAAE,WAAW,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC;IAE5D,IAAI,CAAC,aAAa,IAAI,CAAC,MAAM,EAAE,CAAC;QAC9B,OAAO,IAAI,CAAC;IACd,CAAC;IAED,MAAM,wBAAwB,GAAG,QAAQ,CAAC,wBAAwB,CAAC,wBAAwB,CAAC,QAAQ,EAAE,CAAC;IACvG,MAAM,QAAQ,GAAG,IAAI,GAAG,CAAC,aAAa,CAAC,QAAQ,CAAC,aAAa,EAAE,QAAQ,EAAE,UAAU,EAAE,YAAY,CAAC,CAAC;IACnG,MAAM,sBAAsB,GAAG,MAAM,wBAAwB,CAAC,aAAa,CAAC,eAAe,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;IAC9G,IAAI,sBAAsB,IAAI,QAAQ,IAAI,sBAAsB,EAAE,CAAC;QACjE,MAAM,IAAI,GAAG,sBAAsB,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;QAClD,IAAI,IAAI,EAAE,IAAI,EAAE,CAAC;YACf,OAAO,IAAI,CAAC,IAAI,CAAC;QACnB,CAAC;IACH,CAAC;IACD,OAAO,MAAM,6BAA6B,CAAC,MAAM,EAAE,UAAU,EAAE,YAAY,CAAC,CAAC;AAC/E,CAAC;AAED,IAAI,oBAAoB,GAAiC,cAAkB,CAAC,CAAC;AAE7E,MAAM,CAAC,MAAM,uBAAuB,GAAG,GAAiC,EAAE;IACxE,OAAO,oBAAoB,CAAC;AAC9B,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,uBAAuB,GAAG,CAAC,KAAmC,EAAQ,EAAE;IACnF,oBAAoB,GAAG,KAAK,CAAC;AAC/B,CAAC,CAAC","sourcesContent":["// Copyright 2022 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport * as Root from '../../core/root/root.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport * as Protocol from '../../generated/protocol.js';\nimport * as Bindings from '../bindings/bindings.js';\nimport * as Formatter from '../formatter/formatter.js';\nimport * as TextUtils from '../text_utils/text_utils.js';\n\ninterface CachedScopeMap {\n  sourceMap: SDK.SourceMap.SourceMap|undefined;\n  mappingPromise: Promise<{variableMapping: Map<string, string>, thisMapping: string|null}>;\n}\n\nconst scopeToCachedIdentifiersMap = new WeakMap<Formatter.FormatterWorkerPool.ScopeTreeNode, CachedScopeMap>();\nconst cachedMapByCallFrame = new WeakMap<SDK.DebuggerModel.CallFrame, Map<string, string|null>>();\n\nexport async function getTextFor(contentProvider: TextUtils.ContentProvider.ContentProvider):\n    Promise<TextUtils.Text.Text|null> {\n  const contentData = await contentProvider.requestContentData();\n  if (TextUtils.ContentData.ContentData.isError(contentData) || !contentData.isTextContent) {\n    return null;\n  }\n  return contentData.textObj;\n}\n\nexport class IdentifierPositions {\n  name: string;\n  positions: Array<{lineNumber: number, columnNumber: number}>;\n\n  constructor(name: string, positions: Array<{lineNumber: number, columnNumber: number}> = []) {\n    this.name = name;\n    this.positions = positions;\n  }\n\n  addPosition(lineNumber: number, columnNumber: number): void {\n    this.positions.push({lineNumber, columnNumber});\n  }\n}\n\nconst computeScopeTree = async function(script: SDK.Script.Script): Promise<{\nscopeTree:\n  Formatter.FormatterWorkerPool.ScopeTreeNode, text: TextUtils.Text.Text,\n}|null> {\n  if (!script.sourceMapURL) {\n    return null;\n  }\n\n  return await SDK.ScopeTreeCache.scopeTreeForScript(script);\n};\n\n/**\n * @returns the scope chain from outer-most to inner-most scope where the inner-most\n * scope either contains or matches the \"needle\".\n */\nconst findScopeChain = function(\n                           scopeTree: Formatter.FormatterWorkerPool.ScopeTreeNode,\n                           scopeNeedle: {start: number, end: number}): Formatter.FormatterWorkerPool.ScopeTreeNode[] {\n  if (!contains(scopeTree, scopeNeedle)) {\n    return [];\n  }\n\n  // Find the corresponding scope in the scope tree.\n  let containingScope = scopeTree;\n  const scopeChain = [scopeTree];\n  while (true) {\n    let childFound = false;\n    for (const child of containingScope.children) {\n      if (contains(child, scopeNeedle)) {\n        // We found a nested containing scope, continue with search there.\n        scopeChain.push(child);\n        containingScope = child;\n        childFound = true;\n        break;\n      }\n      // Sanity check: |scope| should not straddle any of the scopes in the tree. That is:\n      // Either |scope| is disjoint from |child| or |child| must be inside |scope|.\n      // (Or the |scope| is inside |child|, but that case is covered above.)\n      if (!disjoint(scopeNeedle, child) && !contains(scopeNeedle, child)) {\n        console.error('Wrong nesting of scopes');\n        return [];\n      }\n    }\n    if (!childFound) {\n      // We found the deepest scope in the tree that contains our scope chain entry.\n      break;\n    }\n  }\n\n  return scopeChain;\n\n  function contains(scope: {start: number, end: number}, candidate: {start: number, end: number}): boolean {\n    return (scope.start <= candidate.start) && (scope.end >= candidate.end);\n  }\n  function disjoint(scope: {start: number, end: number}, other: {start: number, end: number}): boolean {\n    return (scope.end <= other.start) || (other.end <= scope.start);\n  }\n};\n\nexport async function findScopeChainForDebuggerScope(scope: SDK.DebuggerModel.ScopeChainEntry):\n    Promise<Formatter.FormatterWorkerPool.ScopeTreeNode[]> {\n  const startLocation = scope.range()?.start;\n  const endLocation = scope.range()?.end;\n  if (!startLocation || !endLocation) {\n    return [];\n  }\n\n  const script = startLocation.script();\n  if (!script) {\n    return [];\n  }\n\n  const scopeTreeAndText = await computeScopeTree(script);\n  if (!scopeTreeAndText) {\n    return [];\n  }\n  const {scopeTree, text} = scopeTreeAndText;\n\n  // Compute the offset within the scope tree coordinate space.\n  const scopeOffsets = {\n    start: text.offsetFromPosition(startLocation.lineNumber, startLocation.columnNumber),\n    end: text.offsetFromPosition(endLocation.lineNumber, endLocation.columnNumber),\n  };\n\n  return findScopeChain(scopeTree, scopeOffsets);\n}\n\nexport const scopeIdentifiers = async function(\n    script: SDK.Script.Script, scope: Formatter.FormatterWorkerPool.ScopeTreeNode,\n    ancestorScopes: Formatter.FormatterWorkerPool.ScopeTreeNode[]): Promise<{\nfreeVariables:\n  IdentifierPositions[], boundVariables: IdentifierPositions[],\n}|null> {\n  const text = await getTextFor(script);\n  if (!text) {\n    return null;\n  }\n\n  // Now we have containing scope. Collect all the scope variables.\n  const boundVariables = [];\n  const cursor = new TextUtils.TextCursor.TextCursor(text.lineEndings());\n  for (const variable of scope.variables) {\n    // Skip the fixed-kind variable (i.e., 'this' or 'arguments') if we only found their \"definition\"\n    // without any uses.\n    if (variable.kind === Formatter.FormatterWorkerPool.DefinitionKind.FIXED && variable.offsets.length <= 1) {\n      continue;\n    }\n\n    const identifier = new IdentifierPositions(variable.name);\n    for (const offset of variable.offsets) {\n      cursor.resetTo(offset);\n      identifier.addPosition(cursor.lineNumber(), cursor.columnNumber());\n    }\n    boundVariables.push(identifier);\n  }\n\n  // Compute free variables by collecting all the ancestor variables that are used in |containingScope|.\n  const freeVariables = [];\n  for (const ancestor of ancestorScopes) {\n    for (const ancestorVariable of ancestor.variables) {\n      let identifier = null;\n      for (const offset of ancestorVariable.offsets) {\n        if (offset >= scope.start && offset < scope.end) {\n          if (!identifier) {\n            identifier = new IdentifierPositions(ancestorVariable.name);\n          }\n          cursor.resetTo(offset);\n          identifier.addPosition(cursor.lineNumber(), cursor.columnNumber());\n        }\n      }\n      if (identifier) {\n        freeVariables.push(identifier);\n      }\n    }\n  }\n  return {boundVariables, freeVariables};\n};\n\nconst identifierAndPunctuationRegExp = /^\\s*([A-Za-z_$][A-Za-z_$0-9]*)\\s*([.;,=]?)\\s*$/;\n\nconst enum Punctuation {\n  NONE = 'none',\n  COMMA = 'comma',\n  DOT = 'dot',\n  SEMICOLON = 'semicolon',\n  EQUALS = 'equals',\n}\n\nconst resolveDebuggerScope = async(scope: SDK.DebuggerModel.ScopeChainEntry):\n    Promise<{variableMapping: Map<string, string>, thisMapping: string | null}> => {\n      if (!Common.Settings.Settings.instance().moduleSetting('js-source-maps-enabled').get()) {\n        return {variableMapping: new Map(), thisMapping: null};\n      }\n      const script = scope.callFrame().script;\n      const scopeChain = await findScopeChainForDebuggerScope(scope);\n      return await resolveScope(script, scopeChain);\n    };\n\nconst resolveScope = async(script: SDK.Script.Script, scopeChain: Formatter.FormatterWorkerPool.ScopeTreeNode[]):\n    Promise<{variableMapping: Map<string, string>, thisMapping: string | null}> => {\n      const parsedScope = scopeChain[scopeChain.length - 1];\n      if (!parsedScope) {\n        return {variableMapping: new Map<string, string>(), thisMapping: null};\n      }\n      let cachedScopeMap = scopeToCachedIdentifiersMap.get(parsedScope);\n      const sourceMap = script.sourceMap();\n\n      if (!cachedScopeMap || cachedScopeMap.sourceMap !== sourceMap) {\n        const identifiersPromise =\n            (async () => {\n              const variableMapping = new Map<string, string>();\n              let thisMapping = null;\n\n              if (!sourceMap) {\n                return {variableMapping, thisMapping};\n              }\n              // Extract as much as possible from SourceMap and resolve\n              // missing identifier names from SourceMap ranges.\n              const promises: Array<Promise<void>> = [];\n\n              const resolveEntry = (id: IdentifierPositions, handler: (sourceName: string) => void): void => {\n                // First see if we have a source map entry with a name for the identifier.\n                for (const position of id.positions) {\n                  const entry = sourceMap.findEntry(position.lineNumber, position.columnNumber);\n                  if (entry?.name) {\n                    handler(entry.name);\n                    return;\n                  }\n                }\n                /** If there is no entry with the name field, try to infer the name from the source positions. **/\n                async function resolvePosition(): Promise<void> {\n                  if (!sourceMap) {\n                    return;\n                  }\n                  // Let us find the first non-empty mapping of |id| and return that. Ideally, we would\n                  // try to compute all the mappings and only use the mapping if all the non-empty\n                  // mappings agree. However, that can be expensive for identifiers with many uses,\n                  // so we iterate sequentially, stopping at the first non-empty mapping.\n                  for (const position of id.positions) {\n                    const sourceName = await resolveSourceName(script, sourceMap, id.name, position);\n                    if (sourceName) {\n                      handler(sourceName);\n                      return;\n                    }\n                  }\n                }\n                promises.push(resolvePosition());\n              };\n\n              const parsedVariables = await scopeIdentifiers(script, parsedScope, scopeChain.slice(0, -1));\n              if (!parsedVariables) {\n                return {variableMapping, thisMapping};\n              }\n              for (const id of parsedVariables.boundVariables) {\n                resolveEntry(id, sourceName => {\n                  // Let use ignore 'this' mappings - those are handled separately.\n                  if (sourceName !== 'this') {\n                    variableMapping.set(id.name, sourceName);\n                  }\n                });\n              }\n              for (const id of parsedVariables.freeVariables) {\n                resolveEntry(id, sourceName => {\n                  if (sourceName === 'this') {\n                    thisMapping = id.name;\n                  }\n                });\n              }\n              await Promise.all(promises).then(getScopeResolvedForTest());\n              return {variableMapping, thisMapping};\n            })();\n        cachedScopeMap = {sourceMap, mappingPromise: identifiersPromise};\n        scopeToCachedIdentifiersMap.set(parsedScope, {sourceMap, mappingPromise: identifiersPromise});\n      }\n      return await cachedScopeMap.mappingPromise;\n\n      async function resolveSourceName(\n          script: SDK.Script.Script, sourceMap: SDK.SourceMap.SourceMap, name: string,\n          position: {lineNumber: number, columnNumber: number}): Promise<string|null> {\n        const ranges = sourceMap.findEntryRanges(position.lineNumber, position.columnNumber);\n        if (!ranges) {\n          return null;\n        }\n        // Extract the underlying text from the compiled code's range and make sure that\n        // it starts with the identifier |name|.\n        const uiSourceCode =\n            Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding.instance().uiSourceCodeForSourceMapSourceURL(\n                script.debuggerModel, ranges.sourceURL, script.isContentScript());\n        if (!uiSourceCode) {\n          return null;\n        }\n        const compiledText = await getTextFor(script);\n        if (!compiledText) {\n          return null;\n        }\n        const compiledToken = compiledText.extract(ranges.range);\n        const parsedCompiledToken = extractIdentifier(compiledToken);\n        if (!parsedCompiledToken) {\n          return null;\n        }\n        const {name: compiledName, punctuation: compiledPunctuation} = parsedCompiledToken;\n        if (compiledName !== name) {\n          return null;\n        }\n\n        // Extract the mapped name from the source code range and ensure that the punctuation\n        // matches the one from the compiled code.\n        const sourceText = await getTextFor(uiSourceCode);\n        if (!sourceText) {\n          return null;\n        }\n        const sourceToken = sourceText.extract(ranges.sourceRange);\n        const parsedSourceToken = extractIdentifier(sourceToken);\n        if (!parsedSourceToken) {\n          return null;\n        }\n        const {name: sourceName, punctuation: sourcePunctuation} = parsedSourceToken;\n        // Accept the source name if it is followed by the same punctuation.\n        if (compiledPunctuation === sourcePunctuation) {\n          return sourceName;\n        }\n        // Let us also allow semicolons into commas since that it is a common transformation.\n        if (compiledPunctuation === Punctuation.COMMA && sourcePunctuation === Punctuation.SEMICOLON) {\n          return sourceName;\n        }\n\n        return null;\n\n        function extractIdentifier(token: string): {name: string, punctuation: Punctuation}|null {\n          const match = token.match(identifierAndPunctuationRegExp);\n          if (!match) {\n            return null;\n          }\n\n          const name = match[1];\n          let punctuation: Punctuation|null = null;\n          switch (match[2]) {\n            case '.':\n              punctuation = Punctuation.DOT;\n              break;\n            case ',':\n              punctuation = Punctuation.COMMA;\n              break;\n            case ';':\n              punctuation = Punctuation.SEMICOLON;\n              break;\n            case '=':\n              punctuation = Punctuation.EQUALS;\n              break;\n            case '':\n              punctuation = Punctuation.NONE;\n              break;\n            default:\n              console.error(`Name token parsing error: unexpected token \"${match[2]}\"`);\n              return null;\n          }\n\n          return {name, punctuation};\n        }\n      }\n    };\n\nexport const resolveScopeChain =\n    async function(callFrame: SDK.DebuggerModel.CallFrame): Promise<SDK.DebuggerModel.ScopeChainEntry[]> {\n  const {pluginManager} = Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding.instance();\n  let scopeChain: SDK.DebuggerModel.ScopeChainEntry[]|null|undefined = await pluginManager.resolveScopeChain(callFrame);\n  if (scopeChain) {\n    return scopeChain;\n  }\n\n  scopeChain = Root.Runtime.experiments.isEnabled(Root.Runtime.ExperimentName.USE_SOURCE_MAP_SCOPES) ?\n      callFrame.script.sourceMap()?.resolveScopeChain(callFrame) :\n      null;\n  if (scopeChain) {\n    return scopeChain;\n  }\n\n  if (callFrame.script.isWasm()) {\n    return callFrame.scopeChain();\n  }\n  const thisObject = await resolveThisObject(callFrame);\n  return callFrame.scopeChain().map(scope => new ScopeWithSourceMappedVariables(scope, thisObject));\n};\n\n/**\n * @returns A mapping from original name -> compiled name. If the orignal name is unavailable (e.g. because the compiled name was\n * shadowed) we set it to `null`.\n */\nexport const allVariablesInCallFrame =\n    async(callFrame: SDK.DebuggerModel.CallFrame): Promise<Map<string, string|null>> => {\n  if (!Common.Settings.Settings.instance().moduleSetting('js-source-maps-enabled').get()) {\n    return new Map<string, string|null>();\n  }\n  const cachedMap = cachedMapByCallFrame.get(callFrame);\n  if (cachedMap) {\n    return cachedMap;\n  }\n\n  const scopeChain = callFrame.scopeChain();\n  const nameMappings = await Promise.all(scopeChain.map(resolveDebuggerScope));\n  const reverseMapping = new Map<string, string|null>();\n  const compiledNames = new Set<string>();\n  for (const {variableMapping} of nameMappings) {\n    for (const [compiledName, originalName] of variableMapping) {\n      if (!originalName) {\n        continue;\n      }\n      if (!reverseMapping.has(originalName)) {\n        // An inner scope might have shadowed {compiledName}. Mark it as \"unavailable\" in that case.\n        const compiledNameOrNull = compiledNames.has(compiledName) ? null : compiledName;\n        reverseMapping.set(originalName, compiledNameOrNull);\n      }\n      compiledNames.add(compiledName);\n    }\n  }\n  cachedMapByCallFrame.set(callFrame, reverseMapping);\n  return reverseMapping;\n};\n\n/**\n * @returns A mapping from original name -> compiled name. If the orignal name is unavailable (e.g. because the compiled name was\n * shadowed) we set it to `null`.\n */\nexport const allVariablesAtPosition =\n    async(location: SDK.DebuggerModel.Location): Promise<Map<string, string|null>> => {\n  const reverseMapping = new Map<string, string|null>();\n  if (!Common.Settings.Settings.instance().moduleSetting('js-source-maps-enabled').get()) {\n    return reverseMapping;\n  }\n  const script = location.script();\n  if (!script) {\n    return reverseMapping;\n  }\n\n  const scopeTreeAndText = await computeScopeTree(script);\n  if (!scopeTreeAndText) {\n    return reverseMapping;\n  }\n\n  const {scopeTree, text} = scopeTreeAndText;\n  const locationOffset = text.offsetFromPosition(location.lineNumber, location.columnNumber);\n  const scopeChain = findScopeChain(scopeTree, {start: locationOffset, end: locationOffset});\n  const compiledNames = new Set<string>();\n\n  while (scopeChain.length > 0) {\n    const {variableMapping} = await resolveScope(script, scopeChain);\n    for (const [compiledName, originalName] of variableMapping) {\n      if (!originalName) {\n        continue;\n      }\n      if (!reverseMapping.has(originalName)) {\n        // An inner scope might have shadowed {compiledName}. Mark it as \"unavailable\" in that case.\n        const compiledNameOrNull = compiledNames.has(compiledName) ? null : compiledName;\n        reverseMapping.set(originalName, compiledNameOrNull);\n      }\n      compiledNames.add(compiledName);\n    }\n    scopeChain.pop();\n  }\n  return reverseMapping;\n};\n\nexport const resolveThisObject =\n    async(callFrame: SDK.DebuggerModel.CallFrame): Promise<SDK.RemoteObject.RemoteObject|null> => {\n  const scopeChain = callFrame.scopeChain();\n  if (scopeChain.length === 0) {\n    return callFrame.thisObject();\n  }\n\n  const {thisMapping} = await resolveDebuggerScope(scopeChain[0]);\n  if (!thisMapping) {\n    return callFrame.thisObject();\n  }\n\n  const result = await callFrame.evaluate(({\n    expression: thisMapping,\n    objectGroup: 'backtrace',\n    includeCommandLineAPI: false,\n    silent: true,\n    returnByValue: false,\n    generatePreview: true,\n  }));\n  if ('exceptionDetails' in result) {\n    return !result.exceptionDetails && result.object ? result.object : callFrame.thisObject();\n  }\n  return null;\n};\n\nexport const resolveScopeInObject = function(scope: SDK.DebuggerModel.ScopeChainEntry): SDK.RemoteObject.RemoteObject {\n  const endLocation = scope.range()?.end;\n  const startLocationScript = scope.range()?.start.script() ?? null;\n\n  if (scope.type() === Protocol.Debugger.ScopeType.Global || !startLocationScript || !endLocation ||\n      !startLocationScript.sourceMapURL) {\n    return scope.object();\n  }\n\n  return new RemoteObject(scope);\n};\n\n/**\n * Wraps a debugger `Scope` but returns a scope object where variable names are\n * mapped to their authored name.\n *\n * This implementation does not utilize source map \"Scopes\" information but obtains\n * original variable names via parsing + mappings + names.\n */\nclass ScopeWithSourceMappedVariables implements SDK.DebuggerModel.ScopeChainEntry {\n  readonly #debuggerScope: SDK.DebuggerModel.ScopeChainEntry;\n  /** The resolved `this` of the current call frame */\n  readonly #thisObject: SDK.RemoteObject.RemoteObject|null;\n\n  constructor(scope: SDK.DebuggerModel.ScopeChainEntry, thisObject: SDK.RemoteObject.RemoteObject|null) {\n    this.#debuggerScope = scope;\n    this.#thisObject = thisObject;\n  }\n\n  callFrame(): SDK.DebuggerModel.CallFrame {\n    return this.#debuggerScope.callFrame();\n  }\n\n  type(): string {\n    return this.#debuggerScope.type();\n  }\n\n  typeName(): string {\n    return this.#debuggerScope.typeName();\n  }\n\n  name(): string|undefined {\n    return this.#debuggerScope.name();\n  }\n\n  range(): SDK.DebuggerModel.LocationRange|null {\n    return this.#debuggerScope.range();\n  }\n\n  object(): SDK.RemoteObject.RemoteObject {\n    return resolveScopeInObject(this.#debuggerScope);\n  }\n\n  description(): string {\n    return this.#debuggerScope.description();\n  }\n\n  icon(): string|undefined {\n    return this.#debuggerScope.icon();\n  }\n\n  extraProperties(): SDK.RemoteObject.RemoteObjectProperty[] {\n    const extraProperties = this.#debuggerScope.extraProperties();\n    if (this.#thisObject && this.type() === Protocol.Debugger.ScopeType.Local) {\n      extraProperties.unshift(new SDK.RemoteObject.RemoteObjectProperty(\n          'this', this.#thisObject, undefined, undefined, undefined, undefined, undefined, /* synthetic */ true));\n    }\n    return extraProperties;\n  }\n}\n\nexport class RemoteObject extends SDK.RemoteObject.RemoteObject {\n  private readonly scope: SDK.DebuggerModel.ScopeChainEntry;\n  private readonly object: SDK.RemoteObject.RemoteObject;\n  constructor(scope: SDK.DebuggerModel.ScopeChainEntry) {\n    super();\n    this.scope = scope;\n    this.object = scope.object();\n  }\n\n  override customPreview(): Protocol.Runtime.CustomPreview|null {\n    return this.object.customPreview();\n  }\n\n  override get objectId(): Protocol.Runtime.RemoteObjectId|undefined {\n    return this.object.objectId;\n  }\n\n  override get type(): string {\n    return this.object.type;\n  }\n\n  override get subtype(): string|undefined {\n    return this.object.subtype;\n  }\n\n  override get value(): typeof this.object.value {\n    return this.object.value;\n  }\n\n  override get description(): string|undefined {\n    return this.object.description;\n  }\n\n  override get hasChildren(): boolean {\n    return this.object.hasChildren;\n  }\n\n  override get preview(): Protocol.Runtime.ObjectPreview|undefined {\n    return this.object.preview;\n  }\n\n  override arrayLength(): number {\n    return this.object.arrayLength();\n  }\n\n  override getOwnProperties(generatePreview: boolean): Promise<SDK.RemoteObject.GetPropertiesResult> {\n    return this.object.getOwnProperties(generatePreview);\n  }\n\n  override async getAllProperties(accessorPropertiesOnly: boolean, generatePreview: boolean):\n      Promise<SDK.RemoteObject.GetPropertiesResult> {\n    const allProperties = await this.object.getAllProperties(accessorPropertiesOnly, generatePreview);\n    const {variableMapping} = await resolveDebuggerScope(this.scope);\n\n    const properties = allProperties.properties;\n    const internalProperties = allProperties.internalProperties;\n    const newProperties = properties?.map(property => {\n      const name = variableMapping.get(property.name);\n      return name !== undefined ? property.cloneWithNewName(name) : property;\n    });\n    return {properties: newProperties ?? [], internalProperties};\n  }\n\n  override async setPropertyValue(argumentName: string|Protocol.Runtime.CallArgument, value: string):\n      Promise<string|undefined> {\n    const {variableMapping} = await resolveDebuggerScope(this.scope);\n\n    let name;\n    if (typeof argumentName === 'string') {\n      name = argumentName;\n    } else {\n      name = (argumentName.value as string);\n    }\n\n    let actualName: string = name;\n    for (const compiledName of variableMapping.keys()) {\n      if (variableMapping.get(compiledName) === name) {\n        actualName = compiledName;\n        break;\n      }\n    }\n    return await this.object.setPropertyValue(actualName, value);\n  }\n\n  override async deleteProperty(name: Protocol.Runtime.CallArgument): Promise<string|undefined> {\n    return await this.object.deleteProperty(name);\n  }\n\n  override callFunction<T, U>(\n      functionDeclaration: (this: U, ...args: any[]) => T,\n      args?: Protocol.Runtime.CallArgument[]): Promise<SDK.RemoteObject.CallFunctionResult> {\n    return this.object.callFunction(functionDeclaration, args);\n  }\n\n  override callFunctionJSON<T, U>(\n      functionDeclaration: (this: U, ...args: any[]) => T, args?: Protocol.Runtime.CallArgument[]): Promise<T|null> {\n    return this.object.callFunctionJSON(functionDeclaration, args);\n  }\n\n  override release(): void {\n    this.object.release();\n  }\n\n  override debuggerModel(): SDK.DebuggerModel.DebuggerModel {\n    return this.object.debuggerModel();\n  }\n\n  override runtimeModel(): SDK.RuntimeModel.RuntimeModel {\n    return this.object.runtimeModel();\n  }\n\n  override isNode(): boolean {\n    return this.object.isNode();\n  }\n}\n\n/**\n * Resolve the frame's function name using the name associated with the opening\n * paren that starts the scope. If there is no name associated with the scope\n * start or if the function scope does not start with a left paren (e.g., arrow\n * function with one parameter), the resolution returns null.\n **/\nasync function getFunctionNameFromScopeStart(\n    script: SDK.Script.Script, lineNumber: number, columnNumber: number): Promise<string|null> {\n  // To reduce the overhead of resolving function names,\n  // we check for source maps first and immediately leave\n  // this function if the script doesn't have a sourcemap.\n  const sourceMap = script.sourceMap();\n  if (!sourceMap) {\n    return null;\n  }\n\n  const scopeName = sourceMap.findOriginalFunctionName({line: lineNumber, column: columnNumber});\n  if (scopeName !== null) {\n    return scopeName;\n  }\n\n  const mappingEntry = sourceMap.findEntry(lineNumber, columnNumber);\n  if (!mappingEntry?.sourceURL) {\n    return null;\n  }\n\n  const name = mappingEntry.name;\n  if (!name) {\n    return null;\n  }\n\n  const text = await getTextFor(script);\n  if (!text) {\n    return null;\n  }\n\n  const openRange = new TextUtils.TextRange.TextRange(lineNumber, columnNumber, lineNumber, columnNumber + 1);\n\n  if (text.extract(openRange) !== '(') {\n    return null;\n  }\n\n  return name;\n}\n\nexport async function resolveDebuggerFrameFunctionName(frame: SDK.DebuggerModel.CallFrame): Promise<string|null> {\n  const startLocation = frame.localScope()?.range()?.start;\n  if (!startLocation) {\n    return null;\n  }\n  return await getFunctionNameFromScopeStart(frame.script, startLocation.lineNumber, startLocation.columnNumber);\n}\n\nexport async function resolveProfileFrameFunctionName(\n    {scriptId, lineNumber, columnNumber}: Partial<Protocol.Runtime.CallFrame>,\n    target: SDK.Target.Target|null): Promise<string|null> {\n  if (!target || lineNumber === undefined || columnNumber === undefined || scriptId === undefined) {\n    return null;\n  }\n  const debuggerModel = target.model(SDK.DebuggerModel.DebuggerModel);\n  const script = debuggerModel?.scriptForId(String(scriptId));\n\n  if (!debuggerModel || !script) {\n    return null;\n  }\n\n  const debuggerWorkspaceBinding = Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding.instance();\n  const location = new SDK.DebuggerModel.Location(debuggerModel, scriptId, lineNumber, columnNumber);\n  const functionInfoFromPlugin = await debuggerWorkspaceBinding.pluginManager.getFunctionInfo(script, location);\n  if (functionInfoFromPlugin && 'frames' in functionInfoFromPlugin) {\n    const last = functionInfoFromPlugin.frames.at(-1);\n    if (last?.name) {\n      return last.name;\n    }\n  }\n  return await getFunctionNameFromScopeStart(script, lineNumber, columnNumber);\n}\n\nlet scopeResolvedForTest: (...arg0: unknown[]) => void = function(): void {};\n\nexport const getScopeResolvedForTest = (): (...arg0: unknown[]) => void => {\n  return scopeResolvedForTest;\n};\n\nexport const setScopeResolvedForTest = (scope: (...arg0: unknown[]) => void): void => {\n  scopeResolvedForTest = scope;\n};\n"]}