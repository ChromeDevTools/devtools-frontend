{"version":3,"file":"ScopeChainModel.js","sourceRoot":"","sources":["../../../../../../front_end/models/source_map_scopes/ScopeChainModel.ts"],"names":[],"mappings":"AAAA,sCAAsC;AACtC,yEAAyE;AACzE,6BAA6B;AAE7B,OAAO,KAAK,MAAM,MAAM,6BAA6B,CAAC;AACtD,OAAO,KAAK,GAAG,MAAM,uBAAuB,CAAC;AAE7C,OAAO,EAAC,iBAAiB,EAAC,MAAM,oBAAoB,CAAC;AAErD;;;;;;;;;;;GAWG;AACH,MAAM,OAAO,eAAgB,SAAQ,MAAM,CAAC,aAAa,CAAC,aAAyB;IACxE,UAAU,CAA8B;IAEjD,2GAA2G;IAClG,UAAU,GAAG,IAAI,MAAM,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;IAC/C,YAAY,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAEhD,YAAY,SAAsC;QAChD,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,UAAU,GAAG,SAAS,CAAC;QAC5B,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,gBAAgB,CAC1C,GAAG,CAAC,aAAa,CAAC,MAAM,CAAC,iBAAiB,EAAE,IAAI,CAAC,kBAAkB,EAAE,IAAI,CAAC,CAAC;QAC/E,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,gBAAgB,EAAE,CAAC,gBAAgB,CAC7D,GAAG,CAAC,gBAAgB,CAAC,MAAM,CAAC,iBAAiB,EAAE,IAAI,CAAC,kBAAkB,EAAE,IAAI,CAAC,CAAC;QAElF,KAAK,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;IACnD,CAAC;IAED,OAAO;QACL,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,mBAAmB,CAC7C,GAAG,CAAC,aAAa,CAAC,MAAM,CAAC,iBAAiB,EAAE,IAAI,CAAC,kBAAkB,EAAE,IAAI,CAAC,CAAC;QAC/E,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,gBAAgB,EAAE,CAAC,mBAAmB,CAChE,GAAG,CAAC,gBAAgB,CAAC,MAAM,CAAC,iBAAiB,EAAE,IAAI,CAAC,kBAAkB,EAAE,IAAI,CAAC,CAAC;QAClF,IAAI,CAAC,SAAS,EAAE,KAAK,EAAE,CAAC;IAC1B,CAAC;IAED,KAAK,CAAC,OAAO;QACX,MAAM,UAAU,GAAG,MAAM,iBAAiB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QAC5D,IAAI,CAAC,wBAAwB,uDAA6B,IAAI,UAAU,CAAC,UAAU,CAAC,CAAC,CAAC;IACxF,CAAC;IAED,kBAAkB,CAAC,KAA6D;QAC9E,IAAI,KAAK,CAAC,IAAI,KAAK,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC;YAC1C,KAAK,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;QACnD,CAAC;IACH,CAAC;IAED,kBAAkB,CAAC,KACsF;QACvG,IAAI,KAAK,CAAC,IAAI,CAAC,MAAM,KAAK,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC;YACjD,KAAK,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;QACnD,CAAC;IACH,CAAC;CACF;AAUD;;GAEG;AACH,MAAM,OAAO,UAAU;IACZ,UAAU,CAAsC;IAEzD,YAAY,UAA+C;QACzD,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;IAC/B,CAAC;CACF","sourcesContent":["// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport * as SDK from '../../core/sdk/sdk.js';\n\nimport {resolveScopeChain} from './NamesResolver.js';\n\n/**\n * This class is responsible for resolving / updating the scope chain for a specific {@link SDK.DebuggerModel.CallFrame}\n * instance.\n *\n * There are several sources that can influence the scope view:\n *   - Debugger plugins can provide the whole scope info (e.g. from DWARF)\n *   - Source Maps can provide OR augment scope info\n *\n * Source maps can be enabled/disabled dynamically and debugger plugins can attach debug info after the fact.\n *\n * This class tracks all that and sends events with the latest scope chain for a specific call frame.\n */\nexport class ScopeChainModel extends Common.ObjectWrapper.ObjectWrapper<EventTypes> {\n  readonly #callFrame: SDK.DebuggerModel.CallFrame;\n\n  /** We use the `Throttler` here to make sure that `#boundUpdate` is not run multiple times simultanously */\n  readonly #throttler = new Common.Throttler.Throttler(5);\n  readonly #boundUpdate = this.#update.bind(this);\n\n  constructor(callFrame: SDK.DebuggerModel.CallFrame) {\n    super();\n    this.#callFrame = callFrame;\n    this.#callFrame.debuggerModel.addEventListener(\n        SDK.DebuggerModel.Events.DebugInfoAttached, this.#debugInfoAttached, this);\n    this.#callFrame.debuggerModel.sourceMapManager().addEventListener(\n        SDK.SourceMapManager.Events.SourceMapAttached, this.#sourceMapAttached, this);\n\n    void this.#throttler.schedule(this.#boundUpdate);\n  }\n\n  dispose(): void {\n    this.#callFrame.debuggerModel.removeEventListener(\n        SDK.DebuggerModel.Events.DebugInfoAttached, this.#debugInfoAttached, this);\n    this.#callFrame.debuggerModel.sourceMapManager().removeEventListener(\n        SDK.SourceMapManager.Events.SourceMapAttached, this.#sourceMapAttached, this);\n    this.listeners?.clear();\n  }\n\n  async #update(): Promise<void> {\n    const scopeChain = await resolveScopeChain(this.#callFrame);\n    this.dispatchEventToListeners(Events.SCOPE_CHAIN_UPDATED, new ScopeChain(scopeChain));\n  }\n\n  #debugInfoAttached(event: Common.EventTarget.EventTargetEvent<SDK.Script.Script>): void {\n    if (event.data === this.#callFrame.script) {\n      void this.#throttler.schedule(this.#boundUpdate);\n    }\n  }\n\n  #sourceMapAttached(event: Common.EventTarget\n                         .EventTargetEvent<{client: SDK.Script.Script, sourceMap: SDK.SourceMap.SourceMap}>): void {\n    if (event.data.client === this.#callFrame.script) {\n      void this.#throttler.schedule(this.#boundUpdate);\n    }\n  }\n}\n\nexport const enum Events {\n  SCOPE_CHAIN_UPDATED = 'ScopeChainUpdated',\n}\n\nexport interface EventTypes {\n  [Events.SCOPE_CHAIN_UPDATED]: ScopeChain;\n}\n\n/**\n * A scope chain ready to be shown in the UI with debugging info applied.\n */\nexport class ScopeChain {\n  readonly scopeChain: SDK.DebuggerModel.ScopeChainEntry[];\n\n  constructor(scopeChain: SDK.DebuggerModel.ScopeChainEntry[]) {\n    this.scopeChain = scopeChain;\n  }\n}\n"]}