{
  "version": 3,
  "sources": ["../../../../../../front_end/models/source_map_scopes/FunctionCodeResolver.ts", "../../../../../../front_end/models/source_map_scopes/NamesResolver.ts", "../../../../../../front_end/models/source_map_scopes/ScopeChainModel.ts"],
  "sourcesContent": ["// Copyright 2025 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Platform from '../../core/platform/platform.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport * as Bindings from '../bindings/bindings.js';\nimport * as Formatter from '../formatter/formatter.js';\nimport * as TextUtils from '../text_utils/text_utils.js';\nimport * as Workspace from '../workspace/workspace.js';\n\n/** Represents the source code for a given function, including additional context of surrounding lines. */\nexport interface FunctionCode {\n  functionBounds: Workspace.UISourceCode.UIFunctionBounds;\n  /** The text of `uiSourceCode`. */\n  text: TextUtils.Text.Text;\n  /** The function text. */\n  code: string;\n  /** The range of `code` within `text`. */\n  range: TextUtils.TextRange.TextRange;\n  /** The function text, plus some additional context before and after. The actual function is wrapped in <FUNCTION_START>...<FUNCTION_END> */\n  codeWithContext: string;\n  /** The range of `codeWithContext` within `text`. */\n  rangeWithContext: TextUtils.TextRange.TextRange;\n}\n\nexport interface CreateFunctionCodeOptions {\n  /** Number of characters to include before and after the function. Stacks with `contextLineLength`. */\n  contextLength?: number;\n  /** Number of lines to include before and after the function. Stacks with `contextLength`. */\n  contextLineLength?: number;\n  /** If true, appends profile data from the trace at the end of every line of the function in `codeWithContext`. This should match what is seen in the formatted view in the Sources panel. */\n  appendProfileData?: boolean;\n}\n\ninterface InputData {\n  text: TextUtils.Text.Text;\n  formattedContent: Formatter.ScriptFormatter.FormattedContent|null;\n  performanceData: Workspace.UISourceCode.LineColumnProfileMap|undefined;\n}\n\nconst inputCache = new WeakMap<Workspace.UISourceCode.UISourceCode, Promise<InputData>>();\n\nasync function prepareInput(uiSourceCode: Workspace.UISourceCode.UISourceCode, content: string): Promise<InputData> {\n  const formattedContent = await format(uiSourceCode, content);\n  const text = new TextUtils.Text.Text(formattedContent ? formattedContent.formattedContent : content);\n  let performanceData = uiSourceCode.getDecorationData(Workspace.UISourceCode.DecoratorType.PERFORMANCE) as\n          Workspace.UISourceCode.LineColumnProfileMap |\n      undefined;\n\n  // Map profile data to the formatted view of the text.\n  if (formattedContent && performanceData) {\n    performanceData = Workspace.UISourceCode.createMappedProfileData(performanceData, (line, column) => {\n      return formattedContent.formattedMapping.originalToFormatted(line, column);\n    });\n  }\n\n  return {text, formattedContent, performanceData};\n}\n\n/** Formatting and parsing line endings for Text is expensive, so cache it. */\nasync function prepareInputAndCache(\n    uiSourceCode: Workspace.UISourceCode.UISourceCode, content: string): Promise<InputData> {\n  let cachedPromise = inputCache.get(uiSourceCode);\n  if (cachedPromise) {\n    return await cachedPromise;\n  }\n\n  cachedPromise = prepareInput(uiSourceCode, content);\n  inputCache.set(uiSourceCode, cachedPromise);\n  return await cachedPromise;\n}\n\nfunction extractPerformanceDataByLine(\n    textRange: TextUtils.TextRange.TextRange, performanceData: Workspace.UISourceCode.LineColumnProfileMap): number[] {\n  const {startLine, startColumn, endLine, endColumn} = textRange;\n  const byLine = new Array(endLine - startLine + 1).fill(0);\n\n  for (let line = startLine; line <= endLine; line++) {\n    const lineData = performanceData.get(line + 1);\n    if (!lineData) {\n      continue;\n    }\n\n    // Fast-path for when the entire line's data is relevant.\n    if (line !== startLine && line !== endLine) {\n      byLine[line - startLine] = lineData.values().reduce((acc, cur) => acc + cur);\n      continue;\n    }\n\n    const column0 = line === startLine ? startColumn + 1 : 0;\n    const column1 = line === endLine ? endColumn + 1 : Number.POSITIVE_INFINITY;\n\n    let totalData = 0;\n    for (const [column, data] of lineData) {\n      if (column >= column0 && column <= column1) {\n        totalData += data;\n      }\n    }\n\n    byLine[line - startLine] = totalData;\n  }\n\n  return byLine.map(data => Math.round(data * 10) / 10);\n}\n\nfunction createFunctionCode(\n    inputData: InputData, functionBounds: Workspace.UISourceCode.UIFunctionBounds,\n    options?: CreateFunctionCodeOptions): FunctionCode {\n  let {startLine, startColumn, endLine, endColumn} = functionBounds.range;\n  if (inputData.formattedContent) {\n    const startMapped = inputData.formattedContent.formattedMapping.originalToFormatted(startLine, startColumn);\n    startLine = startMapped[0];\n    startColumn = startMapped[1];\n\n    const endMapped = inputData.formattedContent.formattedMapping.originalToFormatted(endLine, endColumn);\n    endLine = endMapped[0];\n    endColumn = endMapped[1];\n  }\n\n  const text = inputData.text;\n  const content = text.value();\n\n  // Define two ranges - the first is just the function bounds, the second includes\n  // that plus some surrounding context as dictated by the options.\n  const range = new TextUtils.TextRange.TextRange(startLine, startColumn, endLine, endColumn);\n\n  const functionStartOffset = text.offsetFromPosition(startLine, startColumn);\n  const functionEndOffset = text.offsetFromPosition(endLine, endColumn);\n\n  let contextStartOffset = 0;\n  if (options?.contextLength !== undefined) {\n    const contextLength = options.contextLength;\n    contextStartOffset = Math.max(contextStartOffset, functionStartOffset - contextLength);\n  }\n  if (options?.contextLineLength !== undefined) {\n    const contextLineLength = options.contextLineLength;\n    const position = text.offsetFromPosition(Math.max(startLine - contextLineLength, 0), 0);\n    contextStartOffset = Math.max(contextStartOffset, position);\n  }\n\n  let contextEndOffset = content.length;\n  if (options?.contextLength !== undefined) {\n    const contextLength = options.contextLength;\n    contextEndOffset = Math.min(contextEndOffset, functionEndOffset + contextLength);\n  }\n  if (options?.contextLineLength !== undefined) {\n    const contextLineLength = options.contextLineLength;\n    const position =\n        text.offsetFromPosition(Math.min(endLine + contextLineLength, text.lineCount() - 1), Number.POSITIVE_INFINITY);\n    contextEndOffset = Math.min(contextEndOffset, position);\n  }\n\n  const contextStart = text.positionFromOffset(contextStartOffset);\n  const contextEnd = text.positionFromOffset(contextEndOffset);\n  const rangeWithContext = new TextUtils.TextRange.TextRange(\n      contextStart.lineNumber, contextStart.columnNumber, contextEnd.lineNumber, contextEnd.columnNumber);\n\n  // Grab substrings for the function range, and for the context range.\n  const code = content.substring(functionStartOffset, functionEndOffset);\n  const before = content.substring(contextStartOffset, functionStartOffset);\n  const after = content.substring(functionEndOffset, contextEndOffset);\n\n  let codeWithContext;\n  if (options?.appendProfileData && inputData.performanceData) {\n    const performanceDataByLine = extractPerformanceDataByLine(range, inputData.performanceData);\n    const lines = performanceDataByLine.map((data, i) => {\n      let line = text.lineAt(startLine + i);\n\n      const isLastLine = i === performanceDataByLine.length - 1;\n      if (i === 0) {\n        if (isLastLine) {\n          line = line.substring(startColumn, endColumn);\n        } else {\n          line = line.substring(startColumn);\n        }\n      } else if (isLastLine) {\n        line = line.substring(0, endColumn);\n      }\n\n      if (isLastLine) {\n        // Don't ever annotate the last line - it could make the rest of the code on\n        // that line get commented out.\n        data = 0;\n      }\n\n      return data ? `${line} // ${data} ms` : line;\n    });\n    const annotatedCode = lines.join('\\n');\n    codeWithContext = before + `<FUNCTION_START>${annotatedCode}<FUNCTION_END>` + after;\n  } else {\n    codeWithContext = before + `<FUNCTION_START>${code}<FUNCTION_END>` + after;\n  }\n\n  return {\n    functionBounds,\n    text,\n    code,\n    range,\n    codeWithContext,\n    rangeWithContext,\n  };\n}\n\n/**\n * The input location may be a source mapped location or a raw location.\n */\nexport async function getFunctionCodeFromLocation(\n    target: SDK.Target.Target, url: Platform.DevToolsPath.UrlString, line: number, column: number,\n    options?: CreateFunctionCodeOptions): Promise<FunctionCode|null> {\n  const debuggerModel = target.model(SDK.DebuggerModel.DebuggerModel);\n  if (!debuggerModel) {\n    throw new Error('missing debugger model');\n  }\n\n  let uiSourceCode;\n  const debuggerWorkspaceBinding = Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding.instance();\n  const projects = debuggerWorkspaceBinding.workspace.projectsForType(Workspace.Workspace.projectTypes.Network);\n  for (const project of projects) {\n    uiSourceCode = project.uiSourceCodeForURL(url);\n    if (uiSourceCode) {\n      break;\n    }\n  }\n\n  if (!uiSourceCode) {\n    return null;\n  }\n\n  const rawLocations = await debuggerWorkspaceBinding.uiLocationToRawLocations(uiSourceCode, line, column);\n  const rawLocation = rawLocations.at(-1);\n  if (!rawLocation) {\n    return null;\n  }\n\n  return await getFunctionCodeFromRawLocation(rawLocation, options);\n}\n\nasync function format(uiSourceCode: Workspace.UISourceCode.UISourceCode, content: string):\n    Promise<Formatter.ScriptFormatter.FormattedContent|null> {\n  const contentType = uiSourceCode.contentType();\n  const shouldFormat = !contentType.isFromSourceMap() && (contentType.isDocument() || contentType.isScript()) &&\n      TextUtils.TextUtils.isMinified(content);\n  if (!shouldFormat) {\n    return null;\n  }\n\n  return await Formatter.ScriptFormatter.formatScriptContent(contentType.canonicalMimeType(), content, '\\t');\n}\n\n/**\n * Returns a {@link FunctionCode} for the given raw location.\n */\nexport async function getFunctionCodeFromRawLocation(\n    rawLocation: SDK.DebuggerModel.Location, options?: CreateFunctionCodeOptions): Promise<FunctionCode|null> {\n  const debuggerWorkspaceBinding = Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding.instance();\n  const functionBounds = await debuggerWorkspaceBinding.functionBoundsAtRawLocation(rawLocation);\n  if (!functionBounds) {\n    return null;\n  }\n\n  await functionBounds.uiSourceCode.requestContentData();\n  const content = functionBounds.uiSourceCode.content();\n  if (!content) {\n    return null;\n  }\n\n  const inputData = await prepareInputAndCache(functionBounds.uiSourceCode, content);\n  return createFunctionCode(inputData, functionBounds, options);\n}\n", "// Copyright 2022 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport * as Root from '../../core/root/root.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport * as Protocol from '../../generated/protocol.js';\nimport * as Bindings from '../bindings/bindings.js';\nimport * as Formatter from '../formatter/formatter.js';\nimport * as TextUtils from '../text_utils/text_utils.js';\n\ninterface CachedScopeMap {\n  sourceMap: SDK.SourceMap.SourceMap|undefined;\n  mappingPromise: Promise<{variableMapping: Map<string, string>, thisMapping: string|null}>;\n}\n\nconst scopeToCachedIdentifiersMap = new WeakMap<Formatter.FormatterWorkerPool.ScopeTreeNode, CachedScopeMap>();\nconst cachedMapByCallFrame = new WeakMap<SDK.DebuggerModel.CallFrame, Map<string, string|null>>();\n\nexport async function getTextFor(contentProvider: TextUtils.ContentProvider.ContentProvider):\n    Promise<TextUtils.Text.Text|null> {\n  const contentData = await contentProvider.requestContentData();\n  if (TextUtils.ContentData.ContentData.isError(contentData) || !contentData.isTextContent) {\n    return null;\n  }\n  return contentData.textObj;\n}\n\nexport class IdentifierPositions {\n  name: string;\n  positions: Array<{lineNumber: number, columnNumber: number}>;\n\n  constructor(name: string, positions: Array<{lineNumber: number, columnNumber: number}> = []) {\n    this.name = name;\n    this.positions = positions;\n  }\n\n  addPosition(lineNumber: number, columnNumber: number): void {\n    this.positions.push({lineNumber, columnNumber});\n  }\n}\n\nconst computeScopeTree = async function(script: SDK.Script.Script): Promise<{\nscopeTree:\n  Formatter.FormatterWorkerPool.ScopeTreeNode, text: TextUtils.Text.Text,\n}|null> {\n  if (!script.sourceMapURL) {\n    return null;\n  }\n\n  return await SDK.ScopeTreeCache.scopeTreeForScript(script);\n};\n\n/**\n * @returns the scope chain from outer-most to inner-most scope where the inner-most\n * scope either contains or matches the \"needle\".\n */\nconst findScopeChain = function(\n                           scopeTree: Formatter.FormatterWorkerPool.ScopeTreeNode,\n                           scopeNeedle: {start: number, end: number}): Formatter.FormatterWorkerPool.ScopeTreeNode[] {\n  if (!contains(scopeTree, scopeNeedle)) {\n    return [];\n  }\n\n  // Find the corresponding scope in the scope tree.\n  let containingScope = scopeTree;\n  const scopeChain = [scopeTree];\n  while (true) {\n    let childFound = false;\n    for (const child of containingScope.children) {\n      if (contains(child, scopeNeedle)) {\n        // We found a nested containing scope, continue with search there.\n        scopeChain.push(child);\n        containingScope = child;\n        childFound = true;\n        break;\n      }\n      // Sanity check: |scope| should not straddle any of the scopes in the tree. That is:\n      // Either |scope| is disjoint from |child| or |child| must be inside |scope|.\n      // (Or the |scope| is inside |child|, but that case is covered above.)\n      if (!disjoint(scopeNeedle, child) && !contains(scopeNeedle, child)) {\n        console.error('Wrong nesting of scopes');\n        return [];\n      }\n    }\n    if (!childFound) {\n      // We found the deepest scope in the tree that contains our scope chain entry.\n      break;\n    }\n  }\n\n  return scopeChain;\n\n  function contains(scope: {start: number, end: number}, candidate: {start: number, end: number}): boolean {\n    return (scope.start <= candidate.start) && (scope.end >= candidate.end);\n  }\n  function disjoint(scope: {start: number, end: number}, other: {start: number, end: number}): boolean {\n    return (scope.end <= other.start) || (other.end <= scope.start);\n  }\n};\n\nexport async function findScopeChainForDebuggerScope(scope: SDK.DebuggerModel.ScopeChainEntry):\n    Promise<Formatter.FormatterWorkerPool.ScopeTreeNode[]> {\n  const startLocation = scope.range()?.start;\n  const endLocation = scope.range()?.end;\n  if (!startLocation || !endLocation) {\n    return [];\n  }\n\n  const script = startLocation.script();\n  if (!script) {\n    return [];\n  }\n\n  const scopeTreeAndText = await computeScopeTree(script);\n  if (!scopeTreeAndText) {\n    return [];\n  }\n  const {scopeTree, text} = scopeTreeAndText;\n\n  // Compute the offset within the scope tree coordinate space.\n  const scopeOffsets = {\n    start: text.offsetFromPosition(startLocation.lineNumber, startLocation.columnNumber),\n    end: text.offsetFromPosition(endLocation.lineNumber, endLocation.columnNumber),\n  };\n\n  return findScopeChain(scopeTree, scopeOffsets);\n}\n\nexport const scopeIdentifiers = async function(\n    script: SDK.Script.Script, scope: Formatter.FormatterWorkerPool.ScopeTreeNode,\n    ancestorScopes: Formatter.FormatterWorkerPool.ScopeTreeNode[]): Promise<{\nfreeVariables:\n  IdentifierPositions[], boundVariables: IdentifierPositions[],\n}|null> {\n  const text = await getTextFor(script);\n  if (!text) {\n    return null;\n  }\n\n  // Now we have containing scope. Collect all the scope variables.\n  const boundVariables = [];\n  const cursor = new TextUtils.TextCursor.TextCursor(text.lineEndings());\n  for (const variable of scope.variables) {\n    // Skip the fixed-kind variable (i.e., 'this' or 'arguments') if we only found their \"definition\"\n    // without any uses.\n    if (variable.kind === Formatter.FormatterWorkerPool.DefinitionKind.FIXED && variable.offsets.length <= 1) {\n      continue;\n    }\n\n    const identifier = new IdentifierPositions(variable.name);\n    for (const offset of variable.offsets) {\n      cursor.resetTo(offset);\n      identifier.addPosition(cursor.lineNumber(), cursor.columnNumber());\n    }\n    boundVariables.push(identifier);\n  }\n\n  // Compute free variables by collecting all the ancestor variables that are used in |containingScope|.\n  const freeVariables = [];\n  for (const ancestor of ancestorScopes) {\n    for (const ancestorVariable of ancestor.variables) {\n      let identifier = null;\n      for (const offset of ancestorVariable.offsets) {\n        if (offset >= scope.start && offset < scope.end) {\n          if (!identifier) {\n            identifier = new IdentifierPositions(ancestorVariable.name);\n          }\n          cursor.resetTo(offset);\n          identifier.addPosition(cursor.lineNumber(), cursor.columnNumber());\n        }\n      }\n      if (identifier) {\n        freeVariables.push(identifier);\n      }\n    }\n  }\n  return {boundVariables, freeVariables};\n};\n\nconst identifierAndPunctuationRegExp = /^\\s*([A-Za-z_$][A-Za-z_$0-9]*)\\s*([.;,=]?)\\s*$/;\n\nconst enum Punctuation {\n  NONE = 'none',\n  COMMA = 'comma',\n  DOT = 'dot',\n  SEMICOLON = 'semicolon',\n  EQUALS = 'equals',\n}\n\nconst resolveDebuggerScope = async(scope: SDK.DebuggerModel.ScopeChainEntry):\n    Promise<{variableMapping: Map<string, string>, thisMapping: string | null}> => {\n      if (!Common.Settings.Settings.instance().moduleSetting('js-source-maps-enabled').get()) {\n        return {variableMapping: new Map(), thisMapping: null};\n      }\n      const script = scope.callFrame().script;\n      const scopeChain = await findScopeChainForDebuggerScope(scope);\n      return await resolveScope(script, scopeChain);\n    };\n\nconst resolveScope = async(script: SDK.Script.Script, scopeChain: Formatter.FormatterWorkerPool.ScopeTreeNode[]):\n    Promise<{variableMapping: Map<string, string>, thisMapping: string | null}> => {\n      const parsedScope = scopeChain[scopeChain.length - 1];\n      if (!parsedScope) {\n        return {variableMapping: new Map<string, string>(), thisMapping: null};\n      }\n      let cachedScopeMap = scopeToCachedIdentifiersMap.get(parsedScope);\n      const sourceMap = script.sourceMap();\n\n      if (!cachedScopeMap || cachedScopeMap.sourceMap !== sourceMap) {\n        const identifiersPromise =\n            (async () => {\n              const variableMapping = new Map<string, string>();\n              let thisMapping = null;\n\n              if (!sourceMap) {\n                return {variableMapping, thisMapping};\n              }\n              // Extract as much as possible from SourceMap and resolve\n              // missing identifier names from SourceMap ranges.\n              const promises: Array<Promise<void>> = [];\n\n              const resolveEntry = (id: IdentifierPositions, handler: (sourceName: string) => void): void => {\n                // First see if we have a source map entry with a name for the identifier.\n                for (const position of id.positions) {\n                  const entry = sourceMap.findEntry(position.lineNumber, position.columnNumber);\n                  if (entry?.name) {\n                    handler(entry.name);\n                    return;\n                  }\n                }\n                /** If there is no entry with the name field, try to infer the name from the source positions. **/\n                async function resolvePosition(): Promise<void> {\n                  if (!sourceMap) {\n                    return;\n                  }\n                  // Let us find the first non-empty mapping of |id| and return that. Ideally, we would\n                  // try to compute all the mappings and only use the mapping if all the non-empty\n                  // mappings agree. However, that can be expensive for identifiers with many uses,\n                  // so we iterate sequentially, stopping at the first non-empty mapping.\n                  for (const position of id.positions) {\n                    const sourceName = await resolveSourceName(script, sourceMap, id.name, position);\n                    if (sourceName) {\n                      handler(sourceName);\n                      return;\n                    }\n                  }\n                }\n                promises.push(resolvePosition());\n              };\n\n              const parsedVariables = await scopeIdentifiers(script, parsedScope, scopeChain.slice(0, -1));\n              if (!parsedVariables) {\n                return {variableMapping, thisMapping};\n              }\n              for (const id of parsedVariables.boundVariables) {\n                resolveEntry(id, sourceName => {\n                  // Let use ignore 'this' mappings - those are handled separately.\n                  if (sourceName !== 'this') {\n                    variableMapping.set(id.name, sourceName);\n                  }\n                });\n              }\n              for (const id of parsedVariables.freeVariables) {\n                resolveEntry(id, sourceName => {\n                  if (sourceName === 'this') {\n                    thisMapping = id.name;\n                  }\n                });\n              }\n              await Promise.all(promises).then(getScopeResolvedForTest());\n              return {variableMapping, thisMapping};\n            })();\n        cachedScopeMap = {sourceMap, mappingPromise: identifiersPromise};\n        scopeToCachedIdentifiersMap.set(parsedScope, {sourceMap, mappingPromise: identifiersPromise});\n      }\n      return await cachedScopeMap.mappingPromise;\n\n      async function resolveSourceName(\n          script: SDK.Script.Script, sourceMap: SDK.SourceMap.SourceMap, name: string,\n          position: {lineNumber: number, columnNumber: number}): Promise<string|null> {\n        const ranges = sourceMap.findEntryRanges(position.lineNumber, position.columnNumber);\n        if (!ranges) {\n          return null;\n        }\n        // Extract the underlying text from the compiled code's range and make sure that\n        // it starts with the identifier |name|.\n        const uiSourceCode =\n            Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding.instance().uiSourceCodeForSourceMapSourceURL(\n                script.debuggerModel, ranges.sourceURL, script.isContentScript());\n        if (!uiSourceCode) {\n          return null;\n        }\n        const compiledText = await getTextFor(script);\n        if (!compiledText) {\n          return null;\n        }\n        const compiledToken = compiledText.extract(ranges.range);\n        const parsedCompiledToken = extractIdentifier(compiledToken);\n        if (!parsedCompiledToken) {\n          return null;\n        }\n        const {name: compiledName, punctuation: compiledPunctuation} = parsedCompiledToken;\n        if (compiledName !== name) {\n          return null;\n        }\n\n        // Extract the mapped name from the source code range and ensure that the punctuation\n        // matches the one from the compiled code.\n        const sourceText = await getTextFor(uiSourceCode);\n        if (!sourceText) {\n          return null;\n        }\n        const sourceToken = sourceText.extract(ranges.sourceRange);\n        const parsedSourceToken = extractIdentifier(sourceToken);\n        if (!parsedSourceToken) {\n          return null;\n        }\n        const {name: sourceName, punctuation: sourcePunctuation} = parsedSourceToken;\n        // Accept the source name if it is followed by the same punctuation.\n        if (compiledPunctuation === sourcePunctuation) {\n          return sourceName;\n        }\n        // Let us also allow semicolons into commas since that it is a common transformation.\n        if (compiledPunctuation === Punctuation.COMMA && sourcePunctuation === Punctuation.SEMICOLON) {\n          return sourceName;\n        }\n\n        return null;\n\n        function extractIdentifier(token: string): {name: string, punctuation: Punctuation}|null {\n          const match = token.match(identifierAndPunctuationRegExp);\n          if (!match) {\n            return null;\n          }\n\n          const name = match[1];\n          let punctuation: Punctuation|null = null;\n          switch (match[2]) {\n            case '.':\n              punctuation = Punctuation.DOT;\n              break;\n            case ',':\n              punctuation = Punctuation.COMMA;\n              break;\n            case ';':\n              punctuation = Punctuation.SEMICOLON;\n              break;\n            case '=':\n              punctuation = Punctuation.EQUALS;\n              break;\n            case '':\n              punctuation = Punctuation.NONE;\n              break;\n            default:\n              console.error(`Name token parsing error: unexpected token \"${match[2]}\"`);\n              return null;\n          }\n\n          return {name, punctuation};\n        }\n      }\n    };\n\nexport const resolveScopeChain =\n    async function(callFrame: SDK.DebuggerModel.CallFrame): Promise<SDK.DebuggerModel.ScopeChainEntry[]> {\n  const {pluginManager} = Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding.instance();\n  let scopeChain: SDK.DebuggerModel.ScopeChainEntry[]|null|undefined = await pluginManager.resolveScopeChain(callFrame);\n  if (scopeChain) {\n    return scopeChain;\n  }\n\n  scopeChain = Root.Runtime.experiments.isEnabled(Root.Runtime.ExperimentName.USE_SOURCE_MAP_SCOPES) ?\n      callFrame.script.sourceMap()?.resolveScopeChain(callFrame) :\n      null;\n  if (scopeChain) {\n    return scopeChain;\n  }\n\n  if (callFrame.script.isWasm()) {\n    return callFrame.scopeChain();\n  }\n  const thisObject = await resolveThisObject(callFrame);\n  return callFrame.scopeChain().map(scope => new ScopeWithSourceMappedVariables(scope, thisObject));\n};\n\n/**\n * @returns A mapping from original name -> compiled name. If the orignal name is unavailable (e.g. because the compiled name was\n * shadowed) we set it to `null`.\n */\nexport const allVariablesInCallFrame =\n    async(callFrame: SDK.DebuggerModel.CallFrame): Promise<Map<string, string|null>> => {\n  if (!Common.Settings.Settings.instance().moduleSetting('js-source-maps-enabled').get()) {\n    return new Map<string, string|null>();\n  }\n  const cachedMap = cachedMapByCallFrame.get(callFrame);\n  if (cachedMap) {\n    return cachedMap;\n  }\n\n  const scopeChain = callFrame.scopeChain();\n  const nameMappings = await Promise.all(scopeChain.map(resolveDebuggerScope));\n  const reverseMapping = new Map<string, string|null>();\n  const compiledNames = new Set<string>();\n  for (const {variableMapping} of nameMappings) {\n    for (const [compiledName, originalName] of variableMapping) {\n      if (!originalName) {\n        continue;\n      }\n      if (!reverseMapping.has(originalName)) {\n        // An inner scope might have shadowed {compiledName}. Mark it as \"unavailable\" in that case.\n        const compiledNameOrNull = compiledNames.has(compiledName) ? null : compiledName;\n        reverseMapping.set(originalName, compiledNameOrNull);\n      }\n      compiledNames.add(compiledName);\n    }\n  }\n  cachedMapByCallFrame.set(callFrame, reverseMapping);\n  return reverseMapping;\n};\n\n/**\n * @returns A mapping from original name -> compiled name. If the orignal name is unavailable (e.g. because the compiled name was\n * shadowed) we set it to `null`.\n */\nexport const allVariablesAtPosition =\n    async(location: SDK.DebuggerModel.Location): Promise<Map<string, string|null>> => {\n  const reverseMapping = new Map<string, string|null>();\n  if (!Common.Settings.Settings.instance().moduleSetting('js-source-maps-enabled').get()) {\n    return reverseMapping;\n  }\n  const script = location.script();\n  if (!script) {\n    return reverseMapping;\n  }\n\n  const scopeTreeAndText = await computeScopeTree(script);\n  if (!scopeTreeAndText) {\n    return reverseMapping;\n  }\n\n  const {scopeTree, text} = scopeTreeAndText;\n  const locationOffset = text.offsetFromPosition(location.lineNumber, location.columnNumber);\n  const scopeChain = findScopeChain(scopeTree, {start: locationOffset, end: locationOffset});\n  const compiledNames = new Set<string>();\n\n  while (scopeChain.length > 0) {\n    const {variableMapping} = await resolveScope(script, scopeChain);\n    for (const [compiledName, originalName] of variableMapping) {\n      if (!originalName) {\n        continue;\n      }\n      if (!reverseMapping.has(originalName)) {\n        // An inner scope might have shadowed {compiledName}. Mark it as \"unavailable\" in that case.\n        const compiledNameOrNull = compiledNames.has(compiledName) ? null : compiledName;\n        reverseMapping.set(originalName, compiledNameOrNull);\n      }\n      compiledNames.add(compiledName);\n    }\n    scopeChain.pop();\n  }\n  return reverseMapping;\n};\n\nexport const resolveThisObject =\n    async(callFrame: SDK.DebuggerModel.CallFrame): Promise<SDK.RemoteObject.RemoteObject|null> => {\n  const scopeChain = callFrame.scopeChain();\n  if (scopeChain.length === 0) {\n    return callFrame.thisObject();\n  }\n\n  const {thisMapping} = await resolveDebuggerScope(scopeChain[0]);\n  if (!thisMapping) {\n    return callFrame.thisObject();\n  }\n\n  const result = await callFrame.evaluate(({\n    expression: thisMapping,\n    objectGroup: 'backtrace',\n    includeCommandLineAPI: false,\n    silent: true,\n    returnByValue: false,\n    generatePreview: true,\n  }));\n  if ('exceptionDetails' in result) {\n    return !result.exceptionDetails && result.object ? result.object : callFrame.thisObject();\n  }\n  return null;\n};\n\nexport const resolveScopeInObject = function(scope: SDK.DebuggerModel.ScopeChainEntry): SDK.RemoteObject.RemoteObject {\n  const endLocation = scope.range()?.end;\n  const startLocationScript = scope.range()?.start.script() ?? null;\n\n  if (scope.type() === Protocol.Debugger.ScopeType.Global || !startLocationScript || !endLocation ||\n      !startLocationScript.sourceMapURL) {\n    return scope.object();\n  }\n\n  return new RemoteObject(scope);\n};\n\n/**\n * Wraps a debugger `Scope` but returns a scope object where variable names are\n * mapped to their authored name.\n *\n * This implementation does not utilize source map \"Scopes\" information but obtains\n * original variable names via parsing + mappings + names.\n */\nclass ScopeWithSourceMappedVariables implements SDK.DebuggerModel.ScopeChainEntry {\n  readonly #debuggerScope: SDK.DebuggerModel.ScopeChainEntry;\n  /** The resolved `this` of the current call frame */\n  readonly #thisObject: SDK.RemoteObject.RemoteObject|null;\n\n  constructor(scope: SDK.DebuggerModel.ScopeChainEntry, thisObject: SDK.RemoteObject.RemoteObject|null) {\n    this.#debuggerScope = scope;\n    this.#thisObject = thisObject;\n  }\n\n  callFrame(): SDK.DebuggerModel.CallFrame {\n    return this.#debuggerScope.callFrame();\n  }\n\n  type(): string {\n    return this.#debuggerScope.type();\n  }\n\n  typeName(): string {\n    return this.#debuggerScope.typeName();\n  }\n\n  name(): string|undefined {\n    return this.#debuggerScope.name();\n  }\n\n  range(): SDK.DebuggerModel.LocationRange|null {\n    return this.#debuggerScope.range();\n  }\n\n  object(): SDK.RemoteObject.RemoteObject {\n    return resolveScopeInObject(this.#debuggerScope);\n  }\n\n  description(): string {\n    return this.#debuggerScope.description();\n  }\n\n  icon(): string|undefined {\n    return this.#debuggerScope.icon();\n  }\n\n  extraProperties(): SDK.RemoteObject.RemoteObjectProperty[] {\n    const extraProperties = this.#debuggerScope.extraProperties();\n    if (this.#thisObject && this.type() === Protocol.Debugger.ScopeType.Local) {\n      extraProperties.unshift(new SDK.RemoteObject.RemoteObjectProperty(\n          'this', this.#thisObject, undefined, undefined, undefined, undefined, undefined, /* synthetic */ true));\n    }\n    return extraProperties;\n  }\n}\n\nexport class RemoteObject extends SDK.RemoteObject.RemoteObject {\n  private readonly scope: SDK.DebuggerModel.ScopeChainEntry;\n  private readonly object: SDK.RemoteObject.RemoteObject;\n  constructor(scope: SDK.DebuggerModel.ScopeChainEntry) {\n    super();\n    this.scope = scope;\n    this.object = scope.object();\n  }\n\n  override customPreview(): Protocol.Runtime.CustomPreview|null {\n    return this.object.customPreview();\n  }\n\n  override get objectId(): Protocol.Runtime.RemoteObjectId|undefined {\n    return this.object.objectId;\n  }\n\n  override get type(): string {\n    return this.object.type;\n  }\n\n  override get subtype(): string|undefined {\n    return this.object.subtype;\n  }\n\n  override get value(): typeof this.object.value {\n    return this.object.value;\n  }\n\n  override get description(): string|undefined {\n    return this.object.description;\n  }\n\n  override get hasChildren(): boolean {\n    return this.object.hasChildren;\n  }\n\n  override get preview(): Protocol.Runtime.ObjectPreview|undefined {\n    return this.object.preview;\n  }\n\n  override arrayLength(): number {\n    return this.object.arrayLength();\n  }\n\n  override getOwnProperties(generatePreview: boolean): Promise<SDK.RemoteObject.GetPropertiesResult> {\n    return this.object.getOwnProperties(generatePreview);\n  }\n\n  override async getAllProperties(accessorPropertiesOnly: boolean, generatePreview: boolean):\n      Promise<SDK.RemoteObject.GetPropertiesResult> {\n    const allProperties = await this.object.getAllProperties(accessorPropertiesOnly, generatePreview);\n    const {variableMapping} = await resolveDebuggerScope(this.scope);\n\n    const properties = allProperties.properties;\n    const internalProperties = allProperties.internalProperties;\n    const newProperties = properties?.map(property => {\n      const name = variableMapping.get(property.name);\n      return name !== undefined ? property.cloneWithNewName(name) : property;\n    });\n    return {properties: newProperties ?? [], internalProperties};\n  }\n\n  override async setPropertyValue(argumentName: string|Protocol.Runtime.CallArgument, value: string):\n      Promise<string|undefined> {\n    const {variableMapping} = await resolveDebuggerScope(this.scope);\n\n    let name;\n    if (typeof argumentName === 'string') {\n      name = argumentName;\n    } else {\n      name = (argumentName.value as string);\n    }\n\n    let actualName: string = name;\n    for (const compiledName of variableMapping.keys()) {\n      if (variableMapping.get(compiledName) === name) {\n        actualName = compiledName;\n        break;\n      }\n    }\n    return await this.object.setPropertyValue(actualName, value);\n  }\n\n  override async deleteProperty(name: Protocol.Runtime.CallArgument): Promise<string|undefined> {\n    return await this.object.deleteProperty(name);\n  }\n\n  override callFunction<T, U>(\n      functionDeclaration: (this: U, ...args: any[]) => T,\n      args?: Protocol.Runtime.CallArgument[]): Promise<SDK.RemoteObject.CallFunctionResult> {\n    return this.object.callFunction(functionDeclaration, args);\n  }\n\n  override callFunctionJSON<T, U>(\n      functionDeclaration: (this: U, ...args: any[]) => T, args?: Protocol.Runtime.CallArgument[]): Promise<T|null> {\n    return this.object.callFunctionJSON(functionDeclaration, args);\n  }\n\n  override release(): void {\n    this.object.release();\n  }\n\n  override debuggerModel(): SDK.DebuggerModel.DebuggerModel {\n    return this.object.debuggerModel();\n  }\n\n  override runtimeModel(): SDK.RuntimeModel.RuntimeModel {\n    return this.object.runtimeModel();\n  }\n\n  override isNode(): boolean {\n    return this.object.isNode();\n  }\n}\n\n/**\n * Resolve the frame's function name using the name associated with the opening\n * paren that starts the scope. If there is no name associated with the scope\n * start or if the function scope does not start with a left paren (e.g., arrow\n * function with one parameter), the resolution returns null.\n **/\nasync function getFunctionNameFromScopeStart(\n    script: SDK.Script.Script, lineNumber: number, columnNumber: number): Promise<string|null> {\n  // To reduce the overhead of resolving function names,\n  // we check for source maps first and immediately leave\n  // this function if the script doesn't have a sourcemap.\n  const sourceMap = script.sourceMap();\n  if (!sourceMap) {\n    return null;\n  }\n\n  const scopeName = sourceMap.findOriginalFunctionName({line: lineNumber, column: columnNumber});\n  if (scopeName !== null) {\n    return scopeName;\n  }\n\n  const mappingEntry = sourceMap.findEntry(lineNumber, columnNumber);\n  if (!mappingEntry?.sourceURL) {\n    return null;\n  }\n\n  const name = mappingEntry.name;\n  if (!name) {\n    return null;\n  }\n\n  const text = await getTextFor(script);\n  if (!text) {\n    return null;\n  }\n\n  const openRange = new TextUtils.TextRange.TextRange(lineNumber, columnNumber, lineNumber, columnNumber + 1);\n\n  if (text.extract(openRange) !== '(') {\n    return null;\n  }\n\n  return name;\n}\n\nexport async function resolveDebuggerFrameFunctionName(frame: SDK.DebuggerModel.CallFrame): Promise<string|null> {\n  const startLocation = frame.localScope()?.range()?.start;\n  if (!startLocation) {\n    return null;\n  }\n  return await getFunctionNameFromScopeStart(frame.script, startLocation.lineNumber, startLocation.columnNumber);\n}\n\nexport async function resolveProfileFrameFunctionName(\n    {scriptId, lineNumber, columnNumber}: Partial<Protocol.Runtime.CallFrame>,\n    target: SDK.Target.Target|null): Promise<string|null> {\n  if (!target || lineNumber === undefined || columnNumber === undefined || scriptId === undefined) {\n    return null;\n  }\n  const debuggerModel = target.model(SDK.DebuggerModel.DebuggerModel);\n  const script = debuggerModel?.scriptForId(String(scriptId));\n\n  if (!debuggerModel || !script) {\n    return null;\n  }\n\n  const debuggerWorkspaceBinding = Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding.instance();\n  const location = new SDK.DebuggerModel.Location(debuggerModel, scriptId, lineNumber, columnNumber);\n  const functionInfoFromPlugin = await debuggerWorkspaceBinding.pluginManager.getFunctionInfo(script, location);\n  if (functionInfoFromPlugin && 'frames' in functionInfoFromPlugin) {\n    const last = functionInfoFromPlugin.frames.at(-1);\n    if (last?.name) {\n      return last.name;\n    }\n  }\n  return await getFunctionNameFromScopeStart(script, lineNumber, columnNumber);\n}\n\nlet scopeResolvedForTest: (...arg0: unknown[]) => void = function(): void {};\n\nexport const getScopeResolvedForTest = (): (...arg0: unknown[]) => void => {\n  return scopeResolvedForTest;\n};\n\nexport const setScopeResolvedForTest = (scope: (...arg0: unknown[]) => void): void => {\n  scopeResolvedForTest = scope;\n};\n", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport * as SDK from '../../core/sdk/sdk.js';\n\nimport {resolveScopeChain} from './NamesResolver.js';\n\n/**\n * This class is responsible for resolving / updating the scope chain for a specific {@link SDK.DebuggerModel.CallFrame}\n * instance.\n *\n * There are several sources that can influence the scope view:\n *   - Debugger plugins can provide the whole scope info (e.g. from DWARF)\n *   - Source Maps can provide OR augment scope info\n *\n * Source maps can be enabled/disabled dynamically and debugger plugins can attach debug info after the fact.\n *\n * This class tracks all that and sends events with the latest scope chain for a specific call frame.\n */\nexport class ScopeChainModel extends Common.ObjectWrapper.ObjectWrapper<EventTypes> {\n  readonly #callFrame: SDK.DebuggerModel.CallFrame;\n\n  /** We use the `Throttler` here to make sure that `#boundUpdate` is not run multiple times simultanously */\n  readonly #throttler = new Common.Throttler.Throttler(5);\n  readonly #boundUpdate = this.#update.bind(this);\n\n  constructor(callFrame: SDK.DebuggerModel.CallFrame) {\n    super();\n    this.#callFrame = callFrame;\n    this.#callFrame.debuggerModel.addEventListener(\n        SDK.DebuggerModel.Events.DebugInfoAttached, this.#debugInfoAttached, this);\n    this.#callFrame.debuggerModel.sourceMapManager().addEventListener(\n        SDK.SourceMapManager.Events.SourceMapAttached, this.#sourceMapAttached, this);\n\n    void this.#throttler.schedule(this.#boundUpdate);\n  }\n\n  dispose(): void {\n    this.#callFrame.debuggerModel.removeEventListener(\n        SDK.DebuggerModel.Events.DebugInfoAttached, this.#debugInfoAttached, this);\n    this.#callFrame.debuggerModel.sourceMapManager().removeEventListener(\n        SDK.SourceMapManager.Events.SourceMapAttached, this.#sourceMapAttached, this);\n    this.listeners?.clear();\n  }\n\n  async #update(): Promise<void> {\n    const scopeChain = await resolveScopeChain(this.#callFrame);\n    this.dispatchEventToListeners(Events.SCOPE_CHAIN_UPDATED, new ScopeChain(scopeChain));\n  }\n\n  #debugInfoAttached(event: Common.EventTarget.EventTargetEvent<SDK.Script.Script>): void {\n    if (event.data === this.#callFrame.script) {\n      void this.#throttler.schedule(this.#boundUpdate);\n    }\n  }\n\n  #sourceMapAttached(event: Common.EventTarget\n                         .EventTargetEvent<{client: SDK.Script.Script, sourceMap: SDK.SourceMap.SourceMap}>): void {\n    if (event.data.client === this.#callFrame.script) {\n      void this.#throttler.schedule(this.#boundUpdate);\n    }\n  }\n}\n\nexport const enum Events {\n  SCOPE_CHAIN_UPDATED = 'ScopeChainUpdated',\n}\n\nexport interface EventTypes {\n  [Events.SCOPE_CHAIN_UPDATED]: ScopeChain;\n}\n\n/**\n * A scope chain ready to be shown in the UI with debugging info applied.\n */\nexport class ScopeChain {\n  readonly scopeChain: SDK.DebuggerModel.ScopeChainEntry[];\n\n  constructor(scopeChain: SDK.DebuggerModel.ScopeChainEntry[]) {\n    this.scopeChain = scopeChain;\n  }\n}\n"],
  "mappings": ";;;;;;;AAAA;;;;;AAKA,YAAY,SAAS;AACrB,YAAY,cAAc;AAC1B,YAAY,eAAe;AAC3B,YAAY,eAAe;AAC3B,YAAY,eAAe;AAgC3B,IAAM,aAAa,oBAAI,QAAO;AAE9B,eAAe,aAAa,cAAmD,SAAe;AAC5F,QAAM,mBAAmB,MAAM,OAAO,cAAc,OAAO;AAC3D,QAAM,OAAO,IAAc,eAAK,KAAK,mBAAmB,iBAAiB,mBAAmB,OAAO;AACnG,MAAI,kBAAkB,aAAa;IAAiB;;EAAA;AAKpD,MAAI,oBAAoB,iBAAiB;AACvC,sBAA4B,uBAAa,wBAAwB,iBAAiB,CAAC,MAAM,WAAU;AACjG,aAAO,iBAAiB,iBAAiB,oBAAoB,MAAM,MAAM;IAC3E,CAAC;EACH;AAEA,SAAO,EAAC,MAAM,kBAAkB,gBAAe;AACjD;AAGA,eAAe,qBACX,cAAmD,SAAe;AACpE,MAAI,gBAAgB,WAAW,IAAI,YAAY;AAC/C,MAAI,eAAe;AACjB,WAAO,MAAM;EACf;AAEA,kBAAgB,aAAa,cAAc,OAAO;AAClD,aAAW,IAAI,cAAc,aAAa;AAC1C,SAAO,MAAM;AACf;AAEA,SAAS,6BACL,WAA0C,iBAA4D;AACxG,QAAM,EAAC,WAAW,aAAa,SAAS,UAAS,IAAI;AACrD,QAAM,SAAS,IAAI,MAAM,UAAU,YAAY,CAAC,EAAE,KAAK,CAAC;AAExD,WAAS,OAAO,WAAW,QAAQ,SAAS,QAAQ;AAClD,UAAM,WAAW,gBAAgB,IAAI,OAAO,CAAC;AAC7C,QAAI,CAAC,UAAU;AACb;IACF;AAGA,QAAI,SAAS,aAAa,SAAS,SAAS;AAC1C,aAAO,OAAO,SAAS,IAAI,SAAS,OAAM,EAAG,OAAO,CAAC,KAAK,QAAQ,MAAM,GAAG;AAC3E;IACF;AAEA,UAAM,UAAU,SAAS,YAAY,cAAc,IAAI;AACvD,UAAM,UAAU,SAAS,UAAU,YAAY,IAAI,OAAO;AAE1D,QAAI,YAAY;AAChB,eAAW,CAAC,QAAQ,IAAI,KAAK,UAAU;AACrC,UAAI,UAAU,WAAW,UAAU,SAAS;AAC1C,qBAAa;MACf;IACF;AAEA,WAAO,OAAO,SAAS,IAAI;EAC7B;AAEA,SAAO,OAAO,IAAI,UAAQ,KAAK,MAAM,OAAO,EAAE,IAAI,EAAE;AACtD;AAEA,SAAS,mBACL,WAAsB,gBACtB,SAAmC;AACrC,MAAI,EAAC,WAAW,aAAa,SAAS,UAAS,IAAI,eAAe;AAClE,MAAI,UAAU,kBAAkB;AAC9B,UAAM,cAAc,UAAU,iBAAiB,iBAAiB,oBAAoB,WAAW,WAAW;AAC1G,gBAAY,YAAY,CAAC;AACzB,kBAAc,YAAY,CAAC;AAE3B,UAAM,YAAY,UAAU,iBAAiB,iBAAiB,oBAAoB,SAAS,SAAS;AACpG,cAAU,UAAU,CAAC;AACrB,gBAAY,UAAU,CAAC;EACzB;AAEA,QAAM,OAAO,UAAU;AACvB,QAAM,UAAU,KAAK,MAAK;AAI1B,QAAM,QAAQ,IAAc,oBAAU,UAAU,WAAW,aAAa,SAAS,SAAS;AAE1F,QAAM,sBAAsB,KAAK,mBAAmB,WAAW,WAAW;AAC1E,QAAM,oBAAoB,KAAK,mBAAmB,SAAS,SAAS;AAEpE,MAAI,qBAAqB;AACzB,MAAI,SAAS,kBAAkB,QAAW;AACxC,UAAM,gBAAgB,QAAQ;AAC9B,yBAAqB,KAAK,IAAI,oBAAoB,sBAAsB,aAAa;EACvF;AACA,MAAI,SAAS,sBAAsB,QAAW;AAC5C,UAAM,oBAAoB,QAAQ;AAClC,UAAM,WAAW,KAAK,mBAAmB,KAAK,IAAI,YAAY,mBAAmB,CAAC,GAAG,CAAC;AACtF,yBAAqB,KAAK,IAAI,oBAAoB,QAAQ;EAC5D;AAEA,MAAI,mBAAmB,QAAQ;AAC/B,MAAI,SAAS,kBAAkB,QAAW;AACxC,UAAM,gBAAgB,QAAQ;AAC9B,uBAAmB,KAAK,IAAI,kBAAkB,oBAAoB,aAAa;EACjF;AACA,MAAI,SAAS,sBAAsB,QAAW;AAC5C,UAAM,oBAAoB,QAAQ;AAClC,UAAM,WACF,KAAK,mBAAmB,KAAK,IAAI,UAAU,mBAAmB,KAAK,UAAS,IAAK,CAAC,GAAG,OAAO,iBAAiB;AACjH,uBAAmB,KAAK,IAAI,kBAAkB,QAAQ;EACxD;AAEA,QAAM,eAAe,KAAK,mBAAmB,kBAAkB;AAC/D,QAAM,aAAa,KAAK,mBAAmB,gBAAgB;AAC3D,QAAM,mBAAmB,IAAc,oBAAU,UAC7C,aAAa,YAAY,aAAa,cAAc,WAAW,YAAY,WAAW,YAAY;AAGtG,QAAM,OAAO,QAAQ,UAAU,qBAAqB,iBAAiB;AACrE,QAAM,SAAS,QAAQ,UAAU,oBAAoB,mBAAmB;AACxE,QAAM,QAAQ,QAAQ,UAAU,mBAAmB,gBAAgB;AAEnE,MAAI;AACJ,MAAI,SAAS,qBAAqB,UAAU,iBAAiB;AAC3D,UAAM,wBAAwB,6BAA6B,OAAO,UAAU,eAAe;AAC3F,UAAM,QAAQ,sBAAsB,IAAI,CAAC,MAAM,MAAK;AAClD,UAAI,OAAO,KAAK,OAAO,YAAY,CAAC;AAEpC,YAAM,aAAa,MAAM,sBAAsB,SAAS;AACxD,UAAI,MAAM,GAAG;AACX,YAAI,YAAY;AACd,iBAAO,KAAK,UAAU,aAAa,SAAS;QAC9C,OAAO;AACL,iBAAO,KAAK,UAAU,WAAW;QACnC;MACF,WAAW,YAAY;AACrB,eAAO,KAAK,UAAU,GAAG,SAAS;MACpC;AAEA,UAAI,YAAY;AAGd,eAAO;MACT;AAEA,aAAO,OAAO,GAAG,IAAI,OAAO,IAAI,QAAQ;IAC1C,CAAC;AACD,UAAM,gBAAgB,MAAM,KAAK,IAAI;AACrC,sBAAkB,SAAS,mBAAmB,aAAa,mBAAmB;EAChF,OAAO;AACL,sBAAkB,SAAS,mBAAmB,IAAI,mBAAmB;EACvE;AAEA,SAAO;IACL;IACA;IACA;IACA;IACA;IACA;;AAEJ;AAKA,eAAsB,4BAClB,QAA2B,KAAsC,MAAc,QAC/E,SAAmC;AACrC,QAAM,gBAAgB,OAAO,MAAU,kBAAc,aAAa;AAClE,MAAI,CAAC,eAAe;AAClB,UAAM,IAAI,MAAM,wBAAwB;EAC1C;AAEA,MAAI;AACJ,QAAM,2BAAoC,kCAAyB,yBAAyB,SAAQ;AACpG,QAAM,WAAW,yBAAyB,UAAU,gBAA0B,oBAAU,aAAa,OAAO;AAC5G,aAAW,WAAW,UAAU;AAC9B,mBAAe,QAAQ,mBAAmB,GAAG;AAC7C,QAAI,cAAc;AAChB;IACF;EACF;AAEA,MAAI,CAAC,cAAc;AACjB,WAAO;EACT;AAEA,QAAM,eAAe,MAAM,yBAAyB,yBAAyB,cAAc,MAAM,MAAM;AACvG,QAAM,cAAc,aAAa,GAAG,EAAE;AACtC,MAAI,CAAC,aAAa;AAChB,WAAO;EACT;AAEA,SAAO,MAAM,+BAA+B,aAAa,OAAO;AAClE;AAEA,eAAe,OAAO,cAAmD,SAAe;AAEtF,QAAM,cAAc,aAAa,YAAW;AAC5C,QAAM,eAAe,CAAC,YAAY,gBAAe,MAAO,YAAY,WAAU,KAAM,YAAY,SAAQ,MAC1F,oBAAU,WAAW,OAAO;AAC1C,MAAI,CAAC,cAAc;AACjB,WAAO;EACT;AAEA,SAAO,MAAgB,0BAAgB,oBAAoB,YAAY,kBAAiB,GAAI,SAAS,GAAI;AAC3G;AAKA,eAAsB,+BAClB,aAAyC,SAAmC;AAC9E,QAAM,2BAAoC,kCAAyB,yBAAyB,SAAQ;AACpG,QAAM,iBAAiB,MAAM,yBAAyB,4BAA4B,WAAW;AAC7F,MAAI,CAAC,gBAAgB;AACnB,WAAO;EACT;AAEA,QAAM,eAAe,aAAa,mBAAkB;AACpD,QAAM,UAAU,eAAe,aAAa,QAAO;AACnD,MAAI,CAAC,SAAS;AACZ,WAAO;EACT;AAEA,QAAM,YAAY,MAAM,qBAAqB,eAAe,cAAc,OAAO;AACjF,SAAO,mBAAmB,WAAW,gBAAgB,OAAO;AAC9D;;;AC7QA;;;sBAAAA;EAAA;;;;;;;;;;;;;AAIA,YAAY,YAAY;AACxB,YAAY,UAAU;AACtB,YAAYC,UAAS;AAErB,YAAYC,eAAc;AAC1B,YAAYC,gBAAe;AAC3B,YAAYC,gBAAe;AAO3B,IAAM,8BAA8B,oBAAI,QAAO;AAC/C,IAAM,uBAAuB,oBAAI,QAAO;AAExC,eAAsB,WAAW,iBAA0D;AAEzF,QAAM,cAAc,MAAM,gBAAgB,mBAAkB;AAC5D,MAAc,uBAAY,YAAY,QAAQ,WAAW,KAAK,CAAC,YAAY,eAAe;AACxF,WAAO;EACT;AACA,SAAO,YAAY;AACrB;AAEM,IAAO,sBAAP,MAA0B;EAC9B;EACA;EAEA,YAAY,MAAc,YAA+D,CAAA,GAAE;AACzF,SAAK,OAAO;AACZ,SAAK,YAAY;EACnB;EAEA,YAAY,YAAoB,cAAoB;AAClD,SAAK,UAAU,KAAK,EAAC,YAAY,aAAY,CAAC;EAChD;;AAGF,IAAM,mBAAmB,eAAe,QAAyB;AAI/D,MAAI,CAAC,OAAO,cAAc;AACxB,WAAO;EACT;AAEA,SAAO,MAAU,oBAAe,mBAAmB,MAAM;AAC3D;AAMA,IAAM,iBAAiB,SACI,WACA,aAAyC;AAClE,MAAI,CAAC,SAAS,WAAW,WAAW,GAAG;AACrC,WAAO,CAAA;EACT;AAGA,MAAI,kBAAkB;AACtB,QAAM,aAAa,CAAC,SAAS;AAC7B,SAAO,MAAM;AACX,QAAI,aAAa;AACjB,eAAW,SAAS,gBAAgB,UAAU;AAC5C,UAAI,SAAS,OAAO,WAAW,GAAG;AAEhC,mBAAW,KAAK,KAAK;AACrB,0BAAkB;AAClB,qBAAa;AACb;MACF;AAIA,UAAI,CAAC,SAAS,aAAa,KAAK,KAAK,CAAC,SAAS,aAAa,KAAK,GAAG;AAClE,gBAAQ,MAAM,yBAAyB;AACvC,eAAO,CAAA;MACT;IACF;AACA,QAAI,CAAC,YAAY;AAEf;IACF;EACF;AAEA,SAAO;AAEP,WAAS,SAAS,OAAqC,WAAuC;AAC5F,WAAQ,MAAM,SAAS,UAAU,SAAW,MAAM,OAAO,UAAU;EACrE;AACA,WAAS,SAAS,OAAqC,OAAmC;AACxF,WAAQ,MAAM,OAAO,MAAM,SAAW,MAAM,OAAO,MAAM;EAC3D;AACF;AAEA,eAAsB,+BAA+B,OAAwC;AAE3F,QAAM,gBAAgB,MAAM,MAAK,GAAI;AACrC,QAAM,cAAc,MAAM,MAAK,GAAI;AACnC,MAAI,CAAC,iBAAiB,CAAC,aAAa;AAClC,WAAO,CAAA;EACT;AAEA,QAAM,SAAS,cAAc,OAAM;AACnC,MAAI,CAAC,QAAQ;AACX,WAAO,CAAA;EACT;AAEA,QAAM,mBAAmB,MAAM,iBAAiB,MAAM;AACtD,MAAI,CAAC,kBAAkB;AACrB,WAAO,CAAA;EACT;AACA,QAAM,EAAC,WAAW,KAAI,IAAI;AAG1B,QAAM,eAAe;IACnB,OAAO,KAAK,mBAAmB,cAAc,YAAY,cAAc,YAAY;IACnF,KAAK,KAAK,mBAAmB,YAAY,YAAY,YAAY,YAAY;;AAG/E,SAAO,eAAe,WAAW,YAAY;AAC/C;AAEO,IAAM,mBAAmB,eAC5B,QAA2B,OAC3B,gBAA6D;AAI/D,QAAM,OAAO,MAAM,WAAW,MAAM;AACpC,MAAI,CAAC,MAAM;AACT,WAAO;EACT;AAGA,QAAM,iBAAiB,CAAA;AACvB,QAAM,SAAS,IAAc,sBAAW,WAAW,KAAK,YAAW,CAAE;AACrE,aAAW,YAAY,MAAM,WAAW;AAGtC,QAAI,SAAS,SAAI,KAA2D,SAAS,QAAQ,UAAU,GAAG;AACxG;IACF;AAEA,UAAM,aAAa,IAAI,oBAAoB,SAAS,IAAI;AACxD,eAAW,UAAU,SAAS,SAAS;AACrC,aAAO,QAAQ,MAAM;AACrB,iBAAW,YAAY,OAAO,WAAU,GAAI,OAAO,aAAY,CAAE;IACnE;AACA,mBAAe,KAAK,UAAU;EAChC;AAGA,QAAM,gBAAgB,CAAA;AACtB,aAAW,YAAY,gBAAgB;AACrC,eAAW,oBAAoB,SAAS,WAAW;AACjD,UAAI,aAAa;AACjB,iBAAW,UAAU,iBAAiB,SAAS;AAC7C,YAAI,UAAU,MAAM,SAAS,SAAS,MAAM,KAAK;AAC/C,cAAI,CAAC,YAAY;AACf,yBAAa,IAAI,oBAAoB,iBAAiB,IAAI;UAC5D;AACA,iBAAO,QAAQ,MAAM;AACrB,qBAAW,YAAY,OAAO,WAAU,GAAI,OAAO,aAAY,CAAE;QACnE;MACF;AACA,UAAI,YAAY;AACd,sBAAc,KAAK,UAAU;MAC/B;IACF;EACF;AACA,SAAO,EAAC,gBAAgB,cAAa;AACvC;AAEA,IAAM,iCAAiC;AAUvC,IAAM,uBAAuB,OAAM,UAC+C;AAC5E,MAAI,CAAQ,gBAAS,SAAS,SAAQ,EAAG,cAAc,wBAAwB,EAAE,IAAG,GAAI;AACtF,WAAO,EAAC,iBAAiB,oBAAI,IAAG,GAAI,aAAa,KAAI;EACvD;AACA,QAAM,SAAS,MAAM,UAAS,EAAG;AACjC,QAAM,aAAa,MAAM,+BAA+B,KAAK;AAC7D,SAAO,MAAM,aAAa,QAAQ,UAAU;AAC9C;AAEJ,IAAM,eAAe,OAAM,QAA2B,eAC4B;AAC5E,QAAM,cAAc,WAAW,WAAW,SAAS,CAAC;AACpD,MAAI,CAAC,aAAa;AAChB,WAAO,EAAC,iBAAiB,oBAAI,IAAG,GAAoB,aAAa,KAAI;EACvE;AACA,MAAI,iBAAiB,4BAA4B,IAAI,WAAW;AAChE,QAAM,YAAY,OAAO,UAAS;AAElC,MAAI,CAAC,kBAAkB,eAAe,cAAc,WAAW;AAC7D,UAAM,sBACD,YAAW;AACV,YAAM,kBAAkB,oBAAI,IAAG;AAC/B,UAAI,cAAc;AAElB,UAAI,CAAC,WAAW;AACd,eAAO,EAAC,iBAAiB,YAAW;MACtC;AAGA,YAAM,WAAiC,CAAA;AAEvC,YAAM,eAAe,CAAC,IAAyB,YAA+C;AAE5F,mBAAW,YAAY,GAAG,WAAW;AACnC,gBAAM,QAAQ,UAAU,UAAU,SAAS,YAAY,SAAS,YAAY;AAC5E,cAAI,OAAO,MAAM;AACf,oBAAQ,MAAM,IAAI;AAClB;UACF;QACF;AAEA,uBAAe,kBAAe;AAC5B,cAAI,CAAC,WAAW;AACd;UACF;AAKA,qBAAW,YAAY,GAAG,WAAW;AACnC,kBAAM,aAAa,MAAM,kBAAkB,QAAQ,WAAW,GAAG,MAAM,QAAQ;AAC/E,gBAAI,YAAY;AACd,sBAAQ,UAAU;AAClB;YACF;UACF;QACF;AACA,iBAAS,KAAK,gBAAe,CAAE;MACjC;AAEA,YAAM,kBAAkB,MAAM,iBAAiB,QAAQ,aAAa,WAAW,MAAM,GAAG,EAAE,CAAC;AAC3F,UAAI,CAAC,iBAAiB;AACpB,eAAO,EAAC,iBAAiB,YAAW;MACtC;AACA,iBAAW,MAAM,gBAAgB,gBAAgB;AAC/C,qBAAa,IAAI,gBAAa;AAE5B,cAAI,eAAe,QAAQ;AACzB,4BAAgB,IAAI,GAAG,MAAM,UAAU;UACzC;QACF,CAAC;MACH;AACA,iBAAW,MAAM,gBAAgB,eAAe;AAC9C,qBAAa,IAAI,gBAAa;AAC5B,cAAI,eAAe,QAAQ;AACzB,0BAAc,GAAG;UACnB;QACF,CAAC;MACH;AACA,YAAM,QAAQ,IAAI,QAAQ,EAAE,KAAK,wBAAuB,CAAE;AAC1D,aAAO,EAAC,iBAAiB,YAAW;IACtC,GAAE;AACN,qBAAiB,EAAC,WAAW,gBAAgB,mBAAkB;AAC/D,gCAA4B,IAAI,aAAa,EAAC,WAAW,gBAAgB,mBAAkB,CAAC;EAC9F;AACA,SAAO,MAAM,eAAe;AAE5B,iBAAe,kBACXC,SAA2BC,YAAoC,MAC/D,UAAoD;AACtD,UAAM,SAASA,WAAU,gBAAgB,SAAS,YAAY,SAAS,YAAY;AACnF,QAAI,CAAC,QAAQ;AACX,aAAO;IACT;AAGA,UAAM,eACO,mCAAyB,yBAAyB,SAAQ,EAAG,kCAClED,QAAO,eAAe,OAAO,WAAWA,QAAO,gBAAe,CAAE;AACxE,QAAI,CAAC,cAAc;AACjB,aAAO;IACT;AACA,UAAM,eAAe,MAAM,WAAWA,OAAM;AAC5C,QAAI,CAAC,cAAc;AACjB,aAAO;IACT;AACA,UAAM,gBAAgB,aAAa,QAAQ,OAAO,KAAK;AACvD,UAAM,sBAAsB,kBAAkB,aAAa;AAC3D,QAAI,CAAC,qBAAqB;AACxB,aAAO;IACT;AACA,UAAM,EAAC,MAAM,cAAc,aAAa,oBAAmB,IAAI;AAC/D,QAAI,iBAAiB,MAAM;AACzB,aAAO;IACT;AAIA,UAAM,aAAa,MAAM,WAAW,YAAY;AAChD,QAAI,CAAC,YAAY;AACf,aAAO;IACT;AACA,UAAM,cAAc,WAAW,QAAQ,OAAO,WAAW;AACzD,UAAM,oBAAoB,kBAAkB,WAAW;AACvD,QAAI,CAAC,mBAAmB;AACtB,aAAO;IACT;AACA,UAAM,EAAC,MAAM,YAAY,aAAa,kBAAiB,IAAI;AAE3D,QAAI,wBAAwB,mBAAmB;AAC7C,aAAO;IACT;AAEA,QAAI,wBAAmB,WAA0B,sBAAiB,aAA4B;AAC5F,aAAO;IACT;AAEA,WAAO;AAEP,aAAS,kBAAkB,OAAa;AACtC,YAAM,QAAQ,MAAM,MAAM,8BAA8B;AACxD,UAAI,CAAC,OAAO;AACV,eAAO;MACT;AAEA,YAAME,QAAO,MAAM,CAAC;AACpB,UAAI,cAAgC;AACpC,cAAQ,MAAM,CAAC,GAAG;QAChB,KAAK;AACH,wBAAW;AACX;QACF,KAAK;AACH,wBAAW;AACX;QACF,KAAK;AACH,wBAAW;AACX;QACF,KAAK;AACH,wBAAW;AACX;QACF,KAAK;AACH,wBAAW;AACX;QACF;AACE,kBAAQ,MAAM,+CAA+C,MAAM,CAAC,CAAC,GAAG;AACxE,iBAAO;MACX;AAEA,aAAO,EAAC,MAAAA,OAAM,YAAW;IAC3B;EACF;AACF;AAEG,IAAM,oBACT,eAAe,WAAsC;AACvD,QAAM,EAAC,cAAa,IAAa,mCAAyB,yBAAyB,SAAQ;AAC3F,MAAI,aAAiE,MAAM,cAAc,kBAAkB,SAAS;AACpH,MAAI,YAAY;AACd,WAAO;EACT;AAEA,eAAkB,aAAQ,YAAY;IAAS;;EAAA,IAC3C,UAAU,OAAO,UAAS,GAAI,kBAAkB,SAAS,IACzD;AACJ,MAAI,YAAY;AACd,WAAO;EACT;AAEA,MAAI,UAAU,OAAO,OAAM,GAAI;AAC7B,WAAO,UAAU,WAAU;EAC7B;AACA,QAAM,aAAa,MAAM,kBAAkB,SAAS;AACpD,SAAO,UAAU,WAAU,EAAG,IAAI,WAAS,IAAI,+BAA+B,OAAO,UAAU,CAAC;AAClG;AAMO,IAAM,0BACT,OAAM,cAA6E;AACrF,MAAI,CAAQ,gBAAS,SAAS,SAAQ,EAAG,cAAc,wBAAwB,EAAE,IAAG,GAAI;AACtF,WAAO,oBAAI,IAAG;EAChB;AACA,QAAM,YAAY,qBAAqB,IAAI,SAAS;AACpD,MAAI,WAAW;AACb,WAAO;EACT;AAEA,QAAM,aAAa,UAAU,WAAU;AACvC,QAAM,eAAe,MAAM,QAAQ,IAAI,WAAW,IAAI,oBAAoB,CAAC;AAC3E,QAAM,iBAAiB,oBAAI,IAAG;AAC9B,QAAM,gBAAgB,oBAAI,IAAG;AAC7B,aAAW,EAAC,gBAAe,KAAK,cAAc;AAC5C,eAAW,CAAC,cAAc,YAAY,KAAK,iBAAiB;AAC1D,UAAI,CAAC,cAAc;AACjB;MACF;AACA,UAAI,CAAC,eAAe,IAAI,YAAY,GAAG;AAErC,cAAM,qBAAqB,cAAc,IAAI,YAAY,IAAI,OAAO;AACpE,uBAAe,IAAI,cAAc,kBAAkB;MACrD;AACA,oBAAc,IAAI,YAAY;IAChC;EACF;AACA,uBAAqB,IAAI,WAAW,cAAc;AAClD,SAAO;AACT;AAMO,IAAM,yBACT,OAAM,aAA2E;AACnF,QAAM,iBAAiB,oBAAI,IAAG;AAC9B,MAAI,CAAQ,gBAAS,SAAS,SAAQ,EAAG,cAAc,wBAAwB,EAAE,IAAG,GAAI;AACtF,WAAO;EACT;AACA,QAAM,SAAS,SAAS,OAAM;AAC9B,MAAI,CAAC,QAAQ;AACX,WAAO;EACT;AAEA,QAAM,mBAAmB,MAAM,iBAAiB,MAAM;AACtD,MAAI,CAAC,kBAAkB;AACrB,WAAO;EACT;AAEA,QAAM,EAAC,WAAW,KAAI,IAAI;AAC1B,QAAM,iBAAiB,KAAK,mBAAmB,SAAS,YAAY,SAAS,YAAY;AACzF,QAAM,aAAa,eAAe,WAAW,EAAC,OAAO,gBAAgB,KAAK,eAAc,CAAC;AACzF,QAAM,gBAAgB,oBAAI,IAAG;AAE7B,SAAO,WAAW,SAAS,GAAG;AAC5B,UAAM,EAAC,gBAAe,IAAI,MAAM,aAAa,QAAQ,UAAU;AAC/D,eAAW,CAAC,cAAc,YAAY,KAAK,iBAAiB;AAC1D,UAAI,CAAC,cAAc;AACjB;MACF;AACA,UAAI,CAAC,eAAe,IAAI,YAAY,GAAG;AAErC,cAAM,qBAAqB,cAAc,IAAI,YAAY,IAAI,OAAO;AACpE,uBAAe,IAAI,cAAc,kBAAkB;MACrD;AACA,oBAAc,IAAI,YAAY;IAChC;AACA,eAAW,IAAG;EAChB;AACA,SAAO;AACT;AAEO,IAAM,oBACT,OAAM,cAAuF;AAC/F,QAAM,aAAa,UAAU,WAAU;AACvC,MAAI,WAAW,WAAW,GAAG;AAC3B,WAAO,UAAU,WAAU;EAC7B;AAEA,QAAM,EAAC,YAAW,IAAI,MAAM,qBAAqB,WAAW,CAAC,CAAC;AAC9D,MAAI,CAAC,aAAa;AAChB,WAAO,UAAU,WAAU;EAC7B;AAEA,QAAM,SAAS,MAAM,UAAU,SAAU;IACvC,YAAY;IACZ,aAAa;IACb,uBAAuB;IACvB,QAAQ;IACR,eAAe;IACf,iBAAiB;GACjB;AACF,MAAI,sBAAsB,QAAQ;AAChC,WAAO,CAAC,OAAO,oBAAoB,OAAO,SAAS,OAAO,SAAS,UAAU,WAAU;EACzF;AACA,SAAO;AACT;AAEO,IAAM,uBAAuB,SAAS,OAAwC;AACnF,QAAM,cAAc,MAAM,MAAK,GAAI;AACnC,QAAM,sBAAsB,MAAM,MAAK,GAAI,MAAM,OAAM,KAAM;AAE7D,MAAI,MAAM,KAAI,MAAE,YAA2C,CAAC,uBAAuB,CAAC,eAChF,CAAC,oBAAoB,cAAc;AACrC,WAAO,MAAM,OAAM;EACrB;AAEA,SAAO,IAAIP,cAAa,KAAK;AAC/B;AASA,IAAM,iCAAN,MAAoC;EACzB;;EAEA;EAET,YAAY,OAA0C,YAA8C;AAClG,SAAK,iBAAiB;AACtB,SAAK,cAAc;EACrB;EAEA,YAAS;AACP,WAAO,KAAK,eAAe,UAAS;EACtC;EAEA,OAAI;AACF,WAAO,KAAK,eAAe,KAAI;EACjC;EAEA,WAAQ;AACN,WAAO,KAAK,eAAe,SAAQ;EACrC;EAEA,OAAI;AACF,WAAO,KAAK,eAAe,KAAI;EACjC;EAEA,QAAK;AACH,WAAO,KAAK,eAAe,MAAK;EAClC;EAEA,SAAM;AACJ,WAAO,qBAAqB,KAAK,cAAc;EACjD;EAEA,cAAW;AACT,WAAO,KAAK,eAAe,YAAW;EACxC;EAEA,OAAI;AACF,WAAO,KAAK,eAAe,KAAI;EACjC;EAEA,kBAAe;AACb,UAAM,kBAAkB,KAAK,eAAe,gBAAe;AAC3D,QAAI,KAAK,eAAe,KAAK,KAAI,MAAE,SAAwC;AACzE,sBAAgB,QAAQ,IAAQ,kBAAa;QACzC;QAAQ,KAAK;QAAa;QAAW;QAAW;QAAW;QAAW;;QAA2B;MAAI,CAAC;IAC5G;AACA,WAAO;EACT;;AAGI,IAAOA,gBAAP,cAAgC,kBAAa,aAAY;EAC5C;EACA;EACjB,YAAY,OAAwC;AAClD,UAAK;AACL,SAAK,QAAQ;AACb,SAAK,SAAS,MAAM,OAAM;EAC5B;EAES,gBAAa;AACpB,WAAO,KAAK,OAAO,cAAa;EAClC;EAEA,IAAa,WAAQ;AACnB,WAAO,KAAK,OAAO;EACrB;EAEA,IAAa,OAAI;AACf,WAAO,KAAK,OAAO;EACrB;EAEA,IAAa,UAAO;AAClB,WAAO,KAAK,OAAO;EACrB;EAEA,IAAa,QAAK;AAChB,WAAO,KAAK,OAAO;EACrB;EAEA,IAAa,cAAW;AACtB,WAAO,KAAK,OAAO;EACrB;EAEA,IAAa,cAAW;AACtB,WAAO,KAAK,OAAO;EACrB;EAEA,IAAa,UAAO;AAClB,WAAO,KAAK,OAAO;EACrB;EAES,cAAW;AAClB,WAAO,KAAK,OAAO,YAAW;EAChC;EAES,iBAAiB,iBAAwB;AAChD,WAAO,KAAK,OAAO,iBAAiB,eAAe;EACrD;EAES,MAAM,iBAAiB,wBAAiC,iBAAwB;AAEvF,UAAM,gBAAgB,MAAM,KAAK,OAAO,iBAAiB,wBAAwB,eAAe;AAChG,UAAM,EAAC,gBAAe,IAAI,MAAM,qBAAqB,KAAK,KAAK;AAE/D,UAAM,aAAa,cAAc;AACjC,UAAM,qBAAqB,cAAc;AACzC,UAAM,gBAAgB,YAAY,IAAI,cAAW;AAC/C,YAAM,OAAO,gBAAgB,IAAI,SAAS,IAAI;AAC9C,aAAO,SAAS,SAAY,SAAS,iBAAiB,IAAI,IAAI;IAChE,CAAC;AACD,WAAO,EAAC,YAAY,iBAAiB,CAAA,GAAI,mBAAkB;EAC7D;EAES,MAAM,iBAAiB,cAAoD,OAAa;AAE/F,UAAM,EAAC,gBAAe,IAAI,MAAM,qBAAqB,KAAK,KAAK;AAE/D,QAAI;AACJ,QAAI,OAAO,iBAAiB,UAAU;AACpC,aAAO;IACT,OAAO;AACL,aAAQ,aAAa;IACvB;AAEA,QAAI,aAAqB;AACzB,eAAW,gBAAgB,gBAAgB,KAAI,GAAI;AACjD,UAAI,gBAAgB,IAAI,YAAY,MAAM,MAAM;AAC9C,qBAAa;AACb;MACF;IACF;AACA,WAAO,MAAM,KAAK,OAAO,iBAAiB,YAAY,KAAK;EAC7D;EAES,MAAM,eAAe,MAAmC;AAC/D,WAAO,MAAM,KAAK,OAAO,eAAe,IAAI;EAC9C;EAES,aACL,qBACA,MAAsC;AACxC,WAAO,KAAK,OAAO,aAAa,qBAAqB,IAAI;EAC3D;EAES,iBACL,qBAAqD,MAAsC;AAC7F,WAAO,KAAK,OAAO,iBAAiB,qBAAqB,IAAI;EAC/D;EAES,UAAO;AACd,SAAK,OAAO,QAAO;EACrB;EAES,gBAAa;AACpB,WAAO,KAAK,OAAO,cAAa;EAClC;EAES,eAAY;AACnB,WAAO,KAAK,OAAO,aAAY;EACjC;EAES,SAAM;AACb,WAAO,KAAK,OAAO,OAAM;EAC3B;;AASF,eAAe,8BACX,QAA2B,YAAoB,cAAoB;AAIrE,QAAM,YAAY,OAAO,UAAS;AAClC,MAAI,CAAC,WAAW;AACd,WAAO;EACT;AAEA,QAAM,YAAY,UAAU,yBAAyB,EAAC,MAAM,YAAY,QAAQ,aAAY,CAAC;AAC7F,MAAI,cAAc,MAAM;AACtB,WAAO;EACT;AAEA,QAAM,eAAe,UAAU,UAAU,YAAY,YAAY;AACjE,MAAI,CAAC,cAAc,WAAW;AAC5B,WAAO;EACT;AAEA,QAAM,OAAO,aAAa;AAC1B,MAAI,CAAC,MAAM;AACT,WAAO;EACT;AAEA,QAAM,OAAO,MAAM,WAAW,MAAM;AACpC,MAAI,CAAC,MAAM;AACT,WAAO;EACT;AAEA,QAAM,YAAY,IAAc,qBAAU,UAAU,YAAY,cAAc,YAAY,eAAe,CAAC;AAE1G,MAAI,KAAK,QAAQ,SAAS,MAAM,KAAK;AACnC,WAAO;EACT;AAEA,SAAO;AACT;AAEA,eAAsB,iCAAiC,OAAkC;AACvF,QAAM,gBAAgB,MAAM,WAAU,GAAI,MAAK,GAAI;AACnD,MAAI,CAAC,eAAe;AAClB,WAAO;EACT;AACA,SAAO,MAAM,8BAA8B,MAAM,QAAQ,cAAc,YAAY,cAAc,YAAY;AAC/G;AAEA,eAAsB,gCAClB,EAAC,UAAU,YAAY,aAAY,GACnC,QAA8B;AAChC,MAAI,CAAC,UAAU,eAAe,UAAa,iBAAiB,UAAa,aAAa,QAAW;AAC/F,WAAO;EACT;AACA,QAAM,gBAAgB,OAAO,MAAU,mBAAc,aAAa;AAClE,QAAM,SAAS,eAAe,YAAY,OAAO,QAAQ,CAAC;AAE1D,MAAI,CAAC,iBAAiB,CAAC,QAAQ;AAC7B,WAAO;EACT;AAEA,QAAM,2BAAoC,mCAAyB,yBAAyB,SAAQ;AACpG,QAAM,WAAW,IAAQ,mBAAc,SAAS,eAAe,UAAU,YAAY,YAAY;AACjG,QAAM,yBAAyB,MAAM,yBAAyB,cAAc,gBAAgB,QAAQ,QAAQ;AAC5G,MAAI,0BAA0B,YAAY,wBAAwB;AAChE,UAAM,OAAO,uBAAuB,OAAO,GAAG,EAAE;AAChD,QAAI,MAAM,MAAM;AACd,aAAO,KAAK;IACd;EACF;AACA,SAAO,MAAM,8BAA8B,QAAQ,YAAY,YAAY;AAC7E;AAEA,IAAI,uBAAqD,WAAA;AAAkB;AAEpE,IAAM,0BAA0B,MAAmC;AACxE,SAAO;AACT;AAEO,IAAM,0BAA0B,CAAC,UAA6C;AACnF,yBAAuB;AACzB;;;AC5vBA;;;;;AAIA,YAAYQ,aAAY;AACxB,YAAYC,UAAS;AAgBf,IAAO,kBAAP,cAAsC,sBAAc,cAAyB;EACxE;;EAGA,aAAa,IAAW,kBAAU,UAAU,CAAC;EAC7C,eAAe,KAAK,QAAQ,KAAK,IAAI;EAE9C,YAAY,WAAsC;AAChD,UAAK;AACL,SAAK,aAAa;AAClB,SAAK,WAAW,cAAc,iBACtB,mBAAc,OAAO,mBAAmB,KAAK,oBAAoB,IAAI;AAC7E,SAAK,WAAW,cAAc,iBAAgB,EAAG,iBACzC,sBAAiB,OAAO,mBAAmB,KAAK,oBAAoB,IAAI;AAEhF,SAAK,KAAK,WAAW,SAAS,KAAK,YAAY;EACjD;EAEA,UAAO;AACL,SAAK,WAAW,cAAc,oBACtB,mBAAc,OAAO,mBAAmB,KAAK,oBAAoB,IAAI;AAC7E,SAAK,WAAW,cAAc,iBAAgB,EAAG,oBACzC,sBAAiB,OAAO,mBAAmB,KAAK,oBAAoB,IAAI;AAChF,SAAK,WAAW,MAAK;EACvB;EAEA,MAAM,UAAO;AACX,UAAM,aAAa,MAAM,kBAAkB,KAAK,UAAU;AAC1D,SAAK,yBAAwB,qBAA6B,IAAI,WAAW,UAAU,CAAC;EACtF;EAEA,mBAAmB,OAA6D;AAC9E,QAAI,MAAM,SAAS,KAAK,WAAW,QAAQ;AACzC,WAAK,KAAK,WAAW,SAAS,KAAK,YAAY;IACjD;EACF;EAEA,mBAAmB,OACsF;AACvG,QAAI,MAAM,KAAK,WAAW,KAAK,WAAW,QAAQ;AAChD,WAAK,KAAK,WAAW,SAAS,KAAK,YAAY;IACjD;EACF;;AAcI,IAAO,aAAP,MAAiB;EACZ;EAET,YAAY,YAA+C;AACzD,SAAK,aAAa;EACpB;;",
  "names": ["RemoteObject", "SDK", "Bindings", "Formatter", "TextUtils", "script", "sourceMap", "name", "Common", "SDK"]
}
