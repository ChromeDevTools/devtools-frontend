{"version":3,"file":"StackTrace.js","sourceRoot":"","sources":["../../../../../../front_end/models/stack_trace/StackTrace.ts"],"names":[],"mappings":"AAAA,sCAAsC;AACtC,yEAAyE;AACzE,6BAA6B;AA+D7B;;;;GAIG;AACH,MAAM,OAAO,qBAAqB;IAChC,MAAM,CAAC,KAAK,CAAyB;IAE5B,GAAG,CAAU;IACb,YAAY,CAAuC;IACnD,IAAI,CAAU;IACd,IAAI,CAAS;IACb,MAAM,CAAS;IACf,gBAAgB,CAAoB;IACpC,QAAQ,CAA8B;IAE/C,oFAAoF;IACpF,YAAY,KAAsB;QAChC,IAAI,CAAC,GAAG,GAAG,KAAK,CAAC,GAAG,CAAC;QACrB,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC,YAAY,CAAC;QACvC,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC;QACvB,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC;QACvB,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC;QAC3B,IAAI,CAAC,gBAAgB,GAAG,KAAK,CAAC,gBAAgB,CAAC;QAC/C,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC,QAAQ,CAAC;IACjC,CAAC;IAED,6HAA6H;IAC7H,MAAM,CAAC,GAAG,CAAC,KAAsB;QAC/B,SAAS,MAAM,CAAC,CAAkB,EAAE,CAAkB;YACpD,OAAO,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,YAAY,KAAK,CAAC,CAAC,YAAY,IAAI,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,IAAI;gBACjG,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC,MAAM,IAAI,CAAC,CAAC,QAAQ,KAAK,CAAC,CAAC,QAAQ,CAAC;QACzD,CAAC;QAED,IAAI,CAAC,qBAAqB,CAAC,KAAK,IAAI,CAAC,MAAM,CAAC,qBAAqB,CAAC,KAAK,EAAE,KAAK,CAAC,EAAE,CAAC;YAChF,qBAAqB,CAAC,KAAK,GAAG,IAAI,qBAAqB,CAAC,KAAK,CAAC,CAAC;QACjE,CAAC;QACD,OAAO,qBAAqB,CAAC,KAAK,CAAC;IACrC,CAAC;CACF","sourcesContent":["// Copyright 2025 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Common from '../../core/common/common.js';\nimport type * as SDK from '../../core/sdk/sdk.js';\nimport type * as Workspace from '../workspace/workspace.js';\n\nexport type StackTrace = BaseStackTrace<Fragment>;\nexport type DebuggableStackTrace = BaseStackTrace<DebuggableFragment>;\n\nexport interface BaseStackTrace<SyncFragmentT extends Fragment> extends Common.EventTarget.EventTarget<EventTypes> {\n  readonly syncFragment: SyncFragmentT;\n  readonly asyncFragments: readonly AsyncFragment[];\n}\n\nexport interface Fragment {\n  readonly frames: readonly Frame[];\n}\n\nexport interface AsyncFragment extends Fragment {\n  readonly description: string;\n}\n\nexport interface DebuggableFragment {\n  readonly frames: readonly DebuggableFrame[];\n}\n\nexport interface Frame {\n  readonly url?: string;\n  readonly uiSourceCode?: Workspace.UISourceCode.UISourceCode;\n  readonly name?: string;\n  readonly line: number;\n  readonly column: number;\n\n  readonly missingDebugInfo?: MissingDebugInfo;\n}\n\nexport interface DebuggableFrame extends Frame {\n  readonly sdkFrame: SDK.DebuggerModel.CallFrame;\n}\n\nexport const enum MissingDebugInfoType {\n  /** No debug information at all for the call frame */\n  NO_INFO = 'NO_INFO',\n\n  /** Some debug information available, but it references files with debug information we were not able to retrieve */\n  PARTIAL_INFO = 'PARTIAL_INFO',\n}\n\nexport type MissingDebugInfo = {\n  type: MissingDebugInfoType.NO_INFO,\n}|{\n  type: MissingDebugInfoType.PARTIAL_INFO,\n  missingDebugFiles: SDK.DebuggerModel.MissingDebugFiles[],\n};\n\nexport const enum Events {\n  UPDATED = 'UPDATED',\n}\n\nexport interface EventTypes {\n  [Events.UPDATED]: void;\n}\n\n/**\n * A small wrapper around a DebuggableFrame usable as a UI.Context flavor.\n * This is necessary as Frame and DebuggableFrame are updated in place, but\n * for UI.Context we need a new instance.\n */\nexport class DebuggableFrameFlavor implements DebuggableFrame {\n  static #last?: DebuggableFrameFlavor;\n\n  readonly url?: string;\n  readonly uiSourceCode?: Workspace.UISourceCode.UISourceCode;\n  readonly name?: string;\n  readonly line: number;\n  readonly column: number;\n  readonly missingDebugInfo?: MissingDebugInfo;\n  readonly sdkFrame: SDK.DebuggerModel.CallFrame;\n\n  /** Use the static {@link for}. Only public to satisfy the `setFlavor` Ctor type  */\n  constructor(frame: DebuggableFrame) {\n    this.url = frame.url;\n    this.uiSourceCode = frame.uiSourceCode;\n    this.name = frame.name;\n    this.line = frame.line;\n    this.column = frame.column;\n    this.missingDebugInfo = frame.missingDebugInfo;\n    this.sdkFrame = frame.sdkFrame;\n  }\n\n  /** @returns the same instance of DebuggableFrameFlavor for repeated calls with the same (i.e. deep equal) DebuggableFrame */\n  static for(frame: DebuggableFrame): DebuggableFrameFlavor {\n    function equals(a: DebuggableFrame, b: DebuggableFrame): boolean {\n      return a.url === b.url && a.uiSourceCode === b.uiSourceCode && a.name === b.name && a.line === b.line &&\n          a.column === b.column && a.sdkFrame === b.sdkFrame;\n    }\n\n    if (!DebuggableFrameFlavor.#last || !equals(DebuggableFrameFlavor.#last, frame)) {\n      DebuggableFrameFlavor.#last = new DebuggableFrameFlavor(frame);\n    }\n    return DebuggableFrameFlavor.#last;\n  }\n}\n"]}