{
  "version": 3,
  "sources": ["../../../../../../front_end/models/stack_trace/StackTraceImpl.ts", "../../../../../../front_end/models/stack_trace/StackTraceModel.ts", "../../../../../../front_end/models/stack_trace/Trie.ts"],
  "sourcesContent": ["// Copyright 2025 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport type * as SDK from '../../core/sdk/sdk.js';\nimport type * as Workspace from '../workspace/workspace.js';\n\nimport type * as StackTrace from './stack_trace.js';\nimport type {FrameNode} from './Trie.js';\n\nexport type AnyStackTraceImpl = StackTraceImpl<FragmentImpl|DebuggableFragmentImpl>;\n\nexport class StackTraceImpl<SyncFragmentT extends FragmentImpl|DebuggableFragmentImpl = FragmentImpl> extends\n    Common.ObjectWrapper.ObjectWrapper<StackTrace.StackTrace.EventTypes> implements\n        StackTrace.StackTrace.BaseStackTrace<SyncFragmentT> {\n  readonly syncFragment: SyncFragmentT;\n  readonly asyncFragments: readonly AsyncFragmentImpl[];\n\n  constructor(syncFragment: SyncFragmentT, asyncFragments: AsyncFragmentImpl[]) {\n    super();\n    this.syncFragment = syncFragment;\n    this.asyncFragments = asyncFragments;\n\n    const fragment =\n        syncFragment instanceof DebuggableFragmentImpl ? syncFragment.fragment : syncFragment as FragmentImpl;\n    fragment.stackTraces.add(this);\n\n    this.asyncFragments.forEach(asyncFragment => asyncFragment.fragment.stackTraces.add(this));\n  }\n}\n\nexport class FragmentImpl implements StackTrace.StackTrace.Fragment {\n  readonly node: FrameNode;\n  readonly stackTraces = new Set<AnyStackTraceImpl>();\n\n  /**\n   * Fragments are deduplicated based on the node.\n   *\n   * In turn, each fragment can be part of multiple stack traces.\n   */\n  static getOrCreate(node: FrameNode): FragmentImpl {\n    if (!node.fragment) {\n      node.fragment = new FragmentImpl(node);\n    }\n    return node.fragment;\n  }\n\n  private constructor(node: FrameNode) {\n    this.node = node;\n  }\n\n  get frames(): FrameImpl[] {\n    const frames: FrameImpl[] = [];\n\n    for (const node of this.node.getCallStack()) {\n      frames.push(...node.frames);\n    }\n\n    return frames;\n  }\n}\n\nexport class AsyncFragmentImpl implements StackTrace.StackTrace.AsyncFragment {\n  constructor(readonly description: string, readonly fragment: FragmentImpl) {\n  }\n\n  get frames(): StackTrace.StackTrace.Frame[] {\n    return this.fragment.frames;\n  }\n}\n\nexport class FrameImpl implements StackTrace.StackTrace.Frame {\n  readonly url?: string;\n  readonly uiSourceCode?: Workspace.UISourceCode.UISourceCode;\n  readonly name?: string;\n  readonly line: number;\n  readonly column: number;\n\n  readonly missingDebugInfo?: StackTrace.StackTrace.MissingDebugInfo;\n\n  constructor(\n      url: string|undefined, uiSourceCode: Workspace.UISourceCode.UISourceCode|undefined, name: string|undefined,\n      line: number, column: number, missingDebugInfo?: StackTrace.StackTrace.MissingDebugInfo) {\n    this.url = url;\n    this.uiSourceCode = uiSourceCode;\n    this.name = name;\n    this.line = line;\n    this.column = column;\n    this.missingDebugInfo = missingDebugInfo;\n  }\n}\n\n/**\n * A DebuggableFragmentImpl wraps an existing FragmentImpl. This is important: We can pause at the\n * same location multiple times and the paused information changes each and everytime while the underlying\n * FragmentImpl will stay the same.\n */\nexport class DebuggableFragmentImpl implements StackTrace.StackTrace.DebuggableFragment {\n  constructor(readonly fragment: FragmentImpl, private readonly callFrames: SDK.DebuggerModel.CallFrame[]) {\n  }\n\n  get frames(): DebuggableFrameImpl[] {\n    const frames: DebuggableFrameImpl[] = [];\n\n    let index = 0;\n    for (const node of this.fragment.node.getCallStack()) {\n      for (const [inlineIdx, frame] of node.frames.entries()) {\n        // Create virtual frames for inlined frames.\n        const sdkFrame = inlineIdx === 0 ? this.callFrames[index] :\n                                           this.callFrames[index].createVirtualCallFrame(inlineIdx, frame.name ?? '');\n        frames.push(new DebuggableFrameImpl(frame, sdkFrame));\n      }\n      index++;\n    }\n\n    return frames;\n  }\n}\n\n/**\n * A DebuggableFrameImpl wraps an existing FrameImpl. This is important: We can pause at the\n * same location multiple times and the paused information changes each and everytime while the underlying\n * FrameImpl will stay the same.\n */\nexport class DebuggableFrameImpl implements StackTrace.StackTrace.DebuggableFrame {\n  readonly #frame: FrameImpl;\n  readonly #sdkFrame: SDK.DebuggerModel.CallFrame;\n\n  constructor(frame: FrameImpl, sdkFrame: SDK.DebuggerModel.CallFrame) {\n    this.#frame = frame;\n    this.#sdkFrame = sdkFrame;\n  }\n\n  get url(): string|undefined {\n    return this.#frame.url;\n  }\n\n  get uiSourceCode(): Workspace.UISourceCode.UISourceCode|undefined {\n    return this.#frame.uiSourceCode;\n  }\n\n  get name(): string|undefined {\n    return this.#frame.name;\n  }\n\n  get line(): number {\n    return this.#frame.line;\n  }\n\n  get column(): number {\n    return this.#frame.column;\n  }\n\n  get missingDebugInfo(): StackTrace.StackTrace.MissingDebugInfo|undefined {\n    return this.#frame.missingDebugInfo;\n  }\n\n  get sdkFrame(): SDK.DebuggerModel.CallFrame {\n    return this.#sdkFrame;\n  }\n}\n", "// Copyright 2025 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport type * as Protocol from '../../generated/protocol.js';\n\n// eslint-disable-next-line @devtools/es-modules-import\nimport * as StackTrace from './stack_trace.js';\nimport {\n  type AnyStackTraceImpl,\n  AsyncFragmentImpl,\n  DebuggableFragmentImpl,\n  FragmentImpl,\n  FrameImpl,\n  StackTraceImpl\n} from './StackTraceImpl.js';\nimport {type FrameNode, type RawFrame, Trie} from './Trie.js';\n\n/**\n * A stack trace translation function.\n *\n * Any implementation must return an array with the same length as `frames`.\n */\nexport type TranslateRawFrames = (frames: readonly RawFrame[], target: SDK.Target.Target) => Promise<\n    Array<Array<Pick<StackTrace.StackTrace.Frame, 'url'|'uiSourceCode'|'name'|'line'|'column'|'missingDebugInfo'>>>>;\n\n/**\n * The {@link StackTraceModel} is a thin wrapper around a fragment trie.\n *\n * We want to store stack trace fragments per target so a SDKModel is the natural choice.\n */\nexport class StackTraceModel extends SDK.SDKModel.SDKModel<unknown> {\n  readonly #trie = new Trie();\n  readonly #mutex = new Common.Mutex.Mutex();\n\n  /** @returns the {@link StackTraceModel} for the target, or the model for the primaryPageTarget when passing null/undefined */\n  static #modelForTarget(target: SDK.Target.Target|null|undefined): StackTraceModel {\n    const model = (target ?? SDK.TargetManager.TargetManager.instance().primaryPageTarget())?.model(StackTraceModel);\n    if (!model) {\n      throw new Error('Unable to find StackTraceModel');\n    }\n    return model;\n  }\n\n  async createFromProtocolRuntime(stackTrace: Protocol.Runtime.StackTrace, rawFramesToUIFrames: TranslateRawFrames):\n      Promise<StackTrace.StackTrace.StackTrace> {\n    const [syncFragment, asyncFragments] = await Promise.all([\n      this.#createFragment(stackTrace.callFrames, rawFramesToUIFrames),\n      this.#createAsyncFragments(stackTrace, rawFramesToUIFrames),\n    ]);\n\n    return new StackTraceImpl(syncFragment, asyncFragments);\n  }\n\n  async createFromDebuggerPaused(\n      pausedDetails: SDK.DebuggerModel.DebuggerPausedDetails,\n      rawFramesToUIFrames: TranslateRawFrames): Promise<StackTrace.StackTrace.DebuggableStackTrace> {\n    const [syncFragment, asyncFragments] = await Promise.all([\n      this.#createDebuggableFragment(pausedDetails, rawFramesToUIFrames),\n      this.#createAsyncFragments(pausedDetails, rawFramesToUIFrames),\n    ]);\n\n    return new StackTraceImpl(syncFragment, asyncFragments);\n  }\n\n  /** Trigger re-translation of all fragments with the provide script in their call stack */\n  async scriptInfoChanged(script: SDK.Script.Script, translateRawFrames: TranslateRawFrames): Promise<void> {\n    const release = await this.#mutex.acquire();\n    try {\n      const translatePromises: Array<Promise<unknown>> = [];\n      let stackTracesToUpdate = new Set<AnyStackTraceImpl>();\n\n      for (const fragment of this.#affectedFragments(script)) {\n        // We trigger re-translation only for fragments of leaf-nodes. Any fragment along the ancestor-chain\n        // is re-translated as a side-effect.\n        // We just need to remember the stack traces of the skipped over fragments, so we can send the\n        // UPDATED event also to them.\n        if (fragment.node.children.length === 0) {\n          translatePromises.push(this.#translateFragment(fragment, translateRawFrames));\n        }\n        stackTracesToUpdate = stackTracesToUpdate.union(fragment.stackTraces);\n      }\n\n      await Promise.all(translatePromises);\n\n      for (const stackTrace of stackTracesToUpdate) {\n        stackTrace.dispatchEventToListeners(StackTrace.StackTrace.Events.UPDATED);\n      }\n    } finally {\n      release();\n    }\n  }\n\n  async #createDebuggableFragment(\n      pausedDetails: SDK.DebuggerModel.DebuggerPausedDetails,\n      rawFramesToUIFrames: TranslateRawFrames): Promise<DebuggableFragmentImpl> {\n    const fragment = await this.#createFragment(\n        pausedDetails.callFrames.map(frame => ({\n                                       scriptId: frame.script.scriptId,\n                                       url: frame.script.sourceURL,\n                                       functionName: frame.functionName,\n                                       lineNumber: frame.location().lineNumber,\n                                       columnNumber: frame.location().columnNumber,\n                                     })),\n        rawFramesToUIFrames);\n    return new DebuggableFragmentImpl(fragment, pausedDetails.callFrames);\n  }\n\n  async #createAsyncFragments(\n      stackTraceOrPausedEvent: Protocol.Runtime.StackTrace|SDK.DebuggerModel.DebuggerPausedDetails,\n      rawFramesToUIFrames: TranslateRawFrames): Promise<AsyncFragmentImpl[]> {\n    const asyncFragments: Array<Promise<AsyncFragmentImpl>> = [];\n\n    const debuggerModel = this.target().model(SDK.DebuggerModel.DebuggerModel);\n    if (debuggerModel) {\n      for await (\n          const {stackTrace: asyncStackTrace, target} of debuggerModel.iterateAsyncParents(stackTraceOrPausedEvent)) {\n        if (asyncStackTrace.callFrames.length === 0) {\n          // Skip empty async fragments, they don't add value.\n          continue;\n        }\n        const model = StackTraceModel.#modelForTarget(target);\n        const asyncFragmentPromise =\n            model.#createFragment(asyncStackTrace.callFrames, rawFramesToUIFrames)\n                .then(fragment => new AsyncFragmentImpl(asyncStackTrace.description ?? '', fragment));\n        asyncFragments.push(asyncFragmentPromise);\n      }\n    }\n\n    return await Promise.all(asyncFragments);\n  }\n\n  async #createFragment(frames: RawFrame[], rawFramesToUIFrames: TranslateRawFrames): Promise<FragmentImpl> {\n    const release = await this.#mutex.acquire();\n    try {\n      const node = this.#trie.insert(frames);\n      const requiresTranslation = !Boolean(node.fragment);\n      const fragment = FragmentImpl.getOrCreate(node);\n\n      if (requiresTranslation) {\n        await this.#translateFragment(fragment, rawFramesToUIFrames);\n      }\n\n      return fragment;\n    } finally {\n      release();\n    }\n  }\n\n  async #translateFragment(fragment: FragmentImpl, rawFramesToUIFrames: TranslateRawFrames): Promise<void> {\n    const rawFrames = fragment.node.getCallStack().map(node => node.rawFrame).toArray();\n    const uiFrames = await rawFramesToUIFrames(rawFrames, this.target());\n    console.assert(rawFrames.length === uiFrames.length, 'Broken rawFramesToUIFrames implementation');\n\n    let i = 0;\n    for (const node of fragment.node.getCallStack()) {\n      node.frames = uiFrames[i++].map(\n          frame => new FrameImpl(\n              frame.url, frame.uiSourceCode, frame.name, frame.line, frame.column, frame.missingDebugInfo));\n    }\n  }\n\n  #affectedFragments(script: SDK.Script.Script): Set<FragmentImpl> {\n    // 1. Collect branches with the matching script.\n    const affectedBranches = new Set<FrameNode>();\n    this.#trie.walk(null, node => {\n      // scriptId has precedence, but if the frame does not have one, check the URL.\n      if (node.rawFrame.scriptId === script.scriptId ||\n          (!node.rawFrame.scriptId && node.rawFrame.url === script.sourceURL)) {\n        affectedBranches.add(node);\n        return false;\n      }\n      return true;\n    });\n\n    // 2. For each branch collect all the fragments.\n    const fragments = new Set<FragmentImpl>();\n    for (const branch of affectedBranches) {\n      this.#trie.walk(branch, node => {\n        if (node.fragment) {\n          fragments.add(node.fragment);\n        }\n        return true;\n      });\n    }\n    return fragments;\n  }\n}\n\nSDK.SDKModel.SDKModel.register(StackTraceModel, {capabilities: SDK.Target.Capability.NONE, autostart: false});\n", "// Copyright 2025 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Protocol from '../../generated/protocol.js';\n\nimport type {FragmentImpl, FrameImpl} from './StackTraceImpl.js';\n\n/**\n * Intentionally very close to a {@link Protocol.Runtime.CallFrame} but with optional `scriptId`.\n */\nexport interface RawFrame {\n  readonly scriptId?: Protocol.Runtime.ScriptId;\n  readonly url?: string;\n  readonly functionName?: string;\n  readonly lineNumber: number;\n  readonly columnNumber: number;\n}\n\n/**\n * @returns whether the frame is a V8 builtin frame e.g. Array.map. Builtin frames\n * have neither source position nor script or URL. They only have a name.\n */\nexport function isBuiltinFrame(rawFrame: RawFrame): boolean {\n  return rawFrame.lineNumber === -1 && rawFrame.columnNumber === -1 && !Boolean(rawFrame.scriptId) &&\n      !Boolean(rawFrame.url);\n}\n\ninterface FrameNodeBase<ChildT, ParentT> {\n  readonly parent: ParentT;\n  readonly children: ChildT[];\n}\n\ntype RootFrameNode = FrameNodeBase<WeakRef<FrameNode>, null>;\ntype AnyFrameNode = FrameNode|RootFrameNode;\n\nexport class FrameNode implements FrameNodeBase<FrameNode, AnyFrameNode> {\n  readonly parent: AnyFrameNode;\n  readonly children: FrameNode[] = [];\n\n  readonly rawFrame: RawFrame;\n  frames: FrameImpl[] = [];\n\n  fragment?: FragmentImpl;\n\n  constructor(rawFrame: RawFrame, parent: AnyFrameNode) {\n    this.rawFrame = rawFrame;\n    this.parent = parent;\n  }\n\n  /**\n   * Produces the ancestor chain. Including `this` but excluding the `RootFrameNode`.\n   */\n  * getCallStack(): Generator<FrameNode> {\n    // The `RootFrameNode` doesn't have an actual frame attached, that's why we check for `node.parent` instead of `node`.\n    for (let node: AnyFrameNode|null = this; node.parent; node = node.parent) {\n      yield node;\n    }\n  }\n}\n\n/**\n * Stores stack trace fragments in a trie, but does not own them/keep them alive.\n */\nexport class Trie {\n  readonly #root: RootFrameNode = {parent: null, children: []};\n\n  /**\n   * Most sources produce stack traces in \"top-to-bottom\" order, so that is what this method expects.\n   *\n   * @returns The {@link FrameNode} corresponding to the top-most stack frame.\n   */\n  insert(frames: RawFrame[]): FrameNode {\n    if (frames.length === 0) {\n      throw new Error('Trie.insert called with an empty frames array.');\n    }\n\n    let currentNode: AnyFrameNode = this.#root;\n    for (let i = frames.length - 1; i >= 0; --i) {\n      currentNode = this.#insert(currentNode, frames[i]);\n    }\n    return currentNode as FrameNode;\n  }\n\n  /**\n   * Inserts `rawFrame` into the children of the provided node if not already there.\n   *\n   * @returns the child node corresponding to `rawFrame`.\n   */\n  #insert(node: AnyFrameNode, rawFrame: RawFrame): FrameNode {\n    let i = 0;\n    for (; i < node.children.length; ++i) {\n      const maybeChild = node.children[i];\n      const child = maybeChild instanceof WeakRef ? maybeChild.deref() : maybeChild;\n      if (!child) {\n        continue;\n      }\n\n      const compareResult = compareRawFrames(child.rawFrame, rawFrame);\n      if (compareResult === 0) {\n        return child;\n      }\n      if (compareResult > 0) {\n        break;\n      }\n    }\n\n    const newNode = new FrameNode(rawFrame, node);\n    if (node.parent) {\n      node.children.splice(i, 0, newNode);\n    } else {\n      node.children.splice(i, 0, new WeakRef(newNode));\n    }\n    return newNode;\n  }\n\n  /**\n   * Traverses the trie in pre-order.\n   *\n   * @param node Start at `node` or `null` to start with the children of the root.\n   * @param visit Called on each node in the trie. Return `true` if the visitor should descend into child nodes of the provided node.\n   */\n  walk(node: FrameNode|null, visit: (node: FrameNode) => boolean): void {\n    const stack =\n        node ? [node] : [...this.#root.children].map(ref => ref.deref()).filter(node => Boolean(node)) as FrameNode[];\n\n    for (let node = stack.pop(); node; node = stack.pop()) {\n      const visitChildren = visit(node);\n      if (visitChildren) {\n        // Pushing the children in reverse means the \"left-most\" child is visited first (i.e. pre-order).\n        for (let i = node.children.length - 1; i >= 0; --i) {\n          stack.push(node.children[i]);\n        }\n      }\n    }\n  }\n}\n\n/**\n * @returns a number < 0, 0 or > 0, if the `a` is smaller then, equal or greater then `b`.\n */\nexport function compareRawFrames(a: RawFrame, b: RawFrame): number {\n  const scriptIdCompare = (a.scriptId ?? '').localeCompare(b.scriptId ?? '');\n  if (scriptIdCompare !== 0) {\n    return scriptIdCompare;\n  }\n\n  const urlCompare = (a.url ?? '').localeCompare(b.url ?? '');\n  if (urlCompare !== 0) {\n    return urlCompare;\n  }\n\n  const nameCompare = (a.functionName ?? '').localeCompare(b.functionName ?? '');\n  if (nameCompare !== 0) {\n    return nameCompare;\n  }\n\n  if (a.lineNumber !== b.lineNumber) {\n    return a.lineNumber - b.lineNumber;\n  }\n\n  return a.columnNumber - b.columnNumber;\n}\n"],
  "mappings": "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",
  "names": ["Common", "node"]
}
