{
  "version": 3,
  "sources": ["../../../../../../front_end/models/stack_trace/StackTraceImpl.ts", "../../../../../../front_end/models/stack_trace/StackTraceModel.ts", "../../../../../../front_end/models/stack_trace/Trie.ts"],
  "sourcesContent": ["// Copyright 2025 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport type * as Workspace from '../workspace/workspace.js';\n\nimport type * as StackTrace from './stack_trace.js';\nimport type {FrameNode} from './Trie.js';\n\nexport class StackTraceImpl extends Common.ObjectWrapper.ObjectWrapper<StackTrace.StackTrace.EventTypes> implements\n    StackTrace.StackTrace.StackTrace {\n  readonly syncFragment: FragmentImpl;\n  readonly asyncFragments: readonly AsyncFragmentImpl[];\n\n  constructor(syncFragment: FragmentImpl, asyncFragments: AsyncFragmentImpl[]) {\n    super();\n    this.syncFragment = syncFragment;\n    this.asyncFragments = asyncFragments;\n\n    syncFragment.stackTraces.add(this);\n    this.asyncFragments.forEach(asyncFragment => asyncFragment.fragment.stackTraces.add(this));\n  }\n}\n\nexport class FragmentImpl implements StackTrace.StackTrace.Fragment {\n  readonly node: FrameNode;\n  readonly stackTraces = new Set<StackTraceImpl>();\n\n  /**\n   * Fragments are deduplicated based on the node.\n   *\n   * In turn, each fragment can be part of multiple stack traces.\n   */\n  static getOrCreate(node: FrameNode): FragmentImpl {\n    if (!node.fragment) {\n      node.fragment = new FragmentImpl(node);\n    }\n    return node.fragment;\n  }\n\n  private constructor(node: FrameNode) {\n    this.node = node;\n  }\n\n  get frames(): FrameImpl[] {\n    const frames: FrameImpl[] = [];\n\n    for (const node of this.node.getCallStack()) {\n      frames.push(...node.frames);\n    }\n\n    return frames;\n  }\n}\n\nexport class AsyncFragmentImpl implements StackTrace.StackTrace.AsyncFragment {\n  constructor(readonly description: string, readonly fragment: FragmentImpl) {\n  }\n\n  get frames(): StackTrace.StackTrace.Frame[] {\n    return this.fragment.frames;\n  }\n}\n\nexport class FrameImpl implements StackTrace.StackTrace.Frame {\n  readonly url?: string;\n  readonly uiSourceCode?: Workspace.UISourceCode.UISourceCode;\n  readonly name?: string;\n  readonly line: number;\n  readonly column: number;\n\n  readonly missingDebugInfo?: StackTrace.StackTrace.MissingDebugInfo;\n\n  constructor(\n      url: string|undefined, uiSourceCode: Workspace.UISourceCode.UISourceCode|undefined, name: string|undefined,\n      line: number, column: number, missingDebugInfo?: StackTrace.StackTrace.MissingDebugInfo) {\n    this.url = url;\n    this.uiSourceCode = uiSourceCode;\n    this.name = name;\n    this.line = line;\n    this.column = column;\n    this.missingDebugInfo = missingDebugInfo;\n  }\n}\n", "// Copyright 2025 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as SDK from '../../core/sdk/sdk.js';\nimport type * as Protocol from '../../generated/protocol.js';\n\n// eslint-disable-next-line @devtools/es-modules-import\nimport * as StackTrace from './stack_trace.js';\nimport {AsyncFragmentImpl, FragmentImpl, FrameImpl, StackTraceImpl} from './StackTraceImpl.js';\nimport {type FrameNode, type RawFrame, Trie} from './Trie.js';\n\n/**\n * A stack trace translation function.\n *\n * Any implementation must return an array with the same length as `frames`.\n */\nexport type TranslateRawFrames = (frames: readonly RawFrame[], target: SDK.Target.Target) => Promise<\n    Array<Array<Pick<StackTrace.StackTrace.Frame, 'url'|'uiSourceCode'|'name'|'line'|'column'|'missingDebugInfo'>>>>;\n\n/**\n * The {@link StackTraceModel} is a thin wrapper around a fragment trie.\n *\n * We want to store stack trace fragments per target so a SDKModel is the natural choice.\n */\nexport class StackTraceModel extends SDK.SDKModel.SDKModel<unknown> {\n  readonly #trie = new Trie();\n\n  /** @returns the {@link StackTraceModel} for the target, or the model for the primaryPageTarget when passing null/undefined */\n  static #modelForTarget(target: SDK.Target.Target|null|undefined): StackTraceModel {\n    const model = (target ?? SDK.TargetManager.TargetManager.instance().primaryPageTarget())?.model(StackTraceModel);\n    if (!model) {\n      throw new Error('Unable to find StackTraceModel');\n    }\n    return model;\n  }\n\n  async createFromProtocolRuntime(stackTrace: Protocol.Runtime.StackTrace, rawFramesToUIFrames: TranslateRawFrames):\n      Promise<StackTrace.StackTrace.StackTrace> {\n    const [syncFragment, asyncFragments] = await Promise.all([\n      this.#createSyncFragment(stackTrace, rawFramesToUIFrames),\n      this.#createAsyncFragments(stackTrace, rawFramesToUIFrames),\n    ]);\n\n    return new StackTraceImpl(syncFragment, asyncFragments);\n  }\n\n  /** Trigger re-translation of all fragments with the provide script in their call stack */\n  async scriptInfoChanged(script: SDK.Script.Script, translateRawFrames: TranslateRawFrames): Promise<void> {\n    const translatePromises: Array<Promise<unknown>> = [];\n    let stackTracesToUpdate = new Set<StackTraceImpl>();\n\n    for (const fragment of this.#affectedFragments(script)) {\n      // We trigger re-translation only for fragments of leaf-nodes. Any fragment along the ancestor-chain\n      // is re-translated as a side-effect.\n      // We just need to remember the stack traces of the skipped over fragments, so we can send the\n      // UPDATED event also to them.\n      if (fragment.node.children.length === 0) {\n        translatePromises.push(this.#translateFragment(fragment, translateRawFrames));\n      }\n      stackTracesToUpdate = stackTracesToUpdate.union(fragment.stackTraces);\n    }\n\n    await Promise.all(translatePromises);\n\n    for (const stackTrace of stackTracesToUpdate) {\n      stackTrace.dispatchEventToListeners(StackTrace.StackTrace.Events.UPDATED);\n    }\n  }\n\n  async #createSyncFragment(stackTrace: Protocol.Runtime.StackTrace, rawFramesToUIFrames: TranslateRawFrames):\n      Promise<FragmentImpl> {\n    const fragment = this.#createFragment(stackTrace.callFrames);\n    await this.#translateFragment(fragment, rawFramesToUIFrames);\n    return fragment;\n  }\n\n  async #createAsyncFragments(\n      stackTraceOrPausedEvent: Protocol.Runtime.StackTrace|Protocol.Debugger.PausedEvent,\n      rawFramesToUIFrames: TranslateRawFrames): Promise<AsyncFragmentImpl[]> {\n    const asyncFragments: AsyncFragmentImpl[] = [];\n    const translatePromises: Array<Promise<unknown>> = [];\n\n    const debuggerModel = this.target().model(SDK.DebuggerModel.DebuggerModel);\n    if (debuggerModel) {\n      for await (\n          const {stackTrace: asyncStackTrace, target} of debuggerModel.iterateAsyncParents(stackTraceOrPausedEvent)) {\n        if (asyncStackTrace.callFrames.length === 0) {\n          // Skip empty async fragments, they don't add value.\n          continue;\n        }\n        const model = StackTraceModel.#modelForTarget(target);\n        const fragment = model.#createFragment(asyncStackTrace.callFrames);\n        translatePromises.push(model.#translateFragment(fragment, rawFramesToUIFrames));\n        asyncFragments.push(new AsyncFragmentImpl(asyncStackTrace.description ?? '', fragment));\n      }\n    }\n\n    await Promise.all(translatePromises);\n    return asyncFragments;\n  }\n\n  #createFragment(frames: RawFrame[]): FragmentImpl {\n    return FragmentImpl.getOrCreate(this.#trie.insert(frames));\n  }\n\n  async #translateFragment(fragment: FragmentImpl, rawFramesToUIFrames: TranslateRawFrames): Promise<void> {\n    const rawFrames = fragment.node.getCallStack().map(node => node.rawFrame).toArray();\n    const uiFrames = await rawFramesToUIFrames(rawFrames, this.target());\n    console.assert(rawFrames.length === uiFrames.length, 'Broken rawFramesToUIFrames implementation');\n\n    let i = 0;\n    for (const node of fragment.node.getCallStack()) {\n      node.frames = uiFrames[i++].map(\n          frame => new FrameImpl(\n              frame.url, frame.uiSourceCode, frame.name, frame.line, frame.column, frame.missingDebugInfo));\n    }\n  }\n\n  #affectedFragments(script: SDK.Script.Script): Set<FragmentImpl> {\n    // 1. Collect branches with the matching script.\n    const affectedBranches = new Set<FrameNode>();\n    this.#trie.walk(null, node => {\n      // scriptId has precedence, but if the frame does not have one, check the URL.\n      if (node.rawFrame.scriptId === script.scriptId ||\n          (!node.rawFrame.scriptId && node.rawFrame.url === script.sourceURL)) {\n        affectedBranches.add(node);\n        return false;\n      }\n      return true;\n    });\n\n    // 2. For each branch collect all the fragments.\n    const fragments = new Set<FragmentImpl>();\n    for (const branch of affectedBranches) {\n      this.#trie.walk(branch, node => {\n        if (node.fragment) {\n          fragments.add(node.fragment);\n        }\n        return true;\n      });\n    }\n    return fragments;\n  }\n}\n\nSDK.SDKModel.SDKModel.register(StackTraceModel, {capabilities: SDK.Target.Capability.NONE, autostart: false});\n", "// Copyright 2025 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Protocol from '../../generated/protocol.js';\n\nimport type {FragmentImpl, FrameImpl} from './StackTraceImpl.js';\n\n/**\n * Intentionally very close to a {@link Protocol.Runtime.CallFrame} but with optional `scriptId`.\n */\nexport interface RawFrame {\n  readonly scriptId?: Protocol.Runtime.ScriptId;\n  readonly url?: string;\n  readonly functionName?: string;\n  readonly lineNumber: number;\n  readonly columnNumber: number;\n}\n\n/**\n * @returns whether the frame is a V8 builtin frame e.g. Array.map. Builtin frames\n * have neither source position nor script or URL. They only have a name.\n */\nexport function isBuiltinFrame(rawFrame: RawFrame): boolean {\n  return rawFrame.lineNumber === -1 && rawFrame.columnNumber === -1 && !Boolean(rawFrame.scriptId) &&\n      !Boolean(rawFrame.url);\n}\n\ninterface FrameNodeBase<ChildT, ParentT> {\n  readonly parent: ParentT;\n  readonly children: ChildT[];\n}\n\ntype RootFrameNode = FrameNodeBase<WeakRef<FrameNode>, null>;\ntype AnyFrameNode = FrameNode|RootFrameNode;\n\nexport class FrameNode implements FrameNodeBase<FrameNode, AnyFrameNode> {\n  readonly parent: AnyFrameNode;\n  readonly children: FrameNode[] = [];\n\n  readonly rawFrame: RawFrame;\n  frames: FrameImpl[] = [];\n\n  fragment?: FragmentImpl;\n\n  constructor(rawFrame: RawFrame, parent: AnyFrameNode) {\n    this.rawFrame = rawFrame;\n    this.parent = parent;\n  }\n\n  /**\n   * Produces the ancestor chain. Including `this` but excluding the `RootFrameNode`.\n   */\n  * getCallStack(): Generator<FrameNode> {\n    // The `RootFrameNode` doesn't have an actual frame attached, that's why we check for `node.parent` instead of `node`.\n    for (let node: AnyFrameNode|null = this; node.parent; node = node.parent) {\n      yield node;\n    }\n  }\n}\n\n/**\n * Stores stack trace fragments in a trie, but does not own them/keep them alive.\n */\nexport class Trie {\n  readonly #root: RootFrameNode = {parent: null, children: []};\n\n  /**\n   * Most sources produce stack traces in \"top-to-bottom\" order, so that is what this method expects.\n   *\n   * @returns The {@link FrameNode} corresponding to the top-most stack frame.\n   */\n  insert(frames: RawFrame[]): FrameNode {\n    if (frames.length === 0) {\n      throw new Error('Trie.insert called with an empty frames array.');\n    }\n\n    let currentNode: AnyFrameNode = this.#root;\n    for (let i = frames.length - 1; i >= 0; --i) {\n      currentNode = this.#insert(currentNode, frames[i]);\n    }\n    return currentNode as FrameNode;\n  }\n\n  /**\n   * Inserts `rawFrame` into the children of the provided node if not already there.\n   *\n   * @returns the child node corresponding to `rawFrame`.\n   */\n  #insert(node: AnyFrameNode, rawFrame: RawFrame): FrameNode {\n    let i = 0;\n    for (; i < node.children.length; ++i) {\n      const maybeChild = node.children[i];\n      const child = maybeChild instanceof WeakRef ? maybeChild.deref() : maybeChild;\n      if (!child) {\n        continue;\n      }\n\n      const compareResult = compareRawFrames(child.rawFrame, rawFrame);\n      if (compareResult === 0) {\n        return child;\n      }\n      if (compareResult > 0) {\n        break;\n      }\n    }\n\n    const newNode = new FrameNode(rawFrame, node);\n    if (node.parent) {\n      node.children.splice(i, 0, newNode);\n    } else {\n      node.children.splice(i, 0, new WeakRef(newNode));\n    }\n    return newNode;\n  }\n\n  /**\n   * Traverses the trie in pre-order.\n   *\n   * @param node Start at `node` or `null` to start with the children of the root.\n   * @param visit Called on each node in the trie. Return `true` if the visitor should descend into child nodes of the provided node.\n   */\n  walk(node: FrameNode|null, visit: (node: FrameNode) => boolean): void {\n    const stack =\n        node ? [node] : [...this.#root.children].map(ref => ref.deref()).filter(node => Boolean(node)) as FrameNode[];\n\n    for (let node = stack.pop(); node; node = stack.pop()) {\n      const visitChildren = visit(node);\n      if (visitChildren) {\n        // Pushing the children in reverse means the \"left-most\" child is visited first (i.e. pre-order).\n        for (let i = node.children.length - 1; i >= 0; --i) {\n          stack.push(node.children[i]);\n        }\n      }\n    }\n  }\n}\n\n/**\n * @returns a number < 0, 0 or > 0, if the `a` is smaller then, equal or greater then `b`.\n */\nexport function compareRawFrames(a: RawFrame, b: RawFrame): number {\n  const scriptIdCompare = (a.scriptId ?? '').localeCompare(b.scriptId ?? '');\n  if (scriptIdCompare !== 0) {\n    return scriptIdCompare;\n  }\n\n  const urlCompare = (a.url ?? '').localeCompare(b.url ?? '');\n  if (urlCompare !== 0) {\n    return urlCompare;\n  }\n\n  const nameCompare = (a.functionName ?? '').localeCompare(b.functionName ?? '');\n  if (nameCompare !== 0) {\n    return nameCompare;\n  }\n\n  if (a.lineNumber !== b.lineNumber) {\n    return a.lineNumber - b.lineNumber;\n  }\n\n  return a.columnNumber - b.columnNumber;\n}\n"],
  "mappings": "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",
  "names": ["node"]
}
