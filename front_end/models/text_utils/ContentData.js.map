{"version":3,"file":"ContentData.js","sourceRoot":"","sources":["../../../../../../front_end/models/text_utils/ContentData.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../core/platform/platform.js';\n\nimport { contentAsDataURL, type DeferredContent } from './ContentProvider.js';\nimport {Text} from './Text.js';\n\n/**\n * This class is a small wrapper around either raw binary or text data.\n * As the binary data can actually contain textual data, we also store the\n * MIME type and if applicable, the charset.\n *\n * This information should be generally kept together, as interpreting text\n * from raw bytes requires an encoding.\n *\n * Note that we only rarely have to decode text ourselves in the frontend,\n * this is mostly handled by the backend. There are cases though (e.g. SVG,\n * or streaming response content) where we receive text data in\n * binary (base64-encoded) form.\n *\n * The class only implements decoding. We currently don't have a use-case\n * to re-encode text into base64 bytes using a specified charset.\n */\nexport class ContentData {\n  readonly mimeType: string;\n  readonly charset: string;\n\n  #contentAsBase64?: string;\n  #contentAsText?: string;\n\n  #contentAsTextObj?: Text;\n\n  constructor(data: string, isBase64: boolean, mimeType: string, charset?: string) {\n    this.charset = charset || 'utf-8';\n    if (isBase64) {\n      this.#contentAsBase64 = data;\n    } else {\n      this.#contentAsText = data;\n    }\n\n    this.mimeType = mimeType;\n    if (!this.mimeType) {\n      // Tests or broken requests might pass an empty/undefined mime type. Fallback to\n      // \"default\" mime types.\n      this.mimeType = isBase64 ? 'application/octet-stream' : 'text/plain';\n    }\n  }\n\n  /**\n   * Returns the data as base64.\n   *\n   * @throws if this `ContentData` was constructed from text content.\n   */\n  get base64(): string {\n    if (this.#contentAsBase64 === undefined) {\n      throw new Error('Encoding text content as base64 is not supported');\n    }\n    return this.#contentAsBase64;\n  }\n\n  /**\n   * Returns the content as text. If this `ContentData` was constructed with base64\n   * encoded bytes, it will use the provided charset to attempt to decode the bytes.\n   *\n   * @throws if `mimeType` is not a text type.\n   */\n  get text(): string {\n    if (this.#contentAsText !== undefined) {\n      return this.#contentAsText;\n    }\n\n    if (!this.isTextContent) {\n      throw new Error('Cannot interpret binary data as text');\n    }\n\n    const binaryString = window.atob(this.#contentAsBase64 as string);\n    const len = binaryString.length;\n    const bytes = new Uint8Array(len);\n    for (let i = 0; i < len; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n\n    this.#contentAsText = new TextDecoder(this.charset).decode(bytes);\n    return this.#contentAsText;\n  }\n\n  /** @returns true, if this `ContentData` was constructed from text content or the mime type indicates text that can be decoded */\n  get isTextContent(): boolean {\n    return this.#createdFromText || Platform.MimeType.isTextType(this.mimeType);\n  }\n\n  get isEmpty(): boolean {\n    // Don't trigger unnecessary decoding. Only check if both of the strings are empty.\n    return !Boolean(this.#contentAsBase64) && !Boolean(this.#contentAsText);\n  }\n\n  get createdFromBase64(): boolean {\n    return this.#contentAsBase64 !== undefined;\n  }\n\n  get #createdFromText(): boolean {\n    return this.#contentAsBase64 === undefined;\n  }\n\n  /**\n   * Returns the text content as a `Text` object. The returned object is always the same to\n   * minimize the number of times we have to calculate the line endings array.\n   *\n   * @throws if `mimeType` is not a text type.\n   */\n  get textObj(): Text {\n    if (this.#contentAsTextObj === undefined) {\n      this.#contentAsTextObj = new Text(this.text);\n    }\n    return this.#contentAsTextObj;\n  }\n\n  /**\n   * @returns True, iff the contents (base64 or text) are equal.\n   * Does not compare mime type and charset, but will decode base64 data if both\n   * mime types indicate that it's text content.\n   */\n  contentEqualTo(other: ContentData): boolean {\n    if (this.#contentAsBase64 !== undefined && other.#contentAsBase64 !== undefined) {\n      return this.#contentAsBase64 === other.#contentAsBase64;\n    }\n    if (this.#contentAsText !== undefined && other.#contentAsText !== undefined) {\n      return this.#contentAsText === other.#contentAsText;\n    }\n    if (this.isTextContent && other.isTextContent) {\n      return this.text === other.text;\n    }\n    return false;\n  }\n\n  asDataUrl(): string|null {\n    // To keep with existing behavior we prefer to return the content\n    // encoded if that is how this ContentData was constructed with.\n    if (this.#contentAsBase64 !== undefined) {\n      const charset = this.isTextContent ? this.charset : null;\n      return contentAsDataURL(this.#contentAsBase64, this.mimeType ?? '', true, charset);\n    }\n    return contentAsDataURL(this.text, this.mimeType ?? '', false, 'utf-8');\n  }\n\n  /**\n   * @deprecated Used during migration from `DeferredContent` to `ContentData`.\n   */\n  asDeferedContent(): DeferredContent {\n    // To prevent encoding mistakes, we'll return text content already decoded.\n    if (this.isTextContent) {\n      return {content: this.text, isEncoded: false};\n    }\n    if (this.#contentAsText !== undefined) {\n      // Unknown text mime type, this should not really happen.\n      return {content: this.#contentAsText, isEncoded: false};\n    }\n    if (this.#contentAsBase64 !== undefined) {\n      return {content: this.#contentAsBase64, isEncoded: true};\n    }\n    throw new Error('Unreachable');\n  }\n\n  static isError(contentDataOrError: ContentDataOrError): contentDataOrError is {error: string} {\n    return 'error' in contentDataOrError;\n  }\n\n  /** @returns `value` if the passed `ContentDataOrError` is an error, or the text content otherwise */\n  static textOr<T>(contentDataOrError: ContentDataOrError, value: T): string|T {\n    if (ContentData.isError(contentDataOrError)) {\n      return value;\n    }\n    return contentDataOrError.text;\n  }\n\n  /** @returns an empty 'text/plain' content data if the passed `ContentDataOrError` is an error, or the content data itself otherwise */\n  static contentDataOrEmpty(contentDataOrError: ContentDataOrError): ContentData {\n    if (ContentData.isError(contentDataOrError)) {\n      return EMPTY_TEXT_CONTENT_DATA;\n    }\n    return contentDataOrError;\n  }\n\n  /**\n   * @deprecated Used during migration from `DeferredContent` to `ContentData`.\n   */\n  static asDeferredContent(contentDataOrError: ContentDataOrError): DeferredContent {\n    if (ContentData.isError(contentDataOrError)) {\n      return {error: contentDataOrError.error, content: null, isEncoded: false};\n    }\n    return contentDataOrError.asDeferedContent();\n  }\n}\n\nexport const EMPTY_TEXT_CONTENT_DATA = new ContentData('', /* isBase64 */ false, 'text/plain');\n\nexport type ContentDataOrError = ContentData|{error: string};\n"]}