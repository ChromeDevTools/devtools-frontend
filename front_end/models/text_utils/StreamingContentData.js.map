{"version":3,"file":"StreamingContentData.js","sourceRoot":"","sources":["../../../../../../front_end/models/text_utils/StreamingContentData.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport * as Platform from '../../core/platform/platform.js';\n\nimport {ContentData, type ContentDataOrError} from './ContentData.js';\n\n/**\n * Usage of this class is mostly intended for content that is never \"complete\".\n * E.g. streaming XHR/fetch requests.\n *\n * Due to the streaming nature this class only supports base64-encoded binary data.\n * Decoding to text only happens on-demand by clients. This ensures that at most we have\n * incomplete unicode at the end and not in-between chunks.\n */\nexport class StreamingContentData extends Common.ObjectWrapper.ObjectWrapper<EventTypes> {\n  readonly mimeType: string;\n  readonly #charset?: string;\n\n  readonly #disallowStreaming: boolean;\n\n  #chunks: string[] = [];\n  #contentData?: ContentData;\n\n  private constructor(mimeType: string, charset?: string, initialContent?: ContentData) {\n    super();\n    this.mimeType = mimeType;\n    this.#charset = charset;\n    this.#disallowStreaming = Boolean(initialContent && !initialContent.createdFromBase64);\n    this.#contentData = initialContent;\n  }\n\n  /**\n   * Creates a new StreamingContentData with the given MIME type/charset.\n   */\n  static create(mimeType: string, charset?: string): StreamingContentData {\n    return new StreamingContentData(mimeType, charset);\n  }\n\n  /**\n   * Creates a new StringContentData from an existing ContentData instance.\n   *\n   * Calling `addChunk` is on the resulting `StreamingContentData` is illegal if\n   * `content` was not created from base64 data. The reason is that JavaScript TextEncoder\n   * only supports UTF-8. We can't convert text with arbitrary encoding back to base64 for concatenation.\n   */\n  static from(content: ContentData): StreamingContentData {\n    return new StreamingContentData(content.mimeType, content.charset, content);\n  }\n\n  /** @returns true, if this `ContentData` was constructed from text content or the mime type indicates text that can be decoded */\n  get isTextContent(): boolean {\n    if (this.#contentData) {\n      return this.#contentData.isTextContent;\n    }\n    return Platform.MimeType.isTextType(this.mimeType);\n  }\n\n  /** @param chunk base64 encoded data */\n  addChunk(chunk: string): void {\n    if (this.#disallowStreaming) {\n      throw new Error('Cannot add base64 data to a text-only ContentData.');\n    }\n\n    this.#chunks.push(chunk);\n    this.dispatchEventToListeners(Events.CHUNK_ADDED, {content: this, chunk});\n  }\n\n  /** @returns An immutable ContentData with all the bytes received so far */\n  content(): ContentData {\n    if (this.#contentData && this.#chunks.length === 0) {\n      return this.#contentData;\n    }\n\n    const initialBase64 = this.#contentData?.base64 ?? '';\n    const base64Content =\n        this.#chunks.reduce((acc, chunk) => Platform.StringUtilities.concatBase64(acc, chunk), initialBase64);\n    this.#contentData = new ContentData(base64Content, /* isBase64=*/ true, this.mimeType, this.#charset);\n    this.#chunks = [];\n    return this.#contentData;\n  }\n}\n\nexport type StreamingContentDataOrError = StreamingContentData|{error: string};\n\nexport const isError = function(contentDataOrError: StreamingContentDataOrError): contentDataOrError is {\nerror:\n  string,\n} {\n  return 'error' in contentDataOrError;\n};\n\nexport const asContentDataOrError = function(contentDataOrError: StreamingContentDataOrError): ContentDataOrError {\n  if (isError(contentDataOrError)) {\n    return contentDataOrError;\n  }\n  return contentDataOrError.content();\n};\n\nexport const enum Events {\n  CHUNK_ADDED = 'ChunkAdded',\n}\n\nexport interface EventTypes {\n  [Events.CHUNK_ADDED]: {content: StreamingContentData, chunk: string};\n}\n"]}