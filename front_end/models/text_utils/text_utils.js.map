{
  "version": 3,
  "sources": ["../../../../../../front_end/models/text_utils/CodeMirrorUtils.ts", "../../../../../../front_end/models/text_utils/ContentData.ts", "../../../../../../front_end/models/text_utils/ContentProvider.ts", "../../../../../../front_end/models/text_utils/Text.ts", "../../../../../../front_end/models/text_utils/TextCursor.ts", "../../../../../../front_end/models/text_utils/TextRange.ts", "../../../../../../front_end/models/text_utils/StaticContentProvider.ts", "../../../../../../front_end/models/text_utils/TextUtils.ts", "../../../../../../front_end/models/text_utils/StreamingContentData.ts", "../../../../../../front_end/models/text_utils/WasmDisassembly.ts"],
  "sourcesContent": ["// Copyright 2022 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as CodeMirror from '../../third_party/codemirror.next/codemirror.next.js';\n\ntype Tokenizer = (line: string, callback: (value: string, style: string|null) => void) => Promise<void>;\n\nexport function createCssTokenizer(): Tokenizer {\n  async function tokenize(line: string, callback: (value: string, style: string|null) => void): Promise<void> {\n    const streamParser = await CodeMirror.cssStreamParser();\n    const stream = new CodeMirror.StringStream(line, 4, 2);\n\n    const state = streamParser.startState(2);\n    let lastPos = stream.pos;\n    while (!stream.eol()) {\n      stream.start = lastPos;\n      let tokenType = streamParser.token(stream, state);\n      /**\n       * We expect unknown properties (like `unknownProp: unknownPropVal`) to still be\n       * formatted correctly. However, `tokenType` for such properties are marked\n       * as `error` from CodeMirror side and the internal state of the parser becomes `maybeprop`.\n       *\n       * So, we handle that specific keyword to be marked as `property` even though it is\n       * not a known property. We do this because for our formatting purposes it doesn't matter\n       * whether a property is a known CSS property or not.\n       */\n      if (tokenType === 'error' && state.state === 'maybeprop') {\n        tokenType = 'property';\n      }\n      const segment = stream.current();\n      callback(segment, tokenType);\n      lastPos = stream.pos;\n    }\n  }\n  return tokenize;\n}\n", "// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../core/platform/platform.js';\n\nimport { contentAsDataURL, type DeferredContent } from './ContentProvider.js';\nimport {Text} from './Text.js';\n\n/**\n * This class is a small wrapper around either raw binary or text data.\n * As the binary data can actually contain textual data, we also store the\n * MIME type and if applicable, the charset.\n *\n * This information should be generally kept together, as interpreting text\n * from raw bytes requires an encoding.\n *\n * Note that we only rarely have to decode text ourselves in the frontend,\n * this is mostly handled by the backend. There are cases though (e.g. SVG,\n * or streaming response content) where we receive text data in\n * binary (base64-encoded) form.\n *\n * The class only implements decoding. We currently don't have a use-case\n * to re-encode text into base64 bytes using a specified charset.\n */\nexport class ContentData {\n  readonly mimeType: string;\n  readonly charset: string;\n\n  #contentAsBase64?: string;\n  #contentAsText?: string;\n\n  #contentAsTextObj?: Text;\n\n  constructor(data: string, isBase64: boolean, mimeType: string, charset?: string) {\n    this.charset = charset || 'utf-8';\n    if (isBase64) {\n      this.#contentAsBase64 = data;\n    } else {\n      this.#contentAsText = data;\n    }\n\n    this.mimeType = mimeType;\n    if (!this.mimeType) {\n      // Tests or broken requests might pass an empty/undefined mime type. Fallback to\n      // \"default\" mime types.\n      this.mimeType = isBase64 ? 'application/octet-stream' : 'text/plain';\n    }\n  }\n\n  /**\n   * Returns the data as base64.\n   *\n   * @throws if this `ContentData` was constructed from text content.\n   */\n  get base64(): string {\n    if (this.#contentAsBase64 === undefined) {\n      throw new Error('Encoding text content as base64 is not supported');\n    }\n    return this.#contentAsBase64;\n  }\n\n  /**\n   * Returns the content as text. If this `ContentData` was constructed with base64\n   * encoded bytes, it will use the provided charset to attempt to decode the bytes.\n   *\n   * @throws if `mimeType` is not a text type.\n   */\n  get text(): string {\n    if (this.#contentAsText !== undefined) {\n      return this.#contentAsText;\n    }\n\n    if (!this.isTextContent) {\n      throw new Error('Cannot interpret binary data as text');\n    }\n\n    const binaryString = window.atob(this.#contentAsBase64 as string);\n    const len = binaryString.length;\n    const bytes = new Uint8Array(len);\n    for (let i = 0; i < len; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n\n    this.#contentAsText = new TextDecoder(this.charset).decode(bytes);\n    return this.#contentAsText;\n  }\n\n  /** @returns true, if this `ContentData` was constructed from text content or the mime type indicates text that can be decoded */\n  get isTextContent(): boolean {\n    return this.#createdFromText || Platform.MimeType.isTextType(this.mimeType);\n  }\n\n  get isEmpty(): boolean {\n    // Don't trigger unnecessary decoding. Only check if both of the strings are empty.\n    return !Boolean(this.#contentAsBase64) && !Boolean(this.#contentAsText);\n  }\n\n  get createdFromBase64(): boolean {\n    return this.#contentAsBase64 !== undefined;\n  }\n\n  get #createdFromText(): boolean {\n    return this.#contentAsBase64 === undefined;\n  }\n\n  /**\n   * Returns the text content as a `Text` object. The returned object is always the same to\n   * minimize the number of times we have to calculate the line endings array.\n   *\n   * @throws if `mimeType` is not a text type.\n   */\n  get textObj(): Text {\n    if (this.#contentAsTextObj === undefined) {\n      this.#contentAsTextObj = new Text(this.text);\n    }\n    return this.#contentAsTextObj;\n  }\n\n  /**\n   * @returns True, iff the contents (base64 or text) are equal.\n   * Does not compare mime type and charset, but will decode base64 data if both\n   * mime types indicate that it's text content.\n   */\n  contentEqualTo(other: ContentData): boolean {\n    if (this.#contentAsBase64 !== undefined && other.#contentAsBase64 !== undefined) {\n      return this.#contentAsBase64 === other.#contentAsBase64;\n    }\n    if (this.#contentAsText !== undefined && other.#contentAsText !== undefined) {\n      return this.#contentAsText === other.#contentAsText;\n    }\n    if (this.isTextContent && other.isTextContent) {\n      return this.text === other.text;\n    }\n    return false;\n  }\n\n  asDataUrl(): string|null {\n    // To keep with existing behavior we prefer to return the content\n    // encoded if that is how this ContentData was constructed with.\n    if (this.#contentAsBase64 !== undefined) {\n      const charset = this.isTextContent ? this.charset : null;\n      return contentAsDataURL(this.#contentAsBase64, this.mimeType ?? '', true, charset);\n    }\n    return contentAsDataURL(this.text, this.mimeType ?? '', false, 'utf-8');\n  }\n\n  /**\n   * @deprecated Used during migration from `DeferredContent` to `ContentData`.\n   */\n  asDeferedContent(): DeferredContent {\n    // To prevent encoding mistakes, we'll return text content already decoded.\n    if (this.isTextContent) {\n      return {content: this.text, isEncoded: false};\n    }\n    if (this.#contentAsText !== undefined) {\n      // Unknown text mime type, this should not really happen.\n      return {content: this.#contentAsText, isEncoded: false};\n    }\n    if (this.#contentAsBase64 !== undefined) {\n      return {content: this.#contentAsBase64, isEncoded: true};\n    }\n    throw new Error('Unreachable');\n  }\n\n  static isError(contentDataOrError: ContentDataOrError): contentDataOrError is {error: string} {\n    return 'error' in contentDataOrError;\n  }\n\n  /** @returns `value` if the passed `ContentDataOrError` is an error, or the text content otherwise */\n  static textOr<T>(contentDataOrError: ContentDataOrError, value: T): string|T {\n    if (ContentData.isError(contentDataOrError)) {\n      return value;\n    }\n    return contentDataOrError.text;\n  }\n\n  /** @returns an empty 'text/plain' content data if the passed `ContentDataOrError` is an error, or the content data itself otherwise */\n  static contentDataOrEmpty(contentDataOrError: ContentDataOrError): ContentData {\n    if (ContentData.isError(contentDataOrError)) {\n      return EMPTY_TEXT_CONTENT_DATA;\n    }\n    return contentDataOrError;\n  }\n\n  /**\n   * @deprecated Used during migration from `DeferredContent` to `ContentData`.\n   */\n  static asDeferredContent(contentDataOrError: ContentDataOrError): DeferredContent {\n    if (ContentData.isError(contentDataOrError)) {\n      return {error: contentDataOrError.error, content: null, isEncoded: false};\n    }\n    return contentDataOrError.asDeferedContent();\n  }\n}\n\nexport const EMPTY_TEXT_CONTENT_DATA = new ContentData('', /* isBase64 */ false, 'text/plain');\n\nexport type ContentDataOrError = ContentData|{error: string};\n", "// Copyright 2012 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Common from '../../core/common/common.js';\nimport type * as Platform from '../../core/platform/platform.js';\n\nimport type {ContentDataOrError} from './ContentData.js';\nimport type {StreamingContentDataOrError} from './StreamingContentData.js';\nimport type {WasmDisassembly} from './WasmDisassembly.js';\n\nexport interface ContentProvider {\n  contentURL(): Platform.DevToolsPath.UrlString;\n  contentType(): Common.ResourceType.ResourceType;\n  requestContentData(): Promise<ContentDataOrError>;\n  searchInContent(query: string, caseSensitive: boolean, isRegex: boolean): Promise<SearchMatch[]>;\n}\n\nexport class SearchMatch {\n  constructor(\n      readonly lineNumber: number, readonly lineContent: string, readonly columnNumber: number,\n      readonly matchLength: number) {\n  }\n\n  static comparator(a: SearchMatch, b: SearchMatch): number {\n    return a.lineNumber - b.lineNumber || a.columnNumber - b.columnNumber;\n  }\n}\n\nexport const contentAsDataURL = function(\n    content: string|null, mimeType: string, contentEncoded: boolean, charset?: string|null,\n    limitSize = true): string|null {\n  const maxDataUrlSize = 1024 * 1024;\n  if (content === undefined || content === null || (limitSize && content.length > maxDataUrlSize)) {\n    return null;\n  }\n\n  content = contentEncoded ? content : encodeURIComponent(content);\n  return 'data:' + mimeType + (charset ? ';charset=' + charset : '') + (contentEncoded ? ';base64' : '') + ',' +\n      content;\n};\n\nexport type DeferredContent = {\n  content: string,\n  isEncoded: boolean,\n}|{\n  content: '',\n  isEncoded: false,\n  wasmDisassemblyInfo: WasmDisassembly,\n}|{\n  content: null,\n  error: string,\n  isEncoded: boolean,\n};\n\n/**\n * Some ContentProvider like NetworkRequests might never actually be able to return\n * a fully completed \"requestContentData\" as the request keeps on going indefinitely.\n * Such proivders can implement the \"StreamingContentProvider\" addition, which allows\n * for partial/streaming content.\n **/\nexport interface StreamingContentProvider extends ContentProvider {\n  requestStreamingContent(): Promise<StreamingContentDataOrError>;\n}\n\nexport const isStreamingContentProvider = function(provider: ContentProvider): provider is StreamingContentProvider {\n  return 'requestStreamingContent' in provider;\n};\n", "// Copyright 2016 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../core/platform/platform.js';\n\nimport {TextCursor} from './TextCursor.js';\nimport {SourceRange, TextRange} from './TextRange.js';\n\nexport class Text {\n  readonly #value: string;\n  #lineEndings?: number[];\n\n  constructor(value: string) {\n    this.#value = value;\n  }\n\n  lineEndings(): number[] {\n    if (!this.#lineEndings) {\n      this.#lineEndings = Platform.StringUtilities.findLineEndingIndexes(this.#value);\n    }\n    return this.#lineEndings;\n  }\n\n  value(): string {\n    return this.#value;\n  }\n\n  lineCount(): number {\n    const lineEndings = this.lineEndings();\n    return lineEndings.length;\n  }\n\n  offsetFromPosition(lineNumber: number, columnNumber: number): number {\n    return (lineNumber ? this.lineEndings()[lineNumber - 1] + 1 : 0) + columnNumber;\n  }\n\n  positionFromOffset(offset: number): Position {\n    const lineEndings = this.lineEndings();\n    const lineNumber =\n        Platform.ArrayUtilities.lowerBound(lineEndings, offset, Platform.ArrayUtilities.DEFAULT_COMPARATOR);\n    return {lineNumber, columnNumber: offset - (lineNumber && (lineEndings[lineNumber - 1] + 1))};\n  }\n\n  lineAt(lineNumber: number): string {\n    const lineEndings = this.lineEndings();\n    const lineStart = lineNumber > 0 ? lineEndings[lineNumber - 1] + 1 : 0;\n    const lineEnd = lineEndings[lineNumber];\n    let lineContent = this.#value.substring(lineStart, lineEnd);\n    if (lineContent.length > 0 && lineContent.charAt(lineContent.length - 1) === '\\r') {\n      lineContent = lineContent.substring(0, lineContent.length - 1);\n    }\n    return lineContent;\n  }\n\n  toSourceRange(range: TextRange): SourceRange {\n    const start = this.offsetFromPosition(range.startLine, range.startColumn);\n    const end = this.offsetFromPosition(range.endLine, range.endColumn);\n    return new SourceRange(start, end - start);\n  }\n\n  toTextRange(sourceRange: SourceRange): TextRange {\n    const cursor = new TextCursor(this.lineEndings());\n    const result = TextRange.createFromLocation(0, 0);\n\n    cursor.resetTo(sourceRange.offset);\n    result.startLine = cursor.lineNumber();\n    result.startColumn = cursor.columnNumber();\n\n    cursor.advance(sourceRange.offset + sourceRange.length);\n    result.endLine = cursor.lineNumber();\n    result.endColumn = cursor.columnNumber();\n    return result;\n  }\n\n  replaceRange(range: TextRange, replacement: string): string {\n    const sourceRange = this.toSourceRange(range);\n    return this.#value.substring(0, sourceRange.offset) + replacement +\n        this.#value.substring(sourceRange.offset + sourceRange.length);\n  }\n\n  extract(range: TextRange): string {\n    const sourceRange = this.toSourceRange(range);\n    return this.#value.substr(sourceRange.offset, sourceRange.length);\n  }\n}\nexport interface Position {\n  lineNumber: number;\n  columnNumber: number;\n}\n", "// Copyright 2020 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../core/platform/platform.js';\n\nexport class TextCursor {\n  readonly #lineEndings: number[];\n\n  #offset = 0;\n  #lineNumber = 0;\n  #columnNumber = 0;\n\n  constructor(lineEndings: number[]) {\n    this.#lineEndings = lineEndings;\n  }\n\n  advance(offset: number): void {\n    this.#offset = offset;\n    while (this.#lineNumber < this.#lineEndings.length && this.#lineEndings[this.#lineNumber] < this.#offset) {\n      ++this.#lineNumber;\n    }\n    this.#columnNumber = this.#lineNumber ? this.#offset - this.#lineEndings[this.#lineNumber - 1] - 1 : this.#offset;\n  }\n\n  offset(): number {\n    return this.#offset;\n  }\n\n  resetTo(offset: number): void {\n    this.#offset = offset;\n    this.#lineNumber =\n        Platform.ArrayUtilities.lowerBound(this.#lineEndings, offset, Platform.ArrayUtilities.DEFAULT_COMPARATOR);\n    this.#columnNumber = this.#lineNumber ? this.#offset - this.#lineEndings[this.#lineNumber - 1] - 1 : this.#offset;\n  }\n\n  lineNumber(): number {\n    return this.#lineNumber;\n  }\n\n  columnNumber(): number {\n    return this.#columnNumber;\n  }\n}\n", "// Copyright 2013 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../core/platform/platform.js';\n\nconst MAX_SAFE_INT32 = 2 ** 31 - 1;\n\nexport interface SerializedTextRange {\n  startLine: number;\n  startColumn: number;\n  endLine: number;\n  endColumn: number;\n}\n\nexport class TextRange {\n  constructor(public startLine: number, public startColumn: number, public endLine: number, public endColumn: number) {\n  }\n\n  static createFromLocation(line: number, column: number): TextRange {\n    return new TextRange(line, column, line, column);\n  }\n\n  static createUnboundedFromLocation(line: number, column: number): TextRange {\n    return new TextRange(line, column, MAX_SAFE_INT32, MAX_SAFE_INT32);\n  }\n\n  static fromObject(serializedTextRange: SerializedTextRange): TextRange {\n    return new TextRange(\n        serializedTextRange.startLine, serializedTextRange.startColumn, serializedTextRange.endLine,\n        serializedTextRange.endColumn);\n  }\n\n  static comparator(range1: TextRange, range2: TextRange): number {\n    return range1.compareTo(range2);\n  }\n\n  static fromEdit(oldRange: TextRange, newText: string): TextRange {\n    let endLine: number = oldRange.startLine;\n    let endColumn: number = oldRange.startColumn + newText.length;\n\n    const lineEndings = Platform.StringUtilities.findLineEndingIndexes(newText);\n    if (lineEndings.length > 1) {\n      endLine = oldRange.startLine + lineEndings.length - 1;\n      const len = lineEndings.length;\n      endColumn = lineEndings[len - 1] - lineEndings[len - 2] - 1;\n    }\n    return new TextRange(oldRange.startLine, oldRange.startColumn, endLine, endColumn);\n  }\n\n  isEmpty(): boolean {\n    return this.startLine === this.endLine && this.startColumn === this.endColumn;\n  }\n\n  immediatelyPrecedes(range?: TextRange): boolean {\n    if (!range) {\n      return false;\n    }\n    return this.endLine === range.startLine && this.endColumn === range.startColumn;\n  }\n\n  immediatelyFollows(range?: TextRange): boolean {\n    if (!range) {\n      return false;\n    }\n    return range.immediatelyPrecedes(this);\n  }\n\n  follows(range: TextRange): boolean {\n    return (range.endLine === this.startLine && range.endColumn <= this.startColumn) || range.endLine < this.startLine;\n  }\n\n  get linesCount(): number {\n    return this.endLine - this.startLine;\n  }\n\n  collapseToEnd(): TextRange {\n    return new TextRange(this.endLine, this.endColumn, this.endLine, this.endColumn);\n  }\n\n  collapseToStart(): TextRange {\n    return new TextRange(this.startLine, this.startColumn, this.startLine, this.startColumn);\n  }\n\n  normalize(): TextRange {\n    if (this.startLine > this.endLine || (this.startLine === this.endLine && this.startColumn > this.endColumn)) {\n      return new TextRange(this.endLine, this.endColumn, this.startLine, this.startColumn);\n    }\n    return this.clone();\n  }\n\n  clone(): TextRange {\n    return new TextRange(this.startLine, this.startColumn, this.endLine, this.endColumn);\n  }\n\n  serializeToObject(): {\n    startLine: number,\n    startColumn: number,\n    endLine: number,\n    endColumn: number,\n  } {\n    return {\n      startLine: this.startLine,\n      startColumn: this.startColumn,\n      endLine: this.endLine,\n      endColumn: this.endColumn,\n    };\n  }\n\n  compareTo(other: TextRange): number {\n    if (this.startLine > other.startLine) {\n      return 1;\n    }\n    if (this.startLine < other.startLine) {\n      return -1;\n    }\n    if (this.startColumn > other.startColumn) {\n      return 1;\n    }\n    if (this.startColumn < other.startColumn) {\n      return -1;\n    }\n    return 0;\n  }\n\n  compareToPosition(lineNumber: number, columnNumber: number): number {\n    if (lineNumber < this.startLine || (lineNumber === this.startLine && columnNumber < this.startColumn)) {\n      return -1;\n    }\n    if (lineNumber > this.endLine || (lineNumber === this.endLine && columnNumber > this.endColumn)) {\n      return 1;\n    }\n    return 0;\n  }\n\n  equal(other: TextRange): boolean {\n    return this.startLine === other.startLine && this.endLine === other.endLine &&\n        this.startColumn === other.startColumn && this.endColumn === other.endColumn;\n  }\n\n  relativeTo(line: number, column: number): TextRange {\n    const relative = this.clone();\n\n    if (this.startLine === line) {\n      relative.startColumn -= column;\n    }\n    if (this.endLine === line) {\n      relative.endColumn -= column;\n    }\n\n    relative.startLine -= line;\n    relative.endLine -= line;\n    return relative;\n  }\n\n  relativeFrom(line: number, column: number): TextRange {\n    const relative = this.clone();\n\n    if (this.startLine === 0) {\n      relative.startColumn += column;\n    }\n    if (this.endLine === 0) {\n      relative.endColumn += column;\n    }\n\n    relative.startLine += line;\n    relative.endLine += line;\n    return relative;\n  }\n\n  rebaseAfterTextEdit(originalRange: TextRange, editedRange: TextRange): TextRange {\n    console.assert(originalRange.startLine === editedRange.startLine);\n    console.assert(originalRange.startColumn === editedRange.startColumn);\n    const rebase = this.clone();\n    if (!this.follows(originalRange)) {\n      return rebase;\n    }\n    const lineDelta = editedRange.endLine - originalRange.endLine;\n    const columnDelta = editedRange.endColumn - originalRange.endColumn;\n    rebase.startLine += lineDelta;\n    rebase.endLine += lineDelta;\n    if (rebase.startLine === editedRange.endLine) {\n      rebase.startColumn += columnDelta;\n    }\n    if (rebase.endLine === editedRange.endLine) {\n      rebase.endColumn += columnDelta;\n    }\n    return rebase;\n  }\n\n  toString(): string {\n    return JSON.stringify(this);\n  }\n\n  /**\n   * Checks whether this {@link TextRange} contains the location identified by the\n   * {@link lineNumber} and {@link columnNumber}. The beginning of the text range is\n   * considered inclusive while the end of the text range is considered exclusive\n   * for this comparison, meaning that for example a range `(0,1)-(1,4)` contains the\n   * location `(0,1)` but does not contain the location `(1,4)`.\n   *\n   * @param lineNumber the location's line offset.\n   * @param columnNumber the location's column offset.\n   * @returns `true` if the location identified by {@link lineNumber} and {@link columnNumber}\n   *          is contained within this text range.\n   */\n  containsLocation(lineNumber: number, columnNumber: number): boolean {\n    if (this.startLine === this.endLine) {\n      return this.startLine === lineNumber && this.startColumn <= columnNumber && columnNumber < this.endColumn;\n    }\n    if (this.startLine === lineNumber) {\n      return this.startColumn <= columnNumber;\n    }\n    if (this.endLine === lineNumber) {\n      return columnNumber < this.endColumn;\n    }\n    return this.startLine < lineNumber && lineNumber < this.endLine;\n  }\n\n  get start(): {lineNumber: number, columnNumber: number} {\n    return {lineNumber: this.startLine, columnNumber: this.startColumn};\n  }\n\n  get end(): {lineNumber: number, columnNumber: number} {\n    return {lineNumber: this.endLine, columnNumber: this.endColumn};\n  }\n\n  /**\n   * Checks whether this and `that` {@link TextRange} overlap and if they do, computes the\n   * intersection range. If they don't overlap an empty text range is returned instead (for\n   * which {@link #isEmpty()} yields `true`).\n   *\n   * The beginning of text ranges is considered to be includes while the end of the text\n   * ranges is considered exclusive for the intersection, meaning that for example intersecting\n   * `(0,1)-(1,4)` and `(1,4)-(1,6)` yields an empty range.\n   *\n   * @param that the other text range.\n   * @returns the intersection of this and `that` text range, which might be empty if their don't\n   *          overlap.\n   */\n  intersection(that: TextRange): TextRange {\n    let {startLine, startColumn} = this;\n    if (startLine < that.startLine) {\n      startLine = that.startLine;\n      startColumn = that.startColumn;\n    } else if (startLine === that.startLine) {\n      startColumn = Math.max(startColumn, that.startColumn);\n    }\n    let {endLine, endColumn} = this;\n    if (endLine > that.endLine) {\n      endLine = that.endLine;\n      endColumn = that.endColumn;\n    } else if (endLine === that.endLine) {\n      endColumn = Math.min(endColumn, that.endColumn);\n    }\n    if (startLine > endLine || (startLine === endLine && startColumn >= endColumn)) {\n      return new TextRange(0, 0, 0, 0);\n    }\n    return new TextRange(startLine, startColumn, endLine, endColumn);\n  }\n}\n\nexport class SourceRange {\n  constructor(public offset: number, public length: number) {\n  }\n}\n", "// Copyright 2014 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Common from '../../core/common/common.js';\nimport type * as Platform from '../../core/platform/platform.js';\n\nimport {ContentData, type ContentDataOrError} from './ContentData.js';\nimport type {ContentProvider, SearchMatch} from './ContentProvider.js';\nimport {performSearchInContentData} from './TextUtils.js';\n\nexport class StaticContentProvider implements ContentProvider {\n  readonly #contentURL: Platform.DevToolsPath.UrlString;\n  readonly #contentType: Common.ResourceType.ResourceType;\n  readonly #lazyContent: () => Promise<ContentDataOrError>;\n\n  constructor(\n      contentURL: Platform.DevToolsPath.UrlString, contentType: Common.ResourceType.ResourceType,\n      lazyContent: () => Promise<ContentDataOrError>) {\n    this.#contentURL = contentURL;\n    this.#contentType = contentType;\n    this.#lazyContent = lazyContent;\n  }\n\n  static fromString(\n      contentURL: Platform.DevToolsPath.UrlString, contentType: Common.ResourceType.ResourceType,\n      content: string): StaticContentProvider {\n    const lazyContent = (): Promise<ContentData> =>\n        Promise.resolve(new ContentData(content, /* isBase64 */ false, contentType.canonicalMimeType()));\n    return new StaticContentProvider(contentURL, contentType, lazyContent);\n  }\n\n  contentURL(): Platform.DevToolsPath.UrlString {\n    return this.#contentURL;\n  }\n\n  contentType(): Common.ResourceType.ResourceType {\n    return this.#contentType;\n  }\n\n  requestContentData(): Promise<ContentDataOrError> {\n    return this.#lazyContent();\n  }\n\n  async searchInContent(query: string, caseSensitive: boolean, isRegex: boolean): Promise<SearchMatch[]> {\n    const contentData = await this.requestContentData();\n    return performSearchInContentData(contentData, query, caseSensitive, isRegex);\n  }\n}\n", "// Copyright 2013 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../core/platform/platform.js';\n\nimport {ContentData, type ContentDataOrError} from './ContentData.js';\nimport {SearchMatch} from './ContentProvider.js';\nimport type {Text} from './Text.js';\n\nconst KEY_VALUE_FILTER_REGEXP = /(?:^|\\s)(\\-)?([\\w\\-]+):([^\\s]+)/;\nconst REGEXP_FILTER_REGEXP = /(?:^|\\s)(\\-)?\\/([^\\/\\\\]+(\\\\.[^\\/]*)*)\\//;\nconst TEXT_FILTER_REGEXP = /(?:^|\\s)(\\-)?([^\\s]+)/;\nconst SPACE_CHAR_REGEXP = /\\s/;\n\nexport const Utils = {\n  isSpaceChar: function(char: string): boolean {\n    return SPACE_CHAR_REGEXP.test(char);\n  },\n\n  lineIndent: function(line: string): string {\n    let indentation = 0;\n    while (indentation < line.length && Utils.isSpaceChar(line.charAt(indentation))) {\n      ++indentation;\n    }\n    return line.substr(0, indentation);\n  },\n\n  splitStringByRegexes(text: string, regexes: RegExp[]): Array<{\n    value: string,\n    position: number,\n    regexIndex: number,\n    captureGroups: Array<string|undefined>,\n  }> {\n    const matches: Array<{\n      value: string,\n      position: number,\n      regexIndex: number,\n      captureGroups: Array<string|undefined>,\n    }> = [];\n    const globalRegexes: RegExp[] = [];\n    for (let i = 0; i < regexes.length; i++) {\n      const regex = regexes[i];\n      if (!regex.global) {\n        globalRegexes.push(new RegExp(regex.source, regex.flags ? regex.flags + 'g' : 'g'));\n      } else {\n        globalRegexes.push(regex);\n      }\n    }\n    doSplit(text, 0, 0);\n    return matches;\n\n    function doSplit(text: string, regexIndex: number, startIndex: number): void {\n      if (regexIndex >= globalRegexes.length) {\n        // Set regexIndex as -1 if text did not match with any regular expression\n        matches.push({value: text, position: startIndex, regexIndex: -1, captureGroups: []});\n        return;\n      }\n      const regex = globalRegexes[regexIndex];\n      let currentIndex = 0;\n      let result;\n      regex.lastIndex = 0;\n      while ((result = regex.exec(text)) !== null) {\n        const stringBeforeMatch = text.substring(currentIndex, result.index);\n        if (stringBeforeMatch) {\n          doSplit(stringBeforeMatch, regexIndex + 1, startIndex + currentIndex);\n        }\n        const match = result[0];\n        matches.push({\n          value: match,\n          position: startIndex + result.index,\n          regexIndex,\n          captureGroups: result.slice(1),\n        });\n        currentIndex = result.index + match.length;\n      }\n      const stringAfterMatches = text.substring(currentIndex);\n      if (stringAfterMatches) {\n        doSplit(stringAfterMatches, regexIndex + 1, startIndex + currentIndex);\n      }\n    }\n  },\n};\n\nexport class FilterParser {\n  private readonly keys: string[];\n  constructor(keys: string[]) {\n    this.keys = keys;\n  }\n\n  static cloneFilter(filter: ParsedFilter): ParsedFilter {\n    return {key: filter.key, text: filter.text, regex: filter.regex, negative: filter.negative};\n  }\n\n  parse(query: string): ParsedFilter[] {\n    const splitFilters =\n        Utils.splitStringByRegexes(query, [KEY_VALUE_FILTER_REGEXP, REGEXP_FILTER_REGEXP, TEXT_FILTER_REGEXP]);\n    const parsedFilters: ParsedFilter[] = [];\n    for (const {regexIndex, captureGroups} of splitFilters) {\n      if (regexIndex === -1) {\n        continue;\n      }\n      if (regexIndex === 0) {\n        const startsWithMinus = captureGroups[0];\n        const parsedKey = captureGroups[1];\n        const parsedValue = captureGroups[2];\n        if (this.keys.indexOf((parsedKey as string)) !== -1) {\n          parsedFilters.push({\n            key: parsedKey,\n            regex: undefined,\n            text: parsedValue,\n            negative: Boolean(startsWithMinus),\n          });\n        } else {\n          parsedFilters.push({\n            key: undefined,\n            regex: undefined,\n            text: `${parsedKey}:${parsedValue}`,\n            negative: Boolean(startsWithMinus),\n          });\n        }\n      } else if (regexIndex === 1) {\n        const startsWithMinus = captureGroups[0];\n        const parsedRegex = captureGroups[1];\n        try {\n          parsedFilters.push({\n            key: undefined,\n            regex: new RegExp((parsedRegex as string), 'im'),\n            text: undefined,\n            negative: Boolean(startsWithMinus),\n          });\n        } catch {\n          parsedFilters.push({\n            key: undefined,\n            regex: undefined,\n            text: `/${parsedRegex}/`,\n            negative: Boolean(startsWithMinus),\n          });\n        }\n      } else if (regexIndex === 2) {\n        const startsWithMinus = captureGroups[0];\n        const parsedText = captureGroups[1];\n        parsedFilters.push({\n          key: undefined,\n          regex: undefined,\n          text: parsedText,\n          negative: Boolean(startsWithMinus),\n        });\n      }\n    }\n    return parsedFilters;\n  }\n}\n\nexport class BalancedJSONTokenizer {\n  private readonly callback: (arg0: string) => void;\n  private index: number;\n  private balance: number;\n  private buffer: string;\n  private findMultiple: boolean;\n  private closingDoubleQuoteRegex: RegExp;\n  private lastBalancedIndex?: number;\n  constructor(callback: (arg0: string) => void, findMultiple?: boolean) {\n    this.callback = callback;\n    this.index = 0;\n    this.balance = 0;\n    this.buffer = '';\n    this.findMultiple = findMultiple || false;\n    this.closingDoubleQuoteRegex = /[^\\\\](?:\\\\\\\\)*\"/g;\n  }\n\n  write(chunk: string): boolean {\n    this.buffer += chunk;\n    const lastIndex = this.buffer.length;\n    const buffer = this.buffer;\n    let index;\n    for (index = this.index; index < lastIndex; ++index) {\n      const character = buffer[index];\n      if (character === '\"') {\n        this.closingDoubleQuoteRegex.lastIndex = index;\n        if (!this.closingDoubleQuoteRegex.test(buffer)) {\n          break;\n        }\n        index = this.closingDoubleQuoteRegex.lastIndex - 1;\n      } else if (character === '{') {\n        ++this.balance;\n      } else if (character === '}') {\n        --this.balance;\n        if (this.balance < 0) {\n          this.reportBalanced();\n          return false;\n        }\n        if (!this.balance) {\n          this.lastBalancedIndex = index + 1;\n          if (!this.findMultiple) {\n            break;\n          }\n        }\n      } else if (character === ']' && !this.balance) {\n        this.reportBalanced();\n        return false;\n      }\n    }\n    this.index = index;\n    this.reportBalanced();\n    return true;\n  }\n\n  private reportBalanced(): void {\n    if (!this.lastBalancedIndex) {\n      return;\n    }\n    this.callback(this.buffer.slice(0, this.lastBalancedIndex));\n    this.buffer = this.buffer.slice(this.lastBalancedIndex);\n    this.index -= this.lastBalancedIndex;\n    this.lastBalancedIndex = 0;\n  }\n\n  remainder(): string {\n    return this.buffer;\n  }\n}\n\n/**\n * Detects the indentation used by a given text document, based on the _Comparing\n * lines_ approach suggested by Heather Arthur (and also found in Firefox DevTools).\n *\n * This implementation differs from the original proposal in that tab indentation\n * isn't detected by checking if at least 50% of the lines start with a tab, but\n * instead by comparing the number of lines that start with a tab to the frequency\n * of the other indentation patterns. This way we also detect small snippets with\n * long leading comments correctly, when tab indentation is used for the snippets\n * of code.\n *\n * @param lines The input document lines.\n * @returns The indentation detected for the lines as string or `null` if it's inconclusive.\n * @see https://heathermoor.medium.com/detecting-code-indentation-eff3ed0fb56b\n */\nexport const detectIndentation = function(lines: Iterable<string>): string|null {\n  const frequencies: number[] = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n  let tabs = 0, previous = 0;\n\n  for (const line of lines) {\n    let current = 0;\n    if (line.length !== 0) {\n      let char = line.charAt(0);\n      if (char === '\\t') {\n        tabs++;\n        continue;\n      }\n      while (char === ' ') {\n        char = line.charAt(++current);\n      }\n    }\n\n    if (current === line.length) {\n      // Don't consider empty lines.\n      previous = 0;\n      continue;\n    }\n\n    const delta = Math.abs(current - previous);\n    if (delta < frequencies.length) {\n      // Don't consider deltas above 8 characters.\n      frequencies[delta] = frequencies[delta] + 1;\n    }\n    previous = current;\n  }\n\n  // Find most frequent non-zero width difference between adjacent lines.\n  let mostFrequentDelta = 0, highestFrequency = 0;\n  for (let delta = 1; delta < frequencies.length; ++delta) {\n    const frequency = frequencies[delta];\n    if (frequency > highestFrequency) {\n      highestFrequency = frequency;\n      mostFrequentDelta = delta;\n    }\n  }\n\n  if (tabs > mostFrequentDelta) {\n    // If more lines start with tabs than any other indentation,\n    // we assume that the document was written with tab indentation\n    // in mind. This differs from the original algorithm.\n    return '\\t';\n  }\n\n  if (!mostFrequentDelta) {\n    return null;\n  }\n\n  return ' '.repeat(mostFrequentDelta);\n};\n\n/**\n * Heuristic to check whether a given text was likely minified. Intended to\n * be used for HTML, CSS, and JavaScript inputs.\n *\n * A text is considered to be the result of minification if the average\n * line length for the whole text is 80 characters or more.\n *\n * @param text The input text to check.\n * @returns `true` if the heuristic considers `text` to be minified.\n */\nexport const isMinified = function(text: string): boolean {\n  let lineCount = 0;\n  for (let lastIndex = 0; lastIndex < text.length; ++lineCount) {\n    let eolIndex = text.indexOf('\\n', lastIndex);\n    if (eolIndex < 0) {\n      eolIndex = text.length;\n    }\n    lastIndex = eolIndex + 1;\n  }\n  return (text.length - lineCount) / lineCount >= 80;\n};\n\n/**\n * Small wrapper around {@link performSearchInContent} to reduce boilerplate when searching\n * in {@link ContentDataOrError}.\n *\n * @returns empty search matches if `contentData` is an error or not text content.\n */\nexport const performSearchInContentData = function(\n    contentData: ContentDataOrError, query: string, caseSensitive: boolean, isRegex: boolean): SearchMatch[] {\n  if (ContentData.isError(contentData) || !contentData.isTextContent) {\n    return [];\n  }\n  return performSearchInContent(contentData.textObj, query, caseSensitive, isRegex);\n};\n\n/**\n * @returns One {@link SearchMatch} per match. Multiple matches on the same line each\n * result in their own `SearchMatchExact` instance.\n */\nexport const performSearchInContent = function(\n    text: Text, query: string, caseSensitive: boolean, isRegex: boolean): SearchMatch[] {\n  const regex = Platform.StringUtilities.createSearchRegex(query, caseSensitive, isRegex);\n\n  const result = [];\n  for (let i = 0; i < text.lineCount(); ++i) {\n    const lineContent = text.lineAt(i);\n    const matches = lineContent.matchAll(regex);\n    for (const match of matches) {\n      result.push(new SearchMatch(i, lineContent, match.index, match[0].length));\n    }\n  }\n  return result;\n};\n\n/**\n * Similar to {@link performSearchInContent} but doesn't search in a whole text but rather\n * finds the exact matches on a prelminiary search result (i.e. lines with known matches).\n * @param matches is deliberatedly typed as an object literal so we can pass the\n *                CDP search result type.\n */\nexport const performSearchInSearchMatches = function(\n    matches: Array<{lineNumber: number, lineContent: string}>, query: string, caseSensitive: boolean,\n    isRegex: boolean): SearchMatch[] {\n  const regex = Platform.StringUtilities.createSearchRegex(query, caseSensitive, isRegex);\n  const result = [];\n\n  for (const {lineNumber, lineContent} of matches) {\n    const matches = lineContent.matchAll(regex);\n    for (const match of matches) {\n      result.push(new SearchMatch(lineNumber, lineContent, match.index, match[0].length));\n    }\n  }\n  return result;\n};\n\n/**\n * Finds the longest overlapping string segment between the end of the first\n * string and the beginning of the second string.\n *\n * @param s1 The first string (whose suffix will be checked).\n * @param s2 The second string (whose prefix will be checked).\n * @returns The overlapping string segment, or an empty string (\"\")\n * if no overlap is found.\n */\nexport const getOverlap = function(s1: string, s2: string): string|null {\n  const minLen = Math.min(s1.length, s2.length);\n  // Check from longest possible overlap down to 1\n  for (let n = minLen; n > 0; n--) {\n    // slice(-n) gets the last 'n' chars\n    const suffix = s1.slice(-n);\n    // substring(0, n) gets the first 'n' chars\n    const prefix = s2.substring(0, n);\n\n    if (suffix === prefix) {\n      return suffix;\n    }\n  }\n\n  return null;\n};\n\nexport interface ParsedFilter {\n  key?: string;\n  text?: string|null;\n  regex?: RegExp;\n  negative: boolean;\n}\n", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport * as Platform from '../../core/platform/platform.js';\n\nimport {ContentData, type ContentDataOrError} from './ContentData.js';\n\n/**\n * Usage of this class is mostly intended for content that is never \"complete\".\n * E.g. streaming XHR/fetch requests.\n *\n * Due to the streaming nature this class only supports base64-encoded binary data.\n * Decoding to text only happens on-demand by clients. This ensures that at most we have\n * incomplete unicode at the end and not in-between chunks.\n */\nexport class StreamingContentData extends Common.ObjectWrapper.ObjectWrapper<EventTypes> {\n  readonly mimeType: string;\n  readonly #charset?: string;\n\n  readonly #disallowStreaming: boolean;\n\n  #chunks: string[] = [];\n  #contentData?: ContentData;\n\n  private constructor(mimeType: string, charset?: string, initialContent?: ContentData) {\n    super();\n    this.mimeType = mimeType;\n    this.#charset = charset;\n    this.#disallowStreaming = Boolean(initialContent && !initialContent.createdFromBase64);\n    this.#contentData = initialContent;\n  }\n\n  /**\n   * Creates a new StreamingContentData with the given MIME type/charset.\n   */\n  static create(mimeType: string, charset?: string): StreamingContentData {\n    return new StreamingContentData(mimeType, charset);\n  }\n\n  /**\n   * Creates a new StringContentData from an existing ContentData instance.\n   *\n   * Calling `addChunk` is on the resulting `StreamingContentData` is illegal if\n   * `content` was not created from base64 data. The reason is that JavaScript TextEncoder\n   * only supports UTF-8. We can't convert text with arbitrary encoding back to base64 for concatenation.\n   */\n  static from(content: ContentData): StreamingContentData {\n    return new StreamingContentData(content.mimeType, content.charset, content);\n  }\n\n  /** @returns true, if this `ContentData` was constructed from text content or the mime type indicates text that can be decoded */\n  get isTextContent(): boolean {\n    if (this.#contentData) {\n      return this.#contentData.isTextContent;\n    }\n    return Platform.MimeType.isTextType(this.mimeType);\n  }\n\n  /** @param chunk base64 encoded data */\n  addChunk(chunk: string): void {\n    if (this.#disallowStreaming) {\n      throw new Error('Cannot add base64 data to a text-only ContentData.');\n    }\n\n    this.#chunks.push(chunk);\n    this.dispatchEventToListeners(Events.CHUNK_ADDED, {content: this, chunk});\n  }\n\n  /** @returns An immutable ContentData with all the bytes received so far */\n  content(): ContentData {\n    if (this.#contentData && this.#chunks.length === 0) {\n      return this.#contentData;\n    }\n\n    const initialBase64 = this.#contentData?.base64 ?? '';\n    const base64Content =\n        this.#chunks.reduce((acc, chunk) => Platform.StringUtilities.concatBase64(acc, chunk), initialBase64);\n    this.#contentData = new ContentData(base64Content, /* isBase64=*/ true, this.mimeType, this.#charset);\n    this.#chunks = [];\n    return this.#contentData;\n  }\n}\n\nexport type StreamingContentDataOrError = StreamingContentData|{error: string};\n\nexport const isError = function(contentDataOrError: StreamingContentDataOrError): contentDataOrError is {\nerror:\n  string,\n} {\n  return 'error' in contentDataOrError;\n};\n\nexport const asContentDataOrError = function(contentDataOrError: StreamingContentDataOrError): ContentDataOrError {\n  if (isError(contentDataOrError)) {\n    return contentDataOrError;\n  }\n  return contentDataOrError.content();\n};\n\nexport const enum Events {\n  CHUNK_ADDED = 'ChunkAdded',\n}\n\nexport interface EventTypes {\n  [Events.CHUNK_ADDED]: {content: StreamingContentData, chunk: string};\n}\n", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../core/platform/platform.js';\n\nimport {ContentData} from './ContentData.js';\nimport type {DeferredContent} from './ContentProvider.js';\n\ninterface FunctionBodyOffset {\n  start: number;\n  end: number;\n}\n\n/**\n * Metadata to map between bytecode #offsets and line numbers in the\n * disassembly for WebAssembly modules.\n */\nexport class WasmDisassembly extends ContentData {\n  readonly lines: string[];\n  readonly #offsets: number[];\n  #functionBodyOffsets: FunctionBodyOffset[];\n\n  // Wasm can be potentially very large, so we calculate `text' lazily.\n  #cachedText?: string;\n\n  constructor(lines: string[], offsets: number[], functionBodyOffsets: FunctionBodyOffset[]) {\n    super('', /* isBase64 */ false, 'text/x-wast', 'utf-8');\n    if (lines.length !== offsets.length) {\n      throw new Error('Lines and offsets don\\'t match');\n    }\n    this.lines = lines;\n    this.#offsets = offsets;\n    this.#functionBodyOffsets = functionBodyOffsets;\n  }\n\n  override get text(): string {\n    if (typeof this.#cachedText === 'undefined') {\n      this.#cachedText = this.lines.join('\\n');\n    }\n    return this.#cachedText;\n  }\n\n  override get isEmpty(): boolean {\n    // Don't trigger unnecessary concatenating. Only check whether we have no lines, or a single empty line.\n    return this.lines.length === 0 || (this.lines.length === 1 && this.lines[0].length === 0);\n  }\n\n  get lineNumbers(): number {\n    return this.#offsets.length;\n  }\n\n  bytecodeOffsetToLineNumber(bytecodeOffset: number): number {\n    return Platform.ArrayUtilities.upperBound(\n               this.#offsets, bytecodeOffset, Platform.ArrayUtilities.DEFAULT_COMPARATOR) -\n        1;\n  }\n\n  lineNumberToBytecodeOffset(lineNumber: number): number {\n    return this.#offsets[lineNumber];\n  }\n\n  /**\n   * returns an iterable enumerating all the non-breakable line numbers in the disassembly\n   */\n  * nonBreakableLineNumbers(): Iterable<number> {\n    let lineNumber = 0;\n    let functionIndex = 0;\n    while (lineNumber < this.lineNumbers) {\n      if (functionIndex < this.#functionBodyOffsets.length) {\n        const offset = this.lineNumberToBytecodeOffset(lineNumber);\n        if (offset >= this.#functionBodyOffsets[functionIndex].start) {\n          lineNumber = this.bytecodeOffsetToLineNumber(this.#functionBodyOffsets[functionIndex++].end) + 1;\n          continue;\n        }\n      }\n      yield lineNumber++;\n    }\n  }\n\n  /**\n   * @deprecated Used during migration from `DeferredContent` to `ContentData`.\n   */\n  override asDeferedContent(): DeferredContent {\n    return {content: '', isEncoded: false, wasmDisassemblyInfo: this};\n  }\n}\n"],
  "mappings": "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",
  "names": ["Platform", "Platform", "Platform", "Platform", "text", "matches", "Platform", "Platform"]
}
