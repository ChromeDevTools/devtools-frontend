// Copyright 2023 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
import * as Platform from '../../core/platform/platform.js';

import * as Helpers from './helpers/helpers.js';
import * as Types from './types/types.js';

type EntryToNodeMap = Map<Types.TraceEvents.TraceEntry, Helpers.TreeHelpers.TraceEntryNode>;

export type FilterAction = FilterApplyAction|FilterUndoAction;

export const enum FilterApplyAction {
  MERGE_FUNCTION = 'MERGE_FUNCTION',
  COLLAPSE_FUNCTION = 'COLLAPSE_FUNCTION',
  COLLAPSE_REPEATING_DESCENDANTS = 'COLLAPSE_REPEATING_DESCENDANTS',
}

export const enum FilterUndoAction {
  RESET_CHILDREN = 'RESET_CHILDREN',
  UNDO_ALL_ACTIONS = 'UNDO_ALL_ACTIONS',
}

const filterApplyActionSet: Set<FilterApplyAction> = new Set([
  FilterApplyAction.MERGE_FUNCTION,
  FilterApplyAction.COLLAPSE_FUNCTION,
  FilterApplyAction.COLLAPSE_REPEATING_DESCENDANTS,
]);

const filterUndoActionSet: Set<FilterUndoAction> = new Set([
  FilterUndoAction.RESET_CHILDREN,
  FilterUndoAction.UNDO_ALL_ACTIONS,
]);

// Object passed from the frontend that can be either Undo or Apply filter action.
export interface UserFilterAction {
  type: FilterAction;
  entry: Types.TraceEvents.TraceEntry;
}

export interface UserApplyFilterAction {
  type: FilterApplyAction;
  entry: Types.TraceEvents.TraceEntry;
}

/**
 * This class can take in a thread that has been generated by the
 * RendererHandler and apply certain actions to it in order to modify what is
 * shown to the user. These actions can be automatically applied by DevTools or
 * applied by the user.
 *
 * Once actions are applied, the invisibleEntries() method will return the
 * entries that are invisible, and this is the list of entries that should be
 * removed before rendering the resulting thread on the timeline.
 **/
export class EntriesFilter {
  // Maps from an individual TraceEvent entry to its representation as a
  // RendererEntryNode. We need this so we can then parse the tree structure
  // generated by the RendererHandler.
  #entryToNode: EntryToNodeMap;

  // Track the set of invisible entries.
  #invisibleEntries: Types.TraceEvents.TraceEventData[] = [];
  // List of entries whose children are modified. This list is used to
  // keep track of entries that should be identified in the UI as modified.
  #modifiedVisibleEntries: Types.TraceEvents.TraceEventData[] = [];

  constructor(entryToNode: EntryToNodeMap) {
    this.#entryToNode = entryToNode;
  }

  /**
   * Applies an action to hide entries or removes entries
   * from hidden entries array depending on the type of action.
   **/
  applyAction(action: UserFilterAction): void {
    if (/* FilterApplyActions */ this.#isUserApplyFilterAction(action)) {
      this.#applyFilterAction(action);

    } else if (/* FilterUndoActions */ this.#isFilterUndoAction(action.type)) {
      this.#applyUndoAction(action);
    }
  }

  /**
   * If undo action is UNDO_ALL_ACTIONS, assign invisibleEntries array to an empty one.
   * **/
  #applyUndoAction(action: UserFilterAction): void {
    switch (action.type) {
      case FilterUndoAction.UNDO_ALL_ACTIONS: {
        this.#invisibleEntries = [];
        this.#modifiedVisibleEntries = [];
        break;
      }
      case FilterUndoAction.RESET_CHILDREN: {
        this.#makeEntryChildrenVisible(action.entry);
        break;
      }
    }
  }

  /**
   * Returns the set of entries that are invisible given the set of applied actions.
   **/
  invisibleEntries(): Types.TraceEvents.TraceEventData[] {
    return this.#invisibleEntries;
  }

  #applyFilterAction(action: UserApplyFilterAction): Types.TraceEvents.TraceEventData[] {
    // Identify in the UI that children of the entry are modified.
    this.#modifiedVisibleEntries.push(action.entry);
    // We apply new user action to the set of all entries, and mark
    // any that should be hidden by adding them to this set.
    // Another approach would be to use splice() to remove items from the
    // array, but doing this would be a mutation of the arry for every hidden
    // event. Instead, we add entries to this set and return it as an array at the end.
    const entriesToHide = new Set<Types.TraceEvents.TraceEventData>();

    switch (action.type) {
      case FilterApplyAction.MERGE_FUNCTION: {
        // The entry that was clicked on is merged into its parent. All its
        // children remain visible, so we just have to hide the entry that was
        // selected.
        entriesToHide.add(action.entry);
        break;
      }

      case FilterApplyAction.COLLAPSE_FUNCTION: {
        // The entry itself remains visible, but all of its ancestors are hidden.
        const entryNode = this.#entryToNode.get(action.entry);
        if (!entryNode) {
          // Invalid node was given, just ignore and move on.
          break;
        }
        const allAncestors = this.#findAllAncestorsOfNode(entryNode);
        allAncestors.forEach(ancestor => entriesToHide.add(ancestor));
        break;
      }

      case FilterApplyAction.COLLAPSE_REPEATING_DESCENDANTS: {
        const entryNode = this.#entryToNode.get(action.entry);
        if (!entryNode) {
          // Invalid node was given, just ignore and move on.
          break;
        }
        const allRepeatingDescendants = this.#findAllRepeatingDescendantsOfNext(entryNode);
        allRepeatingDescendants.forEach(ancestor => entriesToHide.add(ancestor));
        break;
      }
      default:
        Platform.assertNever(action.type, `Unknown EntriesFilter action: ${action.type}`);
    }

    this.#invisibleEntries.push(...entriesToHide);

    return this.#invisibleEntries;
  }

  #findAllAncestorsOfNode(root: Helpers.TreeHelpers.TraceEntryNode): Types.TraceEvents.TraceEventData[] {
    const ancestors: Types.TraceEvents.TraceEntry[] = [];

    // Walk through all the ancestors, starting at the root node.
    const children: Helpers.TreeHelpers.TraceEntryNode[] = [...root.children];
    while (children.length > 0) {
      const childNode = children.shift();
      if (childNode) {
        ancestors.push(childNode.entry);
        children.push(...childNode.children);
      }
    }

    return ancestors;
  }

  #findAllRepeatingDescendantsOfNext(root: Helpers.TreeHelpers.TraceEntryNode): Types.TraceEvents.TraceEntry[] {
    // Walk through all the ancestors, starting at the root node.
    const children: Helpers.TreeHelpers.TraceEntryNode[] = [...root.children];
    const repeatingNodes: Types.TraceEvents.TraceEntry[] = [];
    const rootIsProfileCall = Types.TraceEvents.isProfileCall(root.entry);

    while (children.length > 0) {
      const childNode = children.shift();
      if (childNode) {
        const childIsProfileCall = Types.TraceEvents.isProfileCall(childNode.entry);
        if (/* Handle TraceEventSyntheticProfileCalls */ rootIsProfileCall && childIsProfileCall) {
          const rootNodeEntry = root.entry as Types.TraceEvents.TraceEventSyntheticProfileCall;
          const childNodeEntry = childNode.entry as Types.TraceEvents.TraceEventSyntheticProfileCall;

          if (Helpers.SamplesIntegrator.SamplesIntegrator.framesAreEqual(
                  rootNodeEntry.callFrame, childNodeEntry.callFrame)) {
            repeatingNodes.push(childNode.entry);
          }
        } /* Handle SyntheticRendererEvents */ else if (!rootIsProfileCall && !childIsProfileCall) {
          if (root.entry.name === childNode.entry.name) {
            repeatingNodes.push(childNode.entry);
          }
        }
        children.push(...childNode.children);
      }
    }

    return repeatingNodes;
  }

  /**
   * Removes all of the entry children from the
   * invisible entries array to make them visible.
   **/
  #makeEntryChildrenVisible(entry: Types.TraceEvents.TraceEntry): void {
    const entryNode = this.#entryToNode.get(entry);
    if (!entryNode) {
      // Invalid node was given, just ignore and move on.
      return;
    }
    const ancestors = this.#findAllAncestorsOfNode(entryNode);

    /**
     * Filter out all ancestors of the node
     * from the invisible entries list.
     **/
    this.#invisibleEntries = this.#invisibleEntries.filter(entry => {
      if (ancestors.includes(entry)) {
        return false;
      }
      return true;
    });

    /**
     * Filter out all ancestors and entry from modified entries
     * list to not show that some entries below those are hidden.
     **/
    this.#modifiedVisibleEntries = this.#modifiedVisibleEntries.filter(iterEntry => {
      if (ancestors.includes(iterEntry) || iterEntry === entry) {
        return false;
      }
      return true;
    });
  }

  isEntryModified(event: Types.TraceEvents.TraceEventData): boolean {
    return this.#modifiedVisibleEntries.includes(event);
  }

  #isUserApplyFilterAction(action: UserFilterAction): action is UserApplyFilterAction {
    return filterApplyActionSet.has(action.type as FilterApplyAction);
  }

  #isFilterUndoAction(action: FilterAction): action is FilterUndoAction {
    return filterUndoActionSet.has(action as FilterUndoAction);
  }
}
