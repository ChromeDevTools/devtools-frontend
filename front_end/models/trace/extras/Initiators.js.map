{"version":3,"file":"Initiators.js","sourceRoot":"","sources":["../../../../../../../front_end/models/trace/extras/Initiators.ts"],"names":[],"mappings":"AAMA,OAAO,EAAC,GAAG,IAAI,aAAa,EAAC,MAAM,yBAAyB,CAAC;AAE7D;;;;;;;;GAQG;AACH,MAAM,UAAU,mBAAmB,CAAC,IAAgC,EAAE,KAA2C;IAE/G,MAAM,uBAAuB,GAAG,IAAI,CAAC,eAAe,CAAC,mBAAmB,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;IACpF,IAAI,uBAAuB,EAAE,IAAI,CAAC,IAAI,CAAC,QAAQ,KAAK,UAAU,EAAE,CAAC;QAC/D,wEAAwE;QACxE,sEAAsE;QACtE,2EAA2E;QAC3E,kEAAkE;QAClE,OAAO,uBAAuB,CAAC;IACjC,CAAC;IAED,2EAA2E;IAC3E,kCAAkC;IAElC,yEAAyE;IACzE,mEAAmE;IACnE,uCAAuC;IACvC,MAAM,KAAK,GAAG,aAAa,CAAC,KAAK,CAAC,cAAc,EAAE,IAAI,CAAC,CAAC;IAExD,uEAAuE;IACvE,qEAAqE;IACrE,uEAAuE;IACvE,mBAAmB;IACnB,MAAM,kBAAkB,GAAG,KAAK,EAAE,MAAM,EAAE,UAAU,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;IAC3D,IAAI,CAAC,kBAAkB,EAAE,CAAC;QACxB,OAAO,uBAAuB,CAAC;IACjC,CAAC;IAED,2EAA2E;IAC3E,4EAA4E;IAC5E,yEAAyE;IACzE,2CAA2C;IAC3C,MAAM,kBAAkB,GAAG,IAAI,CAAC,eAAe,CAAC,eAAe,CAAC,GAAG,CAAC,kBAAkB,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC;IAClG,MAAM,gBAAgB,GAAG,kBAAkB,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;SAC1D,MAAM,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,SAAS,CAAC;SAChC,MAAM,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,GAAG,KAAK,CAAC,EAAE,CAAC,CAAC;IAE/D,uEAAuE;IACvE,wEAAwE;IACxE,qEAAqE;IACrE,OAAO,gBAAgB,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;AACjC,CAAC","sourcesContent":["// Copyright 2026 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport type * as Handlers from '../handlers/handlers.js';\nimport type * as Types from '../types/types.js';\n\nimport {get as getStackTrace} from './StackTraceForEvent.js';\n\n/**\n * There are bugs in the backend tracing that means that network requests are\n * often incorrectly tied to an initiator. This function exists as a utility to\n * look up an event's initiator regardless of the type of event, but also to\n * provide a post-parsing fix for network initiators.\n * The TL;DR is that images injected by a script will incorrectly have their\n * initiator set to the root document. To fix this, we look at the stack trace\n * when the request was sent, and use that.\n */\nexport function getNetworkInitiator(data: Handlers.Types.HandlerData, event: Types.Events.SyntheticNetworkRequest):\n    Types.Events.SyntheticNetworkRequest|undefined {\n  const networkHandlerInitiator = data.NetworkRequests.incompleteInitiator.get(event);\n  if (networkHandlerInitiator?.args.data.mimeType === 'text/css') {\n    // The bugs in tracing & initiators apply mostly to scripts; we have not\n    // seen a case where the trace events identify a CSS stylesheet as the\n    // initiator that is incorrect. Therefore, if a stylesheet is identified as\n    // the initiator, we trust that it is accurate and can exit early.\n    return networkHandlerInitiator;\n  }\n\n  // For network requests, it is more reliable to calculate the initiator via\n  // the stack trace if we have one.\n\n  // We have to use the raw source event (`ResourceSendRequest`) as that is\n  // the event with the `sampleStackId` property which is required to\n  // calculate this stacktrace correctly.\n  const stack = getStackTrace(event.rawSourceEvent, data);\n\n  // If the resource was injected by a script, it will have a parent call\n  // frame that points to the script. Otherwise, there is no parent and\n  // therefore we fallthrough to looking at the initiator directly on the\n  // network request.\n  const initiatorCallFrame = stack?.parent?.callFrames.at(0);\n  if (!initiatorCallFrame) {\n    return networkHandlerInitiator;\n  }\n\n  // Find all the requests for the URL we are searching for. Most of the time\n  // there is only 1, but there can be multiple requests for the same URL. The\n  // filtering by the timestamp ensures that we can never pick an initiator\n  // that happened after the initiated event.\n  const matchingRequestIds = data.NetworkRequests.requestIdsByURL.get(initiatorCallFrame.url) ?? [];\n  const matchingRequests = matchingRequestIds.map(id => data.NetworkRequests.byId.get(id))\n                               .filter(req => req !== undefined)\n                               .filter(req => req.ts < event.ts);\n\n  // Now we have filtered and have a list of requests that are before the\n  // event, we take the last one - the one closest to the initiated event.\n  // In the case that there are >1 requests, this is an educated guess.\n  return matchingRequests.at(-1);\n}\n"]}