{"version":3,"file":"MetaHandler.js","sourceRoot":"","sources":["../../../../../../../front_end/models/trace/handlers/MetaHandler.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2022 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport type {FinalizeOptions} from './types.js';\n\nlet config: {showAllEvents: boolean};\n\n// We track the renderer processes we see in each frame on the way through the trace.\nlet rendererProcessesByFrameId: FrameProcessData = new Map();\n\n// We will often want to key data by Frame IDs, and commonly we'll care most\n// about the main frame's ID, so we store and expose that.\nlet mainFrameId = '';\nlet mainFrameURL = '';\n\nlet framesByProcessId = new Map<Types.Events.ProcessID, Map<string, Types.Events.TraceFrame>>();\n\n// We will often want to key data by the browser process, GPU process and top\n// level renderer IDs, so keep a track on those.\nlet browserProcessId: Types.Events.ProcessID = Types.Events.ProcessID(-1);\nlet browserThreadId: Types.Events.ThreadID = Types.Events.ThreadID(-1);\nlet gpuProcessId: Types.Events.ProcessID = Types.Events.ProcessID(-1);\nlet gpuThreadId: Types.Events.ThreadID = Types.Events.ThreadID(-1);\nlet viewportRect: {x: number, y: number, width: number, height: number}|null = null;\nlet devicePixelRatio: number|null = null;\n\nlet processNames = new Map<Types.Events.ProcessID, Types.Events.ProcessName>();\n\nlet topLevelRendererIds = new Set<Types.Events.ProcessID>();\n\nfunction makeNewTraceBounds(): Types.Timing.TraceWindowMicro {\n  return {\n    min: Types.Timing.Micro(Number.POSITIVE_INFINITY),\n    max: Types.Timing.Micro(Number.NEGATIVE_INFINITY),\n    range: Types.Timing.Micro(Number.POSITIVE_INFINITY),\n  };\n}\nlet traceBounds: Types.Timing.TraceWindowMicro = makeNewTraceBounds();\n\n/**\n * These represent the user navigating. Values such as First Contentful Paint,\n * etc, are relative to the navigation.\n *\n *  We store navigation events both by the frame and navigation ID. This means\n * when we need to look them up, we can use whichever ID we have.\n *\n * Note that these Maps will have the same values in them; these are just keyed\n * differently to make look-ups easier.\n *\n * We also additionally maintain an array of only navigations that occurred on\n * the main frame. In many places in the UI we only care about highlighting\n * main frame navigations, so calculating this list here is better than\n * filtering either of the below maps over and over again at the UI layer.\n */\nlet navigationsByFrameId = new Map<string, Types.Events.NavigationStart[]>();\nlet navigationsByNavigationId = new Map<string, Types.Events.NavigationStart>();\nlet softNavigationsById = new Map<number, Types.Events.SoftNavigationStart>();\nlet finalDisplayUrlByNavigationId = new Map<string, string>();\nlet mainFrameNavigations: Types.Events.NavigationStart[] = [];\n\n// Represents all the threads in the trace, organized by process. This is mostly for internal\n// bookkeeping so that during the finalize pass we can obtain the main and browser thread IDs.\nlet threadsInProcess = new Map<Types.Events.ProcessID, Map<Types.Events.ThreadID, Types.Events.ThreadName>>();\n\nlet traceStartedTimeFromTracingStartedEvent = Types.Timing.Micro(-1);\nconst eventPhasesOfInterestForTraceBounds = new Set([\n  Types.Events.Phase.BEGIN,\n  Types.Events.Phase.END,\n  Types.Events.Phase.COMPLETE,\n  Types.Events.Phase.INSTANT,\n]);\n\n// Tracks if the trace is a generic trace, which here means that it did not come from athe DevTools Performance Panel recording.\n// We assume a trace is generic, and mark it as not generic if we see any of:\n// - TracingStartedInPage\n// - TracingStartedInBrowser\n// - TracingSessionIdForWorker\n// - CpuProfile\n// These are all events which indicate this is a Chrome browser trace.\nlet traceIsGeneric = true;\nconst CHROME_WEB_TRACE_EVENTS = new Set([\n  Types.Events.Name.TRACING_STARTED_IN_PAGE,\n  Types.Events.Name.TRACING_SESSION_ID_FOR_WORKER,\n  Types.Events.Name.TRACING_STARTED_IN_BROWSER,\n  Types.Events.Name.CPU_PROFILE,\n]);\n\nexport function reset(): void {\n  navigationsByFrameId = new Map();\n  navigationsByNavigationId = new Map();\n  softNavigationsById = new Map();\n  finalDisplayUrlByNavigationId = new Map();\n  processNames = new Map();\n  mainFrameNavigations = [];\n\n  browserProcessId = Types.Events.ProcessID(-1);\n  browserThreadId = Types.Events.ThreadID(-1);\n  gpuProcessId = Types.Events.ProcessID(-1);\n  gpuThreadId = Types.Events.ThreadID(-1);\n  viewportRect = null;\n  topLevelRendererIds = new Set();\n  threadsInProcess = new Map();\n  rendererProcessesByFrameId = new Map();\n  framesByProcessId = new Map();\n\n  traceBounds = makeNewTraceBounds();\n  traceStartedTimeFromTracingStartedEvent = Types.Timing.Micro(-1);\n\n  traceIsGeneric = true;\n}\n\nfunction updateRendererProcessByFrame(event: Types.Events.Event, frame: Types.Events.TraceFrame): void {\n  const framesInProcessById = Platform.MapUtilities.getWithDefault(framesByProcessId, frame.processId, () => new Map());\n  framesInProcessById.set(frame.frame, frame);\n\n  const rendererProcessInFrame = Platform.MapUtilities.getWithDefault(\n      rendererProcessesByFrameId, frame.frame,\n      () => new Map<\n          Types.Events.ProcessID, Array<{frame: Types.Events.TraceFrame, window: Types.Timing.TraceWindowMicro}>>());\n  const rendererProcessInfo = Platform.MapUtilities.getWithDefault(rendererProcessInFrame, frame.processId, () => {\n    return [];\n  });\n  const lastProcessData = rendererProcessInfo.at(-1);\n\n  // Only store a new entry if the URL changed, otherwise it's just\n  // redundant information.\n  if (lastProcessData && lastProcessData.frame.url === frame.url) {\n    return;\n  }\n  // For now we store the time of the event as the min. In the finalize we step\n  // through each of these windows and update their max and range values.\n  rendererProcessInfo.push({\n    frame,\n    window: {\n      min: event.ts,\n      max: Types.Timing.Micro(0),\n      range: Types.Timing.Micro(0),\n    },\n  });\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (traceIsGeneric && CHROME_WEB_TRACE_EVENTS.has(event.name as Types.Events.Name)) {\n    traceIsGeneric = false;\n  }\n\n  if (Types.Events.isProcessName(event)) {\n    processNames.set(event.pid, event);\n  }\n\n  // If there is a timestamp (which meta events do not have), and the event does\n  // not end with ::UMA then it, and the event is in the set of valid phases,\n  // then it should be included for the purposes of calculating the trace bounds.\n  // The UMA events in particular seem to be reported on page unloading, which\n  // often extends the bounds of the trace unhelpfully.\n  if (event.ts !== 0 && !event.name.endsWith('::UMA') && eventPhasesOfInterestForTraceBounds.has(event.ph)) {\n    traceBounds.min = Types.Timing.Micro(Math.min(event.ts, traceBounds.min));\n    const eventDuration = event.dur ?? Types.Timing.Micro(0);\n    traceBounds.max = Types.Timing.Micro(Math.max(event.ts + eventDuration, traceBounds.max));\n  }\n\n  if (Types.Events.isProcessName(event) && (event.args.name === 'Browser' || event.args.name === 'HeadlessBrowser')) {\n    browserProcessId = event.pid;\n    return;\n  }\n\n  if (Types.Events.isProcessName(event) && (event.args.name === 'Gpu' || event.args.name === 'GPU Process')) {\n    gpuProcessId = event.pid;\n    return;\n  }\n\n  if (Types.Events.isThreadName(event) && event.args.name === 'CrGpuMain') {\n    gpuThreadId = event.tid;\n    return;\n  }\n\n  if (Types.Events.isThreadName(event) && event.args.name === 'CrBrowserMain') {\n    browserThreadId = event.tid;\n  }\n\n  if (Types.Events.isMainFrameViewport(event) && viewportRect === null) {\n    const rectAsArray = event.args.data.viewport_rect;\n    const viewportX = rectAsArray[0];\n    const viewportY = rectAsArray[1];\n    const viewportWidth = rectAsArray[2];\n    const viewportHeight = rectAsArray[5];\n    viewportRect = {x: viewportX, y: viewportY, width: viewportWidth, height: viewportHeight};\n    devicePixelRatio = event.args.data.dpr;\n  }\n\n  // The TracingStartedInBrowser event includes the data on which frames are\n  // in scope at the start of the trace. We use this to identify the frame with\n  // no parent, i.e. the top level frame.\n  if (Types.Events.isTracingStartedInBrowser(event)) {\n    traceStartedTimeFromTracingStartedEvent = event.ts;\n\n    if (!event.args.data) {\n      throw new Error('No frames found in trace data');\n    }\n\n    for (const frame of (event.args.data.frames ?? [])) {\n      updateRendererProcessByFrame(event, frame);\n\n      if (!frame.parent) {\n        topLevelRendererIds.add(frame.processId);\n      }\n      /**\n       * The code here uses a few different methods to try to determine the main frame.\n       * The ideal is that the frames have two flags present:\n       *\n       * 1. isOutermostMainFrame (added in April 2024 - crrev.com/c/5424783)\n       * 2. isInPrimaryMainFrame (added in June 2024 - crrev.com/c/5595033)\n       *\n       * The frame where both of these are set to `true` is the main frame. The\n       * reason we need both of these flags to have 100% confidence is because\n       * with the introduction of MPArch and pre-rendering, we can have other\n       * frames that are the outermost frame, but are not the primary process.\n       * Relying on isOutermostMainFrame in isolation caused the engine to\n       * incorrectly identify the wrong frame as main (see crbug.com/343873756).\n       *\n       * See https://source.chromium.org/chromium/chromium/src/+/main:docs/frame_trees.md\n       * for a bit more context on FrameTrees in Chromium.\n       *\n       * To avoid breaking entirely for traces pre-June 2024 that don't have\n       * both of these flags, we will fallback to less accurate methods:\n       *\n       * 1. If we have isOutermostMainFrame, we will use that\n       *    (and accept we might get it wrong)\n       * 2. If we don't have isOutermostMainFrame, we fallback to finding a\n       *    frame that has a URL, but doesn't have a parent. This is a crude\n       *    guess at the main frame...but better than nothing and is historically\n       *    how DevTools identified the main frame.\n       */\n\n      const traceHasPrimaryMainFrameFlag = 'isInPrimaryMainFrame' in frame;\n      const traceHasOutermostMainFrameFlag = 'isOutermostMainFrame' in frame;\n\n      if (traceHasPrimaryMainFrameFlag && traceHasOutermostMainFrameFlag) {\n        // Ideal situation: identify the main frame as the one that has both these flags set to true.\n        if (frame.isInPrimaryMainFrame && frame.isOutermostMainFrame) {\n          mainFrameId = frame.frame;\n          mainFrameURL = frame.url;\n        }\n      } else if (traceHasOutermostMainFrameFlag) {\n        // Less ideal: \"guess\" at the main thread by using this flag.\n        if (frame.isOutermostMainFrame) {\n          mainFrameId = frame.frame;\n          mainFrameURL = frame.url;\n        }\n        // Worst case: guess by seeing if the frame doesn't have a parent, and does have a URL.\n      } else if (!frame.parent && frame.url) {\n        mainFrameId = frame.frame;\n        mainFrameURL = frame.url;\n      }\n    }\n\n    return;\n  }\n\n  // FrameCommittedInBrowser events tell us information about each frame\n  // and we use these to track how long each individual renderer is active\n  // for. We track all renderers here (top level and those in frames), but\n  // for convenience we also populate a set of top level renderer IDs.\n  if (Types.Events.isFrameCommittedInBrowser(event)) {\n    const frame = event.args.data;\n    if (!frame) {\n      return;\n    }\n\n    updateRendererProcessByFrame(event, frame);\n\n    if (frame.parent) {\n      return;\n    }\n\n    topLevelRendererIds.add(frame.processId);\n    return;\n  }\n\n  if (Types.Events.isCommitLoad(event)) {\n    const frameData = event.args.data;\n    if (!frameData) {\n      return;\n    }\n\n    const {frame, name, url} = frameData;\n    updateRendererProcessByFrame(event, {processId: event.pid, frame, name, url});\n    return;\n  }\n\n  // Track all threads based on the process & thread IDs.\n  if (Types.Events.isThreadName(event)) {\n    const threads = Platform.MapUtilities.getWithDefault(threadsInProcess, event.pid, () => new Map());\n    threads.set(event.tid, event);\n    return;\n  }\n\n  // Track all navigation events. Note that there can be navigation start events\n  // but where the documentLoaderURL is empty. As far as the trace rendering is\n  // concerned, these events are noise so we filter them out here.\n  // (The filtering of empty URLs is done in the isNavigationStart check)\n  if (Types.Events.isNavigationStart(event) && event.args.data) {\n    const navigationId = event.args.data.navigationId;\n    if (navigationsByNavigationId.has(navigationId)) {\n      // We have only ever seen this situation once, in crbug.com/1503982, where the user ran:\n      // window.location.href = 'javascript:console.log(\"foo\")'\n      // In this situation two identical navigationStart events are emitted with the same data, URL and ID.\n      // So, in this situation we drop/ignore any subsequent navigations if we have already seen that ID.\n      return;\n    }\n    navigationsByNavigationId.set(navigationId, event);\n    finalDisplayUrlByNavigationId.set(navigationId, event.args.data.documentLoaderURL);\n\n    const frameId = event.args.frame;\n    const existingFrameNavigations = navigationsByFrameId.get(frameId) || [];\n    existingFrameNavigations.push(event);\n    navigationsByFrameId.set(frameId, existingFrameNavigations);\n    if (frameId === mainFrameId) {\n      mainFrameNavigations.push(event);\n    }\n    return;\n  }\n\n  if (Types.Events.isSoftNavigationStart(event)) {\n    softNavigationsById.set(event.args.context.performanceTimelineNavigationId, event);\n  }\n\n  // Update `finalDisplayUrlByNavigationId` to reflect the latest redirect for each navigation.\n  if (Types.Events.isResourceSendRequest(event)) {\n    if (event.args.data.resourceType !== 'Document') {\n      return;\n    }\n\n    const maybeNavigationId = event.args.data.requestId;\n    const navigation = navigationsByNavigationId.get(maybeNavigationId);\n    if (!navigation) {\n      return;\n    }\n\n    finalDisplayUrlByNavigationId.set(maybeNavigationId, event.args.data.url);\n    return;\n  }\n\n  // Update `finalDisplayUrlByNavigationId` to reflect history API navigations.\n  if (Types.Events.isDidCommitSameDocumentNavigation(event)) {\n    if (event.args.render_frame_host.frame_type !== 'PRIMARY_MAIN_FRAME') {\n      return;\n    }\n\n    const navigation = mainFrameNavigations.at(-1);\n    const key = navigation?.args.data?.navigationId ?? '';\n    finalDisplayUrlByNavigationId.set(key, event.args.url);\n    return;\n  }\n}\n\nexport async function finalize(options?: FinalizeOptions): Promise<void> {\n  config = {showAllEvents: Boolean(options?.showAllEvents)};\n\n  // We try to set the minimum time by finding the event with the smallest\n  // timestamp. However, if we also got a timestamp from the\n  // TracingStartedInBrowser event, we should always use that.\n  // But in some traces (for example, CPU profiles) we do not get that event,\n  // hence why we need to check we got a timestamp from it before setting it.\n  if (traceStartedTimeFromTracingStartedEvent >= 0) {\n    traceBounds.min = traceStartedTimeFromTracingStartedEvent;\n  }\n  traceBounds.range = Types.Timing.Micro(traceBounds.max - traceBounds.min);\n\n  // If we go from foo.com to example.com we will get a new renderer, and\n  // therefore the \"top level renderer\" will have a different PID as it has\n  // changed. Here we step through each renderer process and updated its window\n  // bounds, such that we end up with the time ranges in the trace for when\n  // each particular renderer started and stopped being the main renderer\n  // process.\n  for (const [, processWindows] of rendererProcessesByFrameId) {\n    // Sort the windows by time; we cannot assume by default they arrive via\n    // events in time order. Because we set the window bounds per-process based\n    // on the time of the current + next window, we need them sorted in ASC\n    // order.\n    const processWindowValues = [...processWindows.values()].flat().sort((a, b) => {\n      return a.window.min - b.window.min;\n    });\n    for (let i = 0; i < processWindowValues.length; i++) {\n      const currentWindow = processWindowValues[i];\n      const nextWindow = processWindowValues[i + 1];\n\n      // For the last window we set its max to be positive infinity.\n      // TODO: Move the trace bounds handler into meta so we can clamp first and last windows.\n      if (!nextWindow) {\n        currentWindow.window.max = Types.Timing.Micro(traceBounds.max);\n        currentWindow.window.range = Types.Timing.Micro(traceBounds.max - currentWindow.window.min);\n      } else {\n        currentWindow.window.max = Types.Timing.Micro(nextWindow.window.min - 1);\n        currentWindow.window.range = Types.Timing.Micro(currentWindow.window.max - currentWindow.window.min);\n      }\n    }\n  }\n\n  // Frame ids which we didn't register using either the TracingStartedInBrowser or\n  // the FrameCommittedInBrowser events are considered noise, so we filter them out, as well\n  // as the navigations that belong to such frames.\n  for (const [frameId, navigations] of navigationsByFrameId) {\n    // The frames in the rendererProcessesByFrameId map come only from the\n    // TracingStartedInBrowser and FrameCommittedInBrowser events, so we can use it as point\n    // of comparison to determine if a frameId should be discarded.\n    if (rendererProcessesByFrameId.has(frameId)) {\n      continue;\n    }\n    navigationsByFrameId.delete(frameId);\n    for (const navigation of navigations) {\n      if (!navigation.args.data) {\n        continue;\n      }\n      navigationsByNavigationId.delete(navigation.args.data.navigationId);\n    }\n  }\n\n  // Sometimes in traces the TracingStartedInBrowser event can give us an\n  // incorrect initial URL for the main frame's URL - about:blank or the URL of\n  // the previous page. This doesn't matter too much except we often use this\n  // URL as the visual name of the trace shown to the user (e.g. in the history\n  // dropdown). We can be more accurate by finding the first main frame\n  // navigation, and using its URL, if we have it.\n  // However, to avoid doing this in a case where the first navigation is far\n  // into the trace's lifecycle, we only do this in situations where the first\n  // navigation happened very soon (0.5 seconds) after the trace started\n  // recording.\n  const firstMainFrameNav = mainFrameNavigations.at(0);\n  const firstNavTimeThreshold = Helpers.Timing.secondsToMicro(Types.Timing.Seconds(0.5));\n  if (firstMainFrameNav) {\n    const navigationIsWithinThreshold = firstMainFrameNav.ts - traceBounds.min < firstNavTimeThreshold;\n    if (firstMainFrameNav.args.data?.isOutermostMainFrame && firstMainFrameNav.args.data?.documentLoaderURL &&\n        navigationIsWithinThreshold) {\n      mainFrameURL = firstMainFrameNav.args.data.documentLoaderURL;\n    }\n  }\n}\n\nexport interface MetaHandlerData {\n  config: {showAllEvents: boolean};\n  traceIsGeneric: boolean;\n  traceBounds: Types.Timing.TraceWindowMicro;\n  browserProcessId: Types.Events.ProcessID;\n  processNames: Map<Types.Events.ProcessID, Types.Events.ProcessName>;\n  browserThreadId: Types.Events.ThreadID;\n  gpuProcessId: Types.Events.ProcessID;\n  navigationsByFrameId: Map<string, Types.Events.NavigationStart[]>;\n  /**\n   * This does not include soft navigations.\n   *\n   * TODO(crbug.com/414468047): include soft navs here, so that\n   * PageLoadMetricsHandler and insights can use this map for all navigation types.\n   */\n  navigationsByNavigationId: Map<string, Types.Events.NavigationStart>;\n  softNavigationsById: Map<number, Types.Events.SoftNavigationStart>;\n  /**\n   * The user-visible URL displayed to users in the address bar.\n   * This captures:\n   *  - resolving all redirects\n   *  - history API pushState\n   *\n   * Given no redirects or history API usages, this is just the navigation event's documentLoaderURL.\n   *\n   * Note: empty string special case denotes the duration of the trace between the start\n   * and the first navigation. If there is no history API navigation during this time,\n   * there will be no value for empty string.\n   **/\n  finalDisplayUrlByNavigationId: Map<string, string>;\n  threadsInProcess: Map<Types.Events.ProcessID, Map<Types.Events.ThreadID, Types.Events.ThreadName>>;\n  mainFrameId: string;\n  mainFrameURL: string;\n  /**\n   * A frame can have multiple renderer processes, at the same time,\n   * a renderer process can have multiple URLs. This map tracks the\n   * processes active on a given frame, with the time window in which\n   * they were active. Because a renderer process might have multiple\n   * URLs, each process in each frame has an array of windows, with an\n   * entry for each URL it had.\n   */\n  rendererProcessesByFrame: FrameProcessData;\n  topLevelRendererIds: Set<Types.Events.ProcessID>;\n  frameByProcessId: Map<Types.Events.ProcessID, Map<string, Types.Events.TraceFrame>>;\n  mainFrameNavigations: Types.Events.NavigationStart[];\n  gpuThreadId?: Types.Events.ThreadID;\n  viewportRect?: {x: number, y: number, width: number, height: number};\n  devicePixelRatio?: number;\n}\n\n/**\n * Each frame has a single render process at a given time but it can have\n * multiple render processes  during a trace, for example if a navigation\n * occurred in the frame. This map tracks the process that was active for\n * each frame at each point in time. Also, because a process can be\n * assigned to multiple URLs, there is a window for each URL a process\n * was assigned.\n *\n * Note that different sites always end up in different render\n * processes, however two different URLs can point to the same site.\n * For example: https://google.com and https://maps.google.com point to\n * the same site.\n * Read more about this in\n * https://developer.chrome.com/articles/renderingng-architecture/#threads\n * and https://web.dev/same-site-same-origin/\n **/\nexport type FrameProcessData =\n    Map<string,\n        Map<Types.Events.ProcessID, Array<{frame: Types.Events.TraceFrame, window: Types.Timing.TraceWindowMicro}>>>;\n\nexport function data(): MetaHandlerData {\n  return {\n    config,\n    traceBounds,\n    browserProcessId,\n    browserThreadId,\n    processNames,\n    gpuProcessId,\n    gpuThreadId: gpuThreadId === Types.Events.ThreadID(-1) ? undefined : gpuThreadId,\n    viewportRect: viewportRect || undefined,\n    devicePixelRatio: devicePixelRatio ?? undefined,\n    mainFrameId,\n    mainFrameURL,\n    navigationsByFrameId,\n    navigationsByNavigationId,\n    softNavigationsById,\n    finalDisplayUrlByNavigationId,\n    threadsInProcess,\n    rendererProcessesByFrame: rendererProcessesByFrameId,\n    topLevelRendererIds,\n    frameByProcessId: framesByProcessId,\n    mainFrameNavigations,\n    traceIsGeneric,\n  };\n}\n"]}