{"version":3,"file":"NetworkRequestsHandler.js","sourceRoot":"","sources":["../../../../../../../front_end/models/trace/handlers/NetworkRequestsHandler.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2022 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Protocol from '../../../generated/protocol.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport * as HandlerHelpers from './helpers.js';\nimport {data as metaHandlerData} from './MetaHandler.js';\nimport type {HandlerName} from './types.js';\n\nconst MILLISECONDS_TO_MICROSECONDS = 1000;\nconst SECONDS_TO_MICROSECONDS = 1000000;\n\n/**\n * Network requests from traces are actually formed of 5 trace records.\n * This handler tracks all trace records based on the request ID, and\n * then creates a new synthetic trace event for those network requests.\n *\n * This interface, then, defines the shape of the object we intend to\n * keep for each request in the trace. In the finalize we will convert\n * these 5 types of trace records to a synthetic complete event that\n * represents a composite of these trace records.\n **/\nexport interface TraceEventsForNetworkRequest {\n  changePriority?: Types.Events.ResourceChangePriority;\n  willSendRequests?: Types.Events.ResourceWillSendRequest[];\n  sendRequests?: Types.Events.ResourceSendRequest[];\n  receiveResponse?: Types.Events.ResourceReceiveResponse;\n  resourceFinish?: Types.Events.ResourceFinish;\n  receivedData?: Types.Events.ResourceReceivedData[];\n  resourceMarkAsCached?: Types.Events.ResourceMarkAsCached;\n  preloadRenderBlockingStatusChange?: Types.Events.PreloadRenderBlockingStatusChangeEvent[];\n}\n\nexport interface WebSocketTraceDataForFrame {\n  frame: string;\n  webSocketIdentifier: number;\n  events: Types.Events.WebSocketEvent[];\n  syntheticConnection: Types.Events.SyntheticWebSocketConnection|null;\n}\nexport interface WebSocketTraceDataForWorker {\n  workerId: string;\n  webSocketIdentifier: number;\n  events: Types.Events.WebSocketEvent[];\n  syntheticConnection: Types.Events.SyntheticWebSocketConnection|null;\n}\nexport type WebSocketTraceData = WebSocketTraceDataForFrame|WebSocketTraceDataForWorker;\n\nlet webSocketData = new Map<number, WebSocketTraceData>();\nlet linkPreconnectEvents: Types.Events.LinkPreconnect[] = [];\n\ninterface NetworkRequestData {\n  byId: Map<string, Types.Events.SyntheticNetworkRequest>;\n  byTime: Types.Events.SyntheticNetworkRequest[];\n  requestIdsByURL: Map<string, string[]>;\n  /**\n   * IMPORTANT: you should prefer to use `Trace.Extras.Initiator` to find the initiator.\n   * This is because backend trace events have some bugs which means the initiators are not always accurate.\n   * See crrev.com/c/7032169 for context.\n   */\n  incompleteInitiator: Map<Types.Events.SyntheticNetworkRequest, Types.Events.SyntheticNetworkRequest>;\n  webSocket: WebSocketTraceData[];\n  entityMappings: HandlerHelpers.EntityMappings;\n  linkPreconnectEvents: Types.Events.LinkPreconnect[];\n}\n\nlet requestMap = new Map<string, TraceEventsForNetworkRequest>();\nlet requestsById = new Map<string, Types.Events.SyntheticNetworkRequest>();\nlet requestsByTime: Types.Events.SyntheticNetworkRequest[] = [];\n\n/**\n * URL => RequestId[]. There can be multiple requests for a single URL.\n */\nlet requestIdsByURL = new Map<string, string[]>();\n\nlet networkRequestEventByInitiatorUrl = new Map<string, Types.Events.SyntheticNetworkRequest[]>();\nlet eventToInitiatorMap = new Map<Types.Events.SyntheticNetworkRequest, Types.Events.SyntheticNetworkRequest>();\n\n/**\n * These are to store ThirdParty data relationships between entities and events. To reduce iterating through data\n * more than we have to, here we start building the caches. After this, the RendererHandler will update\n * the relationships. When handling ThirdParty references, use the one in the RendererHandler instead.\n */\nlet entityMappings: HandlerHelpers.EntityMappings = {\n  eventsByEntity: new Map<HandlerHelpers.Entity, Types.Events.Event[]>(),\n  entityByEvent: new Map<Types.Events.Event, HandlerHelpers.Entity>(),\n  createdEntityCache: new Map<string, HandlerHelpers.Entity>(),\n  entityByUrlCache: new Map<string, HandlerHelpers.Entity>(),\n};\n\nfunction storeTraceEventWithRequestId<K extends keyof TraceEventsForNetworkRequest>(\n    requestId: string, key: K, value: TraceEventsForNetworkRequest[K]): void {\n  if (!requestMap.has(requestId)) {\n    requestMap.set(requestId, {});\n  }\n\n  const traceEvents = requestMap.get(requestId);\n  if (!traceEvents) {\n    throw new Error(`Unable to locate trace events for request ID ${requestId}`);\n  }\n\n  if (Array.isArray(traceEvents[key])) {\n    const target = traceEvents[key] as Types.Events.Event[];\n    const values = value as Types.Events.Event[];\n    target.push(...values);\n  } else {\n    traceEvents[key] = value;\n  }\n}\n\nfunction firstPositiveValueInList(entries: Array<number|null>): number {\n  for (const entry of entries) {\n    if (entry && entry > 0) {\n      return entry;\n    }\n  }\n\n  // In the event we don't find a positive value, we return 0 so as to\n  // be a mathematical noop. It's typically not correct to return – say –\n  // a -1 here because it would affect the calculation of stats below.\n  return 0;\n}\n\nexport function reset(): void {\n  requestsById = new Map();\n  requestMap = new Map();\n  requestsByTime = [];\n  networkRequestEventByInitiatorUrl = new Map();\n  eventToInitiatorMap = new Map();\n  webSocketData = new Map();\n  requestIdsByURL = new Map();\n  entityMappings = {\n    eventsByEntity: new Map<HandlerHelpers.Entity, Types.Events.Event[]>(),\n    entityByEvent: new Map<Types.Events.Event, HandlerHelpers.Entity>(),\n    createdEntityCache: new Map<string, HandlerHelpers.Entity>(),\n    entityByUrlCache: new Map<string, HandlerHelpers.Entity>(),\n  };\n  linkPreconnectEvents = [];\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isResourceChangePriority(event)) {\n    storeTraceEventWithRequestId(event.args.data.requestId, 'changePriority', event);\n    return;\n  }\n\n  if (Types.Events.isResourceWillSendRequest(event)) {\n    storeTraceEventWithRequestId(event.args.data.requestId, 'willSendRequests', [event]);\n    return;\n  }\n\n  if (Types.Events.isResourceSendRequest(event)) {\n    storeTraceEventWithRequestId(event.args.data.requestId, 'sendRequests', [event]);\n    return;\n  }\n\n  if (Types.Events.isResourceReceiveResponse(event)) {\n    storeTraceEventWithRequestId(event.args.data.requestId, 'receiveResponse', event);\n    return;\n  }\n\n  if (Types.Events.isResourceReceivedData(event)) {\n    storeTraceEventWithRequestId(event.args.data.requestId, 'receivedData', [event]);\n    return;\n  }\n\n  if (Types.Events.isResourceFinish(event)) {\n    storeTraceEventWithRequestId(event.args.data.requestId, 'resourceFinish', event);\n    return;\n  }\n\n  if (Types.Events.isResourceMarkAsCached(event)) {\n    storeTraceEventWithRequestId(event.args.data.requestId, 'resourceMarkAsCached', event);\n    return;\n  }\n\n  if (Types.Events.isPreloadRenderBlockingStatusChangeEvent(event)) {\n    storeTraceEventWithRequestId(event.args.data.requestId, 'preloadRenderBlockingStatusChange', [event]);\n  }\n\n  if (Types.Events.isWebSocketCreate(event) || Types.Events.isWebSocketInfo(event) ||\n      Types.Events.isWebSocketTransfer(event)) {\n    const identifier = event.args.data.identifier;\n    if (!webSocketData.has(identifier)) {\n      if (event.args.data.frame) {\n        webSocketData.set(identifier, {\n          frame: event.args.data.frame,\n          webSocketIdentifier: identifier,\n          events: [],\n          syntheticConnection: null,\n        });\n      } else if (event.args.data.workerId) {\n        webSocketData.set(identifier, {\n          workerId: event.args.data.workerId,\n          webSocketIdentifier: identifier,\n          events: [],\n          syntheticConnection: null,\n        });\n      }\n    }\n\n    webSocketData.get(identifier)?.events.push(event);\n  }\n\n  if (Types.Events.isLinkPreconnect(event)) {\n    linkPreconnectEvents.push(event);\n    return;\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  const {rendererProcessesByFrame} = metaHandlerData();\n  for (const [requestId, request] of requestMap.entries()) {\n    // If we have an incomplete set of events here, we choose to drop the network\n    // request rather than attempt to synthesize the missing data.\n    if (!request.sendRequests) {\n      continue;\n    }\n\n    // In the data we may get multiple willSendRequests and sendRequests, which\n    // will indicate that there are redirects for a given (sub)resource. In the\n    // case of a navigation, e.g., example.com/ we will get willSendRequests,\n    // and we should use these to calculate time spent in redirects.\n    // In the case of sub-resources, however, e.g., example.com/foo.js we will\n    // *only* get sendRequests, and we use these instead of willSendRequests\n    // to detect the time in redirects. We always use the sendRequest for the\n    // url, priority etc since it contains those values, but we use the\n    // willSendRequest (if it exists) to calculate the timestamp and durations\n    // of redirects.\n    const redirects: Types.Events.SyntheticNetworkRedirect[] = [];\n    for (let i = 0; i < request.sendRequests.length - 1; i++) {\n      const sendRequest = request.sendRequests[i];\n      const nextSendRequest = request.sendRequests[i + 1];\n\n      // Use the willSendRequests as the source for redirects if possible.\n      // We default to those of the sendRequests, however, since willSendRequest\n      // is not guaranteed to be present in the data for every request.\n      let ts = sendRequest.ts;\n      let dur = Types.Timing.Micro(nextSendRequest.ts - sendRequest.ts);\n      if (request.willSendRequests?.[i] && request.willSendRequests[i + 1]) {\n        const willSendRequest = request.willSendRequests[i];\n        const nextWillSendRequest = request.willSendRequests[i + 1];\n        ts = willSendRequest.ts;\n        dur = Types.Timing.Micro(nextWillSendRequest.ts - willSendRequest.ts);\n      }\n\n      redirects.push({\n        url: sendRequest.args.data.url,\n        priority: sendRequest.args.data.priority,\n        requestMethod: sendRequest.args.data.requestMethod,\n        ts,\n        dur,\n      });\n    }\n\n    const firstSendRequest = request.sendRequests[0];\n    const finalSendRequest = request.sendRequests[request.sendRequests.length - 1];\n\n    // We currently do not want to include data URI requests. We may revisit this in the future.\n    if (finalSendRequest.args.data.url.startsWith('data:')) {\n      continue;\n    }\n\n    /**\n     * LR loses transfer size information, but passes it in the 'X-TotalFetchedSize' header.\n     * 'X-TotalFetchedSize' is the canonical transfer size in LR.\n     *\n     * In Lightrider, due to instrumentation limitations, our values for encodedDataLength are bogus\n     * and not valid. However the resource's true encodedDataLength/transferSize is shared via a\n     * special response header, X-TotalFetchedSize. In this situation, we read this value from\n     * responseReceived, use it for the transferSize and ignore the original encodedDataLength values.\n     */\n    // @ts-expect-error\n    const isLightrider = globalThis.isLightrider;\n    if (isLightrider && request.resourceFinish && request.receiveResponse?.args.data.headers) {\n      const lrSizeHeader = request.receiveResponse.args.data.headers.find(h => h.name === 'X-TotalFetchedSize');\n      if (lrSizeHeader) {\n        const size = parseFloat(lrSizeHeader.value);\n        if (!isNaN(size)) {\n          request.resourceFinish.args.data.encodedDataLength = size;\n        }\n      }\n    }\n\n    // If a ResourceFinish event with an encoded data length is received,\n    // then the resource was not cached; it was fetched before it was\n    // requested, e.g. because it was pushed in this navigation.\n    const isPushedResource = request.resourceFinish?.args.data.encodedDataLength !== 0;\n    // This works around crbug.com/998397, which reports pushed resources, and resources served by a service worker as disk cached.\n    const isDiskCached = !!request.receiveResponse && request.receiveResponse.args.data.fromCache &&\n        !request.receiveResponse.args.data.fromServiceWorker && !isPushedResource;\n    // If the request contains a resourceMarkAsCached event, it was served from memory cache.\n    // The timing data returned is from the original (uncached) request, which\n    // means that if we leave the above network record data as-is when the\n    // request came from either the disk cache or memory cache, our calculations\n    // will be incorrect.\n    //\n    // So we use this flag so when we calculate the timestamps of the various\n    // events, we can overwrite them.\n    // These timestamps may not be perfect (indeed they don't always match\n    // the Network CDP domain exactly, which is likely an artifact of the way\n    // the data is routed on the backend), but they're the closest we have.\n    const isMemoryCached = request.resourceMarkAsCached !== undefined;\n    // If a request has `resourceMarkAsCached` field, the `timing` field is not correct.\n    // So let's discard it and override to 0 (which will be handled in later logic if timing field is undefined).\n    let timing = isMemoryCached ? undefined : request.receiveResponse?.args.data.timing;\n\n    /**\n     * LR gets additional, accurate timing information from its underlying fetch infrastructure.  This\n     * is passed in via X-Headers similar to 'X-TotalFetchedSize'.\n     *\n     * See `_updateTimingsForLightrider` in Lighthouse for more detail.\n     */\n    let lrServerResponseTime;\n    if (isLightrider && request.receiveResponse?.args.data.headers) {\n      timing = {\n        requestTime: Helpers.Timing.microToSeconds(request.sendRequests.at(0)?.ts ?? 0 as Types.Timing.Micro),\n        connectEnd: 0 as Types.Timing.Milli,\n        connectStart: 0 as Types.Timing.Milli,\n        dnsEnd: 0 as Types.Timing.Milli,\n        dnsStart: 0 as Types.Timing.Milli,\n        proxyEnd: 0 as Types.Timing.Milli,\n        proxyStart: 0 as Types.Timing.Milli,\n        pushEnd: 0 as Types.Timing.Milli,\n        pushStart: 0 as Types.Timing.Milli,\n        receiveHeadersEnd: 0 as Types.Timing.Milli,\n        receiveHeadersStart: 0 as Types.Timing.Milli,\n        sendEnd: 0 as Types.Timing.Milli,\n        sendStart: 0 as Types.Timing.Milli,\n        sslEnd: 0 as Types.Timing.Milli,\n        sslStart: 0 as Types.Timing.Milli,\n        workerReady: 0 as Types.Timing.Milli,\n        workerStart: 0 as Types.Timing.Milli,\n\n        ...timing,\n      };\n\n      const TCPMsHeader = request.receiveResponse.args.data.headers.find(h => h.name === 'X-TCPMs');\n      const TCPMs = TCPMsHeader ? Math.max(0, parseInt(TCPMsHeader.value, 10)) : 0;\n\n      if (request.receiveResponse.args.data.protocol.startsWith('h3')) {\n        timing.connectStart = 0 as Types.Timing.Milli;\n        timing.connectEnd = TCPMs as Types.Timing.Milli;\n      } else {\n        timing.connectStart = 0 as Types.Timing.Milli;\n        timing.sslStart = TCPMs / 2 as Types.Timing.Milli;\n        timing.connectEnd = TCPMs as Types.Timing.Milli;\n        timing.sslEnd = TCPMs as Types.Timing.Milli;\n      }\n\n      // Lightrider does not have any equivalent for `sendEnd` timing values. The\n      // closest we can get to the server response time is from a header that\n      // Lightrider sets.\n      const ResponseMsHeader = request.receiveResponse.args.data.headers.find(h => h.name === 'X-ResponseMs');\n      if (ResponseMsHeader) {\n        lrServerResponseTime = Math.max(0, parseInt(ResponseMsHeader.value, 10)) as Types.Timing.Milli;\n      }\n    }\n\n    // TODO: consider allowing chrome / about.\n    const allowedProtocols = [\n      'blob:',\n      'file:',\n      'filesystem:',\n      'http:',\n      'https:',\n    ];\n    if (!allowedProtocols.some(p => firstSendRequest.args.data.url.startsWith(p))) {\n      continue;\n    }\n\n    const initialPriority = finalSendRequest.args.data.priority;\n    let finalPriority = initialPriority;\n    if (request.changePriority) {\n      finalPriority = request.changePriority.args.data.priority;\n    }\n\n    // Network timings are complicated.\n    // https://raw.githubusercontent.com/GoogleChrome/lighthouse/main/docs/Network-Timings.svg is generally correct, but.. less so for navigations/redirects/etc.\n\n    // Start time\n    // =======================\n    // The time where the request started, which is either the first willSendRequest\n    // event if there is one, or, if there is not, the sendRequest.\n    const startTime = (request.willSendRequests?.length) ? Types.Timing.Micro(request.willSendRequests[0].ts) :\n                                                           Types.Timing.Micro(firstSendRequest.ts);\n\n    // End redirect time\n    // =======================\n    // It's possible that when we start requesting data we will receive redirections.\n    // Here we note the time of the *last* willSendRequest / sendRequest event,\n    // which is used later on in the calculations for time queueing etc.\n    const endRedirectTime = (request.willSendRequests?.length) ?\n        Types.Timing.Micro(request.willSendRequests[request.willSendRequests.length - 1].ts) :\n        Types.Timing.Micro(finalSendRequest.ts);\n\n    // Finish time and end time\n    // =======================\n    // The finish time and the end time are subtly different.\n    //  - Finish time: records the point at which the network stack stopped receiving the data\n    //  - End time: the timestamp of the finish event itself (if one exists)\n    //\n    // The end time, then, will be slightly after the finish time.\n    const endTime = request.resourceFinish ? request.resourceFinish.ts : endRedirectTime;\n    const finishTime = request.resourceFinish?.args.data.finishTime ?\n        Types.Timing.Micro(request.resourceFinish.args.data.finishTime * SECONDS_TO_MICROSECONDS) :\n        Types.Timing.Micro(endTime);\n\n    // Network duration\n    // =======================\n    // Time spent on the network.\n    const networkDuration = Types.Timing.Micro(timing ? (finishTime || endRedirectTime) - endRedirectTime : 0);\n\n    // Processing duration\n    // =======================\n    // Time spent from start to end.\n    const processingDuration = Types.Timing.Micro(endTime - (finishTime || endTime));\n\n    // Redirection duration\n    // =======================\n    // Time between the first willSendRequest / sendRequest and last. This we place in *front* of the\n    // queueing, since the queueing time that we know about from the trace data is only the last request,\n    // i.e., the one that occurs after all the redirects.\n    const redirectionDuration = Types.Timing.Micro(endRedirectTime - startTime);\n\n    // Queueing\n    // =======================\n    // The amount of time queueing is the time between the request's start time to the requestTime\n    // arg recorded in the receiveResponse event. In the cases where the recorded start time is larger\n    // that the requestTime we set queueing time to zero.\n    const queueingFromTraceData = timing ? timing.requestTime * SECONDS_TO_MICROSECONDS - endRedirectTime : 0;\n    const queueing = Types.Timing.Micro(Platform.NumberUtilities.clamp(queueingFromTraceData, 0, Number.MAX_VALUE));\n\n    // Stalled\n    // =======================\n    // If the request is cached, the amount of time stalled is the time between the start time and\n    // receiving a response.\n    // Otherwise it is whichever positive number comes first from the following timing info:\n    // DNS start, Connection start, Send Start, or the time duration between our start time and\n    // receiving a response.\n    const stalled = timing ?\n        Types.Timing.Micro(firstPositiveValueInList([\n          timing.dnsStart * MILLISECONDS_TO_MICROSECONDS,\n          timing.connectStart * MILLISECONDS_TO_MICROSECONDS,\n          timing.sendStart * MILLISECONDS_TO_MICROSECONDS,\n          request.receiveResponse ? (request.receiveResponse.ts - endRedirectTime) : null,\n        ])) :\n        (request.receiveResponse ? Types.Timing.Micro(request.receiveResponse.ts - startTime) : Types.Timing.Micro(0));\n\n    // Sending HTTP request\n    // =======================\n    // Time when the HTTP request is sent.\n    const sendStartTime = timing ?\n        Types.Timing.Micro(\n            timing.requestTime * SECONDS_TO_MICROSECONDS + timing.sendStart * MILLISECONDS_TO_MICROSECONDS) :\n        startTime;\n\n    // Waiting\n    // =======================\n    // Time from when the send finished going to when the headers were received.\n    const waiting = timing ?\n        Types.Timing.Micro((timing.receiveHeadersEnd - timing.sendEnd) * MILLISECONDS_TO_MICROSECONDS) :\n        Types.Timing.Micro(0);\n\n    // Server Response Time\n    // =======================\n    // Time from when the send finished going to when the first byte of headers were received.\n    const serverResponseTime = timing ?\n        Types.Timing.Micro(\n            ((timing.receiveHeadersStart ?? timing.receiveHeadersEnd) - timing.sendEnd) *\n            MILLISECONDS_TO_MICROSECONDS) :\n        Types.Timing.Micro(0);\n\n    // Download\n    // =======================\n    // Time from receipt of headers to the finish time.\n    const downloadStart = timing ?\n        Types.Timing.Micro(\n            timing.requestTime * SECONDS_TO_MICROSECONDS + timing.receiveHeadersEnd * MILLISECONDS_TO_MICROSECONDS) :\n        startTime;\n    const download = timing     ? Types.Timing.Micro(((finishTime || downloadStart) - downloadStart)) :\n        request.receiveResponse ? Types.Timing.Micro(endTime - request.receiveResponse.ts) :\n                                  Types.Timing.Micro(0);\n\n    const totalTime = Types.Timing.Micro(networkDuration + processingDuration);\n\n    // Collect a few values from the timing info.\n    // If the Network request is cached, these fields will be zero, so the minus will zero out them.\n    const dnsLookup = timing ? Types.Timing.Micro((timing.dnsEnd - timing.dnsStart) * MILLISECONDS_TO_MICROSECONDS) :\n                               Types.Timing.Micro(0);\n    const ssl = timing ? Types.Timing.Micro((timing.sslEnd - timing.sslStart) * MILLISECONDS_TO_MICROSECONDS) :\n                         Types.Timing.Micro(0);\n    const proxyNegotiation = timing ?\n        Types.Timing.Micro((timing.proxyEnd - timing.proxyStart) * MILLISECONDS_TO_MICROSECONDS) :\n        Types.Timing.Micro(0);\n    const requestSent = timing ?\n        Types.Timing.Micro((timing.sendEnd - timing.sendStart) * MILLISECONDS_TO_MICROSECONDS) :\n        Types.Timing.Micro(0);\n    const initialConnection = timing ?\n        Types.Timing.Micro((timing.connectEnd - timing.connectStart) * MILLISECONDS_TO_MICROSECONDS) :\n        Types.Timing.Micro(0);\n\n    // Finally get some of the general data from the trace events.\n    const {frame, url, renderBlocking: sendRequestIsRenderBlocking} = finalSendRequest.args.data;\n    const {encodedDataLength, decodedBodyLength} =\n        request.resourceFinish ? request.resourceFinish.args.data : {encodedDataLength: 0, decodedBodyLength: 0};\n    const parsedUrl = new URL(url);\n    const isHttps = parsedUrl.protocol === 'https:';\n    const requestingFrameUrl =\n        Helpers.Trace.activeURLForFrameAtTime(frame, finalSendRequest.ts, rendererProcessesByFrame) || '';\n\n    // A resource that is preloaded (and not marked as render blocking) can\n    // become render blocked later via a PreloadRenderBlockingStatusChange. In\n    // this case, we take the render blocking value of the last\n    // PreloadRenderBlockingStatusChange for this request.\n    const preloadRenderBlockingStatusChange =\n        request.preloadRenderBlockingStatusChange?.at(-1)?.args.data.renderBlocking;\n\n    // In the event the property isn't set, assume non-blocking.\n    const isRenderBlocking = preloadRenderBlockingStatusChange ?? sendRequestIsRenderBlocking ?? 'non_blocking';\n\n    // Construct a synthetic trace event for this network request.\n    const networkEvent =\n        Helpers.SyntheticEvents.SyntheticEventsManager.registerSyntheticEvent<Types.Events.SyntheticNetworkRequest>({\n          rawSourceEvent: finalSendRequest,\n          args: {\n            data: {\n              // All data we create from trace events should be added to |syntheticData|.\n              syntheticData: {\n                dnsLookup,\n                download,\n                downloadStart,\n                finishTime,\n                initialConnection,\n                isDiskCached,\n                isHttps,\n                isMemoryCached,\n                isPushedResource,\n                networkDuration,\n                processingDuration,\n                proxyNegotiation,\n                queueing,\n                redirectionDuration,\n                requestSent,\n                sendStartTime,\n                ssl,\n                stalled,\n                totalTime,\n                waiting,\n                serverResponseTime,\n              },\n              // All fields below are from TraceEventsForNetworkRequest.\n              decodedBodyLength,\n              encodedDataLength,\n              frame,\n              fromServiceWorker: request.receiveResponse?.args.data.fromServiceWorker,\n              isLinkPreload: finalSendRequest.args.data.isLinkPreload || false,\n              mimeType: request.receiveResponse?.args.data.mimeType ?? '',\n              priority: finalPriority,\n              initialPriority,\n              protocol: request.receiveResponse?.args.data.protocol ?? 'unknown',\n              redirects,\n              renderBlocking: isRenderBlocking,\n              requestId,\n              requestingFrameUrl,\n              requestMethod: finalSendRequest.args.data.requestMethod,\n              resourceType: finalSendRequest.args.data.resourceType ?? Protocol.Network.ResourceType.Other,\n              statusCode: request.receiveResponse?.args.data.statusCode ?? 0,\n              responseHeaders: request.receiveResponse?.args.data.headers ?? null,\n              fetchPriorityHint: finalSendRequest.args.data.fetchPriorityHint ?? 'auto',\n              initiator: finalSendRequest.args.data.initiator,\n              stackTrace: finalSendRequest.args.data.stackTrace,\n              timing,\n              lrServerResponseTime,\n              url,\n              failed: request.resourceFinish?.args.data.didFail ?? false,\n              finished: Boolean(request.resourceFinish),\n              hasResponse: Boolean(request.receiveResponse),\n              connectionId: request.receiveResponse?.args.data.connectionId,\n              connectionReused: request.receiveResponse?.args.data.connectionReused,\n            },\n          },\n          cat: 'loading',\n          name: Types.Events.Name.SYNTHETIC_NETWORK_REQUEST,\n          ph: Types.Events.Phase.COMPLETE,\n          dur: Types.Timing.Micro(endTime - startTime),\n          tdur: Types.Timing.Micro(endTime - startTime),\n          ts: Types.Timing.Micro(startTime),\n          tts: Types.Timing.Micro(startTime),\n          pid: finalSendRequest.pid,\n          tid: finalSendRequest.tid,\n        });\n\n    // However, there are also times where we just want to loop through all\n    // the captured requests, so here we store all of them together.\n    requestsByTime.push(networkEvent);\n    requestsById.set(networkEvent.args.data.requestId, networkEvent);\n\n    const requestsForUrl = requestIdsByURL.get(networkEvent.args.data.url) ?? [];\n    requestsForUrl.push(networkEvent.args.data.requestId);\n    requestIdsByURL.set(networkEvent.args.data.url, requestsForUrl);\n\n    // Update entity relationships for network events\n    HandlerHelpers.addNetworkRequestToEntityMapping(networkEvent, entityMappings, request);\n\n    // Establish initiator relationships\n    const initiatorUrl = networkEvent.args.data.initiator?.url ||\n        Helpers.Trace.getStackTraceTopCallFrameInEventPayload(networkEvent)?.url;\n    if (initiatorUrl) {\n      const events = networkRequestEventByInitiatorUrl.get(initiatorUrl) ?? [];\n      events.push(networkEvent);\n      networkRequestEventByInitiatorUrl.set(initiatorUrl, events);\n    }\n  }\n\n  for (const request of requestsByTime) {\n    const initiatedEvents = networkRequestEventByInitiatorUrl.get(request.args.data.url);\n\n    if (initiatedEvents) {\n      for (const initiatedEvent of initiatedEvents) {\n        eventToInitiatorMap.set(initiatedEvent, request);\n      }\n    }\n  }\n\n  finalizeWebSocketData();\n}\n\nexport function data(): NetworkRequestData {\n  return {\n    byId: requestsById,\n    byTime: requestsByTime,\n    requestIdsByURL,\n    incompleteInitiator: eventToInitiatorMap,\n    webSocket: [...webSocketData.values()],\n    entityMappings: {\n      entityByEvent: entityMappings.entityByEvent,\n      eventsByEntity: entityMappings.eventsByEntity,\n      createdEntityCache: entityMappings.createdEntityCache,\n      entityByUrlCache: entityMappings.entityByUrlCache,\n    },\n    linkPreconnectEvents,\n  };\n}\n\nexport function deps(): HandlerName[] {\n  return ['Meta'];\n}\n\nfunction finalizeWebSocketData(): void {\n  // for each WebSocketTraceData in webSocketData map, we create a synthetic event\n  // to represent the entire WebSocket connection. This is done by finding the start and end event\n  // if they exist, and if they don't, we use the first event in the list for start, and the traceBounds.max\n  // for the end. So each WebSocketTraceData will have\n  // {\n  //    events:  the list of WebSocket events\n  //    syntheticConnection:  the synthetic event representing the entire WebSocket connection\n  // }\n  webSocketData.forEach(data => {\n    let startEvent: Types.Events.WebSocketEvent|null = null;\n    let endEvent: Types.Events.WebSocketDestroy|null = null;\n    for (const event of data.events) {\n      if (Types.Events.isWebSocketCreate(event)) {\n        startEvent = event;\n      }\n      if (Types.Events.isWebSocketDestroy(event)) {\n        endEvent = event;\n      }\n    }\n    data.syntheticConnection = createSyntheticWebSocketConnection(startEvent, endEvent, data.events[0]);\n  });\n}\n\nfunction createSyntheticWebSocketConnection(\n    startEvent: Types.Events.WebSocketCreate|null, endEvent: Types.Events.WebSocketDestroy|null,\n    firstRecordedEvent: Types.Events.WebSocketEvent): Types.Events.SyntheticWebSocketConnection {\n  const {traceBounds} = metaHandlerData();\n  const startTs = startEvent ? startEvent.ts : traceBounds.min;\n  const endTs = endEvent ? endEvent.ts : traceBounds.max;\n  const duration = endTs - startTs;\n  const mainEvent = startEvent || endEvent || firstRecordedEvent;\n  return {\n    name: 'SyntheticWebSocketConnection',\n    cat: mainEvent.cat,\n    ph: Types.Events.Phase.COMPLETE,\n    ts: startTs,\n    dur: duration as Types.Timing.Micro,\n    pid: mainEvent.pid,\n    tid: mainEvent.tid,\n    s: mainEvent.s,\n    rawSourceEvent: mainEvent,\n    _tag: 'SyntheticEntryTag',\n    args: {\n      data: {\n        identifier: mainEvent.args.data.identifier,\n        priority: Protocol.Network.ResourcePriority.Low,\n        url: mainEvent.args.data.url || '',\n      },\n    },\n  };\n}\n"]}