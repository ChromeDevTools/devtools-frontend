{"version":3,"file":"RendererHandler.js","sourceRoot":"","sources":["../../../../../../../front_end/models/trace/handlers/RendererHandler.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2022 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {data as auctionWorkletsData} from './AuctionWorkletsHandler.js';\nimport * as HandlerHelpers from './helpers.js';\nimport {data as metaHandlerData, type FrameProcessData} from './MetaHandler.js';\nimport {data as networkRequestHandlerData} from './NetworkRequestsHandler.js';\nimport {data as samplesHandlerData} from './SamplesHandler.js';\nimport type {HandlerName} from './types.js';\n\n/**\n * This handler builds the hierarchy of trace events and profile calls\n * on each thread on each process.\n *\n * Throughout the code, trace events and profile calls are referred to\n * as \"entries\", but note they are different types of data. Trace events\n * come directly from the backend and it's the type the engine commonly\n * refers to. Profile calls on the other hand are built in the frontend,\n * and, for compatibility purposes, typed as an extension to the trace\n * event type.\n */\n\nlet processes = new Map<Types.Events.ProcessID, RendererProcess>();\n\nlet entityMappings: HandlerHelpers.EntityMappings = {\n  eventsByEntity: new Map<HandlerHelpers.Entity, Types.Events.Event[]>(),\n  entityByEvent: new Map<Types.Events.Event, HandlerHelpers.Entity>(),\n  createdEntityCache: new Map<string, HandlerHelpers.Entity>(),\n  entityByUrlCache: new Map<string, HandlerHelpers.Entity>(),\n};\n\n// We track the compositor tile worker thread name events so that at the end we\n// can return these keyed by the process ID. These are used in the frontend to\n// show the user the rasterization thread(s) on the main frame as tracks.\nlet compositorTileWorkers = Array<{\n  pid: Types.Events.ProcessID,\n  tid: Types.Events.ThreadID,\n}>();\nlet entryToNode = new Map<Types.Events.Event, Helpers.TreeHelpers.TraceEntryNode>();\n\nlet completeEventStack: (Types.Events.SyntheticComplete)[] = [];\n\nlet config: Types.Configuration.Configuration = Types.Configuration.defaults();\n\nconst makeRendererProcess = (): RendererProcess => ({\n  url: null,\n  isOnMainFrame: false,\n  threads: new Map(),\n});\n\nconst makeRendererThread = (): RendererThread => ({\n  name: null,\n  entries: [],\n  profileCalls: [],\n  layoutEvents: [],\n  recalcStyleEvents: [],\n});\n\nconst getOrCreateRendererProcess =\n    (processes: Map<Types.Events.ProcessID, RendererProcess>, pid: Types.Events.ProcessID): RendererProcess => {\n      return Platform.MapUtilities.getWithDefault(processes, pid, makeRendererProcess);\n    };\n\nconst getOrCreateRendererThread = (process: RendererProcess, tid: Types.Events.ThreadID): RendererThread => {\n  return Platform.MapUtilities.getWithDefault(process.threads, tid, makeRendererThread);\n};\n\nexport function handleUserConfig(userConfig: Types.Configuration.Configuration): void {\n  config = userConfig;\n}\n\nexport function reset(): void {\n  processes = new Map();\n  entryToNode = new Map();\n  entityMappings = {\n    eventsByEntity: new Map<HandlerHelpers.Entity, Types.Events.Event[]>(),\n    entityByEvent: new Map<Types.Events.Event, HandlerHelpers.Entity>(),\n    createdEntityCache: new Map<string, HandlerHelpers.Entity>(),\n    entityByUrlCache: new Map<string, HandlerHelpers.Entity>(),\n  };\n  completeEventStack = [];\n  compositorTileWorkers = [];\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isThreadName(event) && event.args.name?.startsWith('CompositorTileWorker')) {\n    compositorTileWorkers.push({\n      pid: event.pid,\n      tid: event.tid,\n    });\n  }\n\n  if (Types.Events.isBegin(event) || Types.Events.isEnd(event)) {\n    const process = getOrCreateRendererProcess(processes, event.pid);\n    const thread = getOrCreateRendererThread(process, event.tid);\n    const completeEvent = makeCompleteEvent(event);\n    if (!completeEvent) {\n      return;\n    }\n    thread.entries.push(completeEvent);\n    return;\n  }\n\n  if (Types.Events.isInstant(event) || Types.Events.isComplete(event)) {\n    const process = getOrCreateRendererProcess(processes, event.pid);\n    const thread = getOrCreateRendererThread(process, event.tid);\n    thread.entries.push(event);\n  }\n\n  if (Types.Events.isLayout(event)) {\n    const process = getOrCreateRendererProcess(processes, event.pid);\n    const thread = getOrCreateRendererThread(process, event.tid);\n    thread.layoutEvents.push(event);\n  }\n\n  if (Types.Events.isRecalcStyle(event)) {\n    const process = getOrCreateRendererProcess(processes, event.pid);\n    const thread = getOrCreateRendererThread(process, event.tid);\n    thread.recalcStyleEvents.push(event);\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  const {mainFrameId, rendererProcessesByFrame, threadsInProcess} = metaHandlerData();\n  entityMappings = networkRequestHandlerData().entityMappings;\n\n  assignMeta(processes, mainFrameId, rendererProcessesByFrame, threadsInProcess);\n  sanitizeProcesses(processes);\n  buildHierarchy(processes);\n  sanitizeThreads(processes);\n}\n\nexport function data(): RendererHandlerData {\n  return {\n    processes,\n    compositorTileWorkers: gatherCompositorThreads(),\n    entryToNode,\n    entityMappings: {\n      entityByEvent: entityMappings.entityByEvent,\n      eventsByEntity: entityMappings.eventsByEntity,\n      createdEntityCache: entityMappings.createdEntityCache,\n      entityByUrlCache: entityMappings.entityByUrlCache,\n    },\n  };\n}\n\nfunction gatherCompositorThreads(): Map<Types.Events.ProcessID, Types.Events.ThreadID[]> {\n  const threadsByProcess = new Map<Types.Events.ProcessID, Types.Events.ThreadID[]>();\n  for (const worker of compositorTileWorkers) {\n    const byProcess = threadsByProcess.get(worker.pid) || [];\n    byProcess.push(worker.tid);\n    threadsByProcess.set(worker.pid, byProcess);\n  }\n  return threadsByProcess;\n}\n\n/**\n * Steps through all the renderer processes we've located so far in the meta\n * handler, obtaining their URL, checking whether they are the main frame, and\n * collecting each one of their threads' name. This meta handler's data is\n * assigned to the renderer handler's data.\n */\nexport function assignMeta(\n    processes: Map<Types.Events.ProcessID, RendererProcess>, mainFrameId: string,\n    rendererProcessesByFrame: FrameProcessData,\n    threadsInProcess: Map<Types.Events.ProcessID, Map<Types.Events.ThreadID, Types.Events.ThreadName>>): void {\n  assignOrigin(processes, rendererProcessesByFrame);\n  assignIsMainFrame(processes, mainFrameId, rendererProcessesByFrame);\n  assignThreadName(processes, threadsInProcess);\n}\n\n/**\n * Assigns origins to all threads in all processes.\n * @see assignMeta\n */\nexport function assignOrigin(\n    processes: Map<Types.Events.ProcessID, RendererProcess>, rendererProcessesByFrame: FrameProcessData): void {\n  for (const renderProcessesByPid of rendererProcessesByFrame.values()) {\n    for (const [pid, processWindows] of renderProcessesByPid) {\n      for (const processInfo of processWindows.flat()) {\n        const process = getOrCreateRendererProcess(processes, pid);\n        // Sometimes a single process is responsible with rendering multiple\n        // frames at the same time. For example, see https://crbug.com/1334563.\n        // When this happens, we'd still like to assign a single url per process\n        // so: 1) use the first frame rendered by this process as the url source\n        // and 2) if the last url is \"about:blank\", use the next frame's url,\n        // data from about:blank is irrelevant.\n        if (process.url === null || process.url === 'about:blank') {\n          // If we are here, it's because we care about this process and the URL. But before we store\n          // it, we check if it is a valid URL by trying to create a URL object. If it isn't, we won't\n          // set it, and this process will be filtered out later.\n          try {\n            new URL(processInfo.frame.url);\n            process.url = processInfo.frame.url;\n          } catch {\n            process.url = null;\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Assigns whether or not a thread is the main frame to all threads in all processes.\n * @see assignMeta\n */\nexport function assignIsMainFrame(\n    processes: Map<Types.Events.ProcessID, RendererProcess>, mainFrameId: string,\n    rendererProcessesByFrame: FrameProcessData): void {\n  for (const [frameId, renderProcessesByPid] of rendererProcessesByFrame) {\n    for (const [pid] of renderProcessesByPid) {\n      const process = getOrCreateRendererProcess(processes, pid);\n      // We have this go in one direction; once a renderer has been flagged as\n      // being on the main frame, we don't unset it to false if were to show up\n      // in a subframe. Equally, if we already saw this renderer in a subframe,\n      // but it becomes the main frame, the flag would get updated.\n      if (frameId === mainFrameId) {\n        process.isOnMainFrame = true;\n      }\n    }\n  }\n}\n\n/**\n * Assigns the thread name to all threads in all processes.\n * @see assignMeta\n */\nexport function assignThreadName(\n    processes: Map<Types.Events.ProcessID, RendererProcess>,\n    threadsInProcess: Map<Types.Events.ProcessID, Map<Types.Events.ThreadID, Types.Events.ThreadName>>): void {\n  for (const [pid, process] of processes) {\n    for (const [tid, threadInfo] of threadsInProcess.get(pid) ?? []) {\n      const thread = getOrCreateRendererThread(process, tid);\n      thread.name = threadInfo?.args.name ?? `${tid}`;\n    }\n  }\n}\n\n/**\n * Removes unneeded trace data opportunistically stored while handling events.\n * This currently does the following:\n *  - Deletes processes with an unknown origin.\n */\nexport function sanitizeProcesses(processes: Map<Types.Events.ProcessID, RendererProcess>): void {\n  const auctionWorklets = auctionWorkletsData().worklets;\n  const metaData = metaHandlerData();\n  if (metaData.traceIsGeneric) {\n    return;\n  }\n  for (const [pid, process] of processes) {\n    // If the process had no url, or if it had a malformed url that could not be\n    // parsed for some reason, or if it's an \"about:\" origin, delete it.\n    // This is done because we don't really care about processes for which we\n    // can't provide actionable insights to the user (e.g. about:blank pages).\n    //\n    // There is one exception; AuctionWorklet processes get parsed in a\n    // separate handler, so at this point we check to see if the process has\n    // been found by the AuctionWorkletsHandler, and if so we update the URL.\n    // This ensures that we keep this process around and do not drop it due to\n    // the lack of a URL.\n    if (process.url === null) {\n      const maybeWorklet = auctionWorklets.get(pid);\n      if (maybeWorklet) {\n        process.url = maybeWorklet.host;\n      } else {\n        processes.delete(pid);\n      }\n      continue;\n    }\n  }\n}\n\n/**\n * Removes unneeded trace data opportunistically stored while handling events.\n * This currently does the following:\n *  - Deletes threads with no roots.\n */\nexport function sanitizeThreads(processes: Map<Types.Events.ProcessID, RendererProcess>): void {\n  for (const [, process] of processes) {\n    for (const [tid, thread] of process.threads) {\n      // If the thread has no roots, delete it. Otherwise, there's going to\n      // be space taken, even though nothing is rendered in the track manager.\n      if (!thread.tree?.roots.size) {\n        process.threads.delete(tid);\n      }\n    }\n  }\n}\n\n/**\n * Creates a hierarchical structure from the trace events. Each thread in each\n * process will contribute to their own individual hierarchy.\n *\n * The trace data comes in as a contiguous array of events, against which we\n * make a couple of assumptions:\n *\n *  1. Events are temporally-ordered in terms of start time (though they're\n *     not necessarily ordered as such in the data stream).\n *  2. If event B's start and end times are within event A's time boundaries\n *     we assume that A is the parent of B.\n *\n * Therefore we expect to reformulate something like:\n *\n * [ Task A ][ Task B ][ Task C ][ Task D ][ Task E ]\n *\n * Into something hierarchically-arranged like below:\n *\n * |------------- Task A -------------||-- Task E --|\n *  |-- Task B --||-- Task D --|\n *   |- Task C -|\n */\nexport function buildHierarchy(\n    processes: Map<Types.Events.ProcessID, RendererProcess>,\n    options?: {filter: {has: (name: Types.Events.Name) => boolean}}): void {\n  const samplesData = samplesHandlerData();\n  for (const [pid, process] of processes) {\n    for (const [tid, thread] of process.threads) {\n      if (!thread.entries.length) {\n        thread.tree = Helpers.TreeHelpers.makeEmptyTraceEntryTree();\n        continue;\n      }\n      // Step 1. Massage the data.\n      Helpers.Trace.sortTraceEventsInPlace(thread.entries);\n      // Step 2. Inject profile calls from samples\n      const samplesDataForThread = samplesData.profilesInProcess.get(pid)?.get(tid);\n      if (samplesDataForThread) {\n        const cpuProfile = samplesDataForThread.parsedProfile;\n        const samplesIntegrator = cpuProfile &&\n            new Helpers.SamplesIntegrator.SamplesIntegrator(\n                cpuProfile, samplesDataForThread.profileId, pid, tid, config);\n        const profileCalls = samplesIntegrator?.buildProfileCalls(thread.entries);\n        if (samplesIntegrator && profileCalls) {\n          thread.entries = Helpers.Trace.mergeEventsInOrder(thread.entries, profileCalls);\n          thread.profileCalls = profileCalls;\n\n          // We'll also inject the instant JSSample events (in debug mode only)\n          const jsSamples = samplesIntegrator.jsSampleEvents;\n          if (jsSamples.length) {\n            thread.entries = Helpers.Trace.mergeEventsInOrder(thread.entries, jsSamples);\n          }\n        }\n      }\n      // Step 3. Build the tree.\n      const treeData = Helpers.TreeHelpers.treify(thread.entries, options);\n      thread.tree = treeData.tree;\n      // Update the entryToNode map with the entries from this thread\n      for (const [entry, node] of treeData.entryToNode) {\n        entryToNode.set(entry, node);\n        // Entity mapping is unrelated to the tree, but calling here as we need to call on every node anyway.\n        HandlerHelpers.addEventToEntityMapping(entry, entityMappings);\n      }\n    }\n  }\n}\n\nexport function makeCompleteEvent(event: Types.Events.Begin|Types.Events.End): Types.Events.SyntheticComplete|null {\n  if (Types.Events.isEnd(event)) {\n    // Quietly ignore unbalanced close events, they're legit (we could\n    // have missed start one).\n    const beginEvent = completeEventStack.pop();\n    if (!beginEvent) {\n      return null;\n    }\n    if (beginEvent.name !== event.name || beginEvent.cat !== event.cat) {\n      console.error(\n          'Begin/End events mismatch at ' + beginEvent.ts + ' (' + beginEvent.name + ') vs. ' + event.ts + ' (' +\n          event.name + ')');\n      return null;\n    }\n    // Update the begin event's duration using the timestamp of the end\n    // event.\n    beginEvent.dur = Types.Timing.Micro(event.ts - beginEvent.ts);\n    return null;\n  }\n\n  // Create a synthetic event using the begin event, when we find the\n  // matching end event later we will update its duration.\n  const syntheticComplete: Types.Events.SyntheticComplete = {\n    ...event,\n    ph: Types.Events.Phase.COMPLETE,\n    dur: Types.Timing.Micro(0),\n  };\n\n  completeEventStack.push(syntheticComplete);\n  return syntheticComplete;\n}\n\nexport function deps(): HandlerName[] {\n  return ['Meta', 'Samples', 'AuctionWorklets', 'NetworkRequests'];\n}\n\nexport interface RendererHandlerData {\n  processes: Map<Types.Events.ProcessID, RendererProcess>;\n  /**\n   * A map of all compositor workers (which we show in the UI as Rasterizers)\n   * by the process ID.\n   */\n  compositorTileWorkers: Map<Types.Events.ProcessID, Types.Events.ThreadID[]>;\n  entryToNode: Map<Types.Events.Event, Helpers.TreeHelpers.TraceEntryNode>;\n  entityMappings: HandlerHelpers.EntityMappings;\n}\n\nexport interface RendererProcess {\n  // In an ideal world this would be modelled as a URL, but URLs cannot be sent\n  // between the main thread and workers, so we have to store it as a string.\n  url: string|null;\n  isOnMainFrame: boolean;\n  threads: Map<Types.Events.ThreadID, RendererThread>;\n}\n\nexport interface RendererThread {\n  name: string|null;\n  /**\n   * Contains trace events and synthetic profile calls made from\n   * samples.\n   */\n  entries: Types.Events.Event[];\n  profileCalls: Types.Events.SyntheticProfileCall[];\n  layoutEvents: Types.Events.Layout[];\n  recalcStyleEvents: Types.Events.RecalcStyle[];\n  tree?: Helpers.TreeHelpers.TraceEntryTree;\n}\n"]}