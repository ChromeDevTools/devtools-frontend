{"version":3,"file":"UserTimingsHandler.js","sourceRoot":"","sources":["../../../../../../../front_end/models/trace/handlers/UserTimingsHandler.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2022 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\n/**\n * IMPORTANT!\n * See UserTimings.md in this directory for some handy documentation on\n * UserTimings and the trace events we parse currently.\n **/\nlet syntheticEvents: Array<Types.Events.SyntheticEventPair<Types.Events.PairableAsync>> = [];\n\n// There are two events dispatched for performance.measure calls: one to\n// represent the measured timing in the tracing clock (which we type as\n// PerformanceMeasure) and another one for the call itself (which we\n// type as UserTimingMeasure). The two events corresponding to the same\n// call are linked together by a common trace_id. The reason two events\n// are dispatched is because the first was originally added with the\n// implementation of the performance.measure API and it uses an\n// overridden timestamp and duration. To prevent breaking potential deps\n// created since then, a second event was added instead of changing the\n// params of the first.\nlet measureTraceByTraceId = new Map<number, Types.Events.UserTimingMeasure>();\nlet performanceMeasureEvents: Types.Events.PerformanceMeasure[] = [];\nlet performanceMarkEvents: Types.Events.PerformanceMark[] = [];\n\nlet consoleTimings: Array<Types.Events.ConsoleTimeBegin|Types.Events.ConsoleTimeEnd> = [];\n\nlet timestampEvents: Types.Events.ConsoleTimeStamp[] = [];\n\nexport interface UserTimingsData {\n  /**\n   * Events triggered with the performance.measure() API.\n   * https://developer.mozilla.org/en-US/docs/Web/API/Performance/measure\n   */\n  performanceMeasures: readonly Types.Events.SyntheticUserTimingPair[];\n  /**\n   * Events triggered with the performance.mark() API.\n   * https://developer.mozilla.org/en-US/docs/Web/API/Performance/mark\n   */\n  performanceMarks: readonly Types.Events.PerformanceMark[];\n  /**\n   * Events triggered with the console.time(), console.timeEnd() and\n   * console.timeLog() API.\n   * https://developer.mozilla.org/en-US/docs/Web/API/console/time\n   */\n  consoleTimings: readonly Types.Events.SyntheticConsoleTimingPair[];\n  /**\n   * Events triggered with the console.timeStamp() API\n   * https://developer.mozilla.org/en-US/docs/Web/API/console/timeStamp\n   */\n  timestampEvents: readonly Types.Events.ConsoleTimeStamp[];\n  /**\n   * Events triggered to trace the call to performance.measure itself,\n   * cached by trace_id.\n   */\n  measureTraceByTraceId: Map<number, Types.Events.UserTimingMeasure>;\n}\n\nexport function reset(): void {\n  syntheticEvents = [];\n  performanceMeasureEvents = [];\n  performanceMarkEvents = [];\n  consoleTimings = [];\n  timestampEvents = [];\n  measureTraceByTraceId = new Map();\n}\n\nconst resourceTimingNames = [\n  'workerStart',\n  'redirectStart',\n  'redirectEnd',\n  'fetchStart',\n  'domainLookupStart',\n  'domainLookupEnd',\n  'connectStart',\n  'connectEnd',\n  'secureConnectionStart',\n  'requestStart',\n  'responseStart',\n  'responseEnd',\n];\nconst navTimingNames = [\n  'navigationStart',\n  'unloadEventStart',\n  'unloadEventEnd',\n  'redirectStart',\n  'redirectEnd',\n  'fetchStart',\n  'commitNavigationEnd',\n  'domainLookupStart',\n  'domainLookupEnd',\n  'connectStart',\n  'connectEnd',\n  'secureConnectionStart',\n  'requestStart',\n  'responseStart',\n  'responseEnd',\n  'domLoading',\n  'domInteractive',\n  'domContentLoadedEventStart',\n  'domContentLoadedEventEnd',\n  'domComplete',\n  'loadEventStart',\n  'loadEventEnd',\n];\n// These are events dispatched under the blink.user_timing category\n// but that the user didn't add. Filter them out so that they do not\n// Appear in the timings track (they still appear in the main thread\n// flame chart).\nconst ignoredNames = [...resourceTimingNames, ...navTimingNames];\n\nfunction getEventTimings(event: Types.Events.SyntheticEventPair|Types.Events.ConsoleTimeStamp):\n    {start: Types.Timing.Micro, end: Types.Timing.Micro} {\n  if ('dur' in event) {\n    // It's a SyntheticEventPair.\n    return {start: event.ts, end: Types.Timing.Micro(event.ts + (event.dur ?? 0))};\n  }\n\n  if (Types.Events.isConsoleTimeStamp(event)) {\n    const {start, end} = event.args.data || {};\n    if (typeof start === 'number' && typeof end === 'number') {\n      return {start: Types.Timing.Micro(start), end: Types.Timing.Micro(end)};\n    }\n  }\n\n  // A ConsoleTimeStamp without start/end is just a point in time, so dur is 0.\n  return {start: event.ts, end: event.ts};\n}\n\nfunction getEventTrack(event: Types.Events.SyntheticEventPair|Types.Events.ConsoleTimeStamp): string|undefined {\n  if (event.cat === 'blink.user_timing') {\n    // This is a SyntheticUserTimingPair\n    const detailString =\n        ((event as Types.Events.SyntheticUserTimingPair).args.data.beginEvent.args as {detail?: string})?.detail;\n    if (detailString) {\n      const details = Helpers.Trace.parseDevtoolsDetails(detailString, 'devtools');\n      if (details && 'track' in details) {\n        return details.track;\n      }\n    }\n  } else if (Types.Events.isConsoleTimeStamp(event)) {\n    const track = event.args.data?.track;\n    return typeof track === 'string' ? track : undefined;\n  }\n\n  // SyntheticConsoleTimingPair does not have track info.\n  return undefined;\n}\n\n/**\n * Similar to the default {@link Helpers.Trace.eventTimeComparator}\n * but with a twist:\n * In case of equal start and end times, put the second event (within a\n * track) first.\n *\n * Explanation:\n * User timing entries come as trace events dispatched when\n * performance.measure/mark is called. The trace events buffered in\n * devtools frontend are sorted by the start time. If their start time\n * is the same, then the event for the first call will appear first.\n *\n * When entries are meant to be stacked, the corresponding\n * performance.measure calls usually are done in bottom-up direction:\n * calls for children first and for parent later (because the call\n * is usually done when the measured task is over). This means that\n * when two user timing events have the same start and end time, usually\n * the second event is the parent of the first. Hence the switch.\n *\n */\nexport function userTimingComparator<T extends Types.Events.SyntheticEventPair|Types.Events.ConsoleTimeStamp>(\n    a: T, b: T, originalArray: readonly T[]): number {\n  const {start: aStart, end: aEnd} = getEventTimings(a);\n  const {start: bStart, end: bEnd} = getEventTimings(b);\n  const timeDifference = Helpers.Trace.compareBeginAndEnd(aStart, bStart, aEnd, bEnd);\n  if (timeDifference) {\n    return timeDifference;\n  }\n\n  // Never re-order entries across different tracks.\n  const aTrack = getEventTrack(a);\n  const bTrack = getEventTrack(b);\n  if (aTrack !== bTrack) {\n    return 0;  // Preserve current positions.\n  }\n\n  // Prefer the event located in a further position in the original array.\n  const aIndex = originalArray.indexOf(a);\n  const bIndex = originalArray.indexOf(b);\n  return bIndex - aIndex;\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (ignoredNames.includes(event.name)) {\n    return;\n  }\n  if (Types.Events.isUserTimingMeasure(event)) {\n    measureTraceByTraceId.set(event.args.traceId, event);\n  }\n  if (Types.Events.isPerformanceMeasure(event)) {\n    performanceMeasureEvents.push(event);\n    return;\n  }\n  if (Types.Events.isPerformanceMark(event)) {\n    performanceMarkEvents.push(event);\n  }\n  if (Types.Events.isConsoleTime(event)) {\n    consoleTimings.push(event);\n  }\n  if (Types.Events.isConsoleTimeStamp(event)) {\n    timestampEvents.push(event);\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  const asyncEvents = [...performanceMeasureEvents, ...consoleTimings];\n  syntheticEvents = Helpers.Trace.createMatchedSortedSyntheticEvents(asyncEvents);\n  syntheticEvents = syntheticEvents.sort((a, b) => userTimingComparator(a, b, [...syntheticEvents]));\n  timestampEvents = timestampEvents.sort((a, b) => userTimingComparator(a, b, [...timestampEvents]));\n}\n\nexport function data(): UserTimingsData {\n  return {\n    consoleTimings: syntheticEvents.filter(e => e.cat === 'blink.console') as Types.Events.SyntheticConsoleTimingPair[],\n    performanceMeasures: syntheticEvents.filter(e => e.cat === 'blink.user_timing') as\n        Types.Events.SyntheticUserTimingPair[],\n    performanceMarks: performanceMarkEvents,\n    timestampEvents,\n    measureTraceByTraceId,\n  };\n}\n"]}