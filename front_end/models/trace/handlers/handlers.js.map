{
  "version": 3,
  "sources": ["../../../../../../../front_end/models/trace/handlers/helpers.ts", "../../../../../../../front_end/models/trace/handlers/ModelHandlers.ts", "../../../../../../../front_end/models/trace/handlers/AnimationFramesHandler.ts", "../../../../../../../front_end/models/trace/handlers/AnimationHandler.ts", "../../../../../../../front_end/models/trace/handlers/AsyncJSCallsHandler.ts", "../../../../../../../front_end/models/trace/handlers/FlowsHandler.ts", "../../../../../../../front_end/models/trace/handlers/RendererHandler.ts", "../../../../../../../front_end/models/trace/handlers/AuctionWorkletsHandler.ts", "../../../../../../../front_end/models/trace/handlers/MetaHandler.ts", "../../../../../../../front_end/models/trace/handlers/NetworkRequestsHandler.ts", "../../../../../../../front_end/models/trace/handlers/SamplesHandler.ts", "../../../../../../../front_end/models/trace/handlers/DOMStatsHandler.ts", "../../../../../../../front_end/models/trace/handlers/ExtensionTraceDataHandler.ts", "../../../../../../../front_end/models/trace/handlers/UserTimingsHandler.ts", "../../../../../../../front_end/models/trace/handlers/FramesHandler.ts", "../../../../../../../front_end/models/trace/handlers/LayerTreeHandler.ts", "../../../../../../../front_end/models/trace/handlers/Threads.ts", "../../../../../../../front_end/models/trace/handlers/GPUHandler.ts", "../../../../../../../front_end/models/trace/handlers/ImagePaintingHandler.ts", "../../../../../../../front_end/models/trace/handlers/InitiatorsHandler.ts", "../../../../../../../front_end/models/trace/handlers/InvalidationsHandler.ts", "../../../../../../../front_end/models/trace/handlers/LargestImagePaintHandler.ts", "../../../../../../../front_end/models/trace/handlers/PageLoadMetricsHandler.ts", "../../../../../../../front_end/models/trace/handlers/LargestTextPaintHandler.ts", "../../../../../../../front_end/models/trace/handlers/LayoutShiftsHandler.ts", "../../../../../../../front_end/models/trace/handlers/ScreenshotsHandler.ts", "../../../../../../../front_end/models/trace/handlers/MemoryHandler.ts", "../../../../../../../front_end/models/trace/handlers/PageFramesHandler.ts", "../../../../../../../front_end/models/trace/handlers/ScriptsHandler.ts", "../../../../../../../front_end/models/trace/handlers/SelectorStatsHandler.ts", "../../../../../../../front_end/models/trace/handlers/UserInteractionsHandler.ts", "../../../../../../../front_end/models/trace/handlers/WarningsHandler.ts", "../../../../../../../front_end/models/trace/handlers/WorkersHandler.ts", "types.js"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Platform from '../../../core/platform/platform.js';\nimport * as ThirdPartyWeb from '../../../third_party/third-party-web/third-party-web.js';\nimport * as Types from '../types/types.js';\n\nimport type {TraceEventsForNetworkRequest} from './NetworkRequestsHandler.js';\nimport type {HandlerData} from './types.js';\n\nexport type Entity = typeof ThirdPartyWeb.ThirdPartyWeb.entities[number]&{\n  isUnrecognized?: boolean,\n};\n\nexport interface EntityMappings {\n  createdEntityCache: Map<string, Entity>;\n  entityByEvent: Map<Types.Events.Event, Entity>;\n  eventsByEntity: Map<Entity, Types.Events.Event[]>;\n  entityByUrlCache: Map<string, Entity>;\n}\n\nexport function getEntityForEvent(event: Types.Events.Event, entityMappings: EntityMappings): Entity|undefined {\n  const url = getNonResolvedURL(event);\n  if (!url) {\n    return;\n  }\n  return getEntityForUrl(url, entityMappings);\n}\n\nexport function getEntityForUrl(url: string, entityMappings: EntityMappings): Entity|undefined {\n  const cachedByUrl = entityMappings.entityByUrlCache.get(url);\n  if (cachedByUrl) {\n    return cachedByUrl;\n  }\n  const entity = ThirdPartyWeb.ThirdPartyWeb.getEntity(url) ?? makeUpEntity(entityMappings.createdEntityCache, url);\n  if (entity) {\n    entityMappings.entityByUrlCache.set(url, entity);\n  }\n  return entity;\n}\n\nexport function getNonResolvedURL(\n    entry: Types.Events.Event, handlerData?: HandlerData): Platform.DevToolsPath.UrlString|null {\n  if (Types.Events.isProfileCall(entry)) {\n    return entry.callFrame.url as Platform.DevToolsPath.UrlString;\n  }\n\n  if (Types.Events.isSyntheticNetworkRequest(entry)) {\n    return entry.args.data.url as Platform.DevToolsPath.UrlString;\n  }\n\n  if (Types.Events.isParseAuthorStyleSheetEvent(entry) && entry.args) {\n    return entry.args.data.stylesheetUrl as Platform.DevToolsPath.UrlString;\n  }\n\n  if (entry.args?.data?.stackTrace && entry.args.data.stackTrace.length > 0) {\n    return entry.args.data.stackTrace[0].url as Platform.DevToolsPath.UrlString;\n  }\n\n  // ParseHTML events store the URL under beginData, not data.\n  if (Types.Events.isParseHTML(entry)) {\n    return entry.args.beginData.url as Platform.DevToolsPath.UrlString;\n  }\n\n  if (handlerData) {\n    // DecodeImage events use the URL from the relevant PaintImage event.\n    if (Types.Events.isDecodeImage(entry)) {\n      const paintEvent = handlerData.ImagePainting.paintImageForEvent.get(entry);\n      return paintEvent ? getNonResolvedURL(paintEvent, handlerData) : null;\n    }\n\n    // DrawLazyPixelRef events use the URL from the relevant PaintImage event.\n    if (Types.Events.isDrawLazyPixelRef(entry) && entry.args?.LazyPixelRef) {\n      const paintEvent = handlerData.ImagePainting.paintImageByDrawLazyPixelRef.get(entry.args.LazyPixelRef);\n      return paintEvent ? getNonResolvedURL(paintEvent, handlerData) : null;\n    }\n  }\n\n  // For all other events, try to see if the URL is provided, else return null.\n  if (entry.args?.data?.url) {\n    return entry.args.data.url as Platform.DevToolsPath.UrlString;\n  }\n\n  // Many events don't have a url, but are associated with a request. Use the\n  // request's url.\n  const requestId = (entry.args?.data as {requestId?: string})?.requestId;\n  if (handlerData && requestId) {\n    const url = handlerData.NetworkRequests.byId.get(requestId)?.args.data.url;\n    if (url) {\n      return url as Platform.DevToolsPath.UrlString;\n    }\n  }\n\n  return null;\n}\n\nexport function makeUpEntity(entityCache: Map<string, Entity>, url: string): Entity|undefined {\n  if (url.startsWith('chrome-extension:')) {\n    return makeUpChromeExtensionEntity(entityCache, url);\n  }\n\n  // Make up an entity only for valid http/https URLs.\n  if (!url.startsWith('http')) {\n    return;\n  }\n\n  // NOTE: Lighthouse uses a tld database to determine the root domain, but here\n  // we are using third party web's database. Doesn't really work for the case of classifying\n  // domains 3pweb doesn't know about, so it will just give us a guess.\n  const rootDomain = ThirdPartyWeb.ThirdPartyWeb.getRootDomain(url);\n  if (!rootDomain) {\n    return;\n  }\n\n  if (entityCache.has(rootDomain)) {\n    return entityCache.get(rootDomain);\n  }\n\n  const unrecognizedEntity = {\n    name: rootDomain,\n    company: rootDomain,\n    category: '',\n    categories: [],\n    domains: [rootDomain],\n    averageExecutionTime: 0,\n    totalExecutionTime: 0,\n    totalOccurrences: 0,\n    isUnrecognized: true,\n  };\n  entityCache.set(rootDomain, unrecognizedEntity);\n  return unrecognizedEntity;\n}\n\nfunction getChromeExtensionOrigin(url: URL): string {\n  return url.protocol + '//' + url.host;\n}\n\nfunction makeUpChromeExtensionEntity(entityCache: Map<string, Entity>, url: string, extensionName?: string): Entity {\n  const parsedUrl = new URL(url);\n  const origin = getChromeExtensionOrigin(parsedUrl);\n  const host = new URL(origin).host;\n  const name = extensionName || host;\n\n  const cachedEntity = entityCache.get(origin);\n  if (cachedEntity) {\n    return cachedEntity;\n  }\n\n  const chromeExtensionEntity = {\n    name,\n    company: name,\n    category: 'Chrome Extension',\n    homepage: 'https://chromewebstore.google.com/detail/' + host,\n    categories: [],\n    domains: [origin],\n    averageExecutionTime: 0,\n    totalExecutionTime: 0,\n    totalOccurrences: 0,\n  };\n\n  entityCache.set(origin, chromeExtensionEntity);\n  return chromeExtensionEntity;\n}\n\nexport function addEventToEntityMapping(event: Types.Events.Event, entityMappings: EntityMappings): void {\n  // As we share the entityMappings between Network and Renderer... We can have ResourceSendRequest events passed in here\n  // that were already mapped in Network. So, to avoid mapping twice, we always check that we didn't yet.\n  if (entityMappings.entityByEvent.has(event)) {\n    return;\n  }\n\n  const entity = getEntityForEvent(event, entityMappings);\n  if (!entity) {\n    return;\n  }\n\n  const mappedEvents = entityMappings.eventsByEntity.get(entity);\n  if (mappedEvents) {\n    mappedEvents.push(event);\n  } else {\n    entityMappings.eventsByEntity.set(entity, [event]);\n  }\n  entityMappings.entityByEvent.set(event, entity);\n}\n\n/** A slight upgrade of addEventToEntityMapping to handle the sub-events of a network request. **/\nexport function addNetworkRequestToEntityMapping(\n    networkRequest: Types.Events.SyntheticNetworkRequest, entityMappings: EntityMappings,\n    requestTraceEvents: TraceEventsForNetworkRequest): void {\n  const entity = getEntityForEvent(networkRequest, entityMappings);\n  if (!entity) {\n    return;\n  }\n  // In addition to mapping the network request, we'll also assign this entity to its \"child\" instant events like receiveData, willSendRequest, finishLoading, etc,\n  const eventsToMap = [networkRequest, ...Object.values(requestTraceEvents).flat()];\n  const mappedEvents = entityMappings.eventsByEntity.get(entity);\n  if (mappedEvents) {\n    mappedEvents.push(...eventsToMap);\n  } else {\n    entityMappings.eventsByEntity.set(entity, eventsToMap);\n  }\n  for (const evt of eventsToMap) {\n    entityMappings.entityByEvent.set(evt, entity);\n  }\n}\n", "// Copyright 2022 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nexport * as AnimationFrames from './AnimationFramesHandler.js';\nexport * as Animations from './AnimationHandler.js';\nexport * as AsyncJSCalls from './AsyncJSCallsHandler.js';\nexport * as AuctionWorklets from './AuctionWorkletsHandler.js';\nexport * as DOMStats from './DOMStatsHandler.js';\nexport * as ExtensionTraceData from './ExtensionTraceDataHandler.js';\nexport * as Flows from './FlowsHandler.js';\nexport * as Frames from './FramesHandler.js';\nexport * as GPU from './GPUHandler.js';\nexport * as ImagePainting from './ImagePaintingHandler.js';\nexport * as Initiators from './InitiatorsHandler.js';\nexport * as Invalidations from './InvalidationsHandler.js';\nexport * as LargestImagePaint from './LargestImagePaintHandler.js';\nexport * as LargestTextPaint from './LargestTextPaintHandler.js';\nexport * as LayerTree from './LayerTreeHandler.js';\nexport * as LayoutShifts from './LayoutShiftsHandler.js';\nexport * as Memory from './MemoryHandler.js';\nexport * as Meta from './MetaHandler.js';\nexport * as NetworkRequests from './NetworkRequestsHandler.js';\nexport * as PageFrames from './PageFramesHandler.js';\nexport * as PageLoadMetrics from './PageLoadMetricsHandler.js';\nexport * as Renderer from './RendererHandler.js';\nexport * as Samples from './SamplesHandler.js';\nexport * as Screenshots from './ScreenshotsHandler.js';\nexport * as Scripts from './ScriptsHandler.js';\nexport * as SelectorStats from './SelectorStatsHandler.js';\nexport * as UserInteractions from './UserInteractionsHandler.js';\nexport * as UserTimings from './UserTimingsHandler.js';\nexport * as Warnings from './WarningsHandler.js';\nexport * as Workers from './WorkersHandler.js';\n", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport type {HandlerName} from './types.js';\n\nexport interface Data {\n  animationFrames: Types.Events.SyntheticAnimationFramePair[];\n  presentationForFrame: Map<Types.Events.SyntheticAnimationFramePair, Types.Events.AnimationFramePresentation>;\n}\n\nfunction threadKey(data: Types.Events.Event): string {\n  return `${data.pid}-${data.tid}`;\n}\n// Track all the start + end events. We key them by the PID+TID so we don't\n// accidentally pair across different threads.\nlet animationFrameStarts = new Map<string, Types.Events.AnimationFrameAsyncStart[]>();\nlet animationFrameEnds = new Map<string, Types.Events.AnimationFrameAsyncEnd[]>();\n// Store all the AnimationFrame::Presentation events. Key them by their ID for\n// easy look-up later on when we associate one to the AnimationFrame event.\nlet animationFramePresentations = new Map<string, Types.Events.AnimationFramePresentation>();\n\n// The final list of animation frames that we return.\nlet animationFrames: Types.Events.SyntheticAnimationFramePair[] = [];\n\nlet presentationForFrame = new Map<Types.Events.SyntheticAnimationFramePair, Types.Events.AnimationFramePresentation>();\n\nexport function reset(): void {\n  animationFrameStarts = new Map();\n  animationFrameEnds = new Map();\n  animationFrames = [];\n  presentationForFrame = new Map();\n  animationFramePresentations = new Map();\n  isEnabled = false;\n}\n\nlet isEnabled = false;\nexport function handleUserConfig(config: Types.Configuration.Configuration): void {\n  isEnabled = config.enableAnimationsFrameHandler;\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (!isEnabled) {\n    return;\n  }\n\n  if (Types.Events.isAnimationFrameAsyncStart(event)) {\n    const key = threadKey(event);\n    const existing = animationFrameStarts.get(key) ?? [];\n    existing.push(event);\n    animationFrameStarts.set(key, existing);\n  } else if (Types.Events.isAnimationFrameAsyncEnd(event)) {\n    const key = threadKey(event);\n    const existing = animationFrameEnds.get(key) ?? [];\n    existing.push(event);\n    animationFrameEnds.set(key, existing);\n  } else if (Types.Events.isAnimationFramePresentation(event) && event.args?.id) {\n    animationFramePresentations.set(event.args.id, event);\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  // AnimationFrames are represented with begin & end events on a stack; so we\n  // can pair them by walking through the list of start events and pairing with\n  // the same index in the list of end events, once both lists are sorted by\n  // timestamp.\n  // We walk through the set of begin/end events we gathered per pid+tid and\n  // pair those up.\n  // Unfortunately we cannot use the pairing helpers in Helpers.Trace because\n  // only the begin event has an ID; the end event does not. But because we\n  // know that AnimationFrames are sequential and do not overlap, we can pair\n  // up events easily.\n  for (const [key, startEvents] of animationFrameStarts.entries()) {\n    const endEvents = animationFrameEnds.get(key);\n    if (!endEvents) {\n      continue;\n    }\n\n    Helpers.Trace.sortTraceEventsInPlace(startEvents);\n    Helpers.Trace.sortTraceEventsInPlace(endEvents);\n\n    for (let i = 0; i < startEvents.length; i++) {\n      const endEvent = endEvents.at(i);\n      if (!endEvent) {\n        // Invalid data: break. We can't pair any other events up.\n        break;\n      }\n      const startEvent = startEvents[i];\n\n      const syntheticEvent = Helpers.SyntheticEvents.SyntheticEventsManager\n                                 .registerSyntheticEvent<Types.Events.SyntheticAnimationFramePair>({\n                                   rawSourceEvent: startEvent,\n                                   ...startEvent,\n                                   dur: Types.Timing.Micro(endEvent.ts - startEvent.ts),\n                                   args: {\n                                     data: {\n                                       beginEvent: startEvent,\n                                       endEvent,\n                                     },\n                                   },\n                                 });\n      animationFrames.push(syntheticEvent);\n\n      // AnimationFrame begin events + AnimationFrame::Presentation events share\n      // an args.id, so we can pair them up based on that.\n      const id = startEvent.args?.id;\n      if (id) {\n        const presentationEvent = animationFramePresentations.get(id);\n        if (presentationEvent) {\n          presentationForFrame.set(syntheticEvent, presentationEvent);\n        }\n      }\n    }\n  }\n}\n\nexport function data(): Data {\n  return {\n    animationFrames,\n    presentationForFrame,\n  };\n}\n\nexport function deps(): HandlerName[] {\n  return ['Meta'];\n}\n", "// Copyright 2022 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nlet animations: Types.Events.Animation[] = [];\nlet animationsSyntheticEvents: Types.Events.SyntheticAnimationPair[] = [];\n\nexport interface AnimationData {\n  animations: readonly Types.Events.SyntheticAnimationPair[];\n}\n\nexport function reset(): void {\n  animations = [];\n  animationsSyntheticEvents = [];\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isAnimation(event)) {\n    animations.push(event);\n    return;\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  const syntheticEvents = Helpers.Trace.createMatchedSortedSyntheticEvents(animations);\n  animationsSyntheticEvents.push(...syntheticEvents);\n}\n\nexport function data(): AnimationData {\n  return {\n    animations: animationsSyntheticEvents,\n  };\n}\n", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Platform from '../../../core/platform/platform.js';\nimport type * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {data as flowsHandlerData} from './FlowsHandler.js';\nimport {data as rendererHandlerData} from './RendererHandler.js';\n\nlet schedulerToRunEntryPoints = new Map<Types.Events.Event, Types.Events.Event[]>();\n\nlet taskScheduleForTaskRunEvent = new Map<Types.Events.DebuggerAsyncTaskRun, Types.Events.DebuggerAsyncTaskScheduled>();\nlet asyncCallToScheduler =\n    new Map<Types.Events.SyntheticProfileCall, {taskName: string, scheduler: Types.Events.Event}>();\n\nlet runEntryPointToScheduler = new Map<Types.Events.Event, {taskName: string, scheduler: Types.Events.Event}>();\n\nexport function reset(): void {\n  schedulerToRunEntryPoints = new Map();\n  asyncCallToScheduler = new Map();\n  taskScheduleForTaskRunEvent = new Map();\n  runEntryPointToScheduler = new Map();\n}\n\nexport function handleEvent(_: Types.Events.Event): void {\n}\n\nexport async function finalize(): Promise<void> {\n  const {flows} = flowsHandlerData();\n  const {entryToNode} = rendererHandlerData();\n  // Process async task flows\n  for (const flow of flows) {\n    let maybeAsyncTaskScheduled = flow.at(0);\n    if (!maybeAsyncTaskScheduled) {\n      continue;\n    }\n    if (Types.Events.isDebuggerAsyncTaskRun(maybeAsyncTaskScheduled)) {\n      // Sometimes a AsyncTaskRun event run can incorrectly appear as\n      // initiated by another AsyncTaskRun from Perfetto's flows\n      // perspective.\n      // For example, in this snippet:\n      //\n      // const myTask = console.createTask('hola'); // creates an AsyncTaskSchedule\n      // myTask.run(something); // creates an AsyncTaskRun\n      // myTask.run(somethingElse); // creates an AsyncTaskRun\n      //\n      // or also in this one\n      //\n      // setInterval(something); // creates multiple connected AsyncTaskRun.\n      //\n      // Because the flow id is created based on the task's memory address,\n      // the three events will end up belonging to the same flow (even if\n      // in the frontend we receive it as pairs), and elements in a flow\n      // are connected to their immediately consecutive neighbor.\n      //\n      // To ensure we use the right Schedule event, if the \"initiating\"\n      // portion of the flow is a Run event, we look for any corresponding\n      // Schedule event that we might have found before.\n      maybeAsyncTaskScheduled = taskScheduleForTaskRunEvent.get(maybeAsyncTaskScheduled);\n    }\n    if (!maybeAsyncTaskScheduled || !Types.Events.isDebuggerAsyncTaskScheduled(maybeAsyncTaskScheduled)) {\n      continue;\n    }\n    const taskName = maybeAsyncTaskScheduled.args.taskName;\n    const asyncTaskRun = flow.at(1);\n    if (!asyncTaskRun || !Types.Events.isDebuggerAsyncTaskRun(asyncTaskRun)) {\n      // Unexpected flow shape, ignore.\n      continue;\n    }\n    // Cache the Schedule event for this Run for future reference.\n    taskScheduleForTaskRunEvent.set(asyncTaskRun, maybeAsyncTaskScheduled);\n\n    // Get the JS call scheduled the task.\n    const asyncCaller = findNearestJSAncestor(maybeAsyncTaskScheduled, entryToNode);\n\n    // Get the trace entrypoint for the scheduled task (e.g. FunctionCall, etc.).\n    const asyncEntryPoint = findFirstJsInvocationForAsyncTaskRun(asyncTaskRun, entryToNode);\n\n    // Store the async relationship between traces to be shown with initiator arrows.\n    // Default to the AsyncTask events in case the JS entrypoints aren't found.\n    runEntryPointToScheduler.set(\n        asyncEntryPoint || asyncTaskRun, {taskName, scheduler: asyncCaller || maybeAsyncTaskScheduled});\n    if (!asyncCaller || !asyncEntryPoint) {\n      // Unexpected async call trace data shape, ignore.\n      continue;\n    }\n    // Set scheduler -> scheduled mapping.\n    // The scheduled being the JS entrypoint\n    const entryPoints = Platform.MapUtilities.getWithDefault(schedulerToRunEntryPoints, asyncCaller, () => []);\n    entryPoints.push(asyncEntryPoint);\n\n    // Set scheduled -> scheduler mapping.\n    // The scheduled being the JS calls (instead of the entrypoints as\n    // above, for usage ergonomics).\n    const scheduledProfileCalls = findFirstJSCallsForAsyncTaskRun(asyncTaskRun, entryToNode);\n    for (const call of scheduledProfileCalls) {\n      asyncCallToScheduler.set(call, {taskName, scheduler: asyncCaller});\n    }\n  }\n}\n/**\n * Given a DebuggerAsyncTaskScheduled event, returns its closest\n * ProfileCall or JS invocation ancestor, which represents the JS call\n * that scheduled the async task.\n */\nfunction findNearestJSAncestor(\n    asyncTaskScheduled: Types.Events.DebuggerAsyncTaskScheduled,\n    entryToNode: Map<Types.Events.Event, Helpers.TreeHelpers.TraceEntryNode>): Types.Events.Event|null {\n  let node = entryToNode.get(asyncTaskScheduled)?.parent;\n  while (node) {\n    if (Types.Events.isProfileCall(node.entry) || acceptJSInvocationsPredicate(node.entry)) {\n      return node.entry;\n    }\n    node = node.parent;\n  }\n  return null;\n}\n/**\n * Entrypoints to JS execution in the timeline. We ignore those starting\n * with 'v8' because they aren't shown in the timeline, and ultimately\n * this function's output results in \"initiated\" events, so ideally this\n * returns events that end up in the flame chart.\n */\nfunction acceptJSInvocationsPredicate(event: Types.Events.Event): event is Types.Events.Event {\n  const eventIsConsoleRunTask = Types.Events.isConsoleRunTask(event);\n  const eventIsV8EntryPoint = event.name.startsWith('v8') || event.name.startsWith('V8');\n  return Types.Events.isJSInvocationEvent(event) && (eventIsConsoleRunTask || !eventIsV8EntryPoint);\n}\n\n/**\n * Given a DebuggerAsyncTaskRun event, returns its closest JS entry\n * point descendant, which contains the task being scheduled.\n */\nfunction findFirstJsInvocationForAsyncTaskRun(\n    asyncTaskRun: Types.Events.DebuggerAsyncTaskRun,\n    entryToNode: Map<Types.Events.Event, Helpers.TreeHelpers.TraceEntryNode>): Types.Events.Event|undefined {\n  // Ignore descendants of other DebuggerAsyncTaskRuns since they\n  // are part of another async task and have to be handled separately\n  return findFirstDescendantsOfType(\n             asyncTaskRun, entryToNode, acceptJSInvocationsPredicate, Types.Events.isDebuggerAsyncTaskRun)\n      .at(0);\n}\n\n/**\n * Given an async task run event, returns the top level call frames\n * (profile calls) directly called by the async task. This implies that\n * any profile calls under another async task run event are ignored.\n * These profile calls represent the JS task being scheduled, AKA\n * the other part of the async stack.\n *\n * For example, here the profile calls \"js 1\", \"js 2\" and \"js 4\" would\n * be returned:\n *\n * |------------------Async Task Run------------------|\n * |--FunctionCall--|    |--FunctionCall--|\n * |-js 1-||-js 2-|        |-js 4-|\n * |-js 3-|\n *\n * But here, only \"js 1\" and \"js 2\" would be returned:\n *\n * |------------------Async Task Run------------------|\n * |--FunctionCall--|    |------------------------|\n * |-js 1-||-js 2-|       |---Async Task Run--|\n * |-js 3-|                |--FunctionCall--|\n *                          |-js 4-|\n */\nfunction findFirstJSCallsForAsyncTaskRun(\n    asyncTaskRun: Types.Events.DebuggerAsyncTaskRun,\n    entryToNode: Map<Types.Events.Event, Helpers.TreeHelpers.TraceEntryNode>): Types.Events.SyntheticProfileCall[] {\n  // Ignore descendants of other DebuggerAsyncTaskRuns since they\n  // are part of another async task and have to be handled separately\n  return findFirstDescendantsOfType(\n      asyncTaskRun, entryToNode, Types.Events.isProfileCall, Types.Events.isDebuggerAsyncTaskRun);\n}\n\n/**\n * Given a root event returns all the first descendants that meet a\n * predicate condition (predicateAccept) while ignoring subtrees whose\n * top event meets an ignore condition (predicateIgnore).\n */\nfunction findFirstDescendantsOfType<T extends Types.Events.Event>(\n    root: Types.Events.Event, entryToNode: Map<Types.Events.Event, Helpers.TreeHelpers.TraceEntryNode>,\n    predicateAccept: (event: Types.Events.Event) => event is T,\n    predicateIgnore: (event: Types.Events.Event) => boolean): T[] {\n  const node = entryToNode.get(root);\n  if (!node) {\n    return [];\n  }\n  const childrenGroups = [[...node.children]];\n  const firstDescendants = [];\n  for (let i = 0; i < childrenGroups.length; i++) {\n    const siblings = childrenGroups[i];\n    for (let j = 0; j < siblings.length; j++) {\n      const node = siblings[j];\n      if (predicateAccept(node.entry)) {\n        firstDescendants.push(node.entry);\n      } else if (!predicateIgnore(node.entry)) {\n        childrenGroups.push([...node.children]);\n      }\n    }\n  }\n  return firstDescendants;\n}\n\nexport function data(): {\n  // Given a profile call, returns the JS entrypoint it scheduled (if any).\n  // For example, given a setTimeout call, returns the JS entry point\n  // trace event for the timeout callback run event (usually a\n  // FunctionCall event).\n  schedulerToRunEntryPoints: typeof schedulerToRunEntryPoints,\n  // Given a profile call, returns the profile call that scheduled it.\n  // For example given a timeout callback run event, returns its\n  // setTimeout call event.\n  asyncCallToScheduler: typeof asyncCallToScheduler,\n  // Given a trace event, returns its corresponding async parent trace\n  // event caused by an async js call. This can be used as a fallback\n  // for cases where a corresponding JS call is not found at either\n  // end of the async task scheduling pair (e.g. due to sampling data\n  // incompleteness).\n  // In the StackTraceForEvent helper, as we move up the call tree,\n  // this is used to jump to an async parent stack from a\n  // non-profile call trace event in cases where a profile call wasn't\n  // found before. In theory we should make the jump from the scheduled\n  // profile  call using `asyncCallToScheduler`, but its possible that\n  // the the call information isn't available to us as a consequence of\n  // missing samples.\n  runEntryPointToScheduler: typeof runEntryPointToScheduler,\n} {\n  return {\n    schedulerToRunEntryPoints,\n    asyncCallToScheduler,\n    runEntryPointToScheduler,\n  };\n}\n\nexport function deps(): ['Renderer', 'Flows'] {\n  return ['Renderer', 'Flows'];\n}\n", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Types from '../types/types.js';\n\n// A flow is a logic connection between trace events. We display this\n// connection as arrows between trace events belonging to the same flow.\n\n// In the trace event format, flows are represented with pairing \"flow\n// phase\" events. Each flow phase event corresponds to one trace event\n// and indicates the role a trace event plays in a flow (start, step or\n// end). For each flow, one `start` and one `end` phase events are\n// included, while the amount of `step` phase events can be >= 0.\n\n// A flow phase event is assigned to a trace event when their cat, tid,\n// pid and ts are equal (see @flowPhaseBindingTokenForEvent ).\n\n// It's possible for a single event to belong to multiple flows. In that\n// case, it will have multiple corresponding flow phase events (one\n// per flow).\n\n// To parse flows, we first handle flow phase events, by creating unique\n// flows with the timestamps of each phase. Then, we place trace events\n// in the flows where their corresponding phase events were placed (if\n// there are any corresponding flow phase events at all).\nlet flowDataByGroupToken = new Map<string, number>();\n\ninterface EventFlowData {\n  flows: Set<number>;\n  bindingParsed: boolean;\n}\ntype FlowBindingTuple =\n    Map<Types.Timing.Micro, Map<Types.Events.ProcessID, Map<Types.Events.ThreadID, Map<string, EventFlowData>>>>;\n\n// Given a trace event's flow binding tuple (timestamp, process id,\n// thread id and category) we determine if there is any flow data bound\n// to it by using this map's content. It's built when processing flow\n// events in a trace.\n// An alternative to having a map of four levels is having single map\n// from a string token built from concatenating the binding data to the\n// corresponding flow data. However, this token would be calculated for\n// every event in a trace, resulting in a lot of memory overhead and\n// major GC triggering. So we are trading off readability for\n// performance.\nlet boundFlowData: FlowBindingTuple = new Map();\n\nlet flowsById = new Map<number, Map<Types.Timing.Micro, Types.Events.Event>>();\nlet flowEvents: Types.Events.FlowEvent[] = [];\nlet nonFlowEvents: Types.Events.Event[] = [];\nlet flows: Types.Events.Event[][] = [];\nconst ID_COMPONENT_SEPARATOR = '-$-';\nexport function reset(): void {\n  flows = [];\n  flowEvents = [];\n  nonFlowEvents = [];\n  flowDataByGroupToken = new Map();\n  boundFlowData = new Map();\n  flowsById = new Map();\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isFlowPhaseEvent(event)) {\n    flowEvents.push(event);\n    return;\n  }\n  nonFlowEvents.push(event);\n}\n\nfunction processNonFlowEvent(event: Types.Events.Event): void {\n  const flowDataForEvent = boundFlowData.get(event.ts)?.get(event.pid)?.get(event.tid)?.get(event.cat);\n  if (!flowDataForEvent) {\n    return;\n  }\n  const {flows, bindingParsed} = flowDataForEvent;\n  if (bindingParsed) {\n    // We only consider the first event for a given flow binding tuple.\n    return;\n  }\n  for (const flowId of flows) {\n    const flow = Platform.MapUtilities.getWithDefault(\n        flowsById, flowId, () => new Map<Types.Timing.Micro, Types.Events.Event>());\n    flow.set(event.ts, event);\n  }\n  flowDataForEvent.bindingParsed = true;\n}\n\n/**\n * Creates unique flows by tracking flow phase events. A new created\n * flow whenever a flow start phase event is detected.\n * Subsequent flow phase events with the same group token are added to\n * this flow until a flow end phase is detected.\n */\nfunction processFlowEvent(flowPhaseEvent: Types.Events.FlowEvent): void {\n  const flowGroup = flowGroupTokenForFlowPhaseEvent(flowPhaseEvent);\n  switch (flowPhaseEvent.ph) {\n    case (Types.Events.Phase.FLOW_START): {\n      const flowMetadata = {flowId: flowPhaseEvent.id, times: new Map([[flowPhaseEvent.ts, undefined]])};\n      flowDataByGroupToken.set(flowGroup, flowPhaseEvent.id);\n      addFlowIdToEventBinding(flowPhaseEvent, flowMetadata.flowId);\n      return;\n    }\n    case (Types.Events.Phase.FLOW_STEP): {\n      const flowId = flowDataByGroupToken.get(flowGroup);\n      if (flowId === undefined) {\n        // Found non-start flow event with no corresponding start flow,\n        // start event. Quietly ignore the problematic event.\n        return;\n      }\n      addFlowIdToEventBinding(flowPhaseEvent, flowId);\n      return;\n    }\n    case (Types.Events.Phase.FLOW_END): {\n      const flowId = flowDataByGroupToken.get(flowGroup);\n      if (flowId === undefined) {\n        // Found non-start flow event with no corresponding start flow,\n        // start event. Quietly ignore the problematic event.\n        return;\n      }\n      addFlowIdToEventBinding(flowPhaseEvent, flowId);\n      // We don't need this data anymore as the flow has been finished,\n      // so we can drop it.\n      flowDataByGroupToken.delete(flowGroup);\n    }\n  }\n}\n\ntype MapValueType<T extends Map<unknown, unknown>> = NonNullable<ReturnType<T['get']>>;\n/**\n * A single trace event can belong to multiple flows. This method\n * tracks which flows (flowId) an event belongs to given its flow\n * binding tuple (made of its ts, pid, tid and cat).\n */\nfunction addFlowIdToEventBinding(event: Types.Events.Event, flowId: number): void {\n  const flowsByPid = Platform.MapUtilities.getWithDefault<Types.Timing.Micro, MapValueType<typeof boundFlowData>>(\n      boundFlowData, event.ts, () => new Map());\n  const flowsByTid = Platform.MapUtilities.getWithDefault<Types.Events.ProcessID, MapValueType<typeof flowsByPid>>(\n      flowsByPid, event.pid, () => new Map());\n  const flowsByCat = Platform.MapUtilities.getWithDefault<Types.Events.ThreadID, MapValueType<typeof flowsByTid>>(\n      flowsByTid, event.tid, () => new Map());\n  const flowData =\n      Platform.MapUtilities.getWithDefault(flowsByCat, event.cat, () => ({flows: new Set(), bindingParsed: false}));\n  flowData.flows.add(flowId);\n}\n\n/**\n * Returns a token to group flow phase events (start, step and end)\n * belonging to the same flow. Flow phase events belonging to the same\n * flow share category, thread id, process id and name.\n *\n * Note that other phase events of other flows can share these\n * attributes too. For this reason, we group flow phase events in\n * cycles. A cycle starts on a flow start phase event and finishes on a\n * flow end phase event. For this reason, flow phase events need to be\n * handled in timestamp order.\n */\nfunction flowGroupTokenForFlowPhaseEvent(event: Types.Events.FlowEvent): string {\n  return `${event.cat}${ID_COMPONENT_SEPARATOR}${event.name}${ID_COMPONENT_SEPARATOR}${event.id}`;\n}\n\nexport async function finalize(): Promise<void> {\n  // Order is important: flow events need to be handled first.\n  flowEvents.forEach(processFlowEvent);\n  nonFlowEvents.forEach(processNonFlowEvent);\n  flows = [...flowsById.values()]\n              .map(flowMapping => [...flowMapping.values()])\n              .map(flow => flow.filter(event => event !== undefined))\n              .filter(flow => flow.length > 1);\n}\n\nexport function data(): {flows: Types.Events.Event[][]} {\n  return {\n    flows,\n  };\n}\n", "// Copyright 2022 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {data as auctionWorkletsData} from './AuctionWorkletsHandler.js';\nimport * as HandlerHelpers from './helpers.js';\nimport {data as metaHandlerData, type FrameProcessData} from './MetaHandler.js';\nimport {data as networkRequestHandlerData} from './NetworkRequestsHandler.js';\nimport {data as samplesHandlerData} from './SamplesHandler.js';\nimport type {HandlerName} from './types.js';\n\n/**\n * This handler builds the hierarchy of trace events and profile calls\n * on each thread on each process.\n *\n * Throughout the code, trace events and profile calls are referred to\n * as \"entries\", but note they are different types of data. Trace events\n * come directly from the backend and it's the type the engine commonly\n * refers to. Profile calls on the other hand are built in the frontend,\n * and, for compatibility purposes, typed as an extension to the trace\n * event type.\n */\n\nlet processes = new Map<Types.Events.ProcessID, RendererProcess>();\n\nlet entityMappings: HandlerHelpers.EntityMappings = {\n  eventsByEntity: new Map<HandlerHelpers.Entity, Types.Events.Event[]>(),\n  entityByEvent: new Map<Types.Events.Event, HandlerHelpers.Entity>(),\n  createdEntityCache: new Map<string, HandlerHelpers.Entity>(),\n  entityByUrlCache: new Map<string, HandlerHelpers.Entity>(),\n};\n\n// We track the compositor tile worker thread name events so that at the end we\n// can return these keyed by the process ID. These are used in the frontend to\n// show the user the rasterization thread(s) on the main frame as tracks.\nlet compositorTileWorkers = Array<{\n  pid: Types.Events.ProcessID,\n  tid: Types.Events.ThreadID,\n}>();\nlet entryToNode = new Map<Types.Events.Event, Helpers.TreeHelpers.TraceEntryNode>();\n\nlet completeEventStack: (Types.Events.SyntheticComplete)[] = [];\n\nlet config: Types.Configuration.Configuration = Types.Configuration.defaults();\n\nconst makeRendererProcess = (): RendererProcess => ({\n  url: null,\n  isOnMainFrame: false,\n  threads: new Map(),\n});\n\nconst makeRendererThread = (): RendererThread => ({\n  name: null,\n  entries: [],\n  profileCalls: [],\n  layoutEvents: [],\n  recalcStyleEvents: [],\n});\n\nconst getOrCreateRendererProcess =\n    (processes: Map<Types.Events.ProcessID, RendererProcess>, pid: Types.Events.ProcessID): RendererProcess => {\n      return Platform.MapUtilities.getWithDefault(processes, pid, makeRendererProcess);\n    };\n\nconst getOrCreateRendererThread = (process: RendererProcess, tid: Types.Events.ThreadID): RendererThread => {\n  return Platform.MapUtilities.getWithDefault(process.threads, tid, makeRendererThread);\n};\n\nexport function handleUserConfig(userConfig: Types.Configuration.Configuration): void {\n  config = userConfig;\n}\n\nexport function reset(): void {\n  processes = new Map();\n  entryToNode = new Map();\n  entityMappings = {\n    eventsByEntity: new Map<HandlerHelpers.Entity, Types.Events.Event[]>(),\n    entityByEvent: new Map<Types.Events.Event, HandlerHelpers.Entity>(),\n    createdEntityCache: new Map<string, HandlerHelpers.Entity>(),\n    entityByUrlCache: new Map<string, HandlerHelpers.Entity>(),\n  };\n  completeEventStack = [];\n  compositorTileWorkers = [];\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isThreadName(event) && event.args.name?.startsWith('CompositorTileWorker')) {\n    compositorTileWorkers.push({\n      pid: event.pid,\n      tid: event.tid,\n    });\n  }\n\n  if (Types.Events.isBegin(event) || Types.Events.isEnd(event)) {\n    const process = getOrCreateRendererProcess(processes, event.pid);\n    const thread = getOrCreateRendererThread(process, event.tid);\n    const completeEvent = makeCompleteEvent(event);\n    if (!completeEvent) {\n      return;\n    }\n    thread.entries.push(completeEvent);\n    return;\n  }\n\n  if (Types.Events.isInstant(event) || Types.Events.isComplete(event)) {\n    const process = getOrCreateRendererProcess(processes, event.pid);\n    const thread = getOrCreateRendererThread(process, event.tid);\n    thread.entries.push(event);\n  }\n\n  if (Types.Events.isLayout(event)) {\n    const process = getOrCreateRendererProcess(processes, event.pid);\n    const thread = getOrCreateRendererThread(process, event.tid);\n    thread.layoutEvents.push(event);\n  }\n\n  if (Types.Events.isRecalcStyle(event)) {\n    const process = getOrCreateRendererProcess(processes, event.pid);\n    const thread = getOrCreateRendererThread(process, event.tid);\n    thread.recalcStyleEvents.push(event);\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  const {mainFrameId, rendererProcessesByFrame, threadsInProcess} = metaHandlerData();\n  entityMappings = networkRequestHandlerData().entityMappings;\n\n  assignMeta(processes, mainFrameId, rendererProcessesByFrame, threadsInProcess);\n  sanitizeProcesses(processes);\n  buildHierarchy(processes);\n  sanitizeThreads(processes);\n}\n\nexport function data(): RendererHandlerData {\n  return {\n    processes,\n    compositorTileWorkers: gatherCompositorThreads(),\n    entryToNode,\n    entityMappings: {\n      entityByEvent: entityMappings.entityByEvent,\n      eventsByEntity: entityMappings.eventsByEntity,\n      createdEntityCache: entityMappings.createdEntityCache,\n      entityByUrlCache: entityMappings.entityByUrlCache,\n    },\n  };\n}\n\nfunction gatherCompositorThreads(): Map<Types.Events.ProcessID, Types.Events.ThreadID[]> {\n  const threadsByProcess = new Map<Types.Events.ProcessID, Types.Events.ThreadID[]>();\n  for (const worker of compositorTileWorkers) {\n    const byProcess = threadsByProcess.get(worker.pid) || [];\n    byProcess.push(worker.tid);\n    threadsByProcess.set(worker.pid, byProcess);\n  }\n  return threadsByProcess;\n}\n\n/**\n * Steps through all the renderer processes we've located so far in the meta\n * handler, obtaining their URL, checking whether they are the main frame, and\n * collecting each one of their threads' name. This meta handler's data is\n * assigned to the renderer handler's data.\n */\nexport function assignMeta(\n    processes: Map<Types.Events.ProcessID, RendererProcess>, mainFrameId: string,\n    rendererProcessesByFrame: FrameProcessData,\n    threadsInProcess: Map<Types.Events.ProcessID, Map<Types.Events.ThreadID, Types.Events.ThreadName>>): void {\n  assignOrigin(processes, rendererProcessesByFrame);\n  assignIsMainFrame(processes, mainFrameId, rendererProcessesByFrame);\n  assignThreadName(processes, threadsInProcess);\n}\n\n/**\n * Assigns origins to all threads in all processes.\n * @see assignMeta\n */\nexport function assignOrigin(\n    processes: Map<Types.Events.ProcessID, RendererProcess>, rendererProcessesByFrame: FrameProcessData): void {\n  for (const renderProcessesByPid of rendererProcessesByFrame.values()) {\n    for (const [pid, processWindows] of renderProcessesByPid) {\n      for (const processInfo of processWindows.flat()) {\n        const process = getOrCreateRendererProcess(processes, pid);\n        // Sometimes a single process is responsible with rendering multiple\n        // frames at the same time. For example, see https://crbug.com/1334563.\n        // When this happens, we'd still like to assign a single url per process\n        // so: 1) use the first frame rendered by this process as the url source\n        // and 2) if the last url is \"about:blank\", use the next frame's url,\n        // data from about:blank is irrelevant.\n        if (process.url === null || process.url === 'about:blank') {\n          // If we are here, it's because we care about this process and the URL. But before we store\n          // it, we check if it is a valid URL by trying to create a URL object. If it isn't, we won't\n          // set it, and this process will be filtered out later.\n          try {\n            new URL(processInfo.frame.url);\n            process.url = processInfo.frame.url;\n          } catch {\n            process.url = null;\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Assigns whether or not a thread is the main frame to all threads in all processes.\n * @see assignMeta\n */\nexport function assignIsMainFrame(\n    processes: Map<Types.Events.ProcessID, RendererProcess>, mainFrameId: string,\n    rendererProcessesByFrame: FrameProcessData): void {\n  for (const [frameId, renderProcessesByPid] of rendererProcessesByFrame) {\n    for (const [pid] of renderProcessesByPid) {\n      const process = getOrCreateRendererProcess(processes, pid);\n      // We have this go in one direction; once a renderer has been flagged as\n      // being on the main frame, we don't unset it to false if were to show up\n      // in a subframe. Equally, if we already saw this renderer in a subframe,\n      // but it becomes the main frame, the flag would get updated.\n      if (frameId === mainFrameId) {\n        process.isOnMainFrame = true;\n      }\n    }\n  }\n}\n\n/**\n * Assigns the thread name to all threads in all processes.\n * @see assignMeta\n */\nexport function assignThreadName(\n    processes: Map<Types.Events.ProcessID, RendererProcess>,\n    threadsInProcess: Map<Types.Events.ProcessID, Map<Types.Events.ThreadID, Types.Events.ThreadName>>): void {\n  for (const [pid, process] of processes) {\n    for (const [tid, threadInfo] of threadsInProcess.get(pid) ?? []) {\n      const thread = getOrCreateRendererThread(process, tid);\n      thread.name = threadInfo?.args.name ?? `${tid}`;\n    }\n  }\n}\n\n/**\n * Removes unneeded trace data opportunistically stored while handling events.\n * This currently does the following:\n *  - Deletes processes with an unknown origin.\n */\nexport function sanitizeProcesses(processes: Map<Types.Events.ProcessID, RendererProcess>): void {\n  const auctionWorklets = auctionWorkletsData().worklets;\n  const metaData = metaHandlerData();\n  if (metaData.traceIsGeneric) {\n    return;\n  }\n  for (const [pid, process] of processes) {\n    // If the process had no url, or if it had a malformed url that could not be\n    // parsed for some reason, or if it's an \"about:\" origin, delete it.\n    // This is done because we don't really care about processes for which we\n    // can't provide actionable insights to the user (e.g. about:blank pages).\n    //\n    // There is one exception; AuctionWorklet processes get parsed in a\n    // separate handler, so at this point we check to see if the process has\n    // been found by the AuctionWorkletsHandler, and if so we update the URL.\n    // This ensures that we keep this process around and do not drop it due to\n    // the lack of a URL.\n    if (process.url === null) {\n      const maybeWorklet = auctionWorklets.get(pid);\n      if (maybeWorklet) {\n        process.url = maybeWorklet.host;\n      } else {\n        processes.delete(pid);\n      }\n      continue;\n    }\n  }\n}\n\n/**\n * Removes unneeded trace data opportunistically stored while handling events.\n * This currently does the following:\n *  - Deletes threads with no roots.\n */\nexport function sanitizeThreads(processes: Map<Types.Events.ProcessID, RendererProcess>): void {\n  for (const [, process] of processes) {\n    for (const [tid, thread] of process.threads) {\n      // If the thread has no roots, delete it. Otherwise, there's going to\n      // be space taken, even though nothing is rendered in the track manager.\n      if (!thread.tree?.roots.size) {\n        process.threads.delete(tid);\n      }\n    }\n  }\n}\n\n/**\n * Creates a hierarchical structure from the trace events. Each thread in each\n * process will contribute to their own individual hierarchy.\n *\n * The trace data comes in as a contiguous array of events, against which we\n * make a couple of assumptions:\n *\n *  1. Events are temporally-ordered in terms of start time (though they're\n *     not necessarily ordered as such in the data stream).\n *  2. If event B's start and end times are within event A's time boundaries\n *     we assume that A is the parent of B.\n *\n * Therefore we expect to reformulate something like:\n *\n * [ Task A ][ Task B ][ Task C ][ Task D ][ Task E ]\n *\n * Into something hierarchically-arranged like below:\n *\n * |------------- Task A -------------||-- Task E --|\n *  |-- Task B --||-- Task D --|\n *   |- Task C -|\n */\nexport function buildHierarchy(\n    processes: Map<Types.Events.ProcessID, RendererProcess>,\n    options?: {filter: {has: (name: Types.Events.Name) => boolean}}): void {\n  const samplesData = samplesHandlerData();\n  for (const [pid, process] of processes) {\n    for (const [tid, thread] of process.threads) {\n      if (!thread.entries.length) {\n        thread.tree = Helpers.TreeHelpers.makeEmptyTraceEntryTree();\n        continue;\n      }\n      // Step 1. Massage the data.\n      Helpers.Trace.sortTraceEventsInPlace(thread.entries);\n      // Step 2. Inject profile calls from samples\n      const samplesDataForThread = samplesData.profilesInProcess.get(pid)?.get(tid);\n      if (samplesDataForThread) {\n        const cpuProfile = samplesDataForThread.parsedProfile;\n        const samplesIntegrator = cpuProfile &&\n            new Helpers.SamplesIntegrator.SamplesIntegrator(\n                cpuProfile, samplesDataForThread.profileId, pid, tid, config);\n        const profileCalls = samplesIntegrator?.buildProfileCalls(thread.entries);\n        if (samplesIntegrator && profileCalls) {\n          thread.entries = Helpers.Trace.mergeEventsInOrder(thread.entries, profileCalls);\n          thread.profileCalls = profileCalls;\n\n          // We'll also inject the instant JSSample events (in debug mode only)\n          const jsSamples = samplesIntegrator.jsSampleEvents;\n          if (jsSamples.length) {\n            thread.entries = Helpers.Trace.mergeEventsInOrder(thread.entries, jsSamples);\n          }\n        }\n      }\n      // Step 3. Build the tree.\n      const treeData = Helpers.TreeHelpers.treify(thread.entries, options);\n      thread.tree = treeData.tree;\n      // Update the entryToNode map with the entries from this thread\n      for (const [entry, node] of treeData.entryToNode) {\n        entryToNode.set(entry, node);\n        // Entity mapping is unrelated to the tree, but calling here as we need to call on every node anyway.\n        HandlerHelpers.addEventToEntityMapping(entry, entityMappings);\n      }\n    }\n  }\n}\n\nexport function makeCompleteEvent(event: Types.Events.Begin|Types.Events.End): Types.Events.SyntheticComplete|null {\n  if (Types.Events.isEnd(event)) {\n    // Quietly ignore unbalanced close events, they're legit (we could\n    // have missed start one).\n    const beginEvent = completeEventStack.pop();\n    if (!beginEvent) {\n      return null;\n    }\n    if (beginEvent.name !== event.name || beginEvent.cat !== event.cat) {\n      console.error(\n          'Begin/End events mismatch at ' + beginEvent.ts + ' (' + beginEvent.name + ') vs. ' + event.ts + ' (' +\n          event.name + ')');\n      return null;\n    }\n    // Update the begin event's duration using the timestamp of the end\n    // event.\n    beginEvent.dur = Types.Timing.Micro(event.ts - beginEvent.ts);\n    return null;\n  }\n\n  // Create a synthetic event using the begin event, when we find the\n  // matching end event later we will update its duration.\n  const syntheticComplete: Types.Events.SyntheticComplete = {\n    ...event,\n    ph: Types.Events.Phase.COMPLETE,\n    dur: Types.Timing.Micro(0),\n  };\n\n  completeEventStack.push(syntheticComplete);\n  return syntheticComplete;\n}\n\nexport function deps(): HandlerName[] {\n  return ['Meta', 'Samples', 'AuctionWorklets', 'NetworkRequests'];\n}\n\nexport interface RendererHandlerData {\n  processes: Map<Types.Events.ProcessID, RendererProcess>;\n  /**\n   * A map of all compositor workers (which we show in the UI as Rasterizers)\n   * by the process ID.\n   */\n  compositorTileWorkers: Map<Types.Events.ProcessID, Types.Events.ThreadID[]>;\n  entryToNode: Map<Types.Events.Event, Helpers.TreeHelpers.TraceEntryNode>;\n  entityMappings: HandlerHelpers.EntityMappings;\n}\n\nexport interface RendererProcess {\n  // In an ideal world this would be modelled as a URL, but URLs cannot be sent\n  // between the main thread and workers, so we have to store it as a string.\n  url: string|null;\n  isOnMainFrame: boolean;\n  threads: Map<Types.Events.ThreadID, RendererThread>;\n}\n\nexport interface RendererThread {\n  name: string|null;\n  /**\n   * Contains trace events and synthetic profile calls made from\n   * samples.\n   */\n  entries: Types.Events.Event[];\n  profileCalls: Types.Events.SyntheticProfileCall[];\n  layoutEvents: Types.Events.Layout[];\n  recalcStyleEvents: Types.Events.RecalcStyle[];\n  tree?: Helpers.TreeHelpers.TraceEntryTree;\n}\n", "// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\n/**\n * There are two metadata events that we care about.\n * => AuctionWorkletRunningInProcess tells us which process the Auction Worklet\n *    has taken to run in.\n * => AuctionWorkletDoneWithProcess tells us when the worklet is done with that\n *    process. This is less useful - but in the future we might want to surface\n *    this information so we still parse and return the event.\n *\n * It is important to note that the top level PID on these events is NOT the\n * PID that the worklet is running on; instead we have to look at its\n * args.data.pid property, which is the PID of the process that it is running\n * on.\n *\n * For any given RunningInProcess event, we would typically expect to see a\n * DoneWithProcess event, however this is not guaranteed, especially as users\n * can record any chunk of time in DevTools.\n *\n * Similarly, it is also possible to see a DoneWithProcess event without a\n * RunningInProcess event, if the user started recording after the auction\n * worklets started. Therefore we are happy to create\n * SyntheticAuctionWorklets as long as we see just one of these events.\n *\n * If we do get two events and need to pair them, we can use the\n * args.data.target property, which is a string ID shared by both\n * events.\n */\nlet runningInProcessEvents = new Map<Types.Events.ProcessID, Types.Events.AuctionWorkletRunningInProcess>();\nlet doneWithProcessEvents = new Map<Types.Events.ProcessID, Types.Events.AuctionWorkletDoneWithProcess>();\n\n// Keyed by the PID defined in  `args.data.pid` on AuctionWorklet trace events..\nlet createdSyntheticEvents = new Map<Types.Events.ProcessID, Types.Events.SyntheticAuctionWorklet>();\n\n// Each AuctonWorklet takes over a process and has 2 threads (that we care\n// about and want to show as tracks):\n// 1. A CrUtilityMain thread which is known as the \"control process\".\n// 2. A AuctionV8HelperThread which is the actual auction worklet and will be\n//    either a \"Seller\" or a \"Bidder\"\n// To detect these we look for the metadata thread_name events. We key these by\n// PID so that we can easily look them up later without having to loop through.\nlet utilityThreads = new Map<Types.Events.ProcessID, Types.Events.ThreadName>();\nlet v8HelperThreads = new Map<Types.Events.ProcessID, Types.Events.ThreadName>();\n\nexport function reset(): void {\n  runningInProcessEvents = new Map();\n  doneWithProcessEvents = new Map();\n  createdSyntheticEvents = new Map();\n  utilityThreads = new Map();\n  v8HelperThreads = new Map();\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isAuctionWorkletRunningInProcess(event)) {\n    runningInProcessEvents.set(event.args.data.pid, event);\n    return;\n  }\n\n  if (Types.Events.isAuctionWorkletDoneWithProcess(event)) {\n    doneWithProcessEvents.set(event.args.data.pid, event);\n    return;\n  }\n\n  if (Types.Events.isThreadName(event)) {\n    if (event.args.name === 'auction_worklet.CrUtilityMain') {\n      utilityThreads.set(event.pid, event);\n      return;\n    }\n    if (event.args.name === 'AuctionV8HelperThread') {\n      v8HelperThreads.set(event.pid, event);\n    }\n  }\n}\n\nfunction workletType(input: string): Types.Events.AuctionWorkletType {\n  switch (input) {\n    case 'seller':\n      return Types.Events.AuctionWorkletType.SELLER;\n    case 'bidder':\n      return Types.Events.AuctionWorkletType.BIDDER;\n    default:\n      return Types.Events.AuctionWorkletType.UNKNOWN;\n  }\n}\n\n/**\n * We cannot make the full event without knowing the type of event, but we can\n * create everything other than the `args` field, as those are identical\n * regardless of the type of event.\n */\nfunction makeSyntheticEventBase(\n    event: Types.Events.AuctionWorkletDoneWithProcess|\n    Types.Events.AuctionWorkletRunningInProcess): Omit<Types.Events.SyntheticAuctionWorklet, 'args'> {\n  return Helpers.SyntheticEvents.SyntheticEventsManager\n      .registerSyntheticEvent<Omit<Types.Events.SyntheticAuctionWorklet, 'args'>>({\n        rawSourceEvent: event,\n        name: 'SyntheticAuctionWorklet',\n        s: Types.Events.Scope.THREAD,\n        cat: event.cat,\n        tid: event.tid,\n        ts: event.ts,\n        ph: Types.Events.Phase.INSTANT,\n        pid: event.args.data.pid,\n        host: event.args.data.host,\n        target: event.args.data.target,\n        type: workletType(event.args.data.type),\n      });\n}\n\nexport async function finalize(): Promise<void> {\n  // Loop through the utility threads we found to create the worklet events. We\n  // expect each worklet to have a utility thread, so we can use them as the\n  // root of our list of worklets.\n  for (const [pid, utilityThreadNameEvent] of utilityThreads) {\n    const v8HelperEvent = v8HelperThreads.get(pid);\n    if (!v8HelperEvent) {\n      // Bad trace data - AuctionWorklets are expected to always have both threads.\n      continue;\n    }\n\n    const runningEvent = runningInProcessEvents.get(pid);\n    const doneWithEvent = doneWithProcessEvents.get(pid);\n\n    // We can create a worklet from either the runningEvent or doneWithEvent -\n    // we do not need both. We cannot express that to TypeScript with an early\n    // return here, so instead we set the event initially to null, and then\n    // create it from either the running event or the doneWith event. If it is\n    // still null after this, that means neither event was found, and we drop\n    // the worklet as we do not have enough information to create the synthetic\n    // event.\n\n    let syntheticEvent: Types.Events.SyntheticAuctionWorklet|null = null;\n\n    if (runningEvent) {\n      syntheticEvent = {\n        ...makeSyntheticEventBase(runningEvent),\n        args: {\n          data: {\n            runningInProcessEvent: runningEvent,\n            utilityThread: utilityThreadNameEvent,\n            v8HelperThread: v8HelperEvent,\n          },\n        },\n      };\n      if (doneWithEvent) {\n        syntheticEvent.args.data.doneWithProcessEvent = doneWithEvent;\n      }\n    } else if (doneWithEvent) {\n      syntheticEvent = {\n        ...makeSyntheticEventBase(doneWithEvent),\n        args: {\n          data: {\n            doneWithProcessEvent: doneWithEvent,\n            utilityThread: utilityThreadNameEvent,\n            v8HelperThread: v8HelperEvent,\n          },\n        },\n      };\n      if (runningEvent) {\n        syntheticEvent.args.data.runningInProcessEvent = runningEvent;\n      }\n    }\n    if (syntheticEvent === null) {\n      continue;\n    }\n    createdSyntheticEvents.set(pid, syntheticEvent);\n  }\n}\n\nexport interface AuctionWorkletsData {\n  worklets: Map<Types.Events.ProcessID, Types.Events.SyntheticAuctionWorklet>;\n}\n\nexport function data(): AuctionWorkletsData {\n  return {\n    worklets: createdSyntheticEvents,\n  };\n}\n", "// Copyright 2022 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport type {FinalizeOptions} from './types.js';\n\nlet config: {showAllEvents: boolean};\n\n// We track the renderer processes we see in each frame on the way through the trace.\nlet rendererProcessesByFrameId: FrameProcessData = new Map();\n\n// We will often want to key data by Frame IDs, and commonly we'll care most\n// about the main frame's ID, so we store and expose that.\nlet mainFrameId = '';\nlet mainFrameURL = '';\n\nlet framesByProcessId = new Map<Types.Events.ProcessID, Map<string, Types.Events.TraceFrame>>();\n\n// We will often want to key data by the browser process, GPU process and top\n// level renderer IDs, so keep a track on those.\nlet browserProcessId: Types.Events.ProcessID = Types.Events.ProcessID(-1);\nlet browserThreadId: Types.Events.ThreadID = Types.Events.ThreadID(-1);\nlet gpuProcessId: Types.Events.ProcessID = Types.Events.ProcessID(-1);\nlet gpuThreadId: Types.Events.ThreadID = Types.Events.ThreadID(-1);\nlet viewportRect: {x: number, y: number, width: number, height: number}|null = null;\nlet devicePixelRatio: number|null = null;\n\nlet processNames = new Map<Types.Events.ProcessID, Types.Events.ProcessName>();\n\nlet topLevelRendererIds = new Set<Types.Events.ProcessID>();\n\nfunction makeNewTraceBounds(): Types.Timing.TraceWindowMicro {\n  return {\n    min: Types.Timing.Micro(Number.POSITIVE_INFINITY),\n    max: Types.Timing.Micro(Number.NEGATIVE_INFINITY),\n    range: Types.Timing.Micro(Number.POSITIVE_INFINITY),\n  };\n}\nlet traceBounds: Types.Timing.TraceWindowMicro = makeNewTraceBounds();\n\n/**\n * These represent the user navigating. Values such as First Contentful Paint,\n * etc, are relative to the navigation.\n *\n *  We store navigation events both by the frame and navigation ID. This means\n * when we need to look them up, we can use whichever ID we have.\n *\n * Note that these Maps will have the same values in them; these are just keyed\n * differently to make look-ups easier.\n *\n * We also additionally maintain an array of only navigations that occurred on\n * the main frame. In many places in the UI we only care about highlighting\n * main frame navigations, so calculating this list here is better than\n * filtering either of the below maps over and over again at the UI layer.\n */\nlet navigationsByFrameId = new Map<string, Types.Events.NavigationStart[]>();\nlet navigationsByNavigationId = new Map<string, Types.Events.NavigationStart>();\nlet finalDisplayUrlByNavigationId = new Map<string, string>();\nlet mainFrameNavigations: Types.Events.NavigationStart[] = [];\n\n// Represents all the threads in the trace, organized by process. This is mostly for internal\n// bookkeeping so that during the finalize pass we can obtain the main and browser thread IDs.\nlet threadsInProcess = new Map<Types.Events.ProcessID, Map<Types.Events.ThreadID, Types.Events.ThreadName>>();\n\nlet traceStartedTimeFromTracingStartedEvent = Types.Timing.Micro(-1);\nconst eventPhasesOfInterestForTraceBounds = new Set([\n  Types.Events.Phase.BEGIN,\n  Types.Events.Phase.END,\n  Types.Events.Phase.COMPLETE,\n  Types.Events.Phase.INSTANT,\n]);\n\n// Tracks if the trace is a generic trace, which here means that it did not come from athe DevTools Performance Panel recording.\n// We assume a trace is generic, and mark it as not generic if we see any of:\n// - TracingStartedInPage\n// - TracingStartedInBrowser\n// - TracingSessionIdForWorker\n// - CpuProfile\n// These are all events which indicate this is a Chrome browser trace.\nlet traceIsGeneric = true;\nconst CHROME_WEB_TRACE_EVENTS = new Set([\n  Types.Events.Name.TRACING_STARTED_IN_PAGE,\n  Types.Events.Name.TRACING_SESSION_ID_FOR_WORKER,\n  Types.Events.Name.TRACING_STARTED_IN_BROWSER,\n  Types.Events.Name.CPU_PROFILE,\n]);\n\nexport function reset(): void {\n  navigationsByFrameId = new Map();\n  navigationsByNavigationId = new Map();\n  finalDisplayUrlByNavigationId = new Map();\n  processNames = new Map();\n  mainFrameNavigations = [];\n\n  browserProcessId = Types.Events.ProcessID(-1);\n  browserThreadId = Types.Events.ThreadID(-1);\n  gpuProcessId = Types.Events.ProcessID(-1);\n  gpuThreadId = Types.Events.ThreadID(-1);\n  viewportRect = null;\n  topLevelRendererIds = new Set();\n  threadsInProcess = new Map();\n  rendererProcessesByFrameId = new Map();\n  framesByProcessId = new Map();\n\n  traceBounds = makeNewTraceBounds();\n  traceStartedTimeFromTracingStartedEvent = Types.Timing.Micro(-1);\n\n  traceIsGeneric = true;\n}\n\nfunction updateRendererProcessByFrame(event: Types.Events.Event, frame: Types.Events.TraceFrame): void {\n  const framesInProcessById = Platform.MapUtilities.getWithDefault(framesByProcessId, frame.processId, () => new Map());\n  framesInProcessById.set(frame.frame, frame);\n\n  const rendererProcessInFrame = Platform.MapUtilities.getWithDefault(\n      rendererProcessesByFrameId, frame.frame,\n      () => new Map<\n          Types.Events.ProcessID, Array<{frame: Types.Events.TraceFrame, window: Types.Timing.TraceWindowMicro}>>());\n  const rendererProcessInfo = Platform.MapUtilities.getWithDefault(rendererProcessInFrame, frame.processId, () => {\n    return [];\n  });\n  const lastProcessData = rendererProcessInfo.at(-1);\n\n  // Only store a new entry if the URL changed, otherwise it's just\n  // redundant information.\n  if (lastProcessData && lastProcessData.frame.url === frame.url) {\n    return;\n  }\n  // For now we store the time of the event as the min. In the finalize we step\n  // through each of these windows and update their max and range values.\n  rendererProcessInfo.push({\n    frame,\n    window: {\n      min: event.ts,\n      max: Types.Timing.Micro(0),\n      range: Types.Timing.Micro(0),\n    },\n  });\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (traceIsGeneric && CHROME_WEB_TRACE_EVENTS.has(event.name as Types.Events.Name)) {\n    traceIsGeneric = false;\n  }\n\n  if (Types.Events.isProcessName(event)) {\n    processNames.set(event.pid, event);\n  }\n\n  // If there is a timestamp (which meta events do not have), and the event does\n  // not end with ::UMA then it, and the event is in the set of valid phases,\n  // then it should be included for the purposes of calculating the trace bounds.\n  // The UMA events in particular seem to be reported on page unloading, which\n  // often extends the bounds of the trace unhelpfully.\n  if (event.ts !== 0 && !event.name.endsWith('::UMA') && eventPhasesOfInterestForTraceBounds.has(event.ph)) {\n    traceBounds.min = Types.Timing.Micro(Math.min(event.ts, traceBounds.min));\n    const eventDuration = event.dur ?? Types.Timing.Micro(0);\n    traceBounds.max = Types.Timing.Micro(Math.max(event.ts + eventDuration, traceBounds.max));\n  }\n\n  if (Types.Events.isProcessName(event) && (event.args.name === 'Browser' || event.args.name === 'HeadlessBrowser')) {\n    browserProcessId = event.pid;\n    return;\n  }\n\n  if (Types.Events.isProcessName(event) && (event.args.name === 'Gpu' || event.args.name === 'GPU Process')) {\n    gpuProcessId = event.pid;\n    return;\n  }\n\n  if (Types.Events.isThreadName(event) && event.args.name === 'CrGpuMain') {\n    gpuThreadId = event.tid;\n    return;\n  }\n\n  if (Types.Events.isThreadName(event) && event.args.name === 'CrBrowserMain') {\n    browserThreadId = event.tid;\n  }\n\n  if (Types.Events.isMainFrameViewport(event) && viewportRect === null) {\n    const rectAsArray = event.args.data.viewport_rect;\n    const viewportX = rectAsArray[0];\n    const viewportY = rectAsArray[1];\n    const viewportWidth = rectAsArray[2];\n    const viewportHeight = rectAsArray[5];\n    viewportRect = {x: viewportX, y: viewportY, width: viewportWidth, height: viewportHeight};\n    devicePixelRatio = event.args.data.dpr;\n  }\n\n  // The TracingStartedInBrowser event includes the data on which frames are\n  // in scope at the start of the trace. We use this to identify the frame with\n  // no parent, i.e. the top level frame.\n  if (Types.Events.isTracingStartedInBrowser(event)) {\n    traceStartedTimeFromTracingStartedEvent = event.ts;\n\n    if (!event.args.data) {\n      throw new Error('No frames found in trace data');\n    }\n\n    for (const frame of (event.args.data.frames ?? [])) {\n      updateRendererProcessByFrame(event, frame);\n\n      if (!frame.parent) {\n        topLevelRendererIds.add(frame.processId);\n      }\n      /**\n       * The code here uses a few different methods to try to determine the main frame.\n       * The ideal is that the frames have two flags present:\n       *\n       * 1. isOutermostMainFrame (added in April 2024 - crrev.com/c/5424783)\n       * 2. isInPrimaryMainFrame (added in June 2024 - crrev.com/c/5595033)\n       *\n       * The frame where both of these are set to `true` is the main frame. The\n       * reason we need both of these flags to have 100% confidence is because\n       * with the introduction of MPArch and pre-rendering, we can have other\n       * frames that are the outermost frame, but are not the primary process.\n       * Relying on isOutermostMainFrame in isolation caused the engine to\n       * incorrectly identify the wrong frame as main (see crbug.com/343873756).\n       *\n       * See https://source.chromium.org/chromium/chromium/src/+/main:docs/frame_trees.md\n       * for a bit more context on FrameTrees in Chromium.\n       *\n       * To avoid breaking entirely for traces pre-June 2024 that don't have\n       * both of these flags, we will fallback to less accurate methods:\n       *\n       * 1. If we have isOutermostMainFrame, we will use that\n       *    (and accept we might get it wrong)\n       * 2. If we don't have isOutermostMainFrame, we fallback to finding a\n       *    frame that has a URL, but doesn't have a parent. This is a crude\n       *    guess at the main frame...but better than nothing and is historically\n       *    how DevTools identified the main frame.\n       */\n\n      const traceHasPrimaryMainFrameFlag = 'isInPrimaryMainFrame' in frame;\n      const traceHasOutermostMainFrameFlag = 'isOutermostMainFrame' in frame;\n\n      if (traceHasPrimaryMainFrameFlag && traceHasOutermostMainFrameFlag) {\n        // Ideal situation: identify the main frame as the one that has both these flags set to true.\n        if (frame.isInPrimaryMainFrame && frame.isOutermostMainFrame) {\n          mainFrameId = frame.frame;\n          mainFrameURL = frame.url;\n        }\n      } else if (traceHasOutermostMainFrameFlag) {\n        // Less ideal: \"guess\" at the main thread by using this flag.\n        if (frame.isOutermostMainFrame) {\n          mainFrameId = frame.frame;\n          mainFrameURL = frame.url;\n        }\n        // Worst case: guess by seeing if the frame doesn't have a parent, and does have a URL.\n      } else if (!frame.parent && frame.url) {\n        mainFrameId = frame.frame;\n        mainFrameURL = frame.url;\n      }\n    }\n\n    return;\n  }\n\n  // FrameCommittedInBrowser events tell us information about each frame\n  // and we use these to track how long each individual renderer is active\n  // for. We track all renderers here (top level and those in frames), but\n  // for convenience we also populate a set of top level renderer IDs.\n  if (Types.Events.isFrameCommittedInBrowser(event)) {\n    const frame = event.args.data;\n    if (!frame) {\n      return;\n    }\n\n    updateRendererProcessByFrame(event, frame);\n\n    if (frame.parent) {\n      return;\n    }\n\n    topLevelRendererIds.add(frame.processId);\n    return;\n  }\n\n  if (Types.Events.isCommitLoad(event)) {\n    const frameData = event.args.data;\n    if (!frameData) {\n      return;\n    }\n\n    const {frame, name, url} = frameData;\n    updateRendererProcessByFrame(event, {processId: event.pid, frame, name, url});\n    return;\n  }\n\n  // Track all threads based on the process & thread IDs.\n  if (Types.Events.isThreadName(event)) {\n    const threads = Platform.MapUtilities.getWithDefault(threadsInProcess, event.pid, () => new Map());\n    threads.set(event.tid, event);\n    return;\n  }\n\n  // Track all navigation events. Note that there can be navigation start events\n  // but where the documentLoaderURL is empty. As far as the trace rendering is\n  // concerned, these events are noise so we filter them out here.\n  // (The filtering of empty URLs is done in the isNavigationStart check)\n  if (Types.Events.isNavigationStart(event) && event.args.data) {\n    const navigationId = event.args.data.navigationId;\n    if (navigationsByNavigationId.has(navigationId)) {\n      // We have only ever seen this situation once, in crbug.com/1503982, where the user ran:\n      // window.location.href = 'javascript:console.log(\"foo\")'\n      // In this situation two identical navigationStart events are emitted with the same data, URL and ID.\n      // So, in this situation we drop/ignore any subsequent navigations if we have already seen that ID.\n      return;\n    }\n    navigationsByNavigationId.set(navigationId, event);\n    finalDisplayUrlByNavigationId.set(navigationId, event.args.data.documentLoaderURL);\n\n    const frameId = event.args.frame;\n    const existingFrameNavigations = navigationsByFrameId.get(frameId) || [];\n    existingFrameNavigations.push(event);\n    navigationsByFrameId.set(frameId, existingFrameNavigations);\n    if (frameId === mainFrameId) {\n      mainFrameNavigations.push(event);\n    }\n    return;\n  }\n\n  // Update `finalDisplayUrlByNavigationId` to reflect the latest redirect for each navigation.\n  if (Types.Events.isResourceSendRequest(event)) {\n    if (event.args.data.resourceType !== 'Document') {\n      return;\n    }\n\n    const maybeNavigationId = event.args.data.requestId;\n    const navigation = navigationsByNavigationId.get(maybeNavigationId);\n    if (!navigation) {\n      return;\n    }\n\n    finalDisplayUrlByNavigationId.set(maybeNavigationId, event.args.data.url);\n    return;\n  }\n\n  // Update `finalDisplayUrlByNavigationId` to reflect history API navigations.\n  if (Types.Events.isDidCommitSameDocumentNavigation(event)) {\n    if (event.args.render_frame_host.frame_type !== 'PRIMARY_MAIN_FRAME') {\n      return;\n    }\n\n    const navigation = mainFrameNavigations.at(-1);\n    const key = navigation?.args.data?.navigationId ?? '';\n    finalDisplayUrlByNavigationId.set(key, event.args.url);\n    return;\n  }\n}\n\nexport async function finalize(options?: FinalizeOptions): Promise<void> {\n  config = {showAllEvents: Boolean(options?.showAllEvents)};\n\n  // We try to set the minimum time by finding the event with the smallest\n  // timestamp. However, if we also got a timestamp from the\n  // TracingStartedInBrowser event, we should always use that.\n  // But in some traces (for example, CPU profiles) we do not get that event,\n  // hence why we need to check we got a timestamp from it before setting it.\n  if (traceStartedTimeFromTracingStartedEvent >= 0) {\n    traceBounds.min = traceStartedTimeFromTracingStartedEvent;\n  }\n  traceBounds.range = Types.Timing.Micro(traceBounds.max - traceBounds.min);\n\n  // If we go from foo.com to example.com we will get a new renderer, and\n  // therefore the \"top level renderer\" will have a different PID as it has\n  // changed. Here we step through each renderer process and updated its window\n  // bounds, such that we end up with the time ranges in the trace for when\n  // each particular renderer started and stopped being the main renderer\n  // process.\n  for (const [, processWindows] of rendererProcessesByFrameId) {\n    // Sort the windows by time; we cannot assume by default they arrive via\n    // events in time order. Because we set the window bounds per-process based\n    // on the time of the current + next window, we need them sorted in ASC\n    // order.\n    const processWindowValues = [...processWindows.values()].flat().sort((a, b) => {\n      return a.window.min - b.window.min;\n    });\n    for (let i = 0; i < processWindowValues.length; i++) {\n      const currentWindow = processWindowValues[i];\n      const nextWindow = processWindowValues[i + 1];\n\n      // For the last window we set its max to be positive infinity.\n      // TODO: Move the trace bounds handler into meta so we can clamp first and last windows.\n      if (!nextWindow) {\n        currentWindow.window.max = Types.Timing.Micro(traceBounds.max);\n        currentWindow.window.range = Types.Timing.Micro(traceBounds.max - currentWindow.window.min);\n      } else {\n        currentWindow.window.max = Types.Timing.Micro(nextWindow.window.min - 1);\n        currentWindow.window.range = Types.Timing.Micro(currentWindow.window.max - currentWindow.window.min);\n      }\n    }\n  }\n\n  // Frame ids which we didn't register using either the TracingStartedInBrowser or\n  // the FrameCommittedInBrowser events are considered noise, so we filter them out, as well\n  // as the navigations that belong to such frames.\n  for (const [frameId, navigations] of navigationsByFrameId) {\n    // The frames in the rendererProcessesByFrameId map come only from the\n    // TracingStartedInBrowser and FrameCommittedInBrowser events, so we can use it as point\n    // of comparison to determine if a frameId should be discarded.\n    if (rendererProcessesByFrameId.has(frameId)) {\n      continue;\n    }\n    navigationsByFrameId.delete(frameId);\n    for (const navigation of navigations) {\n      if (!navigation.args.data) {\n        continue;\n      }\n      navigationsByNavigationId.delete(navigation.args.data.navigationId);\n    }\n  }\n\n  // Sometimes in traces the TracingStartedInBrowser event can give us an\n  // incorrect initial URL for the main frame's URL - about:blank or the URL of\n  // the previous page. This doesn't matter too much except we often use this\n  // URL as the visual name of the trace shown to the user (e.g. in the history\n  // dropdown). We can be more accurate by finding the first main frame\n  // navigation, and using its URL, if we have it.\n  // However, to avoid doing this in a case where the first navigation is far\n  // into the trace's lifecycle, we only do this in situations where the first\n  // navigation happened very soon (0.5 seconds) after the trace started\n  // recording.\n  const firstMainFrameNav = mainFrameNavigations.at(0);\n  const firstNavTimeThreshold = Helpers.Timing.secondsToMicro(Types.Timing.Seconds(0.5));\n  if (firstMainFrameNav) {\n    const navigationIsWithinThreshold = firstMainFrameNav.ts - traceBounds.min < firstNavTimeThreshold;\n    if (firstMainFrameNav.args.data?.isOutermostMainFrame && firstMainFrameNav.args.data?.documentLoaderURL &&\n        navigationIsWithinThreshold) {\n      mainFrameURL = firstMainFrameNav.args.data.documentLoaderURL;\n    }\n  }\n}\n\nexport interface MetaHandlerData {\n  config: {showAllEvents: boolean};\n  traceIsGeneric: boolean;\n  traceBounds: Types.Timing.TraceWindowMicro;\n  browserProcessId: Types.Events.ProcessID;\n  processNames: Map<Types.Events.ProcessID, Types.Events.ProcessName>;\n  browserThreadId: Types.Events.ThreadID;\n  gpuProcessId: Types.Events.ProcessID;\n  navigationsByFrameId: Map<string, Types.Events.NavigationStart[]>;\n  navigationsByNavigationId: Map<string, Types.Events.NavigationStart>;\n  /**\n   * The user-visible URL displayed to users in the address bar.\n   * This captures:\n   *  - resolving all redirects\n   *  - history API pushState\n   *\n   * Given no redirects or history API usages, this is just the navigation event's documentLoaderURL.\n   *\n   * Note: empty string special case denotes the duration of the trace between the start\n   * and the first navigation. If there is no history API navigation during this time,\n   * there will be no value for empty string.\n   **/\n  finalDisplayUrlByNavigationId: Map<string, string>;\n  threadsInProcess: Map<Types.Events.ProcessID, Map<Types.Events.ThreadID, Types.Events.ThreadName>>;\n  mainFrameId: string;\n  mainFrameURL: string;\n  /**\n   * A frame can have multiple renderer processes, at the same time,\n   * a renderer process can have multiple URLs. This map tracks the\n   * processes active on a given frame, with the time window in which\n   * they were active. Because a renderer process might have multiple\n   * URLs, each process in each frame has an array of windows, with an\n   * entry for each URL it had.\n   */\n  rendererProcessesByFrame: FrameProcessData;\n  topLevelRendererIds: Set<Types.Events.ProcessID>;\n  frameByProcessId: Map<Types.Events.ProcessID, Map<string, Types.Events.TraceFrame>>;\n  mainFrameNavigations: Types.Events.NavigationStart[];\n  gpuThreadId?: Types.Events.ThreadID;\n  viewportRect?: {x: number, y: number, width: number, height: number};\n  devicePixelRatio?: number;\n}\n\n/**\n * Each frame has a single render process at a given time but it can have\n * multiple render processes  during a trace, for example if a navigation\n * occurred in the frame. This map tracks the process that was active for\n * each frame at each point in time. Also, because a process can be\n * assigned to multiple URLs, there is a window for each URL a process\n * was assigned.\n *\n * Note that different sites always end up in different render\n * processes, however two different URLs can point to the same site.\n * For example: https://google.com and https://maps.google.com point to\n * the same site.\n * Read more about this in\n * https://developer.chrome.com/articles/renderingng-architecture/#threads\n * and https://web.dev/same-site-same-origin/\n **/\nexport type FrameProcessData =\n    Map<string,\n        Map<Types.Events.ProcessID, Array<{frame: Types.Events.TraceFrame, window: Types.Timing.TraceWindowMicro}>>>;\n\nexport function data(): MetaHandlerData {\n  return {\n    config,\n    traceBounds,\n    browserProcessId,\n    browserThreadId,\n    processNames,\n    gpuProcessId,\n    gpuThreadId: gpuThreadId === Types.Events.ThreadID(-1) ? undefined : gpuThreadId,\n    viewportRect: viewportRect || undefined,\n    devicePixelRatio: devicePixelRatio ?? undefined,\n    mainFrameId,\n    mainFrameURL,\n    navigationsByFrameId,\n    navigationsByNavigationId,\n    finalDisplayUrlByNavigationId,\n    threadsInProcess,\n    rendererProcessesByFrame: rendererProcessesByFrameId,\n    topLevelRendererIds,\n    frameByProcessId: framesByProcessId,\n    mainFrameNavigations,\n    traceIsGeneric,\n  };\n}\n", "// Copyright 2022 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Protocol from '../../../generated/protocol.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport * as HandlerHelpers from './helpers.js';\nimport {data as metaHandlerData} from './MetaHandler.js';\nimport type {HandlerName} from './types.js';\n\nconst MILLISECONDS_TO_MICROSECONDS = 1000;\nconst SECONDS_TO_MICROSECONDS = 1000000;\n\n/**\n * Network requests from traces are actually formed of 5 trace records.\n * This handler tracks all trace records based on the request ID, and\n * then creates a new synthetic trace event for those network requests.\n *\n * This interface, then, defines the shape of the object we intend to\n * keep for each request in the trace. In the finalize we will convert\n * these 5 types of trace records to a synthetic complete event that\n * represents a composite of these trace records.\n **/\nexport interface TraceEventsForNetworkRequest {\n  changePriority?: Types.Events.ResourceChangePriority;\n  willSendRequests?: Types.Events.ResourceWillSendRequest[];\n  sendRequests?: Types.Events.ResourceSendRequest[];\n  receiveResponse?: Types.Events.ResourceReceiveResponse;\n  resourceFinish?: Types.Events.ResourceFinish;\n  receivedData?: Types.Events.ResourceReceivedData[];\n  resourceMarkAsCached?: Types.Events.ResourceMarkAsCached;\n  preloadRenderBlockingStatusChange?: Types.Events.PreloadRenderBlockingStatusChangeEvent[];\n}\n\nexport interface WebSocketTraceDataForFrame {\n  frame: string;\n  webSocketIdentifier: number;\n  events: Types.Events.WebSocketEvent[];\n  syntheticConnection: Types.Events.SyntheticWebSocketConnection|null;\n}\nexport interface WebSocketTraceDataForWorker {\n  workerId: string;\n  webSocketIdentifier: number;\n  events: Types.Events.WebSocketEvent[];\n  syntheticConnection: Types.Events.SyntheticWebSocketConnection|null;\n}\nexport type WebSocketTraceData = WebSocketTraceDataForFrame|WebSocketTraceDataForWorker;\n\nlet webSocketData = new Map<number, WebSocketTraceData>();\nlet linkPreconnectEvents: Types.Events.LinkPreconnect[] = [];\n\ninterface NetworkRequestData {\n  byId: Map<string, Types.Events.SyntheticNetworkRequest>;\n  byTime: Types.Events.SyntheticNetworkRequest[];\n  eventToInitiator: Map<Types.Events.SyntheticNetworkRequest, Types.Events.SyntheticNetworkRequest>;\n  webSocket: WebSocketTraceData[];\n  entityMappings: HandlerHelpers.EntityMappings;\n  linkPreconnectEvents: Types.Events.LinkPreconnect[];\n}\n\nlet requestMap = new Map<string, TraceEventsForNetworkRequest>();\nlet requestsById = new Map<string, Types.Events.SyntheticNetworkRequest>();\nlet requestsByTime: Types.Events.SyntheticNetworkRequest[] = [];\n\nlet networkRequestEventByInitiatorUrl = new Map<string, Types.Events.SyntheticNetworkRequest[]>();\nlet eventToInitiatorMap = new Map<Types.Events.SyntheticNetworkRequest, Types.Events.SyntheticNetworkRequest>();\n\n/**\n * These are to store ThirdParty data relationships between entities and events. To reduce iterating through data\n * more than we have to, here we start building the caches. After this, the RendererHandler will update\n * the relationships. When handling ThirdParty references, use the one in the RendererHandler instead.\n */\nlet entityMappings: HandlerHelpers.EntityMappings = {\n  eventsByEntity: new Map<HandlerHelpers.Entity, Types.Events.Event[]>(),\n  entityByEvent: new Map<Types.Events.Event, HandlerHelpers.Entity>(),\n  createdEntityCache: new Map<string, HandlerHelpers.Entity>(),\n  entityByUrlCache: new Map<string, HandlerHelpers.Entity>(),\n};\n\nfunction storeTraceEventWithRequestId<K extends keyof TraceEventsForNetworkRequest>(\n    requestId: string, key: K, value: TraceEventsForNetworkRequest[K]): void {\n  if (!requestMap.has(requestId)) {\n    requestMap.set(requestId, {});\n  }\n\n  const traceEvents = requestMap.get(requestId);\n  if (!traceEvents) {\n    throw new Error(`Unable to locate trace events for request ID ${requestId}`);\n  }\n\n  if (Array.isArray(traceEvents[key])) {\n    const target = traceEvents[key] as Types.Events.Event[];\n    const values = value as Types.Events.Event[];\n    target.push(...values);\n  } else {\n    traceEvents[key] = value;\n  }\n}\n\nfunction firstPositiveValueInList(entries: Array<number|null>): number {\n  for (const entry of entries) {\n    if (entry && entry > 0) {\n      return entry;\n    }\n  }\n\n  // In the event we don't find a positive value, we return 0 so as to\n  // be a mathematical noop. It's typically not correct to return  say \n  // a -1 here because it would affect the calculation of stats below.\n  return 0;\n}\n\nexport function reset(): void {\n  requestsById = new Map();\n  requestMap = new Map();\n  requestsByTime = [];\n  networkRequestEventByInitiatorUrl = new Map();\n  eventToInitiatorMap = new Map();\n  webSocketData = new Map();\n  entityMappings = {\n    eventsByEntity: new Map<HandlerHelpers.Entity, Types.Events.Event[]>(),\n    entityByEvent: new Map<Types.Events.Event, HandlerHelpers.Entity>(),\n    createdEntityCache: new Map<string, HandlerHelpers.Entity>(),\n    entityByUrlCache: new Map<string, HandlerHelpers.Entity>(),\n  };\n  linkPreconnectEvents = [];\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isResourceChangePriority(event)) {\n    storeTraceEventWithRequestId(event.args.data.requestId, 'changePriority', event);\n    return;\n  }\n\n  if (Types.Events.isResourceWillSendRequest(event)) {\n    storeTraceEventWithRequestId(event.args.data.requestId, 'willSendRequests', [event]);\n    return;\n  }\n\n  if (Types.Events.isResourceSendRequest(event)) {\n    storeTraceEventWithRequestId(event.args.data.requestId, 'sendRequests', [event]);\n    return;\n  }\n\n  if (Types.Events.isResourceReceiveResponse(event)) {\n    storeTraceEventWithRequestId(event.args.data.requestId, 'receiveResponse', event);\n    return;\n  }\n\n  if (Types.Events.isResourceReceivedData(event)) {\n    storeTraceEventWithRequestId(event.args.data.requestId, 'receivedData', [event]);\n    return;\n  }\n\n  if (Types.Events.isResourceFinish(event)) {\n    storeTraceEventWithRequestId(event.args.data.requestId, 'resourceFinish', event);\n    return;\n  }\n\n  if (Types.Events.isResourceMarkAsCached(event)) {\n    storeTraceEventWithRequestId(event.args.data.requestId, 'resourceMarkAsCached', event);\n    return;\n  }\n\n  if (Types.Events.isPreloadRenderBlockingStatusChangeEvent(event)) {\n    storeTraceEventWithRequestId(event.args.data.requestId, 'preloadRenderBlockingStatusChange', [event]);\n  }\n\n  if (Types.Events.isWebSocketCreate(event) || Types.Events.isWebSocketInfo(event) ||\n      Types.Events.isWebSocketTransfer(event)) {\n    const identifier = event.args.data.identifier;\n    if (!webSocketData.has(identifier)) {\n      if (event.args.data.frame) {\n        webSocketData.set(identifier, {\n          frame: event.args.data.frame,\n          webSocketIdentifier: identifier,\n          events: [],\n          syntheticConnection: null,\n        });\n      } else if (event.args.data.workerId) {\n        webSocketData.set(identifier, {\n          workerId: event.args.data.workerId,\n          webSocketIdentifier: identifier,\n          events: [],\n          syntheticConnection: null,\n        });\n      }\n    }\n\n    webSocketData.get(identifier)?.events.push(event);\n  }\n\n  if (Types.Events.isLinkPreconnect(event)) {\n    linkPreconnectEvents.push(event);\n    return;\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  const {rendererProcessesByFrame} = metaHandlerData();\n  for (const [requestId, request] of requestMap.entries()) {\n    // If we have an incomplete set of events here, we choose to drop the network\n    // request rather than attempt to synthesize the missing data.\n    if (!request.sendRequests) {\n      continue;\n    }\n\n    // In the data we may get multiple willSendRequests and sendRequests, which\n    // will indicate that there are redirects for a given (sub)resource. In the\n    // case of a navigation, e.g., example.com/ we will get willSendRequests,\n    // and we should use these to calculate time spent in redirects.\n    // In the case of sub-resources, however, e.g., example.com/foo.js we will\n    // *only* get sendRequests, and we use these instead of willSendRequests\n    // to detect the time in redirects. We always use the sendRequest for the\n    // url, priority etc since it contains those values, but we use the\n    // willSendRequest (if it exists) to calculate the timestamp and durations\n    // of redirects.\n    const redirects: Types.Events.SyntheticNetworkRedirect[] = [];\n    for (let i = 0; i < request.sendRequests.length - 1; i++) {\n      const sendRequest = request.sendRequests[i];\n      const nextSendRequest = request.sendRequests[i + 1];\n\n      // Use the willSendRequests as the source for redirects if possible.\n      // We default to those of the sendRequests, however, since willSendRequest\n      // is not guaranteed to be present in the data for every request.\n      let ts = sendRequest.ts;\n      let dur = Types.Timing.Micro(nextSendRequest.ts - sendRequest.ts);\n      if (request.willSendRequests?.[i] && request.willSendRequests[i + 1]) {\n        const willSendRequest = request.willSendRequests[i];\n        const nextWillSendRequest = request.willSendRequests[i + 1];\n        ts = willSendRequest.ts;\n        dur = Types.Timing.Micro(nextWillSendRequest.ts - willSendRequest.ts);\n      }\n\n      redirects.push({\n        url: sendRequest.args.data.url,\n        priority: sendRequest.args.data.priority,\n        requestMethod: sendRequest.args.data.requestMethod,\n        ts,\n        dur,\n      });\n    }\n\n    const firstSendRequest = request.sendRequests[0];\n    const finalSendRequest = request.sendRequests[request.sendRequests.length - 1];\n\n    // We currently do not want to include data URI requests. We may revisit this in the future.\n    if (finalSendRequest.args.data.url.startsWith('data:')) {\n      continue;\n    }\n\n    /**\n     * LR loses transfer size information, but passes it in the 'X-TotalFetchedSize' header.\n     * 'X-TotalFetchedSize' is the canonical transfer size in LR.\n     *\n     * In Lightrider, due to instrumentation limitations, our values for encodedDataLength are bogus\n     * and not valid. However the resource's true encodedDataLength/transferSize is shared via a\n     * special response header, X-TotalFetchedSize. In this situation, we read this value from\n     * responseReceived, use it for the transferSize and ignore the original encodedDataLength values.\n     */\n    // @ts-expect-error\n    const isLightrider = globalThis.isLightrider;\n    if (isLightrider && request.resourceFinish && request.receiveResponse?.args.data.headers) {\n      const lrSizeHeader = request.receiveResponse.args.data.headers.find(h => h.name === 'X-TotalFetchedSize');\n      if (lrSizeHeader) {\n        const size = parseFloat(lrSizeHeader.value);\n        if (!isNaN(size)) {\n          request.resourceFinish.args.data.encodedDataLength = size;\n        }\n      }\n    }\n\n    // If a ResourceFinish event with an encoded data length is received,\n    // then the resource was not cached; it was fetched before it was\n    // requested, e.g. because it was pushed in this navigation.\n    const isPushedResource = request.resourceFinish?.args.data.encodedDataLength !== 0;\n    // This works around crbug.com/998397, which reports pushed resources, and resources served by a service worker as disk cached.\n    const isDiskCached = !!request.receiveResponse && request.receiveResponse.args.data.fromCache &&\n        !request.receiveResponse.args.data.fromServiceWorker && !isPushedResource;\n    // If the request contains a resourceMarkAsCached event, it was served from memory cache.\n    // The timing data returned is from the original (uncached) request, which\n    // means that if we leave the above network record data as-is when the\n    // request came from either the disk cache or memory cache, our calculations\n    // will be incorrect.\n    //\n    // So we use this flag so when we calculate the timestamps of the various\n    // events, we can overwrite them.\n    // These timestamps may not be perfect (indeed they don't always match\n    // the Network CDP domain exactly, which is likely an artifact of the way\n    // the data is routed on the backend), but they're the closest we have.\n    const isMemoryCached = request.resourceMarkAsCached !== undefined;\n    // If a request has `resourceMarkAsCached` field, the `timing` field is not correct.\n    // So let's discard it and override to 0 (which will be handled in later logic if timing field is undefined).\n    let timing = isMemoryCached ? undefined : request.receiveResponse?.args.data.timing;\n\n    /**\n     * LR gets additional, accurate timing information from its underlying fetch infrastructure.  This\n     * is passed in via X-Headers similar to 'X-TotalFetchedSize'.\n     *\n     * See `_updateTimingsForLightrider` in Lighthouse for more detail.\n     */\n    let lrServerResponseTime;\n    if (isLightrider && request.receiveResponse?.args.data.headers) {\n      timing = {\n        requestTime: Helpers.Timing.microToSeconds(request.sendRequests.at(0)?.ts ?? 0 as Types.Timing.Micro),\n        connectEnd: 0 as Types.Timing.Milli,\n        connectStart: 0 as Types.Timing.Milli,\n        dnsEnd: 0 as Types.Timing.Milli,\n        dnsStart: 0 as Types.Timing.Milli,\n        proxyEnd: 0 as Types.Timing.Milli,\n        proxyStart: 0 as Types.Timing.Milli,\n        pushEnd: 0 as Types.Timing.Milli,\n        pushStart: 0 as Types.Timing.Milli,\n        receiveHeadersEnd: 0 as Types.Timing.Milli,\n        receiveHeadersStart: 0 as Types.Timing.Milli,\n        sendEnd: 0 as Types.Timing.Milli,\n        sendStart: 0 as Types.Timing.Milli,\n        sslEnd: 0 as Types.Timing.Milli,\n        sslStart: 0 as Types.Timing.Milli,\n        workerReady: 0 as Types.Timing.Milli,\n        workerStart: 0 as Types.Timing.Milli,\n\n        ...timing,\n      };\n\n      const TCPMsHeader = request.receiveResponse.args.data.headers.find(h => h.name === 'X-TCPMs');\n      const TCPMs = TCPMsHeader ? Math.max(0, parseInt(TCPMsHeader.value, 10)) : 0;\n\n      if (request.receiveResponse.args.data.protocol.startsWith('h3')) {\n        timing.connectStart = 0 as Types.Timing.Milli;\n        timing.connectEnd = TCPMs as Types.Timing.Milli;\n      } else {\n        timing.connectStart = 0 as Types.Timing.Milli;\n        timing.sslStart = TCPMs / 2 as Types.Timing.Milli;\n        timing.connectEnd = TCPMs as Types.Timing.Milli;\n        timing.sslEnd = TCPMs as Types.Timing.Milli;\n      }\n\n      // Lightrider does not have any equivalent for `sendEnd` timing values. The\n      // closest we can get to the server response time is from a header that\n      // Lightrider sets.\n      const ResponseMsHeader = request.receiveResponse.args.data.headers.find(h => h.name === 'X-ResponseMs');\n      if (ResponseMsHeader) {\n        lrServerResponseTime = Math.max(0, parseInt(ResponseMsHeader.value, 10)) as Types.Timing.Milli;\n      }\n    }\n\n    // TODO: consider allowing chrome / about.\n    const allowedProtocols = [\n      'blob:',\n      'file:',\n      'filesystem:',\n      'http:',\n      'https:',\n    ];\n    if (!allowedProtocols.some(p => firstSendRequest.args.data.url.startsWith(p))) {\n      continue;\n    }\n\n    const initialPriority = finalSendRequest.args.data.priority;\n    let finalPriority = initialPriority;\n    if (request.changePriority) {\n      finalPriority = request.changePriority.args.data.priority;\n    }\n\n    // Network timings are complicated.\n    // https://raw.githubusercontent.com/GoogleChrome/lighthouse/main/docs/Network-Timings.svg is generally correct, but.. less so for navigations/redirects/etc.\n\n    // Start time\n    // =======================\n    // The time where the request started, which is either the first willSendRequest\n    // event if there is one, or, if there is not, the sendRequest.\n    const startTime = (request.willSendRequests?.length) ? Types.Timing.Micro(request.willSendRequests[0].ts) :\n                                                           Types.Timing.Micro(firstSendRequest.ts);\n\n    // End redirect time\n    // =======================\n    // It's possible that when we start requesting data we will receive redirections.\n    // Here we note the time of the *last* willSendRequest / sendRequest event,\n    // which is used later on in the calculations for time queueing etc.\n    const endRedirectTime = (request.willSendRequests?.length) ?\n        Types.Timing.Micro(request.willSendRequests[request.willSendRequests.length - 1].ts) :\n        Types.Timing.Micro(finalSendRequest.ts);\n\n    // Finish time and end time\n    // =======================\n    // The finish time and the end time are subtly different.\n    //  - Finish time: records the point at which the network stack stopped receiving the data\n    //  - End time: the timestamp of the finish event itself (if one exists)\n    //\n    // The end time, then, will be slightly after the finish time.\n    const endTime = request.resourceFinish ? request.resourceFinish.ts : endRedirectTime;\n    const finishTime = request.resourceFinish?.args.data.finishTime ?\n        Types.Timing.Micro(request.resourceFinish.args.data.finishTime * SECONDS_TO_MICROSECONDS) :\n        Types.Timing.Micro(endTime);\n\n    // Network duration\n    // =======================\n    // Time spent on the network.\n    const networkDuration = Types.Timing.Micro(timing ? (finishTime || endRedirectTime) - endRedirectTime : 0);\n\n    // Processing duration\n    // =======================\n    // Time spent from start to end.\n    const processingDuration = Types.Timing.Micro(endTime - (finishTime || endTime));\n\n    // Redirection duration\n    // =======================\n    // Time between the first willSendRequest / sendRequest and last. This we place in *front* of the\n    // queueing, since the queueing time that we know about from the trace data is only the last request,\n    // i.e., the one that occurs after all the redirects.\n    const redirectionDuration = Types.Timing.Micro(endRedirectTime - startTime);\n\n    // Queueing\n    // =======================\n    // The amount of time queueing is the time between the request's start time to the requestTime\n    // arg recorded in the receiveResponse event. In the cases where the recorded start time is larger\n    // that the requestTime we set queueing time to zero.\n    const queueingFromTraceData = timing ? timing.requestTime * SECONDS_TO_MICROSECONDS - endRedirectTime : 0;\n    const queueing = Types.Timing.Micro(Platform.NumberUtilities.clamp(queueingFromTraceData, 0, Number.MAX_VALUE));\n\n    // Stalled\n    // =======================\n    // If the request is cached, the amount of time stalled is the time between the start time and\n    // receiving a response.\n    // Otherwise it is whichever positive number comes first from the following timing info:\n    // DNS start, Connection start, Send Start, or the time duration between our start time and\n    // receiving a response.\n    const stalled = timing ?\n        Types.Timing.Micro(firstPositiveValueInList([\n          timing.dnsStart * MILLISECONDS_TO_MICROSECONDS,\n          timing.connectStart * MILLISECONDS_TO_MICROSECONDS,\n          timing.sendStart * MILLISECONDS_TO_MICROSECONDS,\n          request.receiveResponse ? (request.receiveResponse.ts - endRedirectTime) : null,\n        ])) :\n        (request.receiveResponse ? Types.Timing.Micro(request.receiveResponse.ts - startTime) : Types.Timing.Micro(0));\n\n    // Sending HTTP request\n    // =======================\n    // Time when the HTTP request is sent.\n    const sendStartTime = timing ?\n        Types.Timing.Micro(\n            timing.requestTime * SECONDS_TO_MICROSECONDS + timing.sendStart * MILLISECONDS_TO_MICROSECONDS) :\n        startTime;\n\n    // Waiting\n    // =======================\n    // Time from when the send finished going to when the headers were received.\n    const waiting = timing ?\n        Types.Timing.Micro((timing.receiveHeadersEnd - timing.sendEnd) * MILLISECONDS_TO_MICROSECONDS) :\n        Types.Timing.Micro(0);\n\n    // Server Response Time\n    // =======================\n    // Time from when the send finished going to when the first byte of headers were received.\n    const serverResponseTime = timing ?\n        Types.Timing.Micro(\n            ((timing.receiveHeadersStart ?? timing.receiveHeadersEnd) - timing.sendEnd) *\n            MILLISECONDS_TO_MICROSECONDS) :\n        Types.Timing.Micro(0);\n\n    // Download\n    // =======================\n    // Time from receipt of headers to the finish time.\n    const downloadStart = timing ?\n        Types.Timing.Micro(\n            timing.requestTime * SECONDS_TO_MICROSECONDS + timing.receiveHeadersEnd * MILLISECONDS_TO_MICROSECONDS) :\n        startTime;\n    const download = timing     ? Types.Timing.Micro(((finishTime || downloadStart) - downloadStart)) :\n        request.receiveResponse ? Types.Timing.Micro(endTime - request.receiveResponse.ts) :\n                                  Types.Timing.Micro(0);\n\n    const totalTime = Types.Timing.Micro(networkDuration + processingDuration);\n\n    // Collect a few values from the timing info.\n    // If the Network request is cached, these fields will be zero, so the minus will zero out them.\n    const dnsLookup = timing ? Types.Timing.Micro((timing.dnsEnd - timing.dnsStart) * MILLISECONDS_TO_MICROSECONDS) :\n                               Types.Timing.Micro(0);\n    const ssl = timing ? Types.Timing.Micro((timing.sslEnd - timing.sslStart) * MILLISECONDS_TO_MICROSECONDS) :\n                         Types.Timing.Micro(0);\n    const proxyNegotiation = timing ?\n        Types.Timing.Micro((timing.proxyEnd - timing.proxyStart) * MILLISECONDS_TO_MICROSECONDS) :\n        Types.Timing.Micro(0);\n    const requestSent = timing ?\n        Types.Timing.Micro((timing.sendEnd - timing.sendStart) * MILLISECONDS_TO_MICROSECONDS) :\n        Types.Timing.Micro(0);\n    const initialConnection = timing ?\n        Types.Timing.Micro((timing.connectEnd - timing.connectStart) * MILLISECONDS_TO_MICROSECONDS) :\n        Types.Timing.Micro(0);\n\n    // Finally get some of the general data from the trace events.\n    const {frame, url, renderBlocking: sendRequestIsRenderBlocking} = finalSendRequest.args.data;\n    const {encodedDataLength, decodedBodyLength} =\n        request.resourceFinish ? request.resourceFinish.args.data : {encodedDataLength: 0, decodedBodyLength: 0};\n    const parsedUrl = new URL(url);\n    const isHttps = parsedUrl.protocol === 'https:';\n    const requestingFrameUrl =\n        Helpers.Trace.activeURLForFrameAtTime(frame, finalSendRequest.ts, rendererProcessesByFrame) || '';\n\n    // A resource that is preloaded (and not marked as render blocking) can\n    // become render blocked later via a PreloadRenderBlockingStatusChange. In\n    // this case, we take the render blocking value of the last\n    // PreloadRenderBlockingStatusChange for this request.\n    const preloadRenderBlockingStatusChange =\n        request.preloadRenderBlockingStatusChange?.at(-1)?.args.data.renderBlocking;\n\n    // In the event the property isn't set, assume non-blocking.\n    const isRenderBlocking = preloadRenderBlockingStatusChange ?? sendRequestIsRenderBlocking ?? 'non_blocking';\n\n    // Construct a synthetic trace event for this network request.\n    const networkEvent =\n        Helpers.SyntheticEvents.SyntheticEventsManager.registerSyntheticEvent<Types.Events.SyntheticNetworkRequest>({\n          rawSourceEvent: finalSendRequest,\n          args: {\n            data: {\n              // All data we create from trace events should be added to |syntheticData|.\n              syntheticData: {\n                dnsLookup,\n                download,\n                downloadStart,\n                finishTime,\n                initialConnection,\n                isDiskCached,\n                isHttps,\n                isMemoryCached,\n                isPushedResource,\n                networkDuration,\n                processingDuration,\n                proxyNegotiation,\n                queueing,\n                redirectionDuration,\n                requestSent,\n                sendStartTime,\n                ssl,\n                stalled,\n                totalTime,\n                waiting,\n                serverResponseTime,\n              },\n              // All fields below are from TraceEventsForNetworkRequest.\n              decodedBodyLength,\n              encodedDataLength,\n              frame,\n              fromServiceWorker: request.receiveResponse?.args.data.fromServiceWorker,\n              isLinkPreload: finalSendRequest.args.data.isLinkPreload || false,\n              mimeType: request.receiveResponse?.args.data.mimeType ?? '',\n              priority: finalPriority,\n              initialPriority,\n              protocol: request.receiveResponse?.args.data.protocol ?? 'unknown',\n              redirects,\n              renderBlocking: isRenderBlocking,\n              requestId,\n              requestingFrameUrl,\n              requestMethod: finalSendRequest.args.data.requestMethod,\n              resourceType: finalSendRequest.args.data.resourceType ?? Protocol.Network.ResourceType.Other,\n              statusCode: request.receiveResponse?.args.data.statusCode ?? 0,\n              responseHeaders: request.receiveResponse?.args.data.headers ?? null,\n              fetchPriorityHint: finalSendRequest.args.data.fetchPriorityHint ?? 'auto',\n              initiator: finalSendRequest.args.data.initiator,\n              stackTrace: finalSendRequest.args.data.stackTrace,\n              timing,\n              lrServerResponseTime,\n              url,\n              failed: request.resourceFinish?.args.data.didFail ?? false,\n              finished: Boolean(request.resourceFinish),\n              hasResponse: Boolean(request.receiveResponse),\n              connectionId: request.receiveResponse?.args.data.connectionId,\n              connectionReused: request.receiveResponse?.args.data.connectionReused,\n            },\n          },\n          cat: 'loading',\n          name: Types.Events.Name.SYNTHETIC_NETWORK_REQUEST,\n          ph: Types.Events.Phase.COMPLETE,\n          dur: Types.Timing.Micro(endTime - startTime),\n          tdur: Types.Timing.Micro(endTime - startTime),\n          ts: Types.Timing.Micro(startTime),\n          tts: Types.Timing.Micro(startTime),\n          pid: finalSendRequest.pid,\n          tid: finalSendRequest.tid,\n        });\n\n    // However, there are also times where we just want to loop through all\n    // the captured requests, so here we store all of them together.\n    requestsByTime.push(networkEvent);\n    requestsById.set(networkEvent.args.data.requestId, networkEvent);\n\n    // Update entity relationships for network events\n    HandlerHelpers.addNetworkRequestToEntityMapping(networkEvent, entityMappings, request);\n\n    // Establish initiator relationships\n    const initiatorUrl = networkEvent.args.data.initiator?.url ||\n        Helpers.Trace.getStackTraceTopCallFrameInEventPayload(networkEvent)?.url;\n    if (initiatorUrl) {\n      const events = networkRequestEventByInitiatorUrl.get(initiatorUrl) ?? [];\n      events.push(networkEvent);\n      networkRequestEventByInitiatorUrl.set(initiatorUrl, events);\n    }\n  }\n\n  for (const request of requestsByTime) {\n    const initiatedEvents = networkRequestEventByInitiatorUrl.get(request.args.data.url);\n\n    if (initiatedEvents) {\n      for (const initiatedEvent of initiatedEvents) {\n        eventToInitiatorMap.set(initiatedEvent, request);\n      }\n    }\n  }\n\n  finalizeWebSocketData();\n}\n\nexport function data(): NetworkRequestData {\n  return {\n    byId: requestsById,\n    byTime: requestsByTime,\n    eventToInitiator: eventToInitiatorMap,\n    webSocket: [...webSocketData.values()],\n    entityMappings: {\n      entityByEvent: entityMappings.entityByEvent,\n      eventsByEntity: entityMappings.eventsByEntity,\n      createdEntityCache: entityMappings.createdEntityCache,\n      entityByUrlCache: entityMappings.entityByUrlCache,\n    },\n    linkPreconnectEvents,\n  };\n}\n\nexport function deps(): HandlerName[] {\n  return ['Meta'];\n}\n\nfunction finalizeWebSocketData(): void {\n  // for each WebSocketTraceData in webSocketData map, we create a synthetic event\n  // to represent the entire WebSocket connection. This is done by finding the start and end event\n  // if they exist, and if they don't, we use the first event in the list for start, and the traceBounds.max\n  // for the end. So each WebSocketTraceData will have\n  // {\n  //    events:  the list of WebSocket events\n  //    syntheticConnection:  the synthetic event representing the entire WebSocket connection\n  // }\n  webSocketData.forEach(data => {\n    let startEvent: Types.Events.WebSocketEvent|null = null;\n    let endEvent: Types.Events.WebSocketDestroy|null = null;\n    for (const event of data.events) {\n      if (Types.Events.isWebSocketCreate(event)) {\n        startEvent = event;\n      }\n      if (Types.Events.isWebSocketDestroy(event)) {\n        endEvent = event;\n      }\n    }\n    data.syntheticConnection = createSyntheticWebSocketConnection(startEvent, endEvent, data.events[0]);\n  });\n}\n\nfunction createSyntheticWebSocketConnection(\n    startEvent: Types.Events.WebSocketCreate|null, endEvent: Types.Events.WebSocketDestroy|null,\n    firstRecordedEvent: Types.Events.WebSocketEvent): Types.Events.SyntheticWebSocketConnection {\n  const {traceBounds} = metaHandlerData();\n  const startTs = startEvent ? startEvent.ts : traceBounds.min;\n  const endTs = endEvent ? endEvent.ts : traceBounds.max;\n  const duration = endTs - startTs;\n  const mainEvent = startEvent || endEvent || firstRecordedEvent;\n  return {\n    name: 'SyntheticWebSocketConnection',\n    cat: mainEvent.cat,\n    ph: Types.Events.Phase.COMPLETE,\n    ts: startTs,\n    dur: duration as Types.Timing.Micro,\n    pid: mainEvent.pid,\n    tid: mainEvent.tid,\n    s: mainEvent.s,\n    rawSourceEvent: mainEvent,\n    _tag: 'SyntheticEntryTag',\n    args: {\n      data: {\n        identifier: mainEvent.args.data.identifier,\n        priority: Protocol.Network.ResourcePriority.Low,\n        url: mainEvent.args.data.url || '',\n      },\n    },\n  };\n}\n", "// Copyright 2022 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport type * as Protocol from '../../../generated/protocol.js';\nimport * as CPUProfile from '../../cpu_profile/cpu_profile.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nlet profilesInProcess = new Map<Types.Events.ProcessID, Map<Types.Events.ThreadID, ProfileData>>();\nlet entryToNode = new Map<Types.Events.Event, Helpers.TreeHelpers.TraceEntryNode>();\n\n// The profile head, containing its metadata like its start\n// time, comes in a \"Profile\" event. The sample data comes in\n// \"ProfileChunk\" events. We match these ProfileChunks with their head\n// using process and profile ids. However, in order to integrate sample\n// data with trace data, we need the thread id that owns each profile.\n// This thread id is extracted from the head event.\n// For this reason, we have a preprocessed data structure, where events\n// are matched by profile id, which we then finish processing to export\n// events matched by thread id.\nlet preprocessedData = new Map<Types.Events.ProcessID, Map<Types.Events.ProfileID, PreprocessedData>>();\n\n/**\n * Profile source selection priority when multiple profiles exist for the same thread.\n *\n * Profile sources and their typical scenarios:\n * - 'Internal': Browser-initiated profiling performance panel traces.\n *   This is the profiling mechanism when users click \"Record\" in the Devtools UI.\n * - 'Inspector': User-initiated via console.profile()/profileEnd() calls.\n *   Represents explicit developer intent to profile specific code.\n * - 'SelfProfiling': Page-initiated via JS Self-Profiling API.\n *    Lower signal vs the two above; treated as fallback.\n *\n * Selection strategy:\n * - CPU Profile mode: Prefer 'Inspector' (explicit user request).\n * - Performance trace: Prefer 'Internal' (integrated timeline context), then 'Inspector'.\n * - Sources not in the priority list (including 'SelfProfiling') act as fallbacks.\n *   When no priority source matches, the first candidate profile is selected.\n */\nconst PROFILE_SOURCES_BY_PRIORITY = {\n  cpuProfile: ['Inspector'] as Types.Events.ProfileSource[],\n  performanceTrace: ['Internal', 'Inspector'] as Types.Events.ProfileSource[],\n};\n\nfunction parseCPUProfileData(parseOptions: Types.Configuration.ParseOptions): void {\n  const priorityList =\n      parseOptions.isCPUProfile ? PROFILE_SOURCES_BY_PRIORITY.cpuProfile : PROFILE_SOURCES_BY_PRIORITY.performanceTrace;\n\n  for (const [processId, profiles] of preprocessedData) {\n    const profilesByThread =\n        new Map<Types.Events.ThreadID, Array<{id: Types.Events.ProfileID, data: PreprocessedData}>>();\n    for (const [profileId, preProcessedData] of profiles) {\n      const threadId = preProcessedData.threadId;\n      if (threadId === undefined) {\n        continue;\n      }\n      const listForThread = Platform.MapUtilities.getWithDefault(profilesByThread, threadId, () => []);\n      listForThread.push({id: profileId, data: preProcessedData});\n    }\n\n    for (const [threadId, candidates] of profilesByThread) {\n      if (!candidates.length) {\n        continue;\n      }\n      let chosen = candidates[0];\n      for (const source of priorityList) {\n        const match = candidates.find(p => p.data.source === source);\n        if (match) {\n          chosen = match;\n          break;\n        }\n      }\n      const chosenData = chosen.data;\n      if (!chosenData.rawProfile.nodes.length) {\n        continue;\n      }\n      const indexStack: number[] = [];\n\n      const profileModel = new CPUProfile.CPUProfileDataModel.CPUProfileDataModel(chosenData.rawProfile);\n      const profileTree = Helpers.TreeHelpers.makeEmptyTraceEntryTree();\n      profileTree.maxDepth = profileModel.maxDepth;\n\n      const selectedProfileId = chosen.id;\n      const finalizedData: ProfileData = {\n        rawProfile: chosenData.rawProfile,\n        parsedProfile: profileModel,\n        profileCalls: [],\n        profileTree,\n        profileId: selectedProfileId,\n      };\n      const dataByThread = Platform.MapUtilities.getWithDefault(profilesInProcess, processId, () => new Map());\n      dataByThread.set(threadId, finalizedData);\n\n      // Only need to build pure JS ProfileCalls if we're parsing a CPU Profile, otherwise SamplesIntegrator does the work.\n      if (parseOptions.isCPUProfile) {\n        buildProfileCallsForCPUProfile();\n      }\n\n      function buildProfileCallsForCPUProfile(): void {\n        profileModel.forEachFrame(openFrameCallback, closeFrameCallback);\n\n        function openFrameCallback(\n            depth: number, node: CPUProfile.ProfileTreeModel.ProfileNode, sampleIndex: number,\n            timeStampMilliseconds: number): void {\n          if (threadId === undefined) {\n            return;\n          }\n          const ts = Helpers.Timing.milliToMicro(Types.Timing.Milli(timeStampMilliseconds));\n          const nodeId = node.id as Helpers.TreeHelpers.TraceEntryNodeId;\n\n          const profileCall =\n              Helpers.Trace.makeProfileCall(node, selectedProfileId, sampleIndex, ts, processId, threadId);\n          finalizedData.profileCalls.push(profileCall);\n          indexStack.push(finalizedData.profileCalls.length - 1);\n          const traceEntryNode = Helpers.TreeHelpers.makeEmptyTraceEntryNode(profileCall, nodeId);\n          entryToNode.set(profileCall, traceEntryNode);\n          traceEntryNode.depth = depth;\n          if (indexStack.length === 1) {\n            // First call in the stack is a root call.\n            finalizedData.profileTree?.roots.add(traceEntryNode);\n          }\n        }\n        function closeFrameCallback(\n            _depth: number, _node: CPUProfile.ProfileTreeModel.ProfileNode, _sampleIndex: number,\n            _timeStampMillis: number, durMs: number, selfTimeMs: number): void {\n          const profileCallIndex = indexStack.pop();\n          const profileCall = profileCallIndex !== undefined && finalizedData.profileCalls[profileCallIndex];\n          if (!profileCall) {\n            return;\n          }\n          const {callFrame, ts, pid, tid} = profileCall;\n          const traceEntryNode = entryToNode.get(profileCall);\n          if (callFrame === undefined || ts === undefined || pid === undefined || selectedProfileId === undefined ||\n              tid === undefined || traceEntryNode === undefined) {\n            return;\n          }\n          const dur = Helpers.Timing.milliToMicro(Types.Timing.Milli(durMs));\n          const selfTime = Helpers.Timing.milliToMicro(Types.Timing.Milli(selfTimeMs));\n          profileCall.dur = dur;\n          traceEntryNode.selfTime = selfTime;\n\n          const parentIndex = indexStack.at(-1);\n          const parent = parentIndex !== undefined && finalizedData.profileCalls.at(parentIndex);\n          const parentNode = parent && entryToNode.get(parent);\n          if (!parentNode) {\n            return;\n          }\n          traceEntryNode.parent = parentNode;\n          parentNode.children.push(traceEntryNode);\n        }\n      }\n    }\n  }\n}\n\nexport function reset(): void {\n  preprocessedData = new Map();\n  profilesInProcess = new Map();\n  entryToNode = new Map();\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  /**\n   * A fake trace event created to support CDP.Profiler.Profiles in the\n   * trace engine.\n   */\n  if (Types.Events.isSyntheticCpuProfile(event)) {\n    // At the moment we are attaching to a single node target so we\n    // should only get a single CPU profile. The values of the process\n    // id and thread id are not really important, so we use the data\n    // in the fake event. Should multi-thread CPU profiling be supported\n    // we could use these fields in the event to pass thread info.\n    const profileData = getOrCreatePreProcessedData(event.pid, event.id);\n    profileData.rawProfile = event.args.data.cpuProfile;\n    profileData.threadId = event.tid;\n    return;\n  }\n\n  if (Types.Events.isProfile(event)) {\n    // Do not use event.args.data.startTime as it is in CLOCK_MONOTONIC domain,\n    // but use profileEvent.ts which has been translated to Perfetto's clock\n    // domain. Also convert from ms to us.\n    // Note: events are collected on a different thread than what's sampled.\n    // The correct process and thread ids are specified by the profile.\n    const profileData = getOrCreatePreProcessedData(event.pid, event.id);\n    profileData.rawProfile.startTime = event.ts;\n    profileData.threadId = event.tid;\n    assignProfileSourceIfKnown(profileData, event.args?.data?.source);\n    return;\n  }\n  if (Types.Events.isProfileChunk(event)) {\n    const profileData = getOrCreatePreProcessedData(event.pid, event.id);\n    const cdpProfile = profileData.rawProfile;\n    const nodesAndSamples: Types.Events.PartialProfile = event.args?.data?.cpuProfile || {samples: []};\n    const samples = nodesAndSamples?.samples || [];\n    const traceIds = event.args?.data?.cpuProfile?.trace_ids;\n    for (const n of nodesAndSamples?.nodes || []) {\n      const lineNumber = typeof n.callFrame.lineNumber === 'undefined' ? -1 : n.callFrame.lineNumber;\n      const columnNumber = typeof n.callFrame.columnNumber === 'undefined' ? -1 : n.callFrame.columnNumber;\n\n      const scriptId = String(n.callFrame.scriptId) as Protocol.Runtime.ScriptId;\n      const url = n.callFrame.url || '';\n      const node = {\n        ...n,\n        callFrame: {\n          ...n.callFrame,\n          url,\n          lineNumber,\n          columnNumber,\n          scriptId,\n        },\n      };\n      cdpProfile.nodes.push(node);\n    }\n\n    const timeDeltas = event.args.data?.timeDeltas || [];\n    const lines = event.args.data?.lines || Array(samples.length).fill(0);\n    cdpProfile.samples?.push(...samples);\n    cdpProfile.timeDeltas?.push(...timeDeltas);\n    cdpProfile.lines?.push(...lines);\n\n    if (traceIds) {\n      cdpProfile.traceIds ??= {};\n      for (const key in traceIds) {\n        cdpProfile.traceIds[key] = traceIds[key];\n      }\n    }\n\n    if (cdpProfile.samples && cdpProfile.timeDeltas && cdpProfile.samples.length !== cdpProfile.timeDeltas.length) {\n      console.error('Failed to parse CPU profile.');\n      return;\n    }\n    if (!cdpProfile.endTime && cdpProfile.timeDeltas) {\n      const timeDeltas: number[] = cdpProfile.timeDeltas;\n      cdpProfile.endTime = timeDeltas.reduce((x, y) => x + y, cdpProfile.startTime);\n    }\n    assignProfileSourceIfKnown(profileData, event.args?.data?.source);\n    return;\n  }\n}\n\nexport async function finalize(parseOptions: Types.Configuration.ParseOptions = {}): Promise<void> {\n  parseCPUProfileData(parseOptions);\n}\n\nfunction assignProfileSourceIfKnown(profileData: PreprocessedData, source: unknown): void {\n  if (Types.Events.VALID_PROFILE_SOURCES.includes(source as Types.Events.ProfileSource)) {\n    profileData.source = source as Types.Events.ProfileSource;\n  }\n}\n\nexport function data(): SamplesHandlerData {\n  return {\n    profilesInProcess,\n    entryToNode,\n  };\n}\n\nfunction getOrCreatePreProcessedData(\n    processId: Types.Events.ProcessID, profileId: Types.Events.ProfileID): PreprocessedData {\n  const profileById = Platform.MapUtilities.getWithDefault(preprocessedData, processId, () => new Map());\n  return Platform.MapUtilities.getWithDefault<Types.Events.ProfileID, PreprocessedData>(\n      profileById, profileId, () => ({\n                                rawProfile: {\n                                  startTime: 0,\n                                  endTime: 0,\n                                  nodes: [],\n                                  samples: [],\n                                  timeDeltas: [],\n                                  lines: [],\n                                },\n                                profileId,\n                              }));\n}\n\nexport interface SamplesHandlerData {\n  profilesInProcess: typeof profilesInProcess;\n  entryToNode: typeof entryToNode;\n}\n\nexport interface ProfileData {\n  profileId: Types.Events.ProfileID;\n  rawProfile: CPUProfile.CPUProfileDataModel.ExtendedProfile;\n  parsedProfile: CPUProfile.CPUProfileDataModel.CPUProfileDataModel;\n  /**\n   * Contains the calls built from the CPU profile samples.\n   * Note: This doesn't contain real trace events coming from the\n   * browser, only calls synthetically typed as trace events for\n   * compatibility, as such it only makes sense to use them in pure CPU\n   * profiles.\n   *\n   * If you need the profile calls from a CPU profile obtained from a\n   * web trace, use the data exported by the RendererHandler instead.\n   */\n  profileCalls: Types.Events.SyntheticProfileCall[];\n  /**\n   * Contains the call tree built from the CPU profile samples.\n   * Similar to the profileCalls field, this tree does not contain nor\n   * take into account trace events, as such it only makes sense to use\n   * them in pure CPU profiles.\n   */\n  profileTree?: Helpers.TreeHelpers.TraceEntryTree;\n}\n\ninterface PreprocessedData {\n  rawProfile: CPUProfile.CPUProfileDataModel.ExtendedProfile;\n  profileId: Types.Events.ProfileID;\n  threadId?: Types.Events.ThreadID;\n  source?: Types.Events.ProfileSource;\n}\n\n/**\n * Returns the name of a function for a given synthetic profile call.\n * We first look to find the ProfileNode representing this call, and use its\n * function name. This is preferred (and should always exist) because if we\n * resolve sourcemaps, we will update this name. If that name is not present,\n * we fall back to the function name that was in the callframe that we got\n * when parsing the profile's trace data.\n */\nexport function getProfileCallFunctionName(data: SamplesHandlerData, entry: Types.Events.SyntheticProfileCall): string {\n  const profile = data.profilesInProcess.get(entry.pid)?.get(entry.tid);\n  const node = profile?.parsedProfile.nodeById(entry.nodeId);\n  if (node?.functionName) {\n    return node.functionName;\n  }\n  return entry.callFrame.functionName;\n}\n", "// Copyright 2025 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Types from '../types/types.js';\n\nexport interface DOMStatsData {\n  domStatsByFrameId: Map<string, Types.Events.DOMStats[]>;\n}\n\nlet domStatsByFrameId: DOMStatsData['domStatsByFrameId'] = new Map();\n\nexport function reset(): void {\n  domStatsByFrameId = new Map();\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (!Types.Events.isDOMStats(event)) {\n    return;\n  }\n  const domStatEvents = Platform.MapUtilities.getWithDefault(domStatsByFrameId, event.args.data.frame, () => []);\n  domStatEvents.push(event);\n}\n\nexport async function finalize(): Promise<void> {\n}\n\nexport function data(): DOMStatsData {\n  return {domStatsByFrameId};\n}\n", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport type {HandlerName} from './types.js';\nimport {data as userTimingsData} from './UserTimingsHandler.js';\n\nlet extensionTrackEntries: Types.Extensions.SyntheticExtensionTrackEntry[] = [];\nlet extensionTrackData: Types.Extensions.ExtensionTrackData[] = [];\nlet extensionMarkers: Types.Extensions.SyntheticExtensionMarker[] = [];\nlet entryToNode = new Map<Types.Events.Event, Helpers.TreeHelpers.TraceEntryNode>();\nlet timeStampByName = new Map<string, Types.Events.ConsoleTimeStamp>();\n\nlet syntheticConsoleEntriesForTimingsTrack: Types.Events.SyntheticConsoleTimeStamp[] = [];\n\nexport interface ExtensionTraceData {\n  extensionTrackData: readonly Types.Extensions.ExtensionTrackData[];\n  extensionMarkers: readonly Types.Extensions.SyntheticExtensionMarker[];\n  // TODO(andoli): Can we augment Renderer's entryToNode instead? To avoid the split of TimelineUIUtils's getEventSelfTime()?\n  entryToNode: Map<Types.Events.Event, Helpers.TreeHelpers.TraceEntryNode>;\n  syntheticConsoleEntriesForTimingsTrack: Types.Events.SyntheticConsoleTimeStamp[];\n}\n\nexport function handleEvent(_event: Types.Events.Event): void {\n  // Implementation not needed because data is sourced from UserTimingsHandler\n}\n\nexport function reset(): void {\n  extensionTrackEntries = [];\n  syntheticConsoleEntriesForTimingsTrack = [];\n  extensionTrackData = [];\n  extensionMarkers = [];\n  entryToNode = new Map();\n  timeStampByName = new Map();\n}\n\nexport async function finalize(): Promise<void> {\n  createExtensionFlameChartEntries();\n}\n\nfunction createExtensionFlameChartEntries(): void {\n  const pairedMeasures: readonly Types.Events.SyntheticUserTimingPair[] = userTimingsData().performanceMeasures;\n  const marks: readonly Types.Events.PerformanceMark[] = userTimingsData().performanceMarks;\n  const mergedRawExtensionEvents = Helpers.Trace.mergeEventsInOrder(pairedMeasures, marks);\n\n  extractPerformanceAPIExtensionEntries(mergedRawExtensionEvents);\n  extractConsoleAPIExtensionEntries();\n  // extensionTrackEntries is filled by the above two calls.\n  Helpers.Trace.sortTraceEventsInPlace(extensionTrackEntries);\n  Helpers.Extensions.buildTrackDataFromExtensionEntries(extensionTrackEntries, extensionTrackData, entryToNode);\n}\n\n/**\n * Extracts extension entries from console.timeStamp events.\n *\n * Entries are built by pairing `console.timeStamp` events based on\n * their names. When a `console.timeStamp` event includes a `start`\n * argument (and optionally an `end` argument), it attempts to find\n * previously recorded `console.timeStamp` events with names matching\n * the `start` and `end` values. These matching events are then used to\n * determine the start and end times of the new entry.\n *\n * If a `console.timeStamp` event includes data for a custom track\n * (specified by the `track` argument), an extension track entry is\n * created and added to the `extensionTrackEntries` array. These entries\n * are used to visualize custom tracks in the Performance panel.\n *\n * If a `console.timeStamp` event includes data for a custom track\n * (specified by the `track` argument), an extension track entry is\n * created and added to the `extensionTrackEntries` array. These entries\n * are used to visualize custom tracks in the Performance panel.\n *\n * If a `console.timeStamp` event does not specify a custom track but\n * includes a start and/or end time (referencing other\n * `console.timeStamp` names), a synthetic console time stamp entry is\n * created and added to the `syntheticConsoleEntriesForTimingsTrack`\n * array. These entries are displayed in the \"Timings\" track.\n */\nexport function extractConsoleAPIExtensionEntries(): void {\n  const consoleTimeStamps: readonly Types.Events.ConsoleTimeStamp[] = userTimingsData().timestampEvents;\n  for (const currentTimeStamp of consoleTimeStamps) {\n    if (!currentTimeStamp.args.data) {\n      continue;\n    }\n    const timeStampName = String(currentTimeStamp.args.data.name ?? currentTimeStamp.args.data.message);\n    timeStampByName.set(timeStampName, currentTimeStamp);\n    const {devtoolsObj: extensionData, userDetail} = extensionDataInConsoleTimeStamp(currentTimeStamp);\n    const start = currentTimeStamp.args.data.start;\n    const end = currentTimeStamp.args.data.end;\n    if (!extensionData && !start && !end) {\n      continue;\n    }\n    // If the start or end is a number, it's assumed to be a timestamp\n    // from the tracing clock, so we use that directly, otherwise we\n    // assume it's the label of a previous console timestamp, in which\n    // case we use its corresponding timestamp.\n    const startTimeStamp =\n        typeof start === 'number' ? Types.Timing.Micro(start) : timeStampByName.get(String(start))?.ts;\n    const endTimeStamp = typeof end === 'number' ? Types.Timing.Micro(end) : timeStampByName.get(String(end))?.ts;\n    if (endTimeStamp !== undefined && startTimeStamp === undefined) {\n      // Invalid data\n      continue;\n    }\n    const entryStartTime = startTimeStamp ?? currentTimeStamp.ts;\n    const entryEndTime = endTimeStamp ?? currentTimeStamp.ts;\n    if (extensionData) {\n      const unregisteredExtensionEntry: Omit<Types.Extensions.SyntheticExtensionTrackEntry, '_tag'> = {\n        ...currentTimeStamp,\n        name: timeStampName,\n        cat: 'devtools.extension',\n        devtoolsObj: extensionData,\n        userDetail,\n        rawSourceEvent: currentTimeStamp,\n        dur: Types.Timing.Micro(entryEndTime - entryStartTime),\n        ts: entryStartTime,\n        ph: Types.Events.Phase.COMPLETE,\n      };\n      const extensionEntry =\n          Helpers.SyntheticEvents.SyntheticEventsManager\n              .registerSyntheticEvent<Types.Extensions.SyntheticExtensionTrackEntry>(unregisteredExtensionEntry);\n      extensionTrackEntries.push(extensionEntry);\n      continue;\n    }\n    // If no extension data is found in the entry (no custom track name\n    // was passed), but the entry has a duration. we still save it here\n    // to be added in the timings track. Note that timings w/o duration\n    // and extension data are already handled by the UserTimingsHandler.\n    const unregisteredSyntheticTimeStamp: Omit<Types.Events.SyntheticConsoleTimeStamp, '_tag'> = {\n      ...currentTimeStamp,\n      name: timeStampName,\n      cat: 'disabled-by-default-v8.inspector',\n      ph: Types.Events.Phase.COMPLETE,\n      ts: entryStartTime,\n      dur: Types.Timing.Micro(entryEndTime - entryStartTime),\n      rawSourceEvent: currentTimeStamp\n    };\n    const syntheticTimeStamp =\n        Helpers.SyntheticEvents.SyntheticEventsManager.registerSyntheticEvent<Types.Events.SyntheticConsoleTimeStamp>(\n            unregisteredSyntheticTimeStamp);\n    syntheticConsoleEntriesForTimingsTrack.push(syntheticTimeStamp);\n  }\n}\n\n/**\n * Extracts extension entries from Performance API events (marks and\n * measures).\n * It specifically looks for events that contain extension-specific data\n * within their `detail` property.\n *\n * If an event's `detail` property can be parsed as a JSON object and\n * contains a `devtools` field with a valid extension payload, a\n * synthetic extension entry is created. The type of extension entry\n * created depends on the payload:\n *\n * - If the payload conforms to `ExtensionPayloadMarker`, a\n *   `SyntheticExtensionMarker` is created and added to the\n *   `extensionMarkers` array. These markers represent single points in\n *   time.\n * - If the payload conforms to `ExtensionPayloadTrackEntry`, a\n *   `SyntheticExtensionTrackEntry` is created and added to the\n *   `extensionTrackEntries` array. These entries represent events with\n *   a duration and are displayed on custom tracks in the Performance\n *   panel.\n *\n * **Note:** Only events with a `detail` property that contains valid\n * extension data are processed. Other `performance.mark` and\n * `performance.measure` events are ignored.\n *\n * @param timings An array of `SyntheticUserTimingPair` or\n *                `PerformanceMark` events, typically obtained from the\n *                `UserTimingsHandler`.\n */\nexport function extractPerformanceAPIExtensionEntries(\n    timings: Array<Types.Events.SyntheticUserTimingPair|Types.Events.PerformanceMark>): void {\n  for (const timing of timings) {\n    const {devtoolsObj, userDetail} = extensionDataInPerformanceTiming(timing);\n    if (!devtoolsObj) {\n      // Not an extension user timing.\n      continue;\n    }\n\n    const extensionSyntheticEntry = {\n      name: timing.name,\n      ph: Types.Extensions.isExtensionPayloadMarker(devtoolsObj) ? Types.Events.Phase.INSTANT :\n                                                                   Types.Events.Phase.COMPLETE,\n      pid: timing.pid,\n      tid: timing.tid,\n      ts: timing.ts,\n      dur: timing.dur as Types.Timing.Micro,\n      cat: 'devtools.extension',\n      devtoolsObj,\n      userDetail,\n      rawSourceEvent: Types.Events.isSyntheticUserTiming(timing) ? timing.rawSourceEvent : timing,\n    };\n\n    if (Types.Extensions.isExtensionPayloadMarker(devtoolsObj)) {\n      const extensionMarker =\n          Helpers.SyntheticEvents.SyntheticEventsManager\n              .registerSyntheticEvent<Types.Extensions.SyntheticExtensionMarker>(\n                  extensionSyntheticEntry as Omit<Types.Extensions.SyntheticExtensionMarker, '_tag'>);\n      extensionMarkers.push(extensionMarker);\n      continue;\n    }\n\n    if (Types.Extensions.isExtensionEntryObj(extensionSyntheticEntry.devtoolsObj)) {\n      const extensionTrackEntry =\n          Helpers.SyntheticEvents.SyntheticEventsManager\n              .registerSyntheticEvent<Types.Extensions.SyntheticExtensionTrackEntry>(\n                  extensionSyntheticEntry as Omit<Types.Extensions.SyntheticExtensionTrackEntry, '_tag'>);\n      extensionTrackEntries.push(extensionTrackEntry);\n      continue;\n    }\n  }\n}\n\n/**\n * Parses out the data in a performance.measure / mark call into two parts:\n * 1. devtoolsObj: this is the data required to be passed by the user for the\n *    event to be used to create a custom track in the performance panel.\n * 2. userDetail: this is arbitrary data the user has attached to the event\n *    that we show in the summary drawer.\n */\nexport function extensionDataInPerformanceTiming(\n    timing: Types.Events.SyntheticUserTimingPair|Types.Events.PerformanceMark):\n    {devtoolsObj: Types.Extensions.DevToolsObj|null, userDetail: Types.Extensions.JsonValue|null} {\n  const timingDetail =\n      Types.Events.isPerformanceMark(timing) ? timing.args.data?.detail : timing.args.data.beginEvent.args.detail;\n  if (!timingDetail) {\n    return {devtoolsObj: null, userDetail: null};\n  }\n  const devtoolsObj = Helpers.Trace.parseDevtoolsDetails(timingDetail, 'devtools') as Types.Extensions.DevToolsObj;\n\n  let userDetail = null;\n  try {\n    userDetail = JSON.parse(timingDetail);\n    delete userDetail.devtools;\n  } catch {\n    // Nothing to do here, we still want to return the `devtools` part to make\n    // this a custom event, even if the user detail failed to parse.\n  }\n\n  return {devtoolsObj, userDetail};\n}\n\n/**\n * Extracts extension data from a `console.timeStamp` event.\n *\n * Checks if a `console.timeStamp` event contains data intended for\n * creating a custom track entry in the DevTools Performance panel. It\n * specifically looks for a `track` argument within the event's data.\n *\n * If a `track` argument is present (and not an empty string), the\n * function constructs an `ExtensionTrackEntryPayload` object containing\n * the track name, an optional color, an optional track group. This\n * payload is then used to create a `SyntheticExtensionTrackEntry`.\n *\n * **Note:** The `color` argument is optional and its type is validated\n * against a predefined palette (see\n * `ExtensionUI::extensionEntryColor`).\n *\n * @param timeStamp The `ConsoleTimeStamp` event to extract data from.\n * @returns An `ExtensionTrackEntryPayload` object if the event contains\n *         valid extension data for a track entry, or `null` otherwise.\n */\nexport function extensionDataInConsoleTimeStamp(timeStamp: Types.Events.ConsoleTimeStamp):\n    {devtoolsObj: Types.Extensions.DevToolsObjEntry|null, userDetail: Types.Extensions.JsonValue|null} {\n  if (!timeStamp.args.data || !timeStamp.args.data.track) {\n    return {devtoolsObj: null, userDetail: null};\n  }\n\n  let userDetail = null;\n  try {\n    // While it's in the trace as 'devtools', it's just the 7th argument to console.timeStamp(), stringified.\n    // If no data, fall back to falsy empty string.\n    userDetail = JSON.parse(timeStamp.args.data?.devtools || '\"\"') as Types.Extensions.JsonValue;\n  } catch {\n  }\n\n  const devtoolsObj: Types.Extensions.DevToolsObjEntry = {\n    // the color is defaulted to primary if it's value isn't one from\n    // the defined palette (see ExtensionUI::extensionEntryColor) so\n    // we don't need to check the value is valid here.\n    color: String(timeStamp.args.data.color) as Types.Extensions.DevToolsObjEntry['color'],\n    track: String(timeStamp.args.data.track),\n    dataType: 'track-entry',\n    trackGroup: timeStamp.args.data.trackGroup !== undefined ? String(timeStamp.args.data.trackGroup) : undefined,\n  };\n\n  return {devtoolsObj, userDetail};\n}\n\nexport function data(): ExtensionTraceData {\n  return {\n    entryToNode,\n    extensionTrackData,\n    extensionMarkers,\n    syntheticConsoleEntriesForTimingsTrack,\n  };\n}\n\nexport function deps(): HandlerName[] {\n  return ['UserTimings'];\n}\n", "// Copyright 2022 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\n/**\n * IMPORTANT!\n * See UserTimings.md in this directory for some handy documentation on\n * UserTimings and the trace events we parse currently.\n **/\nlet syntheticEvents: Array<Types.Events.SyntheticEventPair<Types.Events.PairableAsync>> = [];\n\n// There are two events dispatched for performance.measure calls: one to\n// represent the measured timing in the tracing clock (which we type as\n// PerformanceMeasure) and another one for the call itself (which we\n// type as UserTimingMeasure). The two events corresponding to the same\n// call are linked together by a common trace_id. The reason two events\n// are dispatched is because the first was originally added with the\n// implementation of the performance.measure API and it uses an\n// overridden timestamp and duration. To prevent breaking potential deps\n// created since then, a second event was added instead of changing the\n// params of the first.\nlet measureTraceByTraceId = new Map<number, Types.Events.UserTimingMeasure>();\nlet performanceMeasureEvents: Types.Events.PerformanceMeasure[] = [];\nlet performanceMarkEvents: Types.Events.PerformanceMark[] = [];\n\nlet consoleTimings: Array<Types.Events.ConsoleTimeBegin|Types.Events.ConsoleTimeEnd> = [];\n\nlet timestampEvents: Types.Events.ConsoleTimeStamp[] = [];\n\nexport interface UserTimingsData {\n  /**\n   * Events triggered with the performance.measure() API.\n   * https://developer.mozilla.org/en-US/docs/Web/API/Performance/measure\n   */\n  performanceMeasures: readonly Types.Events.SyntheticUserTimingPair[];\n  /**\n   * Events triggered with the performance.mark() API.\n   * https://developer.mozilla.org/en-US/docs/Web/API/Performance/mark\n   */\n  performanceMarks: readonly Types.Events.PerformanceMark[];\n  /**\n   * Events triggered with the console.time(), console.timeEnd() and\n   * console.timeLog() API.\n   * https://developer.mozilla.org/en-US/docs/Web/API/console/time\n   */\n  consoleTimings: readonly Types.Events.SyntheticConsoleTimingPair[];\n  /**\n   * Events triggered with the console.timeStamp() API\n   * https://developer.mozilla.org/en-US/docs/Web/API/console/timeStamp\n   */\n  timestampEvents: readonly Types.Events.ConsoleTimeStamp[];\n  /**\n   * Events triggered to trace the call to performance.measure itself,\n   * cached by trace_id.\n   */\n  measureTraceByTraceId: Map<number, Types.Events.UserTimingMeasure>;\n}\n\nexport function reset(): void {\n  syntheticEvents = [];\n  performanceMeasureEvents = [];\n  performanceMarkEvents = [];\n  consoleTimings = [];\n  timestampEvents = [];\n  measureTraceByTraceId = new Map();\n}\n\nconst resourceTimingNames = [\n  'workerStart',\n  'redirectStart',\n  'redirectEnd',\n  'fetchStart',\n  'domainLookupStart',\n  'domainLookupEnd',\n  'connectStart',\n  'connectEnd',\n  'secureConnectionStart',\n  'requestStart',\n  'responseStart',\n  'responseEnd',\n];\nconst navTimingNames = [\n  'navigationStart',\n  'unloadEventStart',\n  'unloadEventEnd',\n  'redirectStart',\n  'redirectEnd',\n  'fetchStart',\n  'commitNavigationEnd',\n  'domainLookupStart',\n  'domainLookupEnd',\n  'connectStart',\n  'connectEnd',\n  'secureConnectionStart',\n  'requestStart',\n  'responseStart',\n  'responseEnd',\n  'domLoading',\n  'domInteractive',\n  'domContentLoadedEventStart',\n  'domContentLoadedEventEnd',\n  'domComplete',\n  'loadEventStart',\n  'loadEventEnd',\n];\n// These are events dispatched under the blink.user_timing category\n// but that the user didn't add. Filter them out so that they do not\n// Appear in the timings track (they still appear in the main thread\n// flame chart).\nconst ignoredNames = [...resourceTimingNames, ...navTimingNames];\n\nfunction getEventTimings(event: Types.Events.SyntheticEventPair|Types.Events.ConsoleTimeStamp):\n    {start: Types.Timing.Micro, end: Types.Timing.Micro} {\n  if ('dur' in event) {\n    // It's a SyntheticEventPair.\n    return {start: event.ts, end: Types.Timing.Micro(event.ts + (event.dur ?? 0))};\n  }\n\n  if (Types.Events.isConsoleTimeStamp(event)) {\n    const {start, end} = event.args.data || {};\n    if (typeof start === 'number' && typeof end === 'number') {\n      return {start: Types.Timing.Micro(start), end: Types.Timing.Micro(end)};\n    }\n  }\n\n  // A ConsoleTimeStamp without start/end is just a point in time, so dur is 0.\n  return {start: event.ts, end: event.ts};\n}\n\nfunction getEventTrack(event: Types.Events.SyntheticEventPair|Types.Events.ConsoleTimeStamp): string|undefined {\n  if (event.cat === 'blink.user_timing') {\n    // This is a SyntheticUserTimingPair\n    const detailString =\n        ((event as Types.Events.SyntheticUserTimingPair).args.data.beginEvent.args as {detail?: string})?.detail;\n    if (detailString) {\n      const details = Helpers.Trace.parseDevtoolsDetails(detailString, 'devtools');\n      if (details && 'track' in details) {\n        return details.track;\n      }\n    }\n  } else if (Types.Events.isConsoleTimeStamp(event)) {\n    const track = event.args.data?.track;\n    return typeof track === 'string' ? track : undefined;\n  }\n\n  // SyntheticConsoleTimingPair does not have track info.\n  return undefined;\n}\n\n/**\n * Similar to the default {@link Helpers.Trace.eventTimeComparator}\n * but with a twist:\n * In case of equal start and end times, put the second event (within a\n * track) first.\n *\n * Explanation:\n * User timing entries come as trace events dispatched when\n * performance.measure/mark is called. The trace events buffered in\n * devtools frontend are sorted by the start time. If their start time\n * is the same, then the event for the first call will appear first.\n *\n * When entries are meant to be stacked, the corresponding\n * performance.measure calls usually are done in bottom-up direction:\n * calls for children first and for parent later (because the call\n * is usually done when the measured task is over). This means that\n * when two user timing events have the same start and end time, usually\n * the second event is the parent of the first. Hence the switch.\n *\n */\nexport function userTimingComparator<T extends Types.Events.SyntheticEventPair|Types.Events.ConsoleTimeStamp>(\n    a: T, b: T, originalArray: readonly T[]): number {\n  const {start: aStart, end: aEnd} = getEventTimings(a);\n  const {start: bStart, end: bEnd} = getEventTimings(b);\n  const timeDifference = Helpers.Trace.compareBeginAndEnd(aStart, bStart, aEnd, bEnd);\n  if (timeDifference) {\n    return timeDifference;\n  }\n\n  // Never re-order entries across different tracks.\n  const aTrack = getEventTrack(a);\n  const bTrack = getEventTrack(b);\n  if (aTrack !== bTrack) {\n    return 0;  // Preserve current positions.\n  }\n\n  // Prefer the event located in a further position in the original array.\n  const aIndex = originalArray.indexOf(a);\n  const bIndex = originalArray.indexOf(b);\n  return bIndex - aIndex;\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (ignoredNames.includes(event.name)) {\n    return;\n  }\n  if (Types.Events.isUserTimingMeasure(event)) {\n    measureTraceByTraceId.set(event.args.traceId, event);\n  }\n  if (Types.Events.isPerformanceMeasure(event)) {\n    performanceMeasureEvents.push(event);\n    return;\n  }\n  if (Types.Events.isPerformanceMark(event)) {\n    performanceMarkEvents.push(event);\n  }\n  if (Types.Events.isConsoleTime(event)) {\n    consoleTimings.push(event);\n  }\n  if (Types.Events.isConsoleTimeStamp(event)) {\n    timestampEvents.push(event);\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  const asyncEvents = [...performanceMeasureEvents, ...consoleTimings];\n  syntheticEvents = Helpers.Trace.createMatchedSortedSyntheticEvents(asyncEvents);\n  syntheticEvents = syntheticEvents.sort((a, b) => userTimingComparator(a, b, [...syntheticEvents]));\n  timestampEvents = timestampEvents.sort((a, b) => userTimingComparator(a, b, [...timestampEvents]));\n}\n\nexport function data(): UserTimingsData {\n  return {\n    consoleTimings: syntheticEvents.filter(e => e.cat === 'blink.console') as Types.Events.SyntheticConsoleTimingPair[],\n    performanceMeasures: syntheticEvents.filter(e => e.cat === 'blink.user_timing') as\n        Types.Events.SyntheticUserTimingPair[],\n    performanceMarks: performanceMarkEvents,\n    timestampEvents,\n    measureTraceByTraceId,\n  };\n}\n", "// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {type AuctionWorkletsData, data as auctionWorkletsData} from './AuctionWorkletsHandler.js';\nimport {data as layerTreeHandlerData, type LayerTreeData} from './LayerTreeHandler.js';\nimport {data as metaHandlerData, type MetaHandlerData} from './MetaHandler.js';\nimport {data as rendererHandlerData, type RendererHandlerData} from './RendererHandler.js';\nimport * as Threads from './Threads.js';\nimport type {HandlerName} from './types.js';\n\n/**\n * IMPORTANT: this handler is slightly different to the rest. This is because\n * it is an adaptation of the TimelineFrameModel that has been used in DevTools\n * for many years. Rather than re-implement all the logic from scratch, instead\n * this handler gathers up the events and instantitates the class in the\n * finalize() method. Once the class has parsed all events, it is used to then\n * return the array of frames.\n *\n * In time we expect to migrate this code to a more \"typical\" handler.\n */\n\nlet model: TimelineFrameModel|null = null;\nlet relevantFrameEvents: Types.Events.Event[] = [];\n\ntype FrameEvent = Types.Events.BeginFrame|Types.Events.DroppedFrame|Types.Events.RequestMainThreadFrame|\n                  Types.Events.BeginMainThreadFrame|Types.Events.Commit|Types.Events.CompositeLayers|\n                  Types.Events.ActivateLayerTree|Types.Events.NeedsBeginFrameChanged|Types.Events.DrawFrame;\n\nfunction isFrameEvent(event: Types.Events.Event): event is FrameEvent {\n  return (\n      Types.Events.isSetLayerId(event) || Types.Events.isBeginFrame(event) || Types.Events.isDroppedFrame(event) ||\n      Types.Events.isRequestMainThreadFrame(event) || Types.Events.isBeginMainThreadFrame(event) ||\n      Types.Events.isNeedsBeginFrameChanged(event) ||\n      // Note that \"Commit\" is the replacement for \"CompositeLayers\" so in a trace\n      // we wouldn't expect to see a combination of these. All \"new\" trace\n      // recordings use \"Commit\", but we can easily support \"CompositeLayers\" too\n      // to not break older traces being imported.\n      Types.Events.isCommit(event) || Types.Events.isCompositeLayers(event) ||\n      Types.Events.isActivateLayerTree(event) || Types.Events.isDrawFrame(event));\n}\n\nfunction entryIsTopLevel(entry: Types.Events.Event): boolean {\n  const devtoolsTimelineCategory = 'disabled-by-default-devtools.timeline';\n  return entry.name === Types.Events.Name.RUN_TASK && entry.cat.includes(devtoolsTimelineCategory);\n}\n\nconst MAIN_FRAME_MARKERS = new Set<Types.Events.Name>([\n  Types.Events.Name.SCHEDULE_STYLE_RECALCULATION,\n  Types.Events.Name.INVALIDATE_LAYOUT,\n  Types.Events.Name.BEGIN_MAIN_THREAD_FRAME,\n  Types.Events.Name.SCROLL_LAYER,\n]);\n\nexport function reset(): void {\n  model = null;\n  relevantFrameEvents = [];\n}\nexport function handleEvent(event: Types.Events.Event): void {\n  // This might seem like a wide set of events to filter for, but these are all\n  // the types of events that we care about in the TimelineFrameModel class at\n  // the bottom of this file. Previously we would take a copy of an array of\n  // all trace events, but on a few test traces, this set of filtered events\n  // accounts for about 10% of the total events, so it's a big performance win\n  // to deal with a much smaller subset of the data.\n  if (isFrameEvent(event) || Types.Events.isLayerTreeHostImplSnapshot(event) || entryIsTopLevel(event) ||\n      MAIN_FRAME_MARKERS.has(event.name as Types.Events.Name) || Types.Events.isPaint(event)) {\n    relevantFrameEvents.push(event);\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  // We have to sort the events by timestamp, because the model code expects to\n  // process events in order.\n  Helpers.Trace.sortTraceEventsInPlace(relevantFrameEvents);\n\n  const modelForTrace = new TimelineFrameModel(\n      relevantFrameEvents,\n      rendererHandlerData(),\n      auctionWorkletsData(),\n      metaHandlerData(),\n      layerTreeHandlerData(),\n  );\n  model = modelForTrace;\n}\n\nexport interface FramesData {\n  frames: readonly Types.Events.LegacyTimelineFrame[];\n  framesById: Readonly<Record<number, Types.Events.LegacyTimelineFrame|undefined>>;\n}\n\nexport function data(): FramesData {\n  return {\n    frames: model?.frames() ?? [],\n    framesById: model?.framesById() ?? {},\n  };\n}\n\nexport function deps(): HandlerName[] {\n  return ['Meta', 'Renderer', 'AuctionWorklets', 'LayerTree'];\n}\n\nexport class TimelineFrameModel {\n  #frames: TimelineFrame[] = [];\n  #frameById: Record<number, TimelineFrame> = {};\n  #beginFrameQueue: TimelineFrameBeginFrameQueue = new TimelineFrameBeginFrameQueue();\n  #lastFrame: TimelineFrame|null = null;\n  #mainFrameCommitted = false;\n  #mainFrameRequested = false;\n  #lastLayerTree: Types.Events.LegacyFrameLayerTreeData|null = null;\n  #framePendingActivation: PendingFrame|null = null;\n  #framePendingCommit: PendingFrame|null = null;\n  #lastBeginFrame: number|null = null;\n  #lastNeedsBeginFrame: number|null = null;\n  #lastTaskBeginTime: Types.Timing.Micro|null = null;\n  #layerTreeId: number|null = null;\n  #activeProcessId: Types.Events.ProcessID|null = null;\n  #activeThreadId: Types.Events.ThreadID|null = null;\n  #layerTreeData: LayerTreeData;\n\n  constructor(\n      allEvents: readonly Types.Events.Event[], rendererData: RendererHandlerData,\n      auctionWorkletsData: AuctionWorkletsData, metaData: MetaHandlerData, layerTreeData: LayerTreeData) {\n    // We only care about getting threads from the Renderer, not Samples,\n    // because Frames don't exist in a CPU Profile (which won't have Renderer\n    // threads.)\n    const mainThreads = Threads.threadsInRenderer(rendererData, auctionWorkletsData).filter(thread => {\n      return thread.type === Threads.ThreadType.MAIN_THREAD && thread.processIsOnMainFrame;\n    });\n    const threadData = mainThreads.map(thread => {\n      return {\n        tid: thread.tid,\n        pid: thread.pid,\n        startTime: thread.entries[0].ts,\n      };\n    });\n\n    this.#layerTreeData = layerTreeData;\n    this.#addTraceEvents(allEvents, threadData, metaData.mainFrameId);\n  }\n\n  framesById(): Readonly<Record<number, TimelineFrame|undefined>> {\n    return this.#frameById;\n  }\n\n  frames(): TimelineFrame[] {\n    return this.#frames;\n  }\n\n  #handleBeginFrame(startTime: Types.Timing.Micro, seqId: number): void {\n    if (!this.#lastFrame) {\n      this.#startFrame(startTime, seqId);\n    }\n    this.#lastBeginFrame = startTime;\n\n    this.#beginFrameQueue.addFrameIfNotExists(seqId, startTime, false, false);\n  }\n\n  #handleDroppedFrame(startTime: Types.Timing.Micro, seqId: number, isPartial: boolean): void {\n    if (!this.#lastFrame) {\n      this.#startFrame(startTime, seqId);\n    }\n\n    // This line handles the case where no BeginFrame event is issued for\n    // the dropped frame. In this situation, add a BeginFrame to the queue\n    // as if it actually occurred.\n    this.#beginFrameQueue.addFrameIfNotExists(seqId, startTime, true, isPartial);\n    this.#beginFrameQueue.setDropped(seqId, true);\n    this.#beginFrameQueue.setPartial(seqId, isPartial);\n  }\n\n  #handleDrawFrame(startTime: Types.Timing.Micro, seqId: number): void {\n    if (!this.#lastFrame) {\n      this.#startFrame(startTime, seqId);\n      return;\n    }\n\n    // - if it wasn't drawn, it didn't happen!\n    // - only show frames that either did not wait for the main thread frame or had one committed.\n    if (this.#mainFrameCommitted || !this.#mainFrameRequested) {\n      if (this.#lastNeedsBeginFrame) {\n        const idleTimeEnd = this.#framePendingActivation ? this.#framePendingActivation.triggerTime :\n                                                           (this.#lastBeginFrame || this.#lastNeedsBeginFrame);\n        if (idleTimeEnd > this.#lastFrame.startTime) {\n          this.#lastFrame.idle = true;\n          this.#lastBeginFrame = null;\n        }\n        this.#lastNeedsBeginFrame = null;\n      }\n\n      const framesToVisualize = this.#beginFrameQueue.processPendingBeginFramesOnDrawFrame(seqId);\n\n      // Visualize the current frame and all pending frames before it.\n      for (const frame of framesToVisualize) {\n        const isLastFrameIdle = this.#lastFrame.idle;\n\n        // If |frame| is the first frame after an idle period, the CPU time\n        // will be logged (\"committed\") under |frame| if applicable.\n        this.#startFrame(frame.startTime, seqId);\n        if (isLastFrameIdle && this.#framePendingActivation) {\n          this.#commitPendingFrame();\n        }\n        if (frame.isDropped) {\n          this.#lastFrame.dropped = true;\n        }\n        if (frame.isPartial) {\n          this.#lastFrame.isPartial = true;\n        }\n      }\n    }\n    this.#mainFrameCommitted = false;\n  }\n\n  #handleActivateLayerTree(): void {\n    if (!this.#lastFrame) {\n      return;\n    }\n    if (this.#framePendingActivation && !this.#lastNeedsBeginFrame) {\n      this.#commitPendingFrame();\n    }\n  }\n\n  #handleRequestMainThreadFrame(): void {\n    if (!this.#lastFrame) {\n      return;\n    }\n    this.#mainFrameRequested = true;\n  }\n\n  #handleCommit(): void {\n    if (!this.#framePendingCommit) {\n      return;\n    }\n    this.#framePendingActivation = this.#framePendingCommit;\n    this.#framePendingCommit = null;\n    this.#mainFrameRequested = false;\n    this.#mainFrameCommitted = true;\n  }\n\n  #handleLayerTreeSnapshot(layerTree: Types.Events.LegacyFrameLayerTreeData): void {\n    this.#lastLayerTree = layerTree;\n  }\n\n  #handleNeedFrameChanged(startTime: Types.Timing.Micro, needsBeginFrame: boolean): void {\n    if (needsBeginFrame) {\n      this.#lastNeedsBeginFrame = startTime;\n    }\n  }\n\n  #startFrame(startTime: Types.Timing.Micro, seqId: number): void {\n    if (this.#lastFrame) {\n      this.#flushFrame(this.#lastFrame, startTime);\n    }\n    this.#lastFrame =\n        new TimelineFrame(seqId, startTime, Types.Timing.Micro(startTime - metaHandlerData().traceBounds.min));\n  }\n\n  #flushFrame(frame: TimelineFrame, endTime: Types.Timing.Micro): void {\n    frame.setLayerTree(this.#lastLayerTree);\n    frame.setEndTime(endTime);\n    if (this.#lastLayerTree) {\n      this.#lastLayerTree.paints = frame.paints;\n    }\n    const lastFrame = this.#frames[this.#frames.length - 1];\n    if (this.#frames.length && lastFrame &&\n        (frame.startTime !== lastFrame.endTime || frame.startTime > frame.endTime)) {\n      console.assert(\n          false, `Inconsistent frame time for frame ${this.#frames.length} (${frame.startTime} - ${frame.endTime})`);\n    }\n    const newFramesLength = this.#frames.push(frame);\n    frame.setIndex(newFramesLength - 1);\n    if (typeof frame.mainFrameId === 'number') {\n      this.#frameById[frame.mainFrameId] = frame;\n    }\n  }\n\n  #commitPendingFrame(): void {\n    if (!this.#framePendingActivation || !this.#lastFrame) {\n      return;\n    }\n\n    this.#lastFrame.paints = this.#framePendingActivation.paints;\n    this.#lastFrame.mainFrameId = this.#framePendingActivation.mainFrameId;\n    this.#framePendingActivation = null;\n  }\n\n  #addTraceEvents(\n      events: readonly Types.Events.Event[], threadData: Array<{\n        pid: Types.Events.ProcessID,\n        tid: Types.Events.ThreadID,\n        startTime: Types.Timing.Micro,\n      }>,\n      mainFrameId: string): void {\n    let j = 0;\n    this.#activeThreadId = threadData.length && threadData[0].tid || null;\n    this.#activeProcessId = threadData.length && threadData[0].pid || null;\n    for (let i = 0; i < events.length; ++i) {\n      while (j + 1 < threadData.length && threadData[j + 1].startTime <= events[i].ts) {\n        this.#activeThreadId = threadData[++j].tid;\n        this.#activeProcessId = threadData[j].pid;\n      }\n      this.#addTraceEvent(events[i], mainFrameId);\n    }\n    this.#activeThreadId = null;\n    this.#activeProcessId = null;\n  }\n\n  #addTraceEvent(event: Types.Events.Event, mainFrameId: string): void {\n    if (Types.Events.isSetLayerId(event) && event.args.data.frame === mainFrameId) {\n      this.#layerTreeId = event.args.data.layerTreeId;\n    } else if (Types.Events.isLayerTreeHostImplSnapshot(event) && Number(event.id) === this.#layerTreeId) {\n      this.#handleLayerTreeSnapshot({\n        entry: event,\n        paints: [],\n      });\n    } else {\n      if (isFrameEvent(event)) {\n        this.#processCompositorEvents(event);\n      }\n      // Make sure we only use events from the main thread: we check the PID as\n      // well in case two processes have a thread with the same TID.\n      if (event.tid === this.#activeThreadId && event.pid === this.#activeProcessId) {\n        this.#addMainThreadTraceEvent(event);\n      }\n    }\n  }\n\n  #processCompositorEvents(entry: FrameEvent): void {\n    if (entry.args['layerTreeId'] !== this.#layerTreeId) {\n      return;\n    }\n    if (Types.Events.isBeginFrame(entry)) {\n      this.#handleBeginFrame(entry.ts, entry.args['frameSeqId']);\n    } else if (Types.Events.isDrawFrame(entry)) {\n      this.#handleDrawFrame(entry.ts, entry.args['frameSeqId']);\n    } else if (Types.Events.isActivateLayerTree(entry)) {\n      this.#handleActivateLayerTree();\n    } else if (Types.Events.isRequestMainThreadFrame(entry)) {\n      this.#handleRequestMainThreadFrame();\n    } else if (Types.Events.isNeedsBeginFrameChanged(entry)) {\n      // needsBeginFrame property will either be 0 or 1, which represents\n      // true/false in this case, hence the Boolean() wrapper.\n      this.#handleNeedFrameChanged(entry.ts, entry.args['data'] && Boolean(entry.args['data']['needsBeginFrame']));\n    } else if (Types.Events.isDroppedFrame(entry)) {\n      this.#handleDroppedFrame(entry.ts, entry.args['frameSeqId'], Boolean(entry.args['hasPartialUpdate']));\n    }\n  }\n\n  #addMainThreadTraceEvent(entry: Types.Events.Event): void {\n    if (entryIsTopLevel(entry)) {\n      this.#lastTaskBeginTime = entry.ts;\n    }\n    if (!this.#framePendingCommit && MAIN_FRAME_MARKERS.has(entry.name as Types.Events.Name)) {\n      this.#framePendingCommit = new PendingFrame(this.#lastTaskBeginTime || entry.ts);\n    }\n    if (!this.#framePendingCommit) {\n      return;\n    }\n\n    if (Types.Events.isBeginMainThreadFrame(entry) && entry.args.data.frameId) {\n      this.#framePendingCommit.mainFrameId = entry.args.data.frameId;\n    }\n    if (Types.Events.isPaint(entry)) {\n      const snapshot = this.#layerTreeData.paintsToSnapshots.get(entry);\n      if (snapshot) {\n        this.#framePendingCommit.paints.push(new LayerPaintEvent(entry, snapshot));\n      }\n    }\n    // Commit will be replacing CompositeLayers but CompositeLayers is kept\n    // around for backwards compatibility.\n    if ((Types.Events.isCompositeLayers(entry) || Types.Events.isCommit(entry)) &&\n        entry.args['layerTreeId'] === this.#layerTreeId) {\n      this.#handleCommit();\n    }\n  }\n}\n\n/**\n * Legacy class that represents TimelineFrames that was ported from the old SDK.\n * This class is purposefully not exported as it breaks the abstraction that\n * every event shown on the timeline is a trace event. Instead, we use the Type\n * LegacyTimelineFrame to represent frames in the codebase. These do implement\n * the right interface to be treated just like they were a trace event.\n */\nclass TimelineFrame implements Types.Events.LegacyTimelineFrame {\n  // These fields exist to satisfy the base Event type which all\n  // \"trace events\" must implement. They aren't used, but doing this means we\n  // can pass `TimelineFrame` instances into places that expect\n  // Types.Events.Event.\n  cat = 'devtools.legacy_frame';\n  name = 'frame';\n  ph = Types.Events.Phase.COMPLETE;\n  ts: Types.Timing.Micro;\n  pid = Types.Events.ProcessID(-1);\n  tid = Types.Events.ThreadID(-1);\n\n  index = -1;\n  startTime: Types.Timing.Micro;\n  startTimeOffset: Types.Timing.Micro;\n  endTime: Types.Timing.Micro;\n  duration: Types.Timing.Micro;\n  idle: boolean;\n  dropped: boolean;\n  isPartial: boolean;\n  layerTree: Types.Events.LegacyFrameLayerTreeData|null;\n  paints: LayerPaintEvent[];\n  mainFrameId: number|undefined;\n  readonly seqId: number;\n\n  constructor(seqId: number, startTime: Types.Timing.Micro, startTimeOffset: Types.Timing.Micro) {\n    this.seqId = seqId;\n    this.startTime = startTime;\n    this.ts = startTime;\n    this.startTimeOffset = startTimeOffset;\n    this.endTime = this.startTime;\n    this.duration = Types.Timing.Micro(0);\n    this.idle = false;\n    this.dropped = false;\n    this.isPartial = false;\n    this.layerTree = null;\n    this.paints = [];\n    this.mainFrameId = undefined;\n  }\n\n  setIndex(i: number): void {\n    this.index = i;\n  }\n\n  setEndTime(endTime: Types.Timing.Micro): void {\n    this.endTime = endTime;\n    this.duration = Types.Timing.Micro(this.endTime - this.startTime);\n  }\n\n  setLayerTree(layerTree: Types.Events.LegacyFrameLayerTreeData|null): void {\n    this.layerTree = layerTree;\n  }\n\n  /**\n   * Fake the `dur` field to meet the expected value given that we pretend\n   * these TimelineFrame classes are trace events across the codebase.\n   */\n  get dur(): Types.Timing.Micro {\n    return this.duration;\n  }\n}\n\nexport class LayerPaintEvent implements Types.Events.LegacyLayerPaintEvent {\n  readonly #event: Types.Events.Paint;\n  #snapshot: Types.Events.DisplayItemListSnapshot;\n\n  constructor(event: Types.Events.Paint, snapshot: Types.Events.DisplayItemListSnapshot) {\n    this.#event = event;\n    this.#snapshot = snapshot;\n  }\n\n  layerId(): number {\n    return this.#event.args.data.layerId;\n  }\n\n  event(): Types.Events.Paint {\n    return this.#event;\n  }\n\n  picture(): Types.Events.LegacyLayerPaintEventPicture|null {\n    const rect = this.#snapshot.args.snapshot.params?.layer_rect;\n    const pictureData = this.#snapshot.args.snapshot.skp64;\n    return rect && pictureData ? {rect, serializedPicture: pictureData} : null;\n  }\n}\n\nexport class PendingFrame {\n  paints: LayerPaintEvent[];\n  mainFrameId: number|undefined;\n  triggerTime: number;\n  constructor(triggerTime: number) {\n    this.paints = [];\n    this.mainFrameId = undefined;\n    this.triggerTime = triggerTime;\n  }\n}\n\n/** The parameters of an impl-side BeginFrame. **/\nclass BeginFrameInfo {\n  seqId: number;\n  startTime: Types.Timing.Micro;\n  isDropped: boolean;\n  isPartial: boolean;\n  constructor(seqId: number, startTime: Types.Timing.Micro, isDropped: boolean, isPartial: boolean) {\n    this.seqId = seqId;\n    this.startTime = startTime;\n    this.isDropped = isDropped;\n    this.isPartial = isPartial;\n  }\n}\n\n/**\n * A queue of BeginFrames pending visualization.\n * BeginFrames are added into this queue as they occur; later when their\n * corresponding DrawFrames occur (or lack thereof), the BeginFrames are removed\n * from the queue and their timestamps are used for visualization.\n **/\nexport class TimelineFrameBeginFrameQueue {\n  private queueFrames: number[] = [];\n\n  // Maps frameSeqId to BeginFrameInfo.\n  private mapFrames: Record<number, BeginFrameInfo> = {};\n\n  // Add a BeginFrame to the queue, if it does not already exit.\n  addFrameIfNotExists(seqId: number, startTime: Types.Timing.Micro, isDropped: boolean, isPartial: boolean): void {\n    if (!(seqId in this.mapFrames)) {\n      this.mapFrames[seqId] = new BeginFrameInfo(seqId, startTime, isDropped, isPartial);\n      this.queueFrames.push(seqId);\n    }\n  }\n\n  // Set a BeginFrame in queue as dropped.\n  setDropped(seqId: number, isDropped: boolean): void {\n    if (seqId in this.mapFrames) {\n      this.mapFrames[seqId].isDropped = isDropped;\n    }\n  }\n\n  setPartial(seqId: number, isPartial: boolean): void {\n    if (seqId in this.mapFrames) {\n      this.mapFrames[seqId].isPartial = isPartial;\n    }\n  }\n\n  processPendingBeginFramesOnDrawFrame(seqId: number): BeginFrameInfo[] {\n    const framesToVisualize: BeginFrameInfo[] = [];\n\n    // Do not visualize this frame in the rare case where the current DrawFrame\n    // does not have a corresponding BeginFrame.\n    if (seqId in this.mapFrames) {\n      // Pop all BeginFrames before the current frame, and add only the dropped\n      // ones in |frames_to_visualize|.\n      // Non-dropped frames popped here are BeginFrames that are never\n      // drawn (but not considered dropped either for some reason).\n      // Those frames do not require an proactive visualization effort and will\n      // be naturally presented as continuationss of other frames.\n      while (this.queueFrames[0] !== seqId) {\n        const currentSeqId = this.queueFrames[0];\n        if (this.mapFrames[currentSeqId].isDropped) {\n          framesToVisualize.push(this.mapFrames[currentSeqId]);\n        }\n\n        delete this.mapFrames[currentSeqId];\n        this.queueFrames.shift();\n      }\n\n      // Pop the BeginFrame associated with the current DrawFrame.\n      framesToVisualize.push(this.mapFrames[seqId]);\n      delete this.mapFrames[seqId];\n      this.queueFrames.shift();\n    }\n    return framesToVisualize;\n  }\n}\n\nexport function framesWithinWindow(\n    frames: readonly Types.Events.LegacyTimelineFrame[], startTime: Types.Timing.Micro,\n    endTime: Types.Timing.Micro): Types.Events.LegacyTimelineFrame[] {\n  const firstFrame = Platform.ArrayUtilities.lowerBound(frames, startTime || 0, (time, frame) => time - frame.endTime);\n  const lastFrame =\n      Platform.ArrayUtilities.lowerBound(frames, endTime || Infinity, (time, frame) => time - frame.startTime);\n  return frames.slice(firstFrame, lastFrame);\n}\n", "// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {data as metaHandlerData} from './MetaHandler.js';\nimport type {HandlerName} from './types.js';\n\nlet paintEvents: Types.Events.Paint[] = [];\nlet snapshotEvents: Types.Events.DisplayItemListSnapshot[] = [];\nlet paintToSnapshotMap = new Map<Types.Events.Paint, Types.Events.DisplayItemListSnapshot>();\n\nlet lastPaintForLayerId: Record<number, Types.Events.Paint> = {};\n\nlet currentMainFrameLayerTreeId: number|null = null;\nlet updateLayerEvents: Types.Events.UpdateLayer[] = [];\n\ntype RelevantLayerTreeEvent =\n    Types.Events.Paint|Types.Events.DisplayItemListSnapshot|Types.Events.UpdateLayer|Types.Events.SetLayerTreeId;\n\nlet relevantEvents: RelevantLayerTreeEvent[] = [];\nexport function reset(): void {\n  paintEvents = [];\n  snapshotEvents = [];\n  paintToSnapshotMap = new Map();\n\n  lastPaintForLayerId = {};\n  currentMainFrameLayerTreeId = null;\n  updateLayerEvents = [];\n  relevantEvents = [];\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  // We gather up the events here but do all the processing in finalize(). This\n  // is because we need to have all the events before we process them, and we\n  // need the Meta handler to be finalized() so we can use its data as we need\n  // the mainFrameId to know which Layer(s) to care about.\n  if (Types.Events.isPaint(event) || Types.Events.isDisplayListItemListSnapshot(event) ||\n      Types.Events.isUpdateLayer(event) || Types.Events.isSetLayerId(event)) {\n    relevantEvents.push(event);\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  const metaData = metaHandlerData();\n  Helpers.Trace.sortTraceEventsInPlace(relevantEvents);\n\n  for (const event of relevantEvents) {\n    if (Types.Events.isSetLayerId(event)) {\n      if (metaData.mainFrameId !== event.args.data.frame) {\n        // We only care about LayerId changes that affect the main frame.\n        continue;\n      }\n      currentMainFrameLayerTreeId = event.args.data.layerTreeId;\n    } else if (Types.Events.isUpdateLayer(event)) {\n      // We don't do anything with this event, but we need to store it because\n      // the information in it determines if we need to care about future\n      // snapshot events - we need to know what the active layer is when we see a\n      // snapshot.\n      updateLayerEvents.push(event);\n    } else if (Types.Events.isPaint(event)) {\n      if (!event.args.data.layerId) {\n        // Note that this check purposefully includes excluding an event with a layerId of 0.\n        // 0 indicates that this paint was for a subframe - we do not want these\n        // as we only care about paints for top level frames.\n        continue;\n      }\n      paintEvents.push(event);\n      lastPaintForLayerId[event.args.data.layerId] = event;\n      continue;\n    } else if (Types.Events.isDisplayListItemListSnapshot(event)) {\n      // First we figure out which layer is active for this event's thread. To\n      // do this we work backwards through the list of UpdateLayerEvents,\n      // finding the first one (i.e. the most recent one) with the same pid and\n      // tid.\n      let lastUpdateLayerEventForThread: Types.Events.UpdateLayer|null = null;\n      for (let i = updateLayerEvents.length - 1; i > -1; i--) {\n        const updateEvent = updateLayerEvents[i];\n        if (updateEvent.pid === event.pid && updateEvent.tid === event.tid) {\n          lastUpdateLayerEventForThread = updateEvent;\n          break;\n        }\n      }\n      if (!lastUpdateLayerEventForThread) {\n        // No active layer, so this snapshot is not relevant.\n        continue;\n      }\n      if (lastUpdateLayerEventForThread.args.layerTreeId !== currentMainFrameLayerTreeId) {\n        // Snapshot applies to a layer that is not the main frame, so discard.\n        continue;\n      }\n      const paintEvent = lastPaintForLayerId[lastUpdateLayerEventForThread.args.layerId];\n      if (!paintEvent) {\n        // No paint event for this layer, so discard.\n        continue;\n      }\n      snapshotEvents.push(event);\n\n      // Store the relationship between the paint and the snapshot.\n      paintToSnapshotMap.set(paintEvent, event);\n    }\n  }\n}\n\nexport interface LayerTreeData {\n  paints: Types.Events.Paint[];\n  snapshots: Types.Events.DisplayItemListSnapshot[];\n  paintsToSnapshots: Map<Types.Events.Paint, Types.Events.DisplayItemListSnapshot>;\n}\n\nexport function data(): LayerTreeData {\n  return {\n    paints: paintEvents,\n    snapshots: snapshotEvents,\n    paintsToSnapshots: paintToSnapshotMap,\n  };\n}\n\nexport function deps(): HandlerName[] {\n  return ['Meta'];\n}\n", "// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n//\nimport type * as Helpers from '../helpers/helpers.js';\nimport type * as Types from '../types/types.js';\n\nimport type {AuctionWorkletsData} from './AuctionWorkletsHandler.js';\nimport type * as Renderer from './RendererHandler.js';\nimport type {HandlerData} from './types.js';\n\nexport interface ThreadData {\n  pid: Types.Events.ProcessID;\n  tid: Types.Events.ThreadID;\n  entries: readonly Types.Events.Event[];\n  processIsOnMainFrame: boolean;\n  tree: Helpers.TreeHelpers.TraceEntryTree;\n  type: ThreadType;\n  name: string|null;\n  entryToNode: Map<Types.Events.Event, Helpers.TreeHelpers.TraceEntryNode>;\n}\n\nexport const enum ThreadType {\n  MAIN_THREAD = 'MAIN_THREAD',\n  WORKER = 'WORKER',\n  RASTERIZER = 'RASTERIZER',\n  AUCTION_WORKLET = 'AUCTION_WORKLET',\n  OTHER = 'OTHER',\n  CPU_PROFILE = 'CPU_PROFILE',\n  THREAD_POOL = 'THREAD_POOL',\n}\n\nfunction getThreadTypeForRendererThread(\n    pid: Types.Events.ProcessID, thread: Renderer.RendererThread,\n    auctionWorkletsData: AuctionWorkletsData): ThreadType {\n  let threadType = ThreadType.OTHER;\n  if (thread.name === 'CrRendererMain') {\n    threadType = ThreadType.MAIN_THREAD;\n  } else if (thread.name === 'DedicatedWorker thread') {\n    threadType = ThreadType.WORKER;\n  } else if (thread.name?.startsWith('CompositorTileWorker')) {\n    threadType = ThreadType.RASTERIZER;\n  } else if (auctionWorkletsData.worklets.has(pid)) {\n    threadType = ThreadType.AUCTION_WORKLET;\n  } else if (thread.name?.startsWith('ThreadPool')) {\n    // TODO(paulirish): perhaps exclude ThreadPoolServiceThread entirely\n    threadType = ThreadType.THREAD_POOL;\n  }\n  return threadType;\n}\n\nexport function threadsInRenderer(\n    rendererData: Renderer.RendererHandlerData, auctionWorkletsData: AuctionWorkletsData): readonly ThreadData[] {\n  const foundThreads: ThreadData[] = [];\n  // If we have Renderer threads, we prefer to use those. In the event that a\n  // trace is a CPU Profile trace, we will never have Renderer threads, so we\n  // know if there are no Renderer threads that we can fallback to using the\n  // data from the SamplesHandler.\n  if (rendererData.processes.size) {\n    for (const [pid, process] of rendererData.processes) {\n      for (const [tid, thread] of process.threads) {\n        if (!thread.tree) {\n          // Drop threads where we could not create the tree; this indicates\n          // unexpected data and we won't be able to support all the UI\n          // filtering we need.\n          continue;\n        }\n        const threadType = getThreadTypeForRendererThread(pid, thread, auctionWorkletsData);\n        foundThreads.push({\n          name: thread.name,\n          pid,\n          tid,\n          processIsOnMainFrame: process.isOnMainFrame,\n          entries: thread.entries,\n          tree: thread.tree,\n          type: threadType,\n          entryToNode: rendererData.entryToNode,\n        });\n      }\n    }\n  }\n  return foundThreads;\n}\n\nconst threadsInHandlerDataCache = new WeakMap<HandlerData, readonly ThreadData[]>();\n\n/**\n * Given trace parsed data, this helper will return a high level array of\n * ThreadData. This is useful because it allows you to get a list of threads\n * regardless of if the trace is a CPU Profile or a Tracing profile. Thus you\n * can use this helper to iterate over threads in confidence that it will work\n * for both trace types.\n * The resulting data is cached per-trace, so you can safely call this multiple times.\n */\nexport function threadsInTrace(handlerData: HandlerData): readonly ThreadData[] {\n  const cached = threadsInHandlerDataCache.get(handlerData);\n  if (cached) {\n    return cached;\n  }\n\n  // If we have Renderer threads, we prefer to use those.\n  const threadsFromRenderer = threadsInRenderer(handlerData.Renderer, handlerData.AuctionWorklets);\n  if (threadsFromRenderer.length) {\n    threadsInHandlerDataCache.set(handlerData, threadsFromRenderer);\n    return threadsFromRenderer;\n  }\n\n  // If it's a CPU Profile trace, there will be no Renderer threads.\n  // We can fallback to using the data from the SamplesHandler.\n  const foundThreads: ThreadData[] = [];\n  if (handlerData.Samples.profilesInProcess.size) {\n    for (const [pid, process] of handlerData.Samples.profilesInProcess) {\n      for (const [tid, thread] of process) {\n        if (!thread.profileTree) {\n          // Drop threads where we could not create the tree; this indicates\n          // unexpected data and we won't be able to support all the UI\n          // filtering we need.\n          continue;\n        }\n\n        foundThreads.push({\n          pid,\n          tid,\n          // CPU Profile threads do not have a name.\n          name: null,\n          entries: thread.profileCalls,\n          // There is no concept of a \"Main Frame\" in a CPU profile.\n          processIsOnMainFrame: false,\n          tree: thread.profileTree,\n          type: ThreadType.CPU_PROFILE,\n          entryToNode: handlerData.Samples.entryToNode,\n        });\n      }\n    }\n  }\n\n  threadsInHandlerDataCache.set(handlerData, foundThreads);\n  return foundThreads;\n}\n", "// Copyright 2022 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {data as metaHandlerData} from './MetaHandler.js';\nimport type {HandlerName} from './types.js';\n\n// Each thread contains events. Events indicate the thread and process IDs, which are\n// used to store the event in the correct process thread entry below.\nlet eventsInProcessThread = new Map<Types.Events.ProcessID, Map<Types.Events.ThreadID, Types.Events.GPUTask[]>>();\n\nlet mainGPUThreadTasks: Types.Events.GPUTask[] = [];\n\nexport function reset(): void {\n  eventsInProcessThread = new Map();\n  mainGPUThreadTasks = [];\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (!Types.Events.isGPUTask(event)) {\n    return;\n  }\n\n  Helpers.Trace.addEventToProcessThread(event, eventsInProcessThread);\n}\n\nexport async function finalize(): Promise<void> {\n  const {gpuProcessId, gpuThreadId} = metaHandlerData();\n  const gpuThreadsForProcess = eventsInProcessThread.get(gpuProcessId);\n  if (gpuThreadsForProcess && gpuThreadId) {\n    mainGPUThreadTasks = gpuThreadsForProcess.get(gpuThreadId) || [];\n  }\n}\n\nexport interface GPUHandlerReturnData {\n  mainGPUThreadTasks: readonly Types.Events.GPUTask[];\n}\n\nexport function data(): GPUHandlerReturnData {\n  return {\n    mainGPUThreadTasks,\n  };\n}\n\nexport function deps(): HandlerName[] {\n  return ['Meta'];\n}\n", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Types from '../types/types.js';\n\nimport {data as metaHandlerData} from './MetaHandler.js';\nimport type {FinalizeOptions} from './types.js';\n\n/**\n * This handler is responsible for the relationships between:\n * DecodeImage/ResizeImage, PaintImage and DrawLazyPixelRef events.\n *\n * When we get a DecodeImage event, we want to associate it to a PaintImage\n * event, primarily so we can determine the NodeID of the image that was\n * decoded.\n * We can do this in two ways:\n *\n * 1. If there is a PaintImage event on the same thread, use that\n *    (if there are multiple, use the latest one).\n *\n * 2. If not, we can find the DecodeLazyPixelRef event on the same thread, and\n *    use the PaintImage event associated with it via the `LazyPixelRef` key.\n */\n\n// Track paintImageEvents across threads.\nlet paintImageEvents = new Map<Types.Events.ProcessID, Map<Types.Events.ThreadID, Types.Events.PaintImage[]>>();\nlet decodeLazyPixelRefEvents =\n    new Map<Types.Events.ProcessID, Map<Types.Events.ThreadID, Types.Events.DecodeLazyPixelRef[]>>();\n\n// A DrawLazyPixelRef event will contain a numerical reference in\n// args.LazyPixelRef. As we parse each DrawLazyPixelRef, we can assign it to a\n// paint event. Later we want to look up paint events by this reference, so we\n// store them in this map.\nlet paintImageByLazyPixelRef = new Map<number, Types.Events.PaintImage>();\n\n// When we find events that we want to tie to a particular PaintImage event, we add them to this map.\n// These are currently only DecodeImage and ResizeImage events, but the type is\n// deliberately generic as in the future we might want to add more events that\n// have a relationship to a individual PaintImage event.\nlet eventToPaintImage = new Map<Types.Events.Event, Types.Events.PaintImage>();\n\nlet urlToPaintImage = new Map<string, Types.Events.PaintImage[]>();\n\nlet paintEventToCorrectedDisplaySize = new Map<Types.Events.PaintImage, {width: number, height: number}>();\n\nlet didCorrectForHostDpr = false;\n\nexport function reset(): void {\n  paintImageEvents = new Map();\n  decodeLazyPixelRefEvents = new Map();\n  paintImageByLazyPixelRef = new Map();\n  eventToPaintImage = new Map();\n  urlToPaintImage = new Map();\n  paintEventToCorrectedDisplaySize = new Map();\n  didCorrectForHostDpr = false;\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isPaintImage(event)) {\n    const forProcess = paintImageEvents.get(event.pid) || new Map<Types.Events.ThreadID, Types.Events.PaintImage[]>();\n    const forThread = forProcess.get(event.tid) || [];\n    forThread.push(event);\n    forProcess.set(event.tid, forThread);\n    paintImageEvents.set(event.pid, forProcess);\n\n    if (event.args.data.url) {\n      const paintsForUrl = Platform.MapUtilities.getWithDefault(urlToPaintImage, event.args.data.url, () => []);\n      paintsForUrl.push(event);\n    }\n\n    return;\n  }\n\n  if (Types.Events.isDecodeLazyPixelRef(event) && typeof event.args?.LazyPixelRef !== 'undefined') {\n    // Store these because we use them to tie DecodeImage to a PaintEvent.\n    const forProcess =\n        decodeLazyPixelRefEvents.get(event.pid) || new Map<Types.Events.ThreadID, Types.Events.DecodeLazyPixelRef[]>();\n    const forThread = forProcess.get(event.tid) || [];\n    forThread.push(event);\n    forProcess.set(event.tid, forThread);\n    decodeLazyPixelRefEvents.set(event.pid, forProcess);\n  }\n\n  // If we see a DrawLazyPixelRef event, we need to find the last PaintImage\n  // event on the thread and associate it to the LazyPixelRef that is supplied\n  // in the DrawLazyPixelRef event.\n  // This means that later on if we see a DecodeLazyPixelRef event with the\n  // same LazyPixelRef key, we can find its associated PaintImage event by\n  // looking it up.\n  if (Types.Events.isDrawLazyPixelRef(event) && typeof event.args?.LazyPixelRef !== 'undefined') {\n    const lastPaintEvent = paintImageEvents.get(event.pid)?.get(event.tid)?.at(-1);\n    if (!lastPaintEvent) {\n      return;\n    }\n    paintImageByLazyPixelRef.set(event.args.LazyPixelRef, lastPaintEvent);\n    return;\n  }\n\n  if (Types.Events.isDecodeImage(event)) {\n    // When we see a DecodeImage, we want to associate it to a PaintImage\n    // event. We try two approaches:\n    //\n    // 1. If the thread of the DecodeImage event has a previous PaintImage\n    // event, that is the associated event.\n    //\n    // 2. If that is false, we then look on the thread for a DecodeLazyPixelRef\n    // event. If we find that, we then look for its associated PaintImage\n    // event, which we associate via DrawLazyPixelRef events (the code block\n    // above this one)\n    //\n    // 1. Find a PaintImage event on the same thread. If we find it, that's our association done.\n    const lastPaintImageEventOnThread = paintImageEvents.get(event.pid)?.get(event.tid)?.at(-1);\n    if (lastPaintImageEventOnThread) {\n      eventToPaintImage.set(event, lastPaintImageEventOnThread);\n      return;\n    }\n\n    // 2. Find the last DecodeLazyPixelRef event and, if we find it, find its associated PaintImage event.\n    const lastDecodeLazyPixelRef = decodeLazyPixelRefEvents.get(event.pid)?.get(event.tid)?.at(-1);\n    if (typeof lastDecodeLazyPixelRef?.args?.LazyPixelRef === 'undefined') {\n      return;\n    }\n\n    const paintEvent = paintImageByLazyPixelRef.get(lastDecodeLazyPixelRef.args.LazyPixelRef);\n    if (!paintEvent) {\n      return;\n    }\n    eventToPaintImage.set(event, paintEvent);\n  }\n}\n\nexport async function finalize(options: FinalizeOptions): Promise<void> {\n  // Painting in Chrome never uses the emulated DPR, but instead used the host's DPR.\n  // We need to correct for that for our responsive image checks in the ImageDelivery\n  // insight.\n  // See: crbug.com/427552461 crbug.com/416580500#comment5\n\n  if (!options.metadata?.hostDPR) {\n    return;\n  }\n\n  // Note: this isn't necessarily emulated (for desktop+no DPR emulation, it's equal\n  // to host DPR).\n  const {devicePixelRatio: emulatedDpr} = metaHandlerData();\n  if (!emulatedDpr) {\n    return;\n  }\n\n  for (const byThread of paintImageEvents.values()) {\n    for (const paintEvents of byThread.values()) {\n      for (const paintEvent of paintEvents) {\n        const cssPixelsWidth = paintEvent.args.data.width / options.metadata.hostDPR;\n        const cssPixelsHeight = paintEvent.args.data.height / options.metadata.hostDPR;\n        const width = cssPixelsWidth * emulatedDpr;\n        const height = cssPixelsHeight * emulatedDpr;\n        paintEventToCorrectedDisplaySize.set(paintEvent, {width, height});\n      }\n    }\n  }\n\n  didCorrectForHostDpr = true;\n}\n\nexport interface ImagePaintData {\n  paintImageByDrawLazyPixelRef: Map<number, Types.Events.PaintImage>;\n  paintImageForEvent: Map<Types.Events.Event, Types.Events.PaintImage>;\n  paintImageEventForUrl: Map<string, Types.Events.PaintImage[]>;\n  paintEventToCorrectedDisplaySize: Map<Types.Events.PaintImage, {width: number, height: number}>;\n  /** Go read the comment in finalize(). */\n  didCorrectForHostDpr: boolean;\n}\n\nexport function data(): ImagePaintData {\n  return {\n    paintImageByDrawLazyPixelRef: paintImageByLazyPixelRef,\n    paintImageForEvent: eventToPaintImage,\n    paintImageEventForUrl: urlToPaintImage,\n    paintEventToCorrectedDisplaySize,\n    didCorrectForHostDpr,\n  };\n}\n", "// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {data as AsyncJSCallsHandlerData} from './AsyncJSCallsHandler.js';\nimport {data as flowsHandlerData} from './FlowsHandler.js';\n\nlet lastScheduleStyleRecalcByFrame = new Map<string, Types.Events.ScheduleStyleRecalculation>();\n\n// This tracks the last event that is considered to have invalidated the layout\n// for a given frame.\n// Note that although there is an InvalidateLayout event, there are also other\n// events (ScheduleStyleRecalculation) that could be the reason a layout was\n// invalidated.\nlet lastInvalidationEventForFrame = new Map<string, Types.Events.Event>();\n\nlet lastRecalcByFrame = new Map<string, Types.Events.RecalcStyle>();\n\n// These two maps store the same data but in different directions.\n// For a given event, tell me what its initiator was. An event can only have one initiator.\nlet eventToInitiatorMap = new Map<Types.Events.Event, Types.Events.Event>();\n// For a given event, tell me what events it initiated. An event can initiate\n// multiple events, hence why the value for this map is an array.\nlet initiatorToEventsMap = new Map<Types.Events.Event, Types.Events.Event[]>();\n\nlet timerInstallEventsById = new Map<number, Types.Events.TimerInstall>();\nlet requestIdleCallbackEventsById = new Map<number, Types.Events.RequestIdleCallback>();\n\nlet webSocketCreateEventsById = new Map<number, Types.Events.WebSocketCreate>();\nlet schedulePostTaskCallbackEventsById = new Map<number, Types.Events.SchedulePostTaskCallback>();\n\nexport function reset(): void {\n  lastScheduleStyleRecalcByFrame = new Map();\n  lastInvalidationEventForFrame = new Map();\n  lastRecalcByFrame = new Map();\n  timerInstallEventsById = new Map();\n  eventToInitiatorMap = new Map();\n  initiatorToEventsMap = new Map();\n  requestIdleCallbackEventsById = new Map();\n  webSocketCreateEventsById = new Map();\n  schedulePostTaskCallbackEventsById = new Map();\n}\n\nfunction storeInitiator(data: {initiator: Types.Events.Event, event: Types.Events.Event}): void {\n  eventToInitiatorMap.set(data.event, data.initiator);\n  const eventsForInitiator = initiatorToEventsMap.get(data.initiator) || [];\n  eventsForInitiator.push(data.event);\n  initiatorToEventsMap.set(data.initiator, eventsForInitiator);\n}\n\n/**\n * IMPORTANT: Before adding support for new initiator relationships in\n * trace events consider using Perfetto's flow API on the events in\n * question, so that they get automatically computed.\n * @see {@link flowsHandlerData}\n *\n * The events manually computed here were added before we had support\n * for flow events. As such they should be migrated to use the flow\n * API so that no manual parsing is needed.\n */\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isScheduleStyleRecalculation(event)) {\n    lastScheduleStyleRecalcByFrame.set(event.args.data.frame, event);\n  } else if (Types.Events.isRecalcStyle(event)) {\n    if (event.args.beginData) {\n      // Store the last RecalcStyle event: we use this when we see an\n      // InvalidateLayout and try to figure out its initiator.\n      lastRecalcByFrame.set(event.args.beginData.frame, event);\n\n      // If this frame has seen a ScheduleStyleRecalc event, then that event is\n      // considered to be the initiator of this StylesRecalc.\n      const scheduledStyleForFrame = lastScheduleStyleRecalcByFrame.get(event.args.beginData.frame);\n      if (scheduledStyleForFrame) {\n        storeInitiator({\n          event,\n          initiator: scheduledStyleForFrame,\n        });\n      }\n    }\n  } else if (Types.Events.isInvalidateLayout(event)) {\n    // By default, the InvalidateLayout event is what triggered the layout invalidation for this frame.\n    let invalidationInitiator: Types.Events.Event = event;\n\n    // However, if we have not had any prior invalidations for this frame, we\n    // want to consider StyleRecalculation events as they might be the actual\n    // cause of this layout invalidation.\n    if (!lastInvalidationEventForFrame.has(event.args.data.frame)) {\n      // 1. If we have not had an invalidation event for this frame\n      // 2. AND we have had an RecalcStyle for this frame\n      // 3. AND the RecalcStyle event ended AFTER the InvalidateLayout startTime\n      // 4. AND we have an initiator for the RecalcStyle event\n      // 5. Then we set the last invalidation event for this frame to be the RecalcStyle's initiator.\n      const lastRecalcStyleForFrame = lastRecalcByFrame.get(event.args.data.frame);\n      if (lastRecalcStyleForFrame) {\n        const {endTime} = Helpers.Timing.eventTimingsMicroSeconds(lastRecalcStyleForFrame);\n        const initiatorOfRecalcStyle = eventToInitiatorMap.get(lastRecalcStyleForFrame);\n\n        if (initiatorOfRecalcStyle && endTime && endTime > event.ts) {\n          invalidationInitiator = initiatorOfRecalcStyle;\n        }\n      }\n    }\n    lastInvalidationEventForFrame.set(event.args.data.frame, invalidationInitiator);\n  } else if (Types.Events.isLayout(event)) {\n    // The initiator of a Layout event is the last Invalidation event.\n    const lastInvalidation = lastInvalidationEventForFrame.get(event.args.beginData.frame);\n    if (lastInvalidation) {\n      storeInitiator({\n        event,\n        initiator: lastInvalidation,\n      });\n    }\n    // Now clear the last invalidation for the frame: the last invalidation has been linked to a Layout event, so it cannot be the initiator for any future layouts.\n    lastInvalidationEventForFrame.delete(event.args.beginData.frame);\n  } else if (Types.Events.isTimerInstall(event)) {\n    timerInstallEventsById.set(event.args.data.timerId, event);\n  } else if (Types.Events.isTimerFire(event)) {\n    const matchingInstall = timerInstallEventsById.get(event.args.data.timerId);\n    if (matchingInstall) {\n      storeInitiator({event, initiator: matchingInstall});\n    }\n  } else if (Types.Events.isRequestIdleCallback(event)) {\n    requestIdleCallbackEventsById.set(event.args.data.id, event);\n  } else if (Types.Events.isFireIdleCallback(event)) {\n    const matchingRequestEvent = requestIdleCallbackEventsById.get(event.args.data.id);\n    if (matchingRequestEvent) {\n      storeInitiator({\n        event,\n        initiator: matchingRequestEvent,\n      });\n    }\n  } else if (Types.Events.isWebSocketCreate(event)) {\n    webSocketCreateEventsById.set(event.args.data.identifier, event);\n  } else if (Types.Events.isWebSocketInfo(event) || Types.Events.isWebSocketTransfer(event)) {\n    const matchingCreateEvent = webSocketCreateEventsById.get(event.args.data.identifier);\n    if (matchingCreateEvent) {\n      storeInitiator({\n        event,\n        initiator: matchingCreateEvent,\n      });\n    }\n  } else if (Types.Events.isSchedulePostTaskCallback(event)) {\n    schedulePostTaskCallbackEventsById.set(event.args.data.taskId, event);\n  } else if (Types.Events.isRunPostTaskCallback(event) || Types.Events.isAbortPostTaskCallback(event)) {\n    const matchingSchedule = schedulePostTaskCallbackEventsById.get(event.args.data.taskId);\n    if (matchingSchedule) {\n      storeInitiator({event, initiator: matchingSchedule});\n    }\n  }\n}\n\nfunction createRelationshipsFromFlows(): void {\n  const flows = flowsHandlerData().flows;\n  for (let i = 0; i < flows.length; i++) {\n    const flow = flows[i];\n    for (let j = 0; j < flow.length - 1; j++) {\n      storeInitiator({event: flow[j + 1], initiator: flow[j]});\n    }\n  }\n}\n\nfunction createRelationshipsFromAsyncJSCalls(): void {\n  const asyncCallEntries = AsyncJSCallsHandlerData().schedulerToRunEntryPoints.entries();\n  for (const [asyncCaller, asyncCallees] of asyncCallEntries) {\n    for (const asyncCallee of asyncCallees) {\n      storeInitiator({event: asyncCallee, initiator: asyncCaller});\n    }\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  createRelationshipsFromFlows();\n  createRelationshipsFromAsyncJSCalls();\n}\n\nexport interface InitiatorsData {\n  eventToInitiator: Map<Types.Events.Event, Types.Events.Event>;\n  initiatorToEvents: Map<Types.Events.Event, Types.Events.Event[]>;\n}\n\nexport function data(): InitiatorsData {\n  return {\n    eventToInitiator: eventToInitiatorMap,\n    initiatorToEvents: initiatorToEventsMap,\n  };\n}\n\nexport function deps(): ['Flows', 'AsyncJSCalls'] {\n  return ['Flows', 'AsyncJSCalls'];\n}\n", "// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Types from '../types/types.js';\n\n/**\n * @file Associates invalidation to recalc/layout events; mostly used in \"invalidation tracking\" experiment.\n * \"Invalidations\" == \"mutations\" == \"damage\".\n * A DOM change that means we need to recompute style or layout is an invalidation that's tracked here.\n * If the experiment `timeline-invalidation-tracking` is enabled, the `disabledByDefault('devtools.timeline.invalidationTracking')` trace category is enabled, which contains most of these events.\n */\n\ninterface InvalidationsStatePerFrame {\n  invalidationsForEvent: Map<Types.Events.Event, Types.Events.InvalidationTrackingEvent[]>;\n  invalidationCountForEvent: Map<Types.Events.Event, number>;\n  lastRecalcStyleEvent: Types.Events.RecalcStyle|null;\n  hasPainted: boolean;\n  pendingInvalidations: Types.Events.InvalidationTrackingEvent[];\n}\n\nconst frameStateByFrame = new Map<string, InvalidationsStatePerFrame>();\nlet maxInvalidationsPerEvent: number|null = null;\n\nexport function reset(): void {\n  frameStateByFrame.clear();\n  maxInvalidationsPerEvent = null;\n}\n\nexport function handleUserConfig(userConfig: Types.Configuration.Configuration): void {\n  maxInvalidationsPerEvent = userConfig.maxInvalidationEventsPerEvent;\n}\n\nfunction getState(frameId: string): InvalidationsStatePerFrame {\n  let frameState = frameStateByFrame.get(frameId);\n  if (!frameState) {\n    frameState = {\n      invalidationsForEvent: new Map(),\n      invalidationCountForEvent: new Map(),\n      lastRecalcStyleEvent: null,\n      pendingInvalidations: [],\n      hasPainted: false,\n    };\n    frameStateByFrame.set(frameId, frameState);\n  }\n  return frameState;\n}\n\nfunction getFrameId(event: Types.Events.Event): string|null {\n  if (Types.Events.isRecalcStyle(event) || Types.Events.isLayout(event)) {\n    return event.args.beginData?.frame ?? null;\n  }\n  return event.args?.data?.frame ?? null;\n}\n\nfunction addInvalidationToEvent(\n    frameState: InvalidationsStatePerFrame, event: Types.Events.Event,\n    invalidation: Types.Events.InvalidationTrackingEvent): void {\n  const existingInvalidations = frameState.invalidationsForEvent.get(event) || [];\n  existingInvalidations.push(invalidation);\n\n  if (maxInvalidationsPerEvent !== null && existingInvalidations.length > maxInvalidationsPerEvent) {\n    existingInvalidations.shift();\n  }\n  frameState.invalidationsForEvent.set(event, existingInvalidations);\n\n  const count = frameState.invalidationCountForEvent.get(event) ?? 0;\n  frameState.invalidationCountForEvent.set(event, count + 1);\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  // Special case: if we have been configured to not store any invalidations,\n  // we take that as a sign that we don't even want to gather any invalidations\n  // data at all and early exit.\n  if (maxInvalidationsPerEvent === 0) {\n    return;\n  }\n\n  const frameId = getFrameId(event);\n  if (!frameId) {\n    return;\n  }\n  const thisFrame = getState(frameId);\n\n  if (Types.Events.isRecalcStyle(event)) {\n    thisFrame.lastRecalcStyleEvent = event;\n\n    // Associate any prior invalidations with this recalc event.\n    for (const invalidation of thisFrame.pendingInvalidations) {\n      if (Types.Events.isLayoutInvalidationTracking(invalidation)) {\n        // LayoutInvalidation events cannot be associated with a LayoutTree\n        // event.\n        continue;\n      }\n      addInvalidationToEvent(thisFrame, event, invalidation);\n    }\n    return;\n  }\n\n  if (Types.Events.isInvalidationTracking(event)) {\n    if (thisFrame.hasPainted) {\n      // If we have painted, then we can clear out the list of all existing\n      // invalidations, as we cannot associate them across frames.\n      thisFrame.pendingInvalidations.length = 0;\n      thisFrame.lastRecalcStyleEvent = null;\n      thisFrame.hasPainted = false;\n    }\n\n    // Style invalidation events can occur before and during recalc styles. When we get a recalc style event, we check and associate any prior invalidations with it.\n    // But any invalidations that occur during a RecalcStyle\n    // event would be reported in trace events after. So each time we get an\n    // invalidation that might be due to a style recalc, we check if the\n    // timings overlap and if so associate them.\n    if (thisFrame.lastRecalcStyleEvent &&\n        (Types.Events.isScheduleStyleInvalidationTracking(event) ||\n         Types.Events.isStyleRecalcInvalidationTracking(event) ||\n         Types.Events.isStyleInvalidatorInvalidationTracking(event))) {\n      const recalcLastRecalc = thisFrame.lastRecalcStyleEvent;\n      const recalcEndTime = recalcLastRecalc.ts + (recalcLastRecalc.dur || 0);\n      if (event.ts >= recalcLastRecalc.ts && event.ts <= recalcEndTime) {\n        addInvalidationToEvent(thisFrame, recalcLastRecalc, event);\n      }\n    }\n\n    thisFrame.pendingInvalidations.push(event);\n    return;\n  }\n\n  if (Types.Events.isPaint(event)) {\n    thisFrame.hasPainted = true;\n    return;\n  }\n\n  if (Types.Events.isLayout(event)) {\n    for (const invalidation of thisFrame.pendingInvalidations) {\n      // The only invalidations that cause a Layout are LayoutInvalidations :)\n      if (!Types.Events.isLayoutInvalidationTracking(invalidation)) {\n        continue;\n      }\n      addInvalidationToEvent(thisFrame, event, invalidation);\n    }\n  }\n}\n\nexport async function finalize(): Promise<void> {\n}\n\ninterface InvalidationsData {\n  invalidationsForEvent: Map<Types.Events.Event, Types.Events.InvalidationTrackingEvent[]>;\n  invalidationCountForEvent: Map<Types.Events.Event, number>;\n}\n\nexport function data(): InvalidationsData {\n  const invalidationsForEvent = new Map<Types.Events.Event, Types.Events.InvalidationTrackingEvent[]>();\n  const invalidationCountForEvent = new Map<Types.Events.Event, number>();\n  for (const frame of frameStateByFrame.values()) {\n    for (const [event, invalidations] of frame.invalidationsForEvent.entries()) {\n      invalidationsForEvent.set(event, invalidations);\n    }\n    for (const [event, count] of frame.invalidationCountForEvent.entries()) {\n      invalidationCountForEvent.set(event, count);\n    }\n  }\n  return {\n    invalidationsForEvent,\n    invalidationCountForEvent,\n  };\n}\n", "// Copyright 2022 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport type * as Protocol from '../../../generated/protocol.js';\nimport * as Types from '../types/types.js';\n\nimport {data as metaData} from './MetaHandler.js';\nimport {data as networkRequestsData} from './NetworkRequestsHandler.js';\nimport {data as pageLoadMetricsData, MetricName} from './PageLoadMetricsHandler.js';\nimport type {HandlerName} from './types.js';\n\n/**\n * If the LCP resource was an image, and that image was fetched over the\n * network, we want to be able to find the network request in order to construct\n * the critical path for an LCP image.\n * Within the trace file there are `LargestImagePaint::Candidate` events.\n * Within their data object, they contain a `DOMNodeId` property, which maps to\n * the DOM Node ID for that image.\n *\n * This id maps exactly to the `data.nodeId` property that a\n * `LargestContentfulPaint::Candidate` will have. So, when we find an image\n * paint candidate, we can store it, keying it on the node ID.\n * Then, when it comes to finding the network request for an LCP image, we can\n * use the nodeId from the LCP candidate to find the image candidate. That image\n * candidate also contains a `imageUrl` property, which will have the full URL\n * to the image.\n *\n * `BackendNodeId`s are only unique within a given renderer process, so this is\n * also keyed on `ProcessId`.\n **/\nlet imagePaintsByNodeIdAndProcess =\n    new Map<Types.Events.ProcessID, Map<Protocol.DOM.BackendNodeId, Types.Events.LargestImagePaintCandidate>>();\nlet lcpRequestByNavigationId = new Map<string, Types.Events.SyntheticNetworkRequest>();\n\nexport function reset(): void {\n  imagePaintsByNodeIdAndProcess = new Map();\n  lcpRequestByNavigationId = new Map();\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (!Types.Events.isLargestImagePaintCandidate(event) || !event.args.data) {\n    return;\n  }\n\n  const imagePaintsByNodeId =\n      Platform.MapUtilities.getWithDefault(imagePaintsByNodeIdAndProcess, event.pid, () => new Map());\n  imagePaintsByNodeId.set(event.args.data.DOMNodeId, event);\n}\n\nexport async function finalize(): Promise<void> {\n  const requests = networkRequestsData().byTime;\n  const {traceBounds, navigationsByNavigationId} = metaData();\n  const metricScoresByFrameId = pageLoadMetricsData().metricScoresByFrameId;\n\n  for (const [navigationId, navigation] of navigationsByNavigationId) {\n    const lcpMetric = metricScoresByFrameId.get(navigation.args.frame)?.get(navigationId)?.get(MetricName.LCP);\n    const lcpEvent = lcpMetric?.event;\n    if (!lcpEvent || !Types.Events.isLargestContentfulPaintCandidate(lcpEvent)) {\n      continue;\n    }\n\n    const nodeId = lcpEvent.args.data?.nodeId;\n    if (!nodeId) {\n      continue;\n    }\n\n    const lcpImagePaintEvent = imagePaintsByNodeIdAndProcess.get(lcpEvent.pid)?.get(nodeId);\n    const lcpUrl = lcpImagePaintEvent?.args.data?.imageUrl;\n    if (!lcpUrl) {\n      continue;\n    }\n\n    const startTime = navigation?.ts ?? traceBounds.min;\n    const endTime = lcpImagePaintEvent.ts;\n\n    let lcpRequest;\n    for (const request of requests) {\n      if (request.ts < startTime) {\n        continue;\n      }\n      if (request.ts >= endTime) {\n        break;\n      }\n\n      if (request.args.data.url === lcpUrl || request.args.data.redirects.some(r => r.url === lcpUrl)) {\n        lcpRequest = request;\n        break;\n      }\n    }\n\n    if (lcpRequest) {\n      lcpRequestByNavigationId.set(navigationId, lcpRequest);\n    }\n  }\n}\n\nexport interface LargestImagePaintData {\n  lcpRequestByNavigationId: Map<string, Types.Events.SyntheticNetworkRequest>;\n}\n\nexport function data(): LargestImagePaintData {\n  return {lcpRequestByNavigationId};\n}\n\nexport function deps(): HandlerName[] {\n  return ['Meta', 'NetworkRequests', 'PageLoadMetrics'];\n}\n", "// Copyright 2022 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/**\n * This handler stores page load metrics, including web vitals,\n * and exports them in the shape of a map with the following shape:\n * Map(FrameId -> Map(navigationID -> metrics) )\n *\n * It also exports all markers in a trace in an array.\n *\n * Some metrics are taken directly from a page load events (AKA markers) like DCL.\n * Others require processing multiple events to be determined, like CLS and TBT.\n */\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {data as metaHandlerData} from './MetaHandler.js';\nimport type {HandlerName} from './types.js';\n\n// Small helpers to make the below type easier to read.\ntype FrameId = string;\ntype NavigationId = string;\n/**\n * This represents the metric scores for all navigations, for all frames in a trace.\n * Given a frame id, the map points to another map from navigation id to metric scores.\n * The metric scores include the event related to the metric as well as the data regarding\n * the score itself.\n */\nlet metricScoresByFrameId = new Map<FrameId, Map<NavigationId, Map<MetricName, MetricScore>>>();\n\n/**\n * Page load events with no associated duration that happened in the\n * main frame.\n */\nlet allMarkerEvents: Types.Events.PageLoadEvent[] = [];\n\nexport function reset(): void {\n  metricScoresByFrameId = new Map();\n  pageLoadEventsArray = [];\n  allMarkerEvents = [];\n  selectedLCPCandidateEvents = new Set();\n}\n\nlet pageLoadEventsArray: Types.Events.PageLoadEvent[] = [];\n\n// Once we've found the LCP events in the trace we want to fetch their DOM Node\n// from the backend. We could do this by parsing through our Map of frame =>\n// navigation => metric, but it's easier to keep a set of LCP events. As we\n// parse the trace, any time we store an LCP candidate as the potential LCP\n// event, we store the event here. If we later find a new candidate in the\n// trace, we store that and delete the prior event. When we've parsed the\n// entire trace this set will contain all the LCP events that were used - e.g.\n// the candidates that were the actual LCP events.\nlet selectedLCPCandidateEvents = new Set<Types.Events.LargestContentfulPaintCandidate>();\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (!Types.Events.eventIsPageLoadEvent(event)) {\n    return;\n  }\n  pageLoadEventsArray.push(event);\n}\n\nfunction storePageLoadMetricAgainstNavigationId(\n    navigation: Types.Events.NavigationStart, event: Types.Events.PageLoadEvent): void {\n  const navigationId = navigation.args.data?.navigationId;\n  if (!navigationId) {\n    throw new Error('Navigation event unexpectedly had no navigation ID.');\n  }\n  const frameId = getFrameIdForPageLoadEvent(event);\n  const {rendererProcessesByFrame} = metaHandlerData();\n\n  // If either of these pieces of data do not exist, the most likely\n  // explanation is that the page load metric we found is for a frame/process\n  // combo that the MetaHandler discarded. This typically happens if we get a\n  // navigation event with an empty URL. Therefore, we will silently return and\n  // drop this metric. If we didn't care about the navigation, we certainly do\n  // not need to care about metrics for that navigation.\n  const rendererProcessesInFrame = rendererProcessesByFrame.get(frameId);\n  if (!rendererProcessesInFrame) {\n    return;\n  }\n  const processData = rendererProcessesInFrame.get(event.pid);\n  if (!processData) {\n    return;\n  }\n\n  if (Types.Events.isNavigationStart(event)) {\n    return;\n  }\n\n  if (Types.Events.isFirstContentfulPaint(event)) {\n    const fcpTime = Types.Timing.Micro(event.ts - navigation.ts);\n    const classification = scoreClassificationForFirstContentfulPaint(fcpTime);\n    const metricScore = {event, metricName: MetricName.FCP, classification, navigation, timing: fcpTime};\n    storeMetricScore(frameId, navigationId, metricScore);\n    return;\n  }\n\n  if (Types.Events.isFirstPaint(event)) {\n    const paintTime = Types.Timing.Micro(event.ts - navigation.ts);\n    const classification = ScoreClassification.UNCLASSIFIED;\n    const metricScore = {event, metricName: MetricName.FP, classification, navigation, timing: paintTime};\n    storeMetricScore(frameId, navigationId, metricScore);\n    return;\n  }\n\n  if (Types.Events.isMarkDOMContent(event)) {\n    const dclTime = Types.Timing.Micro(event.ts - navigation.ts);\n    const metricScore = {\n      event,\n      metricName: MetricName.DCL,\n      classification: scoreClassificationForDOMContentLoaded(dclTime),\n      navigation,\n      timing: dclTime,\n    };\n    storeMetricScore(frameId, navigationId, metricScore);\n    return;\n  }\n\n  if (Types.Events.isInteractiveTime(event)) {\n    const ttiValue = Types.Timing.Micro(event.ts - navigation.ts);\n    const tti = {\n      event,\n      metricName: MetricName.TTI,\n      classification: scoreClassificationForTimeToInteractive(ttiValue),\n      navigation,\n      timing: ttiValue,\n    };\n    storeMetricScore(frameId, navigationId, tti);\n\n    const tbtValue = Helpers.Timing.milliToMicro(Types.Timing.Milli(event.args.args.total_blocking_time_ms));\n    const tbt = {\n      event,\n      metricName: MetricName.TBT,\n      classification: scoreClassificationForTotalBlockingTime(tbtValue),\n      navigation,\n      timing: tbtValue,\n    };\n    storeMetricScore(frameId, navigationId, tbt);\n    return;\n  }\n\n  if (Types.Events.isMarkLoad(event)) {\n    const loadTime = Types.Timing.Micro(event.ts - navigation.ts);\n    const metricScore = {\n      event,\n      metricName: MetricName.L,\n      classification: ScoreClassification.UNCLASSIFIED,\n      navigation,\n      timing: loadTime,\n    };\n    storeMetricScore(frameId, navigationId, metricScore);\n    return;\n  }\n\n  if (Types.Events.isLargestContentfulPaintCandidate(event)) {\n    const candidateIndex = event.args.data?.candidateIndex;\n    if (!candidateIndex) {\n      throw new Error('Largest Contentful Paint unexpectedly had no candidateIndex.');\n    }\n    const lcpTime = Types.Timing.Micro(event.ts - navigation.ts);\n    const lcp = {\n      event,\n      metricName: MetricName.LCP,\n      classification: scoreClassificationForLargestContentfulPaint(lcpTime),\n      navigation,\n      timing: lcpTime,\n    };\n    const metricsByNavigation = Platform.MapUtilities.getWithDefault(metricScoresByFrameId, frameId, () => new Map());\n    const metrics = Platform.MapUtilities.getWithDefault(metricsByNavigation, navigationId, () => new Map());\n    const lastLCPCandidate = metrics.get(MetricName.LCP);\n    if (lastLCPCandidate === undefined) {\n      selectedLCPCandidateEvents.add(lcp.event);\n      storeMetricScore(frameId, navigationId, lcp);\n      return;\n    }\n    const lastLCPCandidateEvent = lastLCPCandidate.event;\n\n    if (!Types.Events.isLargestContentfulPaintCandidate(lastLCPCandidateEvent)) {\n      return;\n    }\n    const lastCandidateIndex = lastLCPCandidateEvent.args.data?.candidateIndex;\n    if (!lastCandidateIndex) {\n      // lastCandidateIndex cannot be undefined because we don't store candidates with\n      // with an undefined candidateIndex value. This check is only to make TypeScript\n      // treat the field as not undefined below.\n      return;\n    }\n    if (lastCandidateIndex < candidateIndex) {\n      selectedLCPCandidateEvents.delete(lastLCPCandidateEvent);\n      selectedLCPCandidateEvents.add(lcp.event);\n      storeMetricScore(frameId, navigationId, lcp);\n    }\n    return;\n  }\n  if (Types.Events.isLayoutShift(event)) {\n    return;\n  }\n  return Platform.assertNever(event, `Unexpected event type: ${event}`);\n}\n\nfunction storeMetricScore(frameId: string, navigationId: string, metricScore: MetricScore): void {\n  const metricsByNavigation = Platform.MapUtilities.getWithDefault(metricScoresByFrameId, frameId, () => new Map());\n  const metrics = Platform.MapUtilities.getWithDefault(metricsByNavigation, navigationId, () => new Map());\n  // If an entry with that metric name is present, delete it so that the new entry that\n  // will replace it is added at the end of the map. This way we guarantee the map entries\n  // are ordered in ASC manner by timestamp.\n  metrics.delete(metricScore.metricName);\n  metrics.set(metricScore.metricName, metricScore);\n}\n\nexport function getFrameIdForPageLoadEvent(event: Types.Events.PageLoadEvent): string {\n  if (Types.Events.isFirstContentfulPaint(event) || Types.Events.isInteractiveTime(event) ||\n      Types.Events.isLargestContentfulPaintCandidate(event) || Types.Events.isNavigationStart(event) ||\n      Types.Events.isLayoutShift(event) || Types.Events.isFirstPaint(event)) {\n    return event.args.frame;\n  }\n  if (Types.Events.isMarkDOMContent(event) || Types.Events.isMarkLoad(event)) {\n    const frameId = event.args.data?.frame;\n    if (!frameId) {\n      throw new Error('MarkDOMContent unexpectedly had no frame ID.');\n    }\n    return frameId;\n  }\n  Platform.assertNever(event, `Unexpected event type: ${event}`);\n}\n\nfunction getNavigationForPageLoadEvent(event: Types.Events.PageLoadEvent): Types.Events.NavigationStart|null {\n  if (Types.Events.isFirstContentfulPaint(event) || Types.Events.isLargestContentfulPaintCandidate(event) ||\n      Types.Events.isFirstPaint(event)) {\n    const navigationId = event.args.data?.navigationId;\n    if (!navigationId) {\n      throw new Error('Trace event unexpectedly had no navigation ID.');\n    }\n    const {navigationsByNavigationId} = metaHandlerData();\n    const navigation = navigationsByNavigationId.get(navigationId);\n\n    if (!navigation) {\n      // This event's navigation has been filtered out by the meta handler as a noise event.\n      return null;\n    }\n    return navigation;\n  }\n\n  if (Types.Events.isMarkDOMContent(event) || Types.Events.isInteractiveTime(event) ||\n      Types.Events.isLayoutShift(event) || Types.Events.isMarkLoad(event)) {\n    const frameId = getFrameIdForPageLoadEvent(event);\n    const {navigationsByFrameId} = metaHandlerData();\n    return Helpers.Trace.getNavigationForTraceEvent(event, frameId, navigationsByFrameId);\n  }\n\n  if (Types.Events.isNavigationStart(event)) {\n    // We don't want to compute metrics of the navigation relative to itself, so we'll avoid avoid all that.\n    return null;\n  }\n\n  return Platform.assertNever(event, `Unexpected event type: ${event}`);\n}\n\n/**\n * Classifications sourced from\n * https://web.dev/fcp/\n */\nexport function scoreClassificationForFirstContentfulPaint(fcpScoreInMicroseconds: Types.Timing.Micro):\n    ScoreClassification {\n  const FCP_GOOD_TIMING = Helpers.Timing.secondsToMicro(Types.Timing.Seconds(1.8));\n  const FCP_MEDIUM_TIMING = Helpers.Timing.secondsToMicro(Types.Timing.Seconds(3.0));\n  let scoreClassification = ScoreClassification.BAD;\n  if (fcpScoreInMicroseconds <= FCP_MEDIUM_TIMING) {\n    scoreClassification = ScoreClassification.OK;\n  }\n  if (fcpScoreInMicroseconds <= FCP_GOOD_TIMING) {\n    scoreClassification = ScoreClassification.GOOD;\n  }\n  return scoreClassification;\n}\n\n/**\n * Classifications sourced from\n * https://web.dev/interactive/#how-lighthouse-determines-your-tti-score\n */\n\nexport function scoreClassificationForTimeToInteractive(ttiTimeInMicroseconds: Types.Timing.Micro):\n    ScoreClassification {\n  const TTI_GOOD_TIMING = Helpers.Timing.secondsToMicro(Types.Timing.Seconds(3.8));\n  const TTI_MEDIUM_TIMING = Helpers.Timing.secondsToMicro(Types.Timing.Seconds(7.3));\n  let scoreClassification = ScoreClassification.BAD;\n  if (ttiTimeInMicroseconds <= TTI_MEDIUM_TIMING) {\n    scoreClassification = ScoreClassification.OK;\n  }\n  if (ttiTimeInMicroseconds <= TTI_GOOD_TIMING) {\n    scoreClassification = ScoreClassification.GOOD;\n  }\n  return scoreClassification;\n}\n\n/**\n * Classifications sourced from\n * https://web.dev/lcp/#what-is-lcp\n */\n\nexport function scoreClassificationForLargestContentfulPaint(lcpTimeInMicroseconds: Types.Timing.Micro):\n    ScoreClassification {\n  const LCP_GOOD_TIMING = Helpers.Timing.secondsToMicro(Types.Timing.Seconds(2.5));\n  const LCP_MEDIUM_TIMING = Helpers.Timing.secondsToMicro(Types.Timing.Seconds(4));\n  let scoreClassification = ScoreClassification.BAD;\n  if (lcpTimeInMicroseconds <= LCP_MEDIUM_TIMING) {\n    scoreClassification = ScoreClassification.OK;\n  }\n  if (lcpTimeInMicroseconds <= LCP_GOOD_TIMING) {\n    scoreClassification = ScoreClassification.GOOD;\n  }\n  return scoreClassification;\n}\n\n/**\n * DCL does not have a classification.\n */\nexport function scoreClassificationForDOMContentLoaded(_dclTimeInMicroseconds: Types.Timing.Micro):\n    ScoreClassification {\n  return ScoreClassification.UNCLASSIFIED;\n}\n\n/**\n * Classifications sourced from\n * https://web.dev/lighthouse-total-blocking-#time/\n */\n\nexport function scoreClassificationForTotalBlockingTime(tbtTimeInMicroseconds: Types.Timing.Micro):\n    ScoreClassification {\n  const TBT_GOOD_TIMING = Helpers.Timing.milliToMicro(Types.Timing.Milli(200));\n  const TBT_MEDIUM_TIMING = Helpers.Timing.milliToMicro(Types.Timing.Milli(600));\n  let scoreClassification = ScoreClassification.BAD;\n  if (tbtTimeInMicroseconds <= TBT_MEDIUM_TIMING) {\n    scoreClassification = ScoreClassification.OK;\n  }\n  if (tbtTimeInMicroseconds <= TBT_GOOD_TIMING) {\n    scoreClassification = ScoreClassification.GOOD;\n  }\n  return scoreClassification;\n}\n\n/**\n * Gets all the Largest Contentful Paint scores of all the frames in the\n * trace.\n */\nfunction gatherFinalLCPEvents(): Types.Events.PageLoadEvent[] {\n  const allFinalLCPEvents: Types.Events.PageLoadEvent[] = [];\n  const dataForAllFrames = [...metricScoresByFrameId.values()];\n  const dataForAllNavigations = dataForAllFrames.flatMap(frameData => [...frameData.values()]);\n  for (let i = 0; i < dataForAllNavigations.length; i++) {\n    const navigationData = dataForAllNavigations[i];\n    const lcpInNavigation = navigationData.get(MetricName.LCP);\n    if (!lcpInNavigation?.event) {\n      continue;\n    }\n\n    allFinalLCPEvents.push(lcpInNavigation.event);\n  }\n  return allFinalLCPEvents;\n}\n\nexport async function finalize(): Promise<void> {\n  pageLoadEventsArray.sort((a, b) => a.ts - b.ts);\n\n  for (const pageLoadEvent of pageLoadEventsArray) {\n    const navigation = getNavigationForPageLoadEvent(pageLoadEvent);\n    if (navigation) {\n      // Event's navigation was not filtered out as noise.\n      storePageLoadMetricAgainstNavigationId(navigation, pageLoadEvent);\n    }\n  }\n  // NOTE: if you are looking for the TBT calculation, it has temporarily been\n  // removed. See crbug.com/1424335 for details.\n  const allFinalLCPEvents = gatherFinalLCPEvents();\n  const mainFrame = metaHandlerData().mainFrameId;\n  // Filter out LCP candidates to use only definitive LCP values\n  const allEventsButLCP = pageLoadEventsArray.filter(event => !Types.Events.isLargestContentfulPaintCandidate(event));\n  const markerEvents = [...allFinalLCPEvents, ...allEventsButLCP].filter(Types.Events.isMarkerEvent);\n  // Filter by main frame and sort.\n  allMarkerEvents =\n      markerEvents.filter(event => getFrameIdForPageLoadEvent(event) === mainFrame).sort((a, b) => a.ts - b.ts);\n}\n\nexport interface PageLoadMetricsData {\n  /**\n   * This represents the metric scores for all navigations, for all frames in a trace.\n   * Given a frame id, the map points to another map from navigation id to metric scores.\n   * The metric scores include the event related to the metric as well as the data regarding\n   * the score itself.\n   */\n  metricScoresByFrameId: Map<string, Map<string, Map<MetricName, MetricScore>>>;\n  /**\n   * Page load events with no associated duration that happened in the\n   * main frame.\n   */\n  allMarkerEvents: Types.Events.PageLoadEvent[];\n}\n\nexport function data(): PageLoadMetricsData {\n  return {\n    metricScoresByFrameId,\n    allMarkerEvents,\n  };\n}\n\nexport function deps(): HandlerName[] {\n  return ['Meta'];\n}\n\nexport const enum ScoreClassification {\n  GOOD = 'good',\n  OK = 'ok',\n  BAD = 'bad',\n  // Some metrics (such as DOMContentLoaded) don't have a Good/OK/Bad classification, hence this additional entry.\n  UNCLASSIFIED = 'unclassified',\n}\n\nexport const enum MetricName {\n  // First Contentful Paint\n  FCP = 'FCP',\n  // First Paint\n  FP = 'FP',\n  // MarkLoad\n  L = 'L',\n  LCP = 'LCP',\n  // Mark DOM Content\n  DCL = 'DCL',\n  // Time To Interactive\n  TTI = 'TTI',\n  // Total Blocking Time\n  TBT = 'TBT',\n  // Cumulative Layout Shift\n  CLS = 'CLS',\n  // Navigation\n  NAV = 'Nav',\n  // Note: INP is handled in UserInteractionsHandler\n}\n\nexport interface MetricScore {\n  metricName: MetricName;\n  classification: ScoreClassification;\n  event?: Types.Events.PageLoadEvent;\n  // The last navigation that occurred before this metric score.\n  navigation?: Types.Events.NavigationStart;\n  estimated?: boolean;\n  timing: Types.Timing.Micro;\n}\n\nexport type LCPMetricScore = MetricScore&{\n  event: Types.Events.LargestContentfulPaintCandidate,\n  metricName: MetricName.LCP,\n};\n\nexport function metricIsLCP(metric: MetricScore): metric is LCPMetricScore {\n  return metric.metricName === MetricName.LCP;\n}\n", "// Copyright 2022 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Protocol from '../../../generated/protocol.js';\nimport * as Types from '../types/types.js';\n/**\n * A trace file will contain all the text paints that were candidates for the\n * LargestTextPaint. If an LCP event is text, it will point to one of these\n * candidates, so we store them by their DOM Node ID.\n **/\nlet textPaintByDOMNodeId = new Map<Protocol.DOM.BackendNodeId, Types.Events.LargestTextPaintCandidate>();\n\nexport function reset(): void {\n  textPaintByDOMNodeId = new Map();\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (!Types.Events.isLargestTextPaintCandidate(event)) {\n    return;\n  }\n\n  if (!event.args.data) {\n    return;\n  }\n\n  textPaintByDOMNodeId.set(event.args.data.DOMNodeId, event);\n}\n\nexport async function finalize(): Promise<void> {\n}\n\nexport function data(): Map<Protocol.DOM.BackendNodeId, Types.Events.LargestTextPaintCandidate> {\n  return textPaintByDOMNodeId;\n}\n", "// Copyright 2022 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport type * as Protocol from '../../../generated/protocol.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {data as metaHandlerData} from './MetaHandler.js';\nimport {ScoreClassification} from './PageLoadMetricsHandler.js';\nimport {data as screenshotsHandlerData} from './ScreenshotsHandler.js';\nimport type {HandlerName} from './types.js';\n\n// We start with a score of zero and step through all Layout Shift records from\n// all renderers. Each record not only tells us which renderer it is, but also\n// the unweighted and weighted scores. The unweighted score is the score we would\n// get if the renderer were the only one in the viewport. The weighted score, on\n// the other hand, accounts for how much of the viewport that particular render\n// takes up when the shift happened. An ad frame in the corner of the viewport\n// that shifts is considered less disruptive, therefore, than if it were taking\n// up the whole viewport.\n//\n// Next, we step through all the records from all renderers and add the weighted\n// score to a running total across all of the renderers. We create a new \"cluster\"\n// and reset the running total when:\n//\n// 1. We observe a outermost frame navigation, or\n// 2. When there's a gap between records of > 1s, or\n// 3. When there's more than 5 seconds of continuous layout shifting.\n//\n// Note that for it to be Cumulative Layout Shift in the sense described in the\n// documentation we would need to guarantee that we are tracking from navigation\n// to unload. However, we don't make any such guarantees here (since a developer\n// can record and stop when they please), so we support the cluster approach,\n// and we can give them a score, but it is effectively a \"session\" score, a\n// score for the given recording, and almost certainly not the\n// navigation-to-unload CLS score.\n\ninterface LayoutShiftsData {\n  clusters: readonly Types.Events.SyntheticLayoutShiftCluster[];\n  clustersByNavigationId: Map<Types.Events.NavigationId, Types.Events.SyntheticLayoutShiftCluster[]>;\n  sessionMaxScore: number;\n  // The session window which contains the SessionMaxScore\n  clsWindowID: number;\n  // We use these to calculate root causes for a given LayoutShift\n  prePaintEvents: readonly Types.Events.PrePaint[];\n  paintImageEvents: Types.Events.PaintImage[];\n  layoutInvalidationEvents: readonly Types.Events.LayoutInvalidationTracking[];\n  scheduleStyleInvalidationEvents: readonly Types.Events.ScheduleStyleInvalidationTracking[];\n  styleRecalcInvalidationEvents: readonly Types.Events.StyleRecalcInvalidationTracking[];\n  renderFrameImplCreateChildFrameEvents: readonly Types.Events.RenderFrameImplCreateChildFrame[];\n  domLoadingEvents: readonly Types.Events.DomLoading[];\n  layoutImageUnsizedEvents: readonly Types.Events.LayoutImageUnsized[];\n  remoteFonts: readonly RemoteFont[];\n  scoreRecords: readonly ScoreRecord[];\n  backendNodeIds: Set<Protocol.DOM.BackendNodeId>;\n}\n\ninterface RemoteFont {\n  display: string;\n  url?: string;\n  name?: string;\n  beginRemoteFontLoadEvent: Types.Events.BeginRemoteFontLoad;\n}\n\n/**\n * This represents the maximum #time we will allow a cluster to go before we\n * reset it.\n **/\nexport const MAX_CLUSTER_DURATION = Helpers.Timing.milliToMicro(Types.Timing.Milli(5000));\n\n/**\n * This represents the maximum #time we will allow between layout shift events\n * before considering it to be the start of a new cluster.\n **/\nexport const MAX_SHIFT_TIME_DELTA = Helpers.Timing.milliToMicro(Types.Timing.Milli(1000));\n\n// Layout shifts are reported globally to the developer, irrespective of which\n// frame they originated in. However, each process does have its own individual\n// CLS score, so we need to segment by process. This means Layout Shifts from\n// sites with one process (no subframes, or subframes from the same origin)\n// will be reported together. In the case of multiple renderers (frames across\n// different origins), we offer the developer the ability to switch renderer in\n// the UI.\nlet layoutShiftEvents: Types.Events.LayoutShift[] = [];\n\n// These events denote potential node resizings. We store them to link captured\n// layout shifts to the resizing of unsized elements.\nlet layoutInvalidationEvents: Types.Events.LayoutInvalidationTracking[] = [];\nlet scheduleStyleInvalidationEvents: Types.Events.ScheduleStyleInvalidationTracking[] = [];\nlet styleRecalcInvalidationEvents: Types.Events.StyleRecalcInvalidationTracking[] = [];\nlet renderFrameImplCreateChildFrameEvents: Types.Events.RenderFrameImplCreateChildFrame[] = [];\nlet domLoadingEvents: Types.Events.DomLoading[] = [];\nlet layoutImageUnsizedEvents: Types.Events.LayoutImageUnsized[] = [];\nlet remoteFonts: RemoteFont[] = [];\n\nlet backendNodeIds = new Set<Protocol.DOM.BackendNodeId>();\n\n// Layout shifts happen during PrePaint as part of the rendering lifecycle.\n// We determine if a LayoutInvalidation event is a potential root cause of a layout\n// shift if the next PrePaint after the LayoutInvalidation is the parent\n// node of such shift.\nlet prePaintEvents: Types.Events.PrePaint[] = [];\n\nlet paintImageEvents: Types.Events.PaintImage[] = [];\n\nlet sessionMaxScore = 0;\n\nlet clsWindowID = -1;\n\nlet clusters: Types.Events.SyntheticLayoutShiftCluster[] = [];\nlet clustersByNavigationId = new Map<Types.Events.NavigationId, Types.Events.SyntheticLayoutShiftCluster[]>();\n\n/**\n * Represents a point in time in which a  LS score change\n * was recorded.\n **/\ninterface ScoreRecord {\n  ts: number;\n  score: number;\n}\n\n// The complete timeline of LS score changes in a trace.\n// Includes drops to 0 when session windows end.\nlet scoreRecords: ScoreRecord[] = [];\n\nexport function reset(): void {\n  layoutShiftEvents = [];\n  layoutInvalidationEvents = [];\n  scheduleStyleInvalidationEvents = [];\n  styleRecalcInvalidationEvents = [];\n  prePaintEvents = [];\n  paintImageEvents = [];\n  renderFrameImplCreateChildFrameEvents = [];\n  layoutImageUnsizedEvents = [];\n  domLoadingEvents = [];\n  remoteFonts = [];\n  backendNodeIds = new Set();\n  clusters = [];\n  sessionMaxScore = 0;\n  scoreRecords = [];\n  clsWindowID = -1;\n  clustersByNavigationId = new Map();\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isLayoutShift(event) && !event.args.data?.had_recent_input) {\n    layoutShiftEvents.push(event);\n    return;\n  }\n  if (Types.Events.isLayoutInvalidationTracking(event)) {\n    layoutInvalidationEvents.push(event);\n    return;\n  }\n  if (Types.Events.isScheduleStyleInvalidationTracking(event)) {\n    scheduleStyleInvalidationEvents.push(event);\n  }\n  if (Types.Events.isStyleRecalcInvalidationTracking(event)) {\n    styleRecalcInvalidationEvents.push(event);\n  }\n  if (Types.Events.isPrePaint(event)) {\n    prePaintEvents.push(event);\n    return;\n  }\n  if (Types.Events.isRenderFrameImplCreateChildFrame(event)) {\n    renderFrameImplCreateChildFrameEvents.push(event);\n  }\n  if (Types.Events.isDomLoading(event)) {\n    domLoadingEvents.push(event);\n  }\n  if (Types.Events.isLayoutImageUnsized(event)) {\n    layoutImageUnsizedEvents.push(event);\n  }\n  if (Types.Events.isBeginRemoteFontLoad(event)) {\n    remoteFonts.push({\n      display: event.args.display,\n      url: event.args.url,\n      beginRemoteFontLoadEvent: event,\n    });\n  }\n  if (Types.Events.isRemoteFontLoaded(event)) {\n    for (const remoteFont of remoteFonts) {\n      if (remoteFont.url === event.args.url) {\n        remoteFont.name = event.args.name;\n      }\n    }\n  }\n  if (Types.Events.isPaintImage(event)) {\n    paintImageEvents.push(event);\n  }\n}\n\nfunction traceWindowFromTime(time: Types.Timing.Micro): Types.Timing.TraceWindowMicro {\n  return {\n    min: time,\n    max: time,\n    range: Types.Timing.Micro(0),\n  };\n}\n\nfunction updateTraceWindowMax(traceWindow: Types.Timing.TraceWindowMicro, newMax: Types.Timing.Micro): void {\n  traceWindow.max = newMax;\n  traceWindow.range = Types.Timing.Micro(traceWindow.max - traceWindow.min);\n}\n\nfunction findScreenshots(timestamp: Types.Timing.Micro): Types.Events.LayoutShiftParsedData['screenshots'] {\n  const data = screenshotsHandlerData();\n  if (data.screenshots) {\n    const before = Helpers.Trace.findPreviousEventBeforeTimestamp(data.screenshots, timestamp);\n    const after = before ? data.screenshots[data.screenshots.indexOf(before) + 1] : null;\n    return {before, after};\n  }\n  if (data.legacySyntheticScreenshots) {\n    const before = Helpers.Trace.findPreviousEventBeforeTimestamp(data.legacySyntheticScreenshots, timestamp);\n    const after = before ? data.legacySyntheticScreenshots[data.legacySyntheticScreenshots.indexOf(before) + 1] : null;\n    return {before, after};\n  }\n  // No screenshots\n  return {before: null, after: null};\n}\n\nfunction buildScoreRecords(): void {\n  const {traceBounds} = metaHandlerData();\n  scoreRecords.push({ts: traceBounds.min, score: 0});\n\n  for (const cluster of clusters) {\n    let clusterScore = 0;\n    if (cluster.events[0].args.data) {\n      scoreRecords.push({ts: cluster.clusterWindow.min, score: cluster.events[0].args.data.weighted_score_delta});\n    }\n    for (let i = 0; i < cluster.events.length; i++) {\n      const event = cluster.events[i];\n      if (!event.args.data) {\n        continue;\n      }\n      clusterScore += event.args.data.weighted_score_delta;\n      scoreRecords.push({ts: event.ts, score: clusterScore});\n    }\n    scoreRecords.push({ts: cluster.clusterWindow.max, score: 0});\n  }\n}\n\n/**\n * Collects backend node ids coming from LayoutShift and LayoutInvalidation\n * events.\n */\nfunction collectNodes(): void {\n  backendNodeIds.clear();\n\n  // Collect the node ids present in the shifts.\n  for (const layoutShift of layoutShiftEvents) {\n    if (!layoutShift.args.data?.impacted_nodes) {\n      continue;\n    }\n    for (const node of layoutShift.args.data.impacted_nodes) {\n      backendNodeIds.add(node.node_id);\n    }\n  }\n\n  // Collect the node ids present in LayoutInvalidation & scheduleStyleInvalidation events.\n  for (const layoutInvalidation of layoutInvalidationEvents) {\n    if (!layoutInvalidation.args.data?.nodeId) {\n      continue;\n    }\n    backendNodeIds.add(layoutInvalidation.args.data.nodeId);\n  }\n  for (const scheduleStyleInvalidation of scheduleStyleInvalidationEvents) {\n    if (!scheduleStyleInvalidation.args.data?.nodeId) {\n      continue;\n    }\n    backendNodeIds.add(scheduleStyleInvalidation.args.data.nodeId);\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  // Ensure the events are sorted by #time ascending.\n  layoutShiftEvents.sort((a, b) => a.ts - b.ts);\n  prePaintEvents.sort((a, b) => a.ts - b.ts);\n  layoutInvalidationEvents.sort((a, b) => a.ts - b.ts);\n  renderFrameImplCreateChildFrameEvents.sort((a, b) => a.ts - b.ts);\n  domLoadingEvents.sort((a, b) => a.ts - b.ts);\n  layoutImageUnsizedEvents.sort((a, b) => a.ts - b.ts);\n  remoteFonts.sort((a, b) => a.beginRemoteFontLoadEvent.ts - b.beginRemoteFontLoadEvent.ts);\n  paintImageEvents.sort((a, b) => a.ts - b.ts);\n\n  // Each function transforms the data used by the next, as such the invoke order\n  // is important.\n  await buildLayoutShiftsClusters();\n  buildScoreRecords();\n  collectNodes();\n}\n\nasync function buildLayoutShiftsClusters(): Promise<void> {\n  const {navigationsByFrameId, mainFrameId, traceBounds} = metaHandlerData();\n  const navigations = navigationsByFrameId.get(mainFrameId) || [];\n  if (layoutShiftEvents.length === 0) {\n    return;\n  }\n  let firstShiftTime = layoutShiftEvents[0].ts;\n  let lastShiftTime = layoutShiftEvents[0].ts;\n  let lastShiftNavigation = null;\n  // Now step through each and create clusters.\n  // A cluster is equivalent to a session window (see https://web.dev/cls/#what-is-cls).\n  // To make the line chart clear, we explicitly demark the limits of each session window\n  // by starting the cumulative score of the window at the time of the first layout shift\n  // and ending it (dropping the line back to 0) when the window ends according to the\n  // thresholds (MAX_CLUSTER_DURATION, MAX_SHIFT_TIME_DELTA).\n  for (const event of layoutShiftEvents) {\n    // First detect if either the cluster duration or the #time between this and\n    // the last shift has been exceeded.\n    const clusterDurationExceeded = event.ts - firstShiftTime > MAX_CLUSTER_DURATION;\n    const maxTimeDeltaSinceLastShiftExceeded = event.ts - lastShiftTime > MAX_SHIFT_TIME_DELTA;\n\n    // Next take a look at navigations. If between this and the last shift we have navigated,\n    // note it.\n    const currentShiftNavigation = Platform.ArrayUtilities.nearestIndexFromEnd(navigations, nav => nav.ts < event.ts);\n    const hasNavigated = lastShiftNavigation !== currentShiftNavigation && currentShiftNavigation !== null;\n\n    // If any of the above criteria are met or if we don't have any cluster yet we should\n    // start a new one.\n    if (clusterDurationExceeded || maxTimeDeltaSinceLastShiftExceeded || hasNavigated || !clusters.length) {\n      // The cluster starts #time should be the timestamp of the first layout shift in it.\n      const clusterStartTime = event.ts;\n\n      // If the last session window ended because the max delta time between shifts\n      // was exceeded set the endtime to MAX_SHIFT_TIME_DELTA microseconds after the\n      // last shift in the session.\n      const endTimeByMaxSessionDuration = clusterDurationExceeded ? firstShiftTime + MAX_CLUSTER_DURATION : Infinity;\n\n      // If the last session window ended because the max session duration was\n      // surpassed, set the endtime so that the window length = MAX_CLUSTER_DURATION;\n      const endTimeByMaxShiftGap = maxTimeDeltaSinceLastShiftExceeded ? lastShiftTime + MAX_SHIFT_TIME_DELTA : Infinity;\n\n      // If there was a navigation during the last window, close it at the time\n      // of the navigation.\n      const endTimeByNavigation = hasNavigated ? navigations[currentShiftNavigation].ts : Infinity;\n\n      // End the previous cluster at the time of the first of the criteria above that was met.\n      const previousClusterEndTime = Math.min(endTimeByMaxSessionDuration, endTimeByMaxShiftGap, endTimeByNavigation);\n\n      // If there is an existing cluster update its closing time.\n      if (clusters.length > 0) {\n        const currentCluster = clusters[clusters.length - 1];\n        updateTraceWindowMax(currentCluster.clusterWindow, Types.Timing.Micro(previousClusterEndTime));\n      }\n\n      // If this cluster happened after a navigation, set the navigationId to\n      // the current navigation. This lets us easily group clusters by\n      // navigation.\n      const navigationId = currentShiftNavigation === null ?\n          Types.Events.NO_NAVIGATION :\n          navigations[currentShiftNavigation].args.data?.navigationId;\n      // TODO: `navigationId` is `string | undefined`, but the undefined portion\n      // comes from `data.navigationId`. I don't think that is possible for this\n      // event type. Can we make this typing stronger? In the meantime, we allow\n      // `navigationId` to include undefined values.\n\n      clusters.push(Helpers.SyntheticEvents.SyntheticEventsManager\n                        .registerSyntheticEvent<Types.Events.SyntheticLayoutShiftCluster>({\n                          name: 'SyntheticLayoutShiftCluster',\n                          // Will be replaced by the worst layout shift in the next for loop.\n                          rawSourceEvent: event,\n                          events: [],\n                          clusterWindow: traceWindowFromTime(clusterStartTime),\n                          clusterCumulativeScore: 0,\n                          scoreWindows: {\n                            good: traceWindowFromTime(clusterStartTime),\n                          },\n                          navigationId,\n                          // Set default Event so that this event is treated accordingly for the track appender.\n                          ts: event.ts,\n                          pid: event.pid,\n                          tid: event.tid,\n                          ph: Types.Events.Phase.COMPLETE,\n                          cat: '',\n                          dur: Types.Timing.Micro(-1),  // This `cluster.dur` is updated below.\n                        }));\n\n      firstShiftTime = clusterStartTime;\n    }\n\n    // Given the above we should have a cluster available, so pick the most\n    // recent one and append the shift, bump its score and window values accordingly.\n    const currentCluster = clusters[clusters.length - 1];\n    const timeFromNavigation = currentShiftNavigation !== null ?\n        Types.Timing.Micro(event.ts - navigations[currentShiftNavigation].ts) :\n        undefined;\n\n    currentCluster.clusterCumulativeScore += event.args.data ? event.args.data.weighted_score_delta : 0;\n    if (!event.args.data) {\n      continue;\n    }\n    const shift =\n        Helpers.SyntheticEvents.SyntheticEventsManager.registerSyntheticEvent<Types.Events.SyntheticLayoutShift>({\n          rawSourceEvent: event,\n          ...event,\n          name: Types.Events.Name.SYNTHETIC_LAYOUT_SHIFT,\n          args: {\n            frame: event.args.frame,\n            data: {\n              ...event.args.data,\n              rawEvent: event,\n              navigationId: currentCluster.navigationId ?? undefined,\n            },\n          },\n          parsedData: {\n            timeFromNavigation,\n            screenshots: findScreenshots(event.ts),\n            cumulativeWeightedScoreInWindow: currentCluster.clusterCumulativeScore,\n            // The score of the session window is temporarily set to 0 just\n            // to initialize it. Since we need to get the score of all shifts\n            // in the session window to determine its value, its definite\n            // value is set when stepping through the built clusters.\n            sessionWindowData: {cumulativeWindowScore: 0, id: clusters.length},\n          },\n        });\n    currentCluster.events.push(shift);\n    updateTraceWindowMax(currentCluster.clusterWindow, event.ts);\n\n    lastShiftTime = event.ts;\n    lastShiftNavigation = currentShiftNavigation;\n  }\n\n  // Now step through each cluster and set up the times at which the value\n  // goes from Good, to needs improvement, to Bad. Note that if there is a\n  // large jump we may go from Good to Bad without ever creating a Needs\n  // Improvement window at all.\n  for (const cluster of clusters) {\n    let weightedScore = 0;\n    let windowID = -1;\n    // If this is the last cluster update its window. The cluster duration is determined\n    // by the minimum between: time to next navigation, trace end time, time to maximum\n    // cluster duration and time to maximum gap between layout shifts.\n    if (cluster === clusters[clusters.length - 1]) {\n      const clusterEndByMaxDuration = MAX_CLUSTER_DURATION + cluster.clusterWindow.min;\n      const clusterEndByMaxGap = cluster.clusterWindow.max + MAX_SHIFT_TIME_DELTA;\n      const nextNavigationIndex =\n          Platform.ArrayUtilities.nearestIndexFromBeginning(navigations, nav => nav.ts > cluster.clusterWindow.max);\n      const nextNavigationTime = nextNavigationIndex ? navigations[nextNavigationIndex].ts : Infinity;\n      const clusterEnd = Math.min(clusterEndByMaxDuration, clusterEndByMaxGap, traceBounds.max, nextNavigationTime);\n      updateTraceWindowMax(cluster.clusterWindow, Types.Timing.Micro(clusterEnd));\n    }\n\n    let largestScore = 0;\n    let worstShiftEvent: Types.Events.Event|null = null;\n\n    for (const shift of cluster.events) {\n      weightedScore += shift.args.data ? shift.args.data.weighted_score_delta : 0;\n      windowID = shift.parsedData.sessionWindowData.id;\n      const ts = shift.ts;\n      // Update the the CLS score of this shift's session window now that\n      // we have it.\n      shift.parsedData.sessionWindowData.cumulativeWindowScore = cluster.clusterCumulativeScore;\n      if (weightedScore < LayoutShiftsThreshold.NEEDS_IMPROVEMENT) {\n        // Expand the Good window.\n        updateTraceWindowMax(cluster.scoreWindows.good, ts);\n      } else if (\n          weightedScore >= LayoutShiftsThreshold.NEEDS_IMPROVEMENT && weightedScore < LayoutShiftsThreshold.BAD) {\n        if (!cluster.scoreWindows.needsImprovement) {\n          // Close the Good window, and open the needs improvement window.\n          updateTraceWindowMax(cluster.scoreWindows.good, Types.Timing.Micro(ts - 1));\n          cluster.scoreWindows.needsImprovement = traceWindowFromTime(ts);\n        }\n\n        // Expand the needs improvement window.\n        updateTraceWindowMax(cluster.scoreWindows.needsImprovement, ts);\n      } else if (weightedScore >= LayoutShiftsThreshold.BAD) {\n        if (!cluster.scoreWindows.bad) {\n          // We may jump from Good to Bad here, so update whichever window is open.\n          if (cluster.scoreWindows.needsImprovement) {\n            updateTraceWindowMax(cluster.scoreWindows.needsImprovement, Types.Timing.Micro(ts - 1));\n          } else {\n            updateTraceWindowMax(cluster.scoreWindows.good, Types.Timing.Micro(ts - 1));\n          }\n\n          cluster.scoreWindows.bad = traceWindowFromTime(shift.ts);\n        }\n\n        // Expand the Bad window.\n        updateTraceWindowMax(cluster.scoreWindows.bad, ts);\n      }\n\n      // At this point the windows are set by the timestamps of the events, but the\n      // next cluster begins at the timestamp of its first event. As such we now\n      // need to expand the score window to the end of the cluster, and we do so\n      // by using the Bad widow if it's there, or the NI window, or finally the\n      // Good window.\n      if (cluster.scoreWindows.bad) {\n        updateTraceWindowMax(cluster.scoreWindows.bad, cluster.clusterWindow.max);\n      } else if (cluster.scoreWindows.needsImprovement) {\n        updateTraceWindowMax(cluster.scoreWindows.needsImprovement, cluster.clusterWindow.max);\n      } else {\n        updateTraceWindowMax(cluster.scoreWindows.good, cluster.clusterWindow.max);\n      }\n\n      // Find the worst layout shift of the cluster.\n      const score = shift.args.data?.weighted_score_delta;\n      if (score !== undefined && score > largestScore) {\n        largestScore = score;\n        worstShiftEvent = shift;\n      }\n    }\n    // Update the cluster's worst layout shift.\n    if (worstShiftEvent) {\n      cluster.worstShiftEvent = worstShiftEvent;\n      cluster.rawSourceEvent = worstShiftEvent;\n    }\n\n    // layout shifts are already sorted by time ascending.\n    // Capture the time range of the cluster.\n    cluster.ts = cluster.events[0].ts;\n    const lastShiftTimings = Helpers.Timing.eventTimingsMicroSeconds(cluster.events[cluster.events.length - 1]);\n    // Add MAX_SHIFT_TIME_DELTA, the section gap after the last layout shift. This marks the end of the cluster.\n    cluster.dur = Types.Timing.Micro((lastShiftTimings.endTime - cluster.events[0].ts) + MAX_SHIFT_TIME_DELTA);\n\n    if (weightedScore > sessionMaxScore) {\n      clsWindowID = windowID;\n      sessionMaxScore = weightedScore;\n    }\n\n    if (cluster.navigationId) {\n      const clustersForId = Platform.MapUtilities.getWithDefault(clustersByNavigationId, cluster.navigationId, () => {\n        return [];\n      });\n      clustersForId.push(cluster);\n    }\n  }\n}\n\nexport function data(): LayoutShiftsData {\n  return {\n    clusters,\n    sessionMaxScore,\n    clsWindowID,\n    prePaintEvents,\n    layoutInvalidationEvents,\n    scheduleStyleInvalidationEvents,\n    styleRecalcInvalidationEvents,\n    renderFrameImplCreateChildFrameEvents,\n    domLoadingEvents,\n    layoutImageUnsizedEvents,\n    remoteFonts,\n    scoreRecords,\n    backendNodeIds,\n    clustersByNavigationId,\n    paintImageEvents,\n  };\n}\n\nexport function deps(): HandlerName[] {\n  return ['Screenshots', 'Meta'];\n}\n\nexport function scoreClassificationForLayoutShift(score: number): ScoreClassification {\n  let state = ScoreClassification.GOOD;\n  if (score >= LayoutShiftsThreshold.NEEDS_IMPROVEMENT) {\n    state = ScoreClassification.OK;\n  }\n\n  if (score >= LayoutShiftsThreshold.BAD) {\n    state = ScoreClassification.BAD;\n  }\n\n  return state;\n}\n\n/** Based on https://web.dev/cls/ **/\nexport const enum LayoutShiftsThreshold {\n  GOOD = 0,\n  NEEDS_IMPROVEMENT = 0.1,\n  BAD = 0.25,\n}\n", "// Copyright 2022 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport type {HandlerName} from './types.js';\n\n// Each thread contains events. Events indicate the thread and process IDs, which are\n// used to store the event in the correct process thread entry below.\nlet unpairedAsyncEvents: Types.Events.PipelineReporter[] = [];\n\nlet legacyScreenshotEvents: Types.Events.LegacyScreenshot[] = [];\nlet modernScreenshotEvents: Types.Events.Screenshot[] = [];\nlet syntheticScreenshots: Types.Events.LegacySyntheticScreenshot[] = [];\nlet frameSequenceToTs: Record<string, Types.Timing.Micro> = {};\n\nexport function reset(): void {\n  unpairedAsyncEvents = [];\n  legacyScreenshotEvents = [];\n  syntheticScreenshots = [];\n  modernScreenshotEvents = [];\n  frameSequenceToTs = {};\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isLegacyScreenshot(event)) {\n    legacyScreenshotEvents.push(event);\n  } else if (Types.Events.isScreenshot(event)) {\n    modernScreenshotEvents.push(event);\n  } else if (Types.Events.isPipelineReporter(event)) {\n    unpairedAsyncEvents.push(event);\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  const pipelineReporterEvents = Helpers.Trace.createMatchedSortedSyntheticEvents(unpairedAsyncEvents);\n\n  frameSequenceToTs = Object.fromEntries(pipelineReporterEvents.map(evt => {\n    const args = evt.args.data.beginEvent.args;\n    const frameReporter = 'frame_reporter' in args ? args.frame_reporter : args.chrome_frame_reporter;\n    const frameSequenceId = frameReporter.frame_sequence;\n    const presentationTs = Types.Timing.Micro(evt.ts + evt.dur);\n    return [frameSequenceId, presentationTs];\n  }));\n\n  for (const snapshotEvent of legacyScreenshotEvents) {\n    const {cat, name, ph, pid, tid} = snapshotEvent;\n    const syntheticEvent = Helpers.SyntheticEvents.SyntheticEventsManager.registerSyntheticEvent<\n        Types.Events.LegacySyntheticScreenshot>({\n      rawSourceEvent: snapshotEvent,\n      cat,\n      name,\n      ph,\n      pid,\n      tid,\n      // TODO(paulirish, crbug.com/41363012): investigate why getPresentationTimestamp(snapshotEvent) seems less accurate. Resolve screenshot timing inaccuracy.\n      // `getPresentationTimestamp(snapshotEvent) - snapshotEvent.ts` is how many microsec the screenshot should be adjusted to the right/later\n      ts: snapshotEvent.ts,\n      args: {\n        dataUri: `data:image/jpg;base64,${snapshotEvent.args.snapshot}`,\n      },\n    });\n    syntheticScreenshots.push(syntheticEvent);\n  }\n}\n\nexport function screenshotImageDataUri(event: Types.Events.LegacySyntheticScreenshot|Types.Events.Screenshot): string {\n  if (Types.Events.isLegacySyntheticScreenshot(event)) {\n    return event.args.dataUri;\n  }\n  return `data:image/jpg;base64,${event.args.snapshot}`;\n}\n\n/**\n * Correct the screenshot timestamps\n * The screenshot 'snapshot object' trace event has the \"frame sequence number\" attached as an ID.\n * We match that up with the \"PipelineReporter\" trace events as they terminate at presentation.\n * Presentation == when the pixels hit the screen. AKA Swap on the GPU\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction getPresentationTimestamp(screenshotEvent: Types.Events.LegacyScreenshot): Types.Timing.Micro {\n  const frameSequence = parseInt(screenshotEvent.id, 16);\n  // If it's 1, then it's an old trace (before https://crrev.com/c/4957973) and cannot be corrected.\n  if (frameSequence === 1) {\n    return screenshotEvent.ts;\n  }\n  // The screenshot trace event's `ts` reflects the \"expected display time\" which is ESTIMATE.\n  // It is set by the compositor frame sink from the `expected_display_time`, which is based on a previously known\n  // frame start PLUS the vsync interval (eg 16.6ms)\n  const updatedTs = frameSequenceToTs[frameSequence];\n  // Do we always find a match? No...\n  // We generally don't match the very first screenshot and, sometimes, the last\n  // The very first screenshot is requested immediately (even if nothing is painting). As a result there's no compositor\n  // instrumentation running alongside.\n  // The last one is sometimes missing as because the trace terminates right before the associated PipelineReporter is emitted.\n  return updatedTs ?? screenshotEvent.ts;\n}\n\nexport interface Data {\n  // These are nullable because in January 2025 a CL in Chromium\n  // crrev.com/c/6197645 landed which changed the format of screenshots. For a\n  // given trace, it can have either \"legacy\" screenshot events, or \"modern\"\n  // screenshot events, but no trace can ever contain both.\n  // So, if either of these arrays are empty, we instead return `null`. This forces consumers to check the presence of the array.\n  // Traces can have no screenshots if the trace category is not enabled, so it\n  // is possible for a trace to return null for both of these arrays.\n  legacySyntheticScreenshots: Types.Events.LegacySyntheticScreenshot[]|null;\n  screenshots: Types.Events.Screenshot[]|null;\n}\n\nexport function data(): Data {\n  return {\n    legacySyntheticScreenshots: syntheticScreenshots.length ? syntheticScreenshots : null,\n    screenshots: modernScreenshotEvents.length ? modernScreenshotEvents : null,\n  };\n}\n\nexport function deps(): HandlerName[] {\n  return ['Meta'];\n}\n", "// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Types from '../types/types.js';\n\nexport interface MemoryData {\n  updateCountersByProcess: Map<Types.Events.ProcessID, Types.Events.UpdateCounters[]>;\n}\n\nlet updateCountersByProcess: MemoryData['updateCountersByProcess'] = new Map();\n\nexport function reset(): void {\n  updateCountersByProcess = new Map();\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isUpdateCounters(event)) {\n    const countersForProcess = Platform.MapUtilities.getWithDefault(updateCountersByProcess, event.pid, () => []);\n    countersForProcess.push(event);\n    updateCountersByProcess.set(event.pid, countersForProcess);\n  }\n}\n\nexport async function finalize(): Promise<void> {\n}\n\nexport function data(): MemoryData {\n  return {updateCountersByProcess};\n}\n", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Types from '../types/types.js';\n\nlet frames = new Map<string, Types.Events.TraceFrame>();\n\nexport function reset(): void {\n  frames = new Map();\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isTracingStartedInBrowser(event)) {\n    for (const frame of event.args.data?.frames ?? []) {\n      // The ID of a frame is stored under the `frame` key.\n      frames.set(frame.frame, frame);\n    }\n    return;\n  }\n\n  // CommitLoad events can contain an updated URL or Name for a frame.\n  if (Types.Events.isCommitLoad(event)) {\n    const frameData = event.args.data;\n    if (!frameData) {\n      return;\n    }\n    // We don't want to mutate the original object, hence why\n    // we set a new object from the new and existing values.\n    const frame = frames.get(frameData.frame);\n    if (!frame) {\n      return;\n    }\n    frames.set(frameData.frame, {\n      ...frame,\n      url: frameData.url || frame.url,\n      name: frameData.name || frameData.name,\n    });\n  }\n}\n\nexport async function finalize(): Promise<void> {\n}\n\nexport interface PageFrameData {\n  frames: Map<string, Types.Events.TraceFrame>;\n}\nexport function data(): PageFrameData {\n  return {\n    frames,\n  };\n}\n", "// Copyright 2025 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../../core/common/common.js';\nimport * as Platform from '../../../core/platform/platform.js';\nimport type * as SDK from '../../../core/sdk/sdk.js';\nimport type * as Protocol from '../../../generated/protocol.js';\nimport * as Types from '../types/types.js';\n\nimport {data as metaHandlerData, type MetaHandlerData} from './MetaHandler.js';\nimport {data as networkRequestsHandlerData} from './NetworkRequestsHandler.js';\nimport type {FinalizeOptions, HandlerName} from './types.js';\n\nexport interface ScriptsData {\n  /** Note: this is only populated when the \"Enhanced Traces\" feature is enabled. */\n  scripts: Script[];\n}\n\nexport interface Script {\n  isolate: string;\n  scriptId: Protocol.Runtime.ScriptId;\n  frame: string;\n  ts: Types.Timing.Micro;\n  inline: boolean;\n  url?: string;\n  sourceUrl?: string;\n  content?: string;\n  /**\n   * Note: this is the literal text given as the sourceMappingURL value. It has not been resolved relative to the script url.\n   * Since M138, data urls are never set here.\n   */\n  sourceMapUrl?: string;\n  /** If true, the source map url was a data URL, so it got removed from the trace event. */\n  sourceMapUrlElided?: boolean;\n  sourceMap?: SDK.SourceMap.SourceMap;\n  request?: Types.Events.SyntheticNetworkRequest;\n  /** Lazily generated - use getScriptGeneratedSizes to access. */\n  sizes?: GeneratedFileSizes;\n}\n\ntype GeneratedFileSizes = {\n  errorMessage: string,\n}|{files: Record<string, number>, unmappedBytes: number, totalBytes: number};\n\nlet scriptById = new Map<string, Script>();\nlet frameIdByIsolate = new Map<string, string>();\n\nexport function deps(): HandlerName[] {\n  return ['Meta', 'NetworkRequests'];\n}\n\nexport function reset(): void {\n  scriptById = new Map();\n  frameIdByIsolate = new Map();\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  const getOrMakeScript = (isolate: string|number, scriptIdAsNumber: number): Script => {\n    const scriptId = String(scriptIdAsNumber) as Protocol.Runtime.ScriptId;\n    const key = `${isolate}.${scriptId}`;\n    return Platform.MapUtilities.getWithDefault(\n        scriptById, key, () => ({isolate, scriptId, frame: '', ts: event.ts} as Script));\n  };\n\n  if (Types.Events.isRundownScriptCompiled(event) && event.args.data) {\n    const {isolate, scriptId, frame} = event.args.data;\n    const script = getOrMakeScript(isolate, scriptId);\n    script.frame = frame;\n    script.ts = event.ts;\n\n    return;\n  }\n\n  if (Types.Events.isRundownScript(event)) {\n    const {isolate, scriptId, url, sourceUrl, sourceMapUrl, sourceMapUrlElided} = event.args.data;\n    const script = getOrMakeScript(isolate, scriptId);\n    if (!script.frame) {\n      script.frame = frameIdByIsolate.get(String(isolate)) ?? '';\n    }\n    script.url = url;\n    script.ts = event.ts;\n    if (sourceUrl) {\n      script.sourceUrl = sourceUrl;\n    }\n\n    // Older traces may have data source map urls. Those can be very large, so a change\n    // was made to elide them from the trace.\n    // If elided, a fresh trace will fetch the source map from the Script model\n    // (see TimelinePanel getExistingSourceMap). If not fresh, the source map is resolved\n    // instead in this handler via `findCachedRawSourceMap`.\n    if (sourceMapUrlElided) {\n      script.sourceMapUrlElided = true;\n    } else if (sourceMapUrl) {\n      script.sourceMapUrl = sourceMapUrl;\n    }\n    return;\n  }\n\n  if (Types.Events.isRundownScriptSource(event)) {\n    const {isolate, scriptId, sourceText} = event.args.data;\n    const script = getOrMakeScript(isolate, scriptId);\n    script.content = sourceText;\n    return;\n  }\n\n  if (Types.Events.isRundownScriptSourceLarge(event)) {\n    const {isolate, scriptId, sourceText} = event.args.data;\n    const script = getOrMakeScript(isolate, scriptId);\n    script.content = (script.content ?? '') + sourceText;\n    return;\n  }\n\n  // Setup frameIdByIsolate, which is used only in the case that we are missing\n  // rundown events for a script. We won't get a frame association from the rundown\n  // events if the recording started only after the script was first compiled. In\n  // that scenario, derive the frame via the isolate / FunctionCall events.\n  // TODO: ideally, we put the frame on ScriptCatchup event. So much easier. This approach has some\n  // issues.\n  if (Types.Events.isFunctionCall(event) && event.args.data?.isolate && event.args.data.frame) {\n    const {isolate, frame} = event.args.data;\n    const existingValue = frameIdByIsolate.get(isolate);\n    if (existingValue !== frame) {\n      frameIdByIsolate.set(isolate, frame);\n\n      // Update the scripts we discovered but without knowing their frame.\n      for (const script of scriptById.values()) {\n        if (!script.frame && script.isolate === isolate) {\n          script.frame = frame;\n        }\n      }\n    }\n  }\n}\n\nfunction findFrame(meta: MetaHandlerData, frameId: string): Types.Events.TraceFrame|null {\n  for (const frames of meta.frameByProcessId?.values()) {\n    const frame = frames.get(frameId);\n    if (frame) {\n      return frame;\n    }\n  }\n\n  return null;\n}\n\nfunction findNetworkRequest(networkRequests: Types.Events.SyntheticNetworkRequest[], script: Script):\n    Types.Events.SyntheticNetworkRequest|null {\n  if (!script.url) {\n    return null;\n  }\n\n  return networkRequests.find(request => request.args.data.url === script.url) ?? null;\n}\n\nfunction computeMappingEndColumns(map: SDK.SourceMap.SourceMap): Map<SDK.SourceMap.SourceMapEntry, number> {\n  const result = new Map<SDK.SourceMap.SourceMapEntry, number>();\n\n  const mappings = map.mappings();\n  for (let i = 0; i < mappings.length - 1; i++) {\n    const mapping = mappings[i];\n    const nextMapping = mappings[i + 1];\n    if (mapping.lineNumber === nextMapping.lineNumber) {\n      result.set(mapping, nextMapping.columnNumber);\n    }\n  }\n\n  // Now, all but the last mapping on each line will have a value in this map.\n  return result;\n}\n\n/**\n * Using a script's contents and source map, attribute every generated byte to an authored source file.\n */\nfunction computeGeneratedFileSizes(script: Script): GeneratedFileSizes {\n  if (!script.sourceMap) {\n    throw new Error('expected source map');\n  }\n\n  const map = script.sourceMap;\n  const content = script.content ?? '';\n  const contentLength = content.length;\n  const lines = content.split('\\n');\n  const files: Record<string, number> = {};\n  const totalBytes = contentLength;\n  let unmappedBytes = totalBytes;\n\n  const mappingEndCols = computeMappingEndColumns(script.sourceMap);\n\n  for (const mapping of map.mappings()) {\n    const source = mapping.sourceURL;\n    const lineNum = mapping.lineNumber;\n    const colNum = mapping.columnNumber;\n    const lastColNum = mappingEndCols.get(mapping);\n\n    // Webpack sometimes emits null mappings.\n    // https://github.com/mozilla/source-map/pull/303\n    if (!source) {\n      continue;\n    }\n\n    // Lines and columns are zero-based indices. Visually, lines are shown as a 1-based index.\n\n    const line = lines[lineNum];\n    if (line === null || line === undefined) {\n      const errorMessage = `${map.url()} mapping for line out of bounds: ${lineNum + 1}`;\n      return {errorMessage};\n    }\n\n    if (colNum > line.length) {\n      const errorMessage = `${map.url()} mapping for column out of bounds: ${lineNum + 1}:${colNum}`;\n      return {errorMessage};\n    }\n\n    let mappingLength = 0;\n    if (lastColNum !== undefined) {\n      if (lastColNum > line.length) {\n        const errorMessage = `${map.url()} mapping for last column out of bounds: ${lineNum + 1}:${lastColNum}`;\n        return {errorMessage};\n      }\n      mappingLength = lastColNum - colNum;\n    } else {\n      // Add +1 to account for the newline.\n      mappingLength = line.length - colNum + 1;\n    }\n    files[source] = (files[source] || 0) + mappingLength;\n    unmappedBytes -= mappingLength;\n  }\n\n  return {\n    files,\n    unmappedBytes,\n    totalBytes,\n  };\n}\n\nexport function getScriptGeneratedSizes(script: Script): GeneratedFileSizes|null {\n  if (script.sourceMap && !script.sizes) {\n    script.sizes = computeGeneratedFileSizes(script);\n  }\n\n  return script.sizes ?? null;\n}\n\nfunction findCachedRawSourceMap(script: Script, options: Types.Configuration.ParseOptions): SDK.SourceMap.SourceMapV3|\n    undefined {\n  if (options.isFreshRecording || !options.metadata?.sourceMaps) {\n    // Exit if this is not a loaded trace w/ source maps in the metadata.\n    return;\n  }\n\n  // For elided data url source maps, search the metadata source maps by script url.\n  if (script.sourceMapUrlElided) {\n    if (!script.url) {\n      return;\n    }\n\n    const cachedSourceMap = options.metadata.sourceMaps.find(m => m.url === script.url);\n    if (cachedSourceMap) {\n      return cachedSourceMap.sourceMap;\n    }\n\n    return;\n  }\n\n  if (!script.sourceMapUrl) {\n    return;\n  }\n\n  // Otherwise, search by source map url.\n  // Note: early enhanced traces may have this field set for data urls. Ignore those,\n  // as they were never stored in metadata sourcemap.\n  const isDataUrl = script.sourceMapUrl.startsWith('data:');\n  if (!isDataUrl) {\n    const cachedSourceMap = options.metadata.sourceMaps.find(m => m.sourceMapUrl === script.sourceMapUrl);\n    if (cachedSourceMap) {\n      return cachedSourceMap.sourceMap;\n    }\n  }\n\n  return;\n}\n\nexport async function finalize(options: FinalizeOptions): Promise<void> {\n  const meta = metaHandlerData();\n  const networkRequests = [...networkRequestsHandlerData().byId.values()];\n\n  const documentUrls = new Set<string>();\n  for (const frames of meta.frameByProcessId.values()) {\n    for (const frame of frames.values()) {\n      documentUrls.add(frame.url);\n    }\n  }\n\n  for (const script of scriptById.values()) {\n    script.request = findNetworkRequest(networkRequests, script) ?? undefined;\n    script.inline = !!script.url && documentUrls.has(script.url);\n  }\n\n  if (!options.resolveSourceMap) {\n    return;\n  }\n\n  const promises = [];\n  for (const script of scriptById.values()) {\n    // No frame or url means the script came from somewhere we don't care about.\n    // Note: scripts from inline <SCRIPT> elements use the url of the HTML document,\n    // so aren't ignored.\n    if (!script.frame || !script.url || (!script.sourceMapUrl && !script.sourceMapUrlElided)) {\n      continue;\n    }\n\n    const frameUrl = findFrame(meta, script.frame)?.url as Platform.DevToolsPath.UrlString | undefined;\n    if (!frameUrl) {\n      continue;\n    }\n\n    // If there is a `sourceURL` magic comment, resolve the compiledUrl against the frame url.\n    // example: `// #sourceURL=foo.js` for target frame https://www.example.com/home -> https://www.example.com/home/foo.js\n    let sourceUrl = script.url;\n    if (script.sourceUrl) {\n      sourceUrl = Common.ParsedURL.ParsedURL.completeURL(frameUrl, script.sourceUrl) ?? script.sourceUrl;\n    }\n\n    let sourceMapUrl;\n    if (script.sourceMapUrl) {\n      // Resolve the source map url. The value given by v8 may be relative, so resolve it here.\n      // This process should match the one in `SourceMapManager.attachSourceMap`.\n      sourceMapUrl =\n          Common.ParsedURL.ParsedURL.completeURL(sourceUrl as Platform.DevToolsPath.UrlString, script.sourceMapUrl);\n      if (!sourceMapUrl) {\n        continue;\n      }\n\n      script.sourceMapUrl = sourceMapUrl;\n    }\n\n    const params: Types.Configuration.ResolveSourceMapParams = {\n      scriptId: script.scriptId,\n      scriptUrl: script.url as Platform.DevToolsPath.UrlString,\n      sourceUrl: sourceUrl as Platform.DevToolsPath.UrlString,\n      sourceMapUrl: sourceMapUrl ?? '' as Platform.DevToolsPath.UrlString,\n      frame: script.frame as Protocol.Page.FrameId,\n      cachedRawSourceMap: findCachedRawSourceMap(script, options),\n    };\n    const promise = options.resolveSourceMap(params).then(sourceMap => {\n      if (sourceMap) {\n        script.sourceMap = sourceMap;\n      }\n    });\n    promises.push(promise.catch(e => {\n      console.error('Uncaught error when resolving source map', params, e);\n    }));\n  }\n  await Promise.all(promises);\n}\n\nexport function data(): ScriptsData {\n  return {\n    scripts: [...scriptById.values()],\n  };\n}\n", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Protocol from '../../../generated/protocol.js';\nimport * as Types from '../types/types.js';\n\ninterface SelectorWithStyleSheedId {\n  selector: string;\n  styleSheetId: string;\n}\n\ninterface InvalidatedNode {\n  frame: string;\n  backendNodeId: Protocol.DOM.BackendNodeId;\n  type: Types.Events.InvalidationEventType;\n  selectorList: SelectorWithStyleSheedId[];\n  ts: Types.Timing.Micro;\n  tts?: Types.Timing.Micro;\n  subtree:\n      boolean;  // Indicates if the invalidation applies solely to the node (false) or extends to all its descendants (true)\n  lastRecalcStyleEventTs: Types.Timing.Micro;\n}\n\nlet lastRecalcStyleEvent: Types.Events.RecalcStyle|null = null;\nlet lastInvalidatedNode: InvalidatedNode|null = null;\n\nlet selectorDataForRecalcStyle = new Map<Types.Events.RecalcStyle, {\n  timings: Types.Events.SelectorTiming[],\n}>();\n\nlet invalidatedNodeList = new Array<InvalidatedNode>();\n\nexport function reset(): void {\n  lastRecalcStyleEvent = null;\n  lastInvalidatedNode = null;\n  selectorDataForRecalcStyle = new Map();\n  invalidatedNodeList = [];\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isStyleRecalcInvalidationTracking(event)) {\n    /**\n     * CSS Style substree invalidation\n     * A subtree invalidation comes with two records, 1) a StyleInvalidatorInvalidationTracking\n     * event 2) following with a StyleRecalcInvalidationTracking event. List of selectors and style\n     * sheet ID information is stored in the 1st event. Subtree flag is stored in the 2nd\n     * event.\n     */\n    if (event.args.data.subtree &&\n        event.args.data.reason === Types.Events.StyleRecalcInvalidationReason.RELATED_STYLE_RULE &&\n        lastInvalidatedNode && event.args.data.nodeId === lastInvalidatedNode.backendNodeId) {\n      lastInvalidatedNode.subtree = true;\n      return;\n    }\n  }\n\n  if (Types.Events.isSelectorStats(event) && lastRecalcStyleEvent && event.args.selector_stats) {\n    selectorDataForRecalcStyle.set(lastRecalcStyleEvent, {\n      timings: event.args.selector_stats.selector_timings,\n    });\n    return;\n  }\n\n  if (Types.Events.isStyleInvalidatorInvalidationTracking(event)) {\n    const selectorList = new Array<SelectorWithStyleSheedId>();\n    event.args.data.selectors?.forEach(selector => {\n      selectorList.push({\n        selector: selector.selector,\n        styleSheetId: selector.style_sheet_id,\n      });\n    });\n\n    if (selectorList.length > 0) {\n      lastInvalidatedNode = {\n        frame: event.args.data.frame,\n        backendNodeId: event.args.data.nodeId,\n        type: Types.Events.InvalidationEventType.StyleInvalidatorInvalidationTracking,\n        selectorList,\n        ts: event.ts,\n        tts: event.tts,\n        subtree: false,\n        lastRecalcStyleEventTs: lastRecalcStyleEvent ? lastRecalcStyleEvent.ts : Types.Timing.Micro(0),\n      };\n      invalidatedNodeList.push(lastInvalidatedNode);\n    }\n  }\n\n  if (Types.Events.isRecalcStyle(event)) {\n    lastRecalcStyleEvent = event;\n    return;\n  }\n}\n\nexport async function finalize(): Promise<void> {\n}\n\nexport interface SelectorStatsData {\n  dataForRecalcStyleEvent: Map<Types.Events.RecalcStyle, {\n    timings: Types.Events.SelectorTiming[],\n  }>;\n  invalidatedNodeList: InvalidatedNode[];\n}\n\nexport function data(): SelectorStatsData {\n  return {\n    dataForRecalcStyleEvent: selectorDataForRecalcStyle,\n    invalidatedNodeList,\n  };\n}\n", "// Copyright 2022 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {data as metaHandlerData} from './MetaHandler.js';\nimport {ScoreClassification} from './PageLoadMetricsHandler.js';\nimport type {HandlerName} from './types.js';\n\n// This handler gathers EventTimings into Interactions, which we use to show\n// interactions and highlight long interactions to the user, along with INP.\n\nlet beginCommitCompositorFrameEvents: Types.Events.BeginCommitCompositorFrame[] = [];\nlet parseMetaViewportEvents: Types.Events.ParseMetaViewport[] = [];\n\nexport const LONG_INTERACTION_THRESHOLD = Helpers.Timing.milliToMicro(Types.Timing.Milli(200));\n\nconst INP_GOOD_TIMING = LONG_INTERACTION_THRESHOLD;\nconst INP_MEDIUM_TIMING = Helpers.Timing.milliToMicro(Types.Timing.Milli(500));\n\nexport interface UserInteractionsData {\n  /** All the BeginCommitCompositorFrame events we found in the trace */\n  beginCommitCompositorFrameEvents: readonly Types.Events.BeginCommitCompositorFrame[];\n  /** All the ParseMetaViewport events we found in the trace */\n  parseMetaViewportEvents: readonly Types.Events.ParseMetaViewport[];\n  /**\n   * All the interaction events we found in the trace that had an\n   * interactionId and a duration > 0\n   **/\n  interactionEvents: readonly Types.Events.SyntheticInteractionPair[];\n  /**\n   * If the user rapidly generates interaction events (think typing into a\n   * text box), in the UI we only really want to show the user the longest\n   * interaction in that set.\n   * For example picture interactions like this:\n   * ===[interaction A]==========\n   *       =[interaction B]======\n   *            =[interaction C]=\n   *\n   * These events all end at the same time, and so in this instance we only want\n   * to show the first interaction A on the timeline, as that is the longest one\n   * and the one the developer should be focusing on. So this array of events is\n   * all the interaction events filtered down, removing any nested interactions\n   * entirely.\n   **/\n  interactionEventsWithNoNesting: readonly Types.Events.SyntheticInteractionPair[];\n  // The longest duration interaction event. Can be null if the trace has no interaction events.\n  longestInteractionEvent: Readonly<Types.Events.SyntheticInteractionPair>|null;\n  // All interactions that went over the interaction threshold (200ms, see https://web.dev/inp/)\n  interactionsOverThreshold: Readonly<Set<Types.Events.SyntheticInteractionPair>>;\n}\n\nlet longestInteractionEvent: Types.Events.SyntheticInteractionPair|null = null;\n\nlet interactionEvents: Types.Events.SyntheticInteractionPair[] = [];\nlet interactionEventsWithNoNesting: Types.Events.SyntheticInteractionPair[] = [];\nlet eventTimingStartEventsForInteractions: Types.Events.EventTimingBegin[] = [];\nlet eventTimingEndEventsForInteractions: Types.Events.EventTimingEnd[] = [];\n\nexport function reset(): void {\n  beginCommitCompositorFrameEvents = [];\n  parseMetaViewportEvents = [];\n  interactionEvents = [];\n  eventTimingStartEventsForInteractions = [];\n  eventTimingEndEventsForInteractions = [];\n  interactionEventsWithNoNesting = [];\n  longestInteractionEvent = null;\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isBeginCommitCompositorFrame(event)) {\n    beginCommitCompositorFrameEvents.push(event);\n    return;\n  }\n\n  if (Types.Events.isParseMetaViewport(event)) {\n    parseMetaViewportEvents.push(event);\n    return;\n  }\n\n  if (!Types.Events.isEventTiming(event)) {\n    return;\n  }\n\n  if (Types.Events.isEventTimingEnd(event)) {\n    // Store the end event; for each start event that is an interaction, we need the matching end event to calculate the duration correctly.\n    eventTimingEndEventsForInteractions.push(event);\n  }\n\n  // From this point on we want to find events that represent interactions.\n  // These events are always start events - those are the ones that contain all\n  // the metadata about the interaction.\n  if (!event.args.data || !Types.Events.isEventTimingStart(event)) {\n    return;\n  }\n  const {duration, interactionId} = event.args.data;\n  // We exclude events for the sake of interactions if:\n  // 1. They have no duration.\n  // 2. They have no interactionId\n  // 3. They have an interactionId of 0: this indicates that it's not an\n  //    interaction that we care about because it hasn't had its own interactionId\n  //    set (0 is the default on the backend).\n  // See: https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/timing/responsiveness_metrics.cc;l=133;drc=40c209a9c365ebb9f16fb99dfe78c7fe768b9594\n\n  if (duration < 1 || interactionId === undefined || interactionId === 0) {\n    return;\n  }\n\n  // Store the start event. In the finalize() function we will pair this with\n  // its end event and create the synthetic interaction event.\n  eventTimingStartEventsForInteractions.push(event);\n}\n\n/**\n * See https://web.dev/better-responsiveness-metric/#interaction-types for the\n * table that defines these sets.\n **/\nconst pointerEventTypes = new Set([\n  'pointerdown',\n  'touchstart',\n  'pointerup',\n  'touchend',\n  'mousedown',\n  'mouseup',\n  'click',\n]);\n\nconst keyboardEventTypes = new Set([\n  'keydown',\n  'keypress',\n  'keyup',\n]);\n\nexport type InteractionCategory = 'KEYBOARD'|'POINTER'|'OTHER';\nexport function categoryOfInteraction(interaction: Types.Events.SyntheticInteractionPair): InteractionCategory {\n  if (pointerEventTypes.has(interaction.type)) {\n    return 'POINTER';\n  }\n  if (keyboardEventTypes.has(interaction.type)) {\n    return 'KEYBOARD';\n  }\n\n  return 'OTHER';\n}\n\n/**\n * We define a set of interactions as nested where:\n * 1. Their end times align.\n * 2. The longest interaction's start time is earlier than all other\n * interactions with the same end time.\n * 3. The interactions are of the same category [each interaction is either\n * categorised as keyboard, or pointer.]\n *\n * =============A=[pointerup]=\n *        ====B=[pointerdown]=\n *        ===C=[pointerdown]==\n *         ===D=[pointerup]===\n *\n * In this example, B, C and D are all nested and therefore should not be\n * returned from this function.\n *\n * However, in this example we would only consider B nested (under A) and D\n * nested (under C). A and C both stay because they are of different types.\n * ========A=[keydown]====\n *   =======B=[keyup]=====\n *    ====C=[pointerdown]=\n *         =D=[pointerup]=\n *\n * Additionally, this method will also maximise the processing duration of the\n * events that we keep as non-nested. We want to make sure we give an accurate\n * representation of main thread activity, so if we keep an event + hide its\n * nested children, we set the top level event's processing start &\n * processing end to be the earliest processing start & the latest processing\n * end of its children. This ensures we report a more accurate main thread\n * activity time which is important as we want developers to focus on fixing\n * this.\n **/\nexport function removeNestedInteractionsAndSetProcessingTime(\n    interactions: readonly Types.Events.SyntheticInteractionPair[]): readonly Types.Events.SyntheticInteractionPair[] {\n  /**\n   * Because we nest events only that are in the same category, we store the\n   * longest event for a given end time by category.\n   **/\n  const earliestEventForEndTimePerCategory:\n      Record<InteractionCategory, Map<Types.Timing.Micro, Types.Events.SyntheticInteractionPair>> = {\n        POINTER: new Map(),\n        KEYBOARD: new Map(),\n        OTHER: new Map(),\n      };\n\n  function storeEventIfEarliestForCategoryAndEndTime(interaction: Types.Events.SyntheticInteractionPair): void {\n    const category = categoryOfInteraction(interaction);\n    const earliestEventForEndTime = earliestEventForEndTimePerCategory[category];\n    const endTime = Types.Timing.Micro(interaction.ts + interaction.dur);\n\n    const earliestCurrentEvent = earliestEventForEndTime.get(endTime);\n    if (!earliestCurrentEvent) {\n      earliestEventForEndTime.set(endTime, interaction);\n      return;\n    }\n    if (interaction.ts < earliestCurrentEvent.ts) {\n      earliestEventForEndTime.set(endTime, interaction);\n    } else if (\n        interaction.ts === earliestCurrentEvent.ts &&\n        interaction.interactionId === earliestCurrentEvent.interactionId) {\n      // We have seen in traces that the same interaction can have multiple\n      // events (e.g. a 'click' and a 'pointerdown'). Often only one of these\n      // events will have an event handler bound to it which caused delay on\n      // the main thread, and the others will not. This leads to a situation\n      // where if we pick one of the events that had no event handler, its\n      // processing duration (processingEnd - processingStart) will be 0, but if we\n      // had picked the event that had the slow event handler, we would show\n      // correctly the main thread delay due to the event handler.\n      // So, if we find events with the same interactionId and the same\n      // begin/end times, we pick the one with the largest (processingEnd -\n      // processingStart) time in order to make sure we find the event with the\n      // worst main thread delay, as that is the one the user should care\n      // about.\n      const currentProcessingDuration = earliestCurrentEvent.processingEnd - earliestCurrentEvent.processingStart;\n      const newProcessingDuration = interaction.processingEnd - interaction.processingStart;\n\n      // Use the new interaction if it has a longer processing duration than the existing one.\n      if (newProcessingDuration > currentProcessingDuration) {\n        earliestEventForEndTime.set(endTime, interaction);\n      }\n    }\n\n    // Maximize the processing duration based on the \"children\" interactions.\n    // We pick the earliest start processing duration, and the latest end\n    // processing duration to avoid under-reporting.\n    if (interaction.processingStart < earliestCurrentEvent.processingStart) {\n      earliestCurrentEvent.processingStart = interaction.processingStart;\n      writeSyntheticTimespans(earliestCurrentEvent);\n    }\n    if (interaction.processingEnd > earliestCurrentEvent.processingEnd) {\n      earliestCurrentEvent.processingEnd = interaction.processingEnd;\n      writeSyntheticTimespans(earliestCurrentEvent);\n    }\n  }\n\n  for (const interaction of interactions) {\n    storeEventIfEarliestForCategoryAndEndTime(interaction);\n  }\n\n  // Combine all the events that we have kept from all the per-category event\n  // maps back into an array and sort them by timestamp.\n  const keptEvents = Object.values(earliestEventForEndTimePerCategory)\n                         .flatMap(eventsByEndTime => Array.from(eventsByEndTime.values()));\n  keptEvents.sort((eventA, eventB) => {\n    return eventA.ts - eventB.ts;\n  });\n  return keptEvents;\n}\n\nfunction writeSyntheticTimespans(event: Types.Events.SyntheticInteractionPair): void {\n  const startEvent = event.args.data.beginEvent;\n  const endEvent = event.args.data.endEvent;\n\n  event.inputDelay = Types.Timing.Micro(event.processingStart - startEvent.ts);\n  event.mainThreadHandling = Types.Timing.Micro(event.processingEnd - event.processingStart);\n  event.presentationDelay = Types.Timing.Micro(endEvent.ts - event.processingEnd);\n}\n\nexport async function finalize(): Promise<void> {\n  const {navigationsByFrameId} = metaHandlerData();\n\n  const beginAndEndEvents = Platform.ArrayUtilities.mergeOrdered(\n                                eventTimingStartEventsForInteractions, eventTimingEndEventsForInteractions,\n                                Helpers.Trace.eventTimeComparator) as Types.Events.EventTimingBeginOrEnd[];\n\n  // Pair up the begin & end events and create synthetic user timing events.\n  const beginEventById = new Map<string, Types.Events.EventTimingBegin[]>();\n  for (const event of beginAndEndEvents) {\n    if (Types.Events.isEventTimingStart(event)) {\n      const forId = beginEventById.get(event.id) ?? [];\n      forId.push(event);\n      beginEventById.set(event.id, forId);\n    } else if (Types.Events.isEventTimingEnd(event)) {\n      const beginEvents = beginEventById.get(event.id) ?? [];\n      const beginEvent = beginEvents.pop();\n      if (!beginEvent) {\n        continue;\n      }\n      const {type, interactionId, timeStamp, processingStart, processingEnd} = beginEvent.args.data;\n      if (!type || !interactionId || !timeStamp || !processingStart || !processingEnd) {\n        // A valid interaction event that we care about has to have a type (e.g. pointerdown, keyup).\n        // We also need to ensure it has an interactionId and various timings. There are edge cases where these aren't included in the trace event.\n        continue;\n      }\n      // In the future we will add microsecond timestamps to the trace events\n      // (See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/timing/window_performance.cc;l=900-901;drc=b503c262e425eae59ced4a80d59d176ed07152c7 )\n      // but until then we can use the millisecond precision values that are in\n      // the trace event. To adjust them to be relative to the event.ts and the\n      // trace timestamps, for both processingStart and processingEnd we subtract\n      // the event timestamp (NOT event.ts, but the timeStamp millisecond value\n      // emitted in args.data), and then add that value to the event.ts. This\n      // will give us a processingStart and processingEnd time in microseconds\n      // that is relative to event.ts, and can be used when drawing boxes.\n      // There is some inaccuracy here as we are converting milliseconds to\n      // microseconds, but it is good enough until the backend emits more\n      // accurate numbers.\n      const processingStartRelativeToTraceTime = Types.Timing.Micro(\n          Helpers.Timing.milliToMicro(processingStart) - Helpers.Timing.milliToMicro(timeStamp) + beginEvent.ts,\n      );\n\n      const processingEndRelativeToTraceTime = Types.Timing.Micro(\n          (Helpers.Timing.milliToMicro(processingEnd) - Helpers.Timing.milliToMicro(timeStamp)) + beginEvent.ts);\n\n      // Ultimate frameId fallback only needed for TSC, see comments in the type.\n      const frameId = beginEvent.args.frame ?? beginEvent.args.data.frame ?? '';\n      const navigation = Helpers.Trace.getNavigationForTraceEvent(beginEvent, frameId, navigationsByFrameId);\n      const navigationId = navigation?.args.data?.navigationId;\n      const interactionEvent =\n          Helpers.SyntheticEvents.SyntheticEventsManager.registerSyntheticEvent<Types.Events.SyntheticInteractionPair>({\n            // Use the start event to define the common fields.\n            rawSourceEvent: beginEvent,\n            cat: beginEvent.cat,\n            name: beginEvent.name,\n            pid: beginEvent.pid,\n            tid: beginEvent.tid,\n            ph: beginEvent.ph,\n            processingStart: processingStartRelativeToTraceTime,\n            processingEnd: processingEndRelativeToTraceTime,\n            // These will be set in writeSyntheticTimespans()\n            inputDelay: Types.Timing.Micro(-1),\n            mainThreadHandling: Types.Timing.Micro(-1),\n            presentationDelay: Types.Timing.Micro(-1),\n            args: {\n              data: {\n                beginEvent,\n                endEvent: event,\n                frame: frameId,\n                navigationId,\n              },\n            },\n            ts: beginEvent.ts,\n            dur: Types.Timing.Micro(event.ts - beginEvent.ts),\n            type: beginEvent.args.data.type,\n            interactionId: beginEvent.args.data.interactionId,\n          });\n      writeSyntheticTimespans(interactionEvent);\n      interactionEvents.push(interactionEvent);\n    }\n  }\n\n  // Once we gather up all the interactions, we want to remove nested\n  // interactions. Interactions can be nested because one user action (e.g. a\n  // click) will cause a pointerdown, pointerup and click. But we don't want to\n  // fill the interactions track with lots of noise. To fix this, we go through\n  // all the events and remove any nested ones so on the timeline we focus the\n  // user on the most important events, which we define as the longest one. But\n  // this algorithm assumes the events are in ASC order, so we first sort the\n  // set of interactions.\n  Helpers.Trace.sortTraceEventsInPlace(interactionEvents);\n  interactionEventsWithNoNesting.push(...removeNestedInteractionsAndSetProcessingTime(interactionEvents));\n\n  // Pick the longest interactions from the set that were not nested, as we\n  // know those are the set of the largest interactions.\n  for (const interactionEvent of interactionEventsWithNoNesting) {\n    if (!longestInteractionEvent || longestInteractionEvent.dur < interactionEvent.dur) {\n      longestInteractionEvent = interactionEvent;\n    }\n  }\n}\n\nexport function data(): UserInteractionsData {\n  return {\n    beginCommitCompositorFrameEvents,\n    parseMetaViewportEvents,\n    interactionEvents,\n    interactionEventsWithNoNesting,\n    longestInteractionEvent,\n    interactionsOverThreshold: new Set(interactionEvents.filter(event => {\n      return event.dur > LONG_INTERACTION_THRESHOLD;\n    })),\n  };\n}\n\nexport function deps(): HandlerName[] {\n  return ['Meta'];\n}\n\n/**\n * Classifications sourced from\n * https://web.dev/articles/inp#good-score\n */\nexport function scoreClassificationForInteractionToNextPaint(timing: Types.Timing.Micro): ScoreClassification {\n  if (timing <= INP_GOOD_TIMING) {\n    return ScoreClassification.GOOD;\n  }\n\n  if (timing <= INP_MEDIUM_TIMING) {\n    return ScoreClassification.OK;\n  }\n\n  return ScoreClassification.BAD;\n}\n", "// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport type {HandlerName} from './types.js';\nimport {data as userInteractionsHandlerData} from './UserInteractionsHandler.js';\nimport {data as workersData} from './WorkersHandler.js';\n\nexport interface WarningsData {\n  // Tracks warnings keyed by the event.\n  perEvent: Map<Types.Events.Event, Warning[]>;\n  // The same data in reverse: for each type of warning, track the events.\n  // Useful if we need to enumerate events by type of issue\n  perWarning: Map<Warning, Types.Events.Event[]>;\n}\n\nexport type Warning = 'LONG_TASK'|'IDLE_CALLBACK_OVER_TIME'|'FORCED_REFLOW'|'LONG_INTERACTION';\n\nlet warningsPerEvent: WarningsData['perEvent'] = new Map();\nlet eventsPerWarning: WarningsData['perWarning'] = new Map();\n\n/**\n * Tracks the stack formed by nested trace events up to a given point\n */\nlet allEventsStack: Types.Events.Event[] = [];\n/**\n * Tracks the stack formed by JS invocation trace events up to a given point.\n * F.e. FunctionCall, EvaluateScript, V8Execute.\n * Not to be confused with ProfileCalls.\n */\nlet jsInvokeStack: Types.Events.Event[] = [];\n/**\n * Tracks reflow events in a task.\n */\nlet taskReflowEvents: Types.Events.Event[] = [];\n/**\n * Tracks events containing long running tasks. These are compared later against the worker thread pool to filter out long tasks from worker threads.\n */\nlet longTaskEvents: Types.Events.Event[] = [];\n\nexport const FORCED_REFLOW_THRESHOLD = Helpers.Timing.milliToMicro(Types.Timing.Milli(30));\n\nexport const LONG_MAIN_THREAD_TASK_THRESHOLD = Helpers.Timing.milliToMicro(Types.Timing.Milli(50));\n\nexport function reset(): void {\n  warningsPerEvent = new Map();\n  eventsPerWarning = new Map();\n  allEventsStack = [];\n  jsInvokeStack = [];\n  taskReflowEvents = [];\n  longTaskEvents = [];\n}\n\nfunction storeWarning(event: Types.Events.Event, warning: Warning): void {\n  const existingWarnings = Platform.MapUtilities.getWithDefault(warningsPerEvent, event, () => []);\n  existingWarnings.push(warning);\n  warningsPerEvent.set(event, existingWarnings);\n\n  const existingEvents = Platform.MapUtilities.getWithDefault(eventsPerWarning, warning, () => []);\n  existingEvents.push(event);\n  eventsPerWarning.set(warning, existingEvents);\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  processForcedReflowWarning(event);\n  if (event.name === Types.Events.Name.RUN_TASK) {\n    const {duration} = Helpers.Timing.eventTimingsMicroSeconds(event);\n    if (duration > LONG_MAIN_THREAD_TASK_THRESHOLD) {\n      longTaskEvents.push(event);\n    }\n    return;\n  }\n\n  if (Types.Events.isFireIdleCallback(event)) {\n    const {duration} = Helpers.Timing.eventTimingsMilliSeconds(event);\n    if (duration > event.args.data.allottedMilliseconds) {\n      storeWarning(event, 'IDLE_CALLBACK_OVER_TIME');\n    }\n    return;\n  }\n}\n\n/**\n * Reflows* are added a warning to if:\n * 1. They are forced/sync, meaning they are invoked by JS and finish\n *    during the Script execution.\n * 2. Their duration exceeds a threshold.\n * - *Reflow: The style recalculation and layout steps in a render task.\n */\nfunction processForcedReflowWarning(event: Types.Events.Event): void {\n  // Update the event and the JS invocation stacks.\n  accomodateEventInStack(event, allEventsStack);\n  accomodateEventInStack(event, jsInvokeStack, /* pushEventToStack */ Types.Events.isJSInvocationEvent(event));\n  if (jsInvokeStack.length) {\n    // Current event falls inside a JS call.\n    if (event.name === Types.Events.Name.LAYOUT || event.name === Types.Events.Name.RECALC_STYLE) {\n      // A forced reflow happened. However we need to check if\n      // the threshold is surpassed to add a warning. Accumulate the\n      // event to check for this after the current Task is over.\n      taskReflowEvents.push(event);\n      return;\n    }\n  }\n  if (allEventsStack.length === 1) {\n    // We hit a new task. Check if the forced reflows in the previous\n    // task exceeded the threshold and add a warning if so.\n    const totalTime = taskReflowEvents.reduce((time, event) => time + (event.dur || 0), 0);\n    if (totalTime >= FORCED_REFLOW_THRESHOLD) {\n      taskReflowEvents.forEach(reflowEvent => storeWarning(reflowEvent, 'FORCED_REFLOW'));\n    }\n    taskReflowEvents.length = 0;\n  }\n}\n\n/**\n * Updates a given trace event stack given a new event.\n */\nfunction accomodateEventInStack(event: Types.Events.Event, stack: Types.Events.Event[], pushEventToStack = true): void {\n  let nextItem = stack.at(-1);\n  while (nextItem && event.ts > nextItem.ts + (nextItem.dur || 0)) {\n    stack.pop();\n    nextItem = stack.at(-1);\n  }\n  if (!pushEventToStack) {\n    return;\n  }\n  stack.push(event);\n}\n\nexport function deps(): HandlerName[] {\n  return ['UserInteractions', 'Workers'];\n}\n\nexport async function finalize(): Promise<void> {\n  // These events do exist on the UserInteractionsHandler, but we also put\n  // them into the WarningsHandler so that the warnings handler can be the\n  // source of truth and the way to look up all warnings for a given event.\n  // Otherwise, we would have to look up warnings across multiple handlers for\n  // a given event, which will start to get messy very quickly.\n  const longInteractions = userInteractionsHandlerData().interactionsOverThreshold;\n  for (const interaction of longInteractions) {\n    storeWarning(interaction, 'LONG_INTERACTION');\n  }\n\n  for (const event of longTaskEvents) {\n    if (!(event.tid, workersData().workerIdByThread.has(event.tid))) {\n      storeWarning(event, 'LONG_TASK');\n    }\n  }\n  longTaskEvents.length = 0;\n}\n\nexport function data(): WarningsData {\n  return {\n    perEvent: warningsPerEvent,\n    perWarning: eventsPerWarning,\n  };\n}\n", "// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Types from '../types/types.js';\n\nexport interface WorkersData {\n  workerSessionIdEvents: readonly Types.Events.TracingSessionIdForWorker[];\n  workerIdByThread: Map<Types.Events.ThreadID, Types.Events.WorkerId>;\n  workerURLById: Map<Types.Events.WorkerId, string>;\n}\n\nlet sessionIdEvents: Types.Events.TracingSessionIdForWorker[] = [];\nlet workerIdByThread = new Map<Types.Events.ThreadID, Types.Events.WorkerId>();\nlet workerURLById = new Map<Types.Events.WorkerId, string>();\n\nexport function reset(): void {\n  sessionIdEvents = [];\n  workerIdByThread = new Map();\n  workerURLById = new Map();\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isTracingSessionIdForWorker(event)) {\n    sessionIdEvents.push(event);\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  for (const sessionIdEvent of sessionIdEvents) {\n    if (!sessionIdEvent.args.data) {\n      continue;\n    }\n    workerIdByThread.set(sessionIdEvent.args.data.workerThreadId, sessionIdEvent.args.data.workerId);\n    workerURLById.set(sessionIdEvent.args.data.workerId, sessionIdEvent.args.data.url);\n  }\n}\n\nexport function data(): WorkersData {\n  return {\n    workerSessionIdEvents: sessionIdEvents,\n    workerIdByThread,\n    workerURLById,\n  };\n}\n", "export {};\n//# sourceMappingURL=types.js.map"],
  "mappings": "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",
  "names": ["entityMappings", "Types", "data", "config", "data", "finalize", "handleEvent", "reset", "Helpers", "Types", "syntheticEvents", "data", "deps", "finalize", "handleEvent", "reset", "Platform", "Types", "data", "finalize", "handleEvent", "reset", "Types", "flows", "data", "deps", "finalize", "handleEvent", "handleUserConfig", "reset", "Platform", "Helpers", "Types", "data", "finalize", "handleEvent", "reset", "Helpers", "Types", "data", "finalize", "handleEvent", "reset", "Platform", "Helpers", "Types", "data", "deps", "finalize", "handleEvent", "reset", "Platform", "Helpers", "Types", "reset", "handleEvent", "finalize", "data", "deps", "traceBounds", "data", "finalize", "handleEvent", "reset", "Platform", "Helpers", "Types", "timeDeltas", "entityMappings", "entryToNode", "config", "processes", "handleUserConfig", "reset", "handleEvent", "finalize", "mainFrameId", "threadsInProcess", "data", "deps", "reset", "handleEvent", "finalize", "flows", "data", "entryToNode", "node", "deps", "data", "finalize", "handleEvent", "reset", "Platform", "Types", "data", "deps", "finalize", "handleEvent", "reset", "Helpers", "Types", "data", "finalize", "handleEvent", "reset", "Helpers", "Types", "entryToNode", "handleEvent", "reset", "finalize", "data", "deps", "data", "deps", "finalize", "handleEvent", "reset", "Platform", "Helpers", "Types", "data", "deps", "finalize", "handleEvent", "reset", "Helpers", "Types", "reset", "handleEvent", "finalize", "data", "deps", "reset", "handleEvent", "finalize", "data", "deps", "mainFrameId", "frames", "data", "deps", "finalize", "handleEvent", "reset", "Helpers", "Types", "reset", "handleEvent", "finalize", "gpuProcessId", "gpuThreadId", "data", "deps", "data", "finalize", "handleEvent", "reset", "Platform", "Types", "reset", "handleEvent", "finalize", "data", "paintEvents", "data", "deps", "finalize", "handleEvent", "reset", "Helpers", "Types", "eventToInitiatorMap", "reset", "data", "handleEvent", "flows", "finalize", "deps", "data", "finalize", "handleEvent", "handleUserConfig", "reset", "Types", "data", "deps", "finalize", "handleEvent", "reset", "Platform", "Types", "data", "deps", "finalize", "handleEvent", "reset", "Platform", "Helpers", "Types", "reset", "handleEvent", "data", "navigationsByNavigationId", "navigationsByFrameId", "finalize", "deps", "reset", "handleEvent", "finalize", "data", "traceBounds", "navigationsByNavigationId", "metricScoresByFrameId", "deps", "data", "finalize", "handleEvent", "reset", "Types", "data", "deps", "finalize", "handleEvent", "reset", "Platform", "Helpers", "Types", "data", "deps", "finalize", "handleEvent", "reset", "Helpers", "Types", "data", "deps", "paintImageEvents", "reset", "handleEvent", "data", "traceBounds", "finalize", "navigationsByFrameId", "mainFrameId", "currentCluster", "deps", "data", "finalize", "handleEvent", "reset", "Platform", "Types", "data", "finalize", "handleEvent", "reset", "Types", "data", "deps", "finalize", "handleEvent", "reset", "Platform", "Types", "deps", "reset", "handleEvent", "frames", "finalize", "data", "data", "finalize", "handleEvent", "reset", "Types", "data", "deps", "finalize", "handleEvent", "reset", "Platform", "Helpers", "Types", "reset", "handleEvent", "finalize", "navigationsByFrameId", "data", "deps", "data", "deps", "finalize", "handleEvent", "reset", "Platform", "Helpers", "Types", "data", "finalize", "handleEvent", "reset", "Types", "reset", "handleEvent", "event", "deps", "finalize", "data"]
}
