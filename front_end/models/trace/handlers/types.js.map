{"version":3,"file":"types.js","sourceRoot":"","sources":["../../../../../../../front_end/models/trace/handlers/types.ts"],"names":[],"mappings":"","sourcesContent":["\n// Copyright 2022 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport type * as Types from './../types/types.js';\nimport type * as ModelHandlers from './ModelHandlers.js';\n\nexport type FinalizeOptions = Types.Configuration.ParseOptions&{\n  allTraceEvents: readonly Types.Events.Event[],\n};\n\nexport interface Handler {\n  reset(): void;\n  handleEvent(data: object): void;\n  finalize(options?: FinalizeOptions): Promise<void>;\n  data(): unknown;\n  deps?(): HandlerName[];\n  handleUserConfig?(config: Types.Configuration.Configuration): void;\n}\n\nexport type HandlerName = keyof typeof ModelHandlers;\n\n/**\n * This type maps Handler names to the return type of their data\n * function. So, for example, if we are given an object with a key of 'foo'\n * and a value which is a TraceHandler containing a data() function that\n * returns a string, this type will be { foo: string }.\n *\n * This allows us to model the behavior of the TraceProcessor in the model,\n * which takes an object with Handlers as part of its config, and\n * which ultimately returns an object keyed off the names of the\n * Handlers, and with values that are derived from each\n * Handler's data function.\n *\n * So, concretely, we provide a Handler for calculating the #time\n * bounds of a trace called TraceBounds, whose data() function returns a\n * TraceWindow. The HandlerData, therefore, would determine that the\n * TraceProcessor would contain a key called 'TraceBounds' whose value is\n * a TraceWindow.\n **/\nexport type EnabledHandlerDataWithMeta<T extends Record<string, Handler>> = {\n  // We allow the user to configure which handlers are created by passing them\n  // in when constructing a model instance. However, we then ensure that the\n  // Meta handler is added to that, as the Model relies on some of the data\n  // from the Meta handler when creating the file. Therefore, this type\n  // explicitly defines that the Meta data is present, before then extending it\n  // with the index type to represent all the other handlers.\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  Meta: Readonly<ReturnType<typeof ModelHandlers['Meta']['data']>>,\n}&{\n  // For every key in the object, look up the Handler's data function\n  // and use its return type as the value for the object.\n  [K in keyof T]: Readonly<ReturnType<T[K]['data']>>;\n};\n\nexport type HandlersWithMeta<T extends Record<string, Handler>> = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  Meta: typeof ModelHandlers.Meta,\n}&{\n  [K in keyof T]: T[K];\n};\n\n/**\n * Represents the final data from all of the handlers. If you instantiate a\n * TraceProcessor with a subset of handlers, you should instead use\n * `EnabledHandlerDataWithMeta<>`.\n **/\nexport type HandlerData = Readonly<EnabledHandlerDataWithMeta<typeof ModelHandlers>>;\n\ntype DeepWriteable<T> = {\n  -readonly[P in keyof T]: DeepWriteable<T[P]>\n};\nexport type HandlerDataMutable = DeepWriteable<HandlerData>;\n\nexport type Handlers = typeof ModelHandlers;\n"]}