{"version":3,"file":"SamplesIntegrator.js","sourceRoot":"","sources":["../../../../../../../front_end/models/trace/helpers/SamplesIntegrator.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Protocol from '../../../generated/protocol.js';\nimport type * as CPUProfile from '../../cpu_profile/cpu_profile.js';\nimport * as Types from '../types/types.js';\n\nimport {milliToMicro} from './Timing.js';\nimport {extractSampleTraceId, makeProfileCall, mergeEventsInOrder, sortTraceEventsInPlace} from './Trace.js';\n\n/**\n * This is a helper that integrates CPU profiling data coming in the\n * shape of samples, with trace events. Samples indicate what the JS\n * stack trace looked at a given point in time, but they don't have\n * duration. The SamplesIntegrator task is to make an approximation\n * of what the duration of each JS call was, given the sample data and\n * given the trace events profiled during that time. At the end of its\n * execution, the SamplesIntegrator returns an array of ProfileCalls\n * (under SamplesIntegrator::buildProfileCalls()), which\n * represent JS calls, with a call frame and duration. These calls have\n * the shape of a complete trace events and can be treated as flame\n * chart entries in the timeline.\n *\n * The approach to build the profile calls consists in tracking the\n * current stack as the following events happen (in order):\n * 1. A sample was done.\n * 2. A trace event started.\n * 3. A trace event ended.\n * Depending on the event and on the data that's coming with it the\n * stack is updated by adding or removing JS calls to it and updating\n * the duration of the calls in the tracking stack.\n *\n * note: Although this approach has been implemented since long ago, and\n * is relatively efficient (adds a complexity over the trace parsing of\n * O(n) where n is the number of samples) it has proven to be faulty.\n * It might be worthwhile experimenting with improvements or with a\n * completely different approach. Improving the approach is tracked in\n * crbug.com/1417439\n */\nexport class SamplesIntegrator {\n  /**\n   * The result of running the samples integrator. Holds the JS calls\n   * with their approximated duration after integrating samples into the\n   * trace event tree.\n   */\n  #constructedProfileCalls: Types.Events.SyntheticProfileCall[] = [];\n  /**\n   * tracks the state of the JS stack at each point in time to update\n   * the profile call durations as new events arrive. This doesn't only\n   * happen with new profile calls (in which case we would compare the\n   * stack in them) but also with trace events (in which case we would\n   * update the duration of the events we are tracking at the moment).\n   */\n  #currentJSStack: Types.Events.SyntheticProfileCall[] = [];\n  /**\n   * Process holding the CPU profile and trace events.\n   */\n  #processId: Types.Events.ProcessID;\n  /**\n   * Thread holding the CPU profile and trace events.\n   */\n  #threadId: Types.Events.ThreadID;\n  /**\n   * Tracks the depth of the JS stack at the moment a trace event starts\n   * or ends. It is assumed that for the duration of a trace event, the\n   * JS stack's depth cannot decrease, since JS calls that started\n   * before a trace event cannot end during the trace event. So as trace\n   * events arrive, we store the \"locked\" amount of JS frames that were\n   * in the stack before the event came.\n   */\n  #lockedJsStackDepth: number[] = [];\n  /**\n   * Used to keep track when samples should be integrated even if they\n   * are not children of invocation trace events. This is useful in\n   * cases where we can be missing the start of JS invocation events if\n   * we start tracing half-way through.\n   */\n  #fakeJSInvocation = false;\n  /**\n   * The parsed CPU profile, holding the tree hierarchy of JS frames and\n   * the sample data.\n   */\n  #profileModel: CPUProfile.CPUProfileDataModel.CPUProfileDataModel;\n  /**\n   * Because GC nodes don't have a stack, we artificially add a stack to\n   * them which corresponds to that of the previous sample. This map\n   * tracks which node is used for the stack of a GC call.\n   * Note that GC samples are not shown in the flamechart, however they\n   * are used during the construction of for profile calls, as we can\n   * infer information about the duration of the executed code when a\n   * GC node is sampled.\n   */\n  #nodeForGC = new Map<Types.Events.SyntheticProfileCall, CPUProfile.ProfileTreeModel.ProfileNode>();\n\n  #engineConfig: Types.Configuration.Configuration;\n  #profileId: Types.Events.ProfileID;\n\n  /**\n   * Keeps track of the individual samples from the CPU Profile.\n   * Only used with Debug Mode experiment enabled.\n   */\n  jsSampleEvents: Types.Events.SyntheticJSSample[] = [];\n\n  constructor(\n      profileModel: CPUProfile.CPUProfileDataModel.CPUProfileDataModel, profileId: Types.Events.ProfileID,\n      pid: Types.Events.ProcessID, tid: Types.Events.ThreadID, configuration?: Types.Configuration.Configuration) {\n    this.#profileModel = profileModel;\n    this.#threadId = tid;\n    this.#processId = pid;\n    this.#engineConfig = configuration || Types.Configuration.defaults();\n    this.#profileId = profileId;\n  }\n\n  buildProfileCalls(traceEvents: Types.Events.Event[]): Types.Events.SyntheticProfileCall[] {\n    const mergedEvents = mergeEventsInOrder(traceEvents, this.callsFromProfileSamples());\n    const stack = [];\n    for (let i = 0; i < mergedEvents.length; i++) {\n      const event = mergedEvents[i];\n      // Because instant trace events have no duration, they don't provide\n      // useful information for possible changes in the duration of calls\n      // in the JS stack.\n      if (event.ph === Types.Events.Phase.INSTANT && !extractSampleTraceId(event)) {\n        continue;\n      }\n      if (stack.length === 0) {\n        if (Types.Events.isProfileCall(event)) {\n          this.#onProfileCall(event);\n          continue;\n        }\n        stack.push(event);\n        this.#onTraceEventStart(event);\n        continue;\n      }\n\n      const parentEvent = stack.at(-1);\n      if (parentEvent === undefined) {\n        continue;\n      }\n      const begin = event.ts;\n      const parentBegin = parentEvent.ts;\n      const parentDuration = parentEvent.dur || 0;\n      const parentEnd = parentBegin + parentDuration;\n\n      const startsAfterParent = begin >= parentEnd;\n      if (startsAfterParent) {\n        this.#onTraceEventEnd(parentEvent);\n        stack.pop();\n        i--;\n        continue;\n      }\n      if (Types.Events.isProfileCall(event)) {\n        this.#onProfileCall(event, parentEvent);\n        continue;\n      }\n      this.#onTraceEventStart(event);\n      stack.push(event);\n    }\n    while (stack.length) {\n      const last = stack.pop();\n      if (last) {\n        this.#onTraceEventEnd(last);\n      }\n    }\n    sortTraceEventsInPlace(this.jsSampleEvents);\n    return this.#constructedProfileCalls;\n  }\n\n  #onTraceEventStart(event: Types.Events.Event): void {\n    // Top level events cannot be nested into JS frames so we reset\n    // the stack when we find one.\n    if (event.name === Types.Events.Name.RUN_MICROTASKS || event.name === Types.Events.Name.RUN_TASK) {\n      this.#lockedJsStackDepth = [];\n      this.#truncateJSStack(0, event.ts);\n      this.#fakeJSInvocation = false;\n    }\n\n    if (this.#fakeJSInvocation) {\n      this.#truncateJSStack(this.#lockedJsStackDepth.pop() || 0, event.ts);\n      this.#fakeJSInvocation = false;\n    }\n    this.#extractStackTrace(event);\n    // Keep track of the call frames in the stack before the event\n    // happened. For the duration of this event, these frames cannot\n    // change (none can be terminated before this event finishes).\n    //\n    // Also, every frame that is opened after this event, is considered\n    // to be a descendant of the event. So once the event finishes, the\n    // frames that were opened after it, need to be closed (see\n    // onEndEvent).\n    //\n    // TODO(crbug.com/1417439):\n    // The assumption that every frame opened after an event is a\n    // descendant of the event is incorrect. For example, a JS call that\n    // parents a trace event might have been sampled after the event was\n    // dispatched. In this case the JS call would be discarded if this\n    // event isn't an invocation event, otherwise the call will be\n    // considered a child of the event. In both cases, the result would\n    // be incorrect.\n    this.#lockedJsStackDepth.push(this.#currentJSStack.length);\n  }\n\n  #onProfileCall(event: Types.Events.SyntheticProfileCall, parent?: Types.Events.Event): void {\n    if ((parent && Types.Events.isJSInvocationEvent(parent)) || this.#fakeJSInvocation) {\n      this.#extractStackTrace(event);\n    } else if (Types.Events.isProfileCall(event) && this.#currentJSStack.length === 0) {\n      // Force JS Samples to show up even if we are not inside a JS\n      // invocation event, because we can be missing the start of JS\n      // invocation events if we start tracing half-way through. Pretend\n      // we have a top-level JS invocation event.\n      this.#fakeJSInvocation = true;\n      const stackDepthBefore = this.#currentJSStack.length;\n      this.#extractStackTrace(event);\n      this.#lockedJsStackDepth.push(stackDepthBefore);\n    }\n  }\n\n  #onTraceEventEnd(event: Types.Events.Event): void {\n    // Because the event has ended, any frames that happened after\n    // this event are terminated. Frames that are ancestors to this\n    // event are extended to cover its ending.\n    const endTime = Types.Timing.Micro(event.ts + (event.dur ?? 0));\n    this.#truncateJSStack(this.#lockedJsStackDepth.pop() || 0, endTime);\n  }\n\n  /**\n   * Builds the initial calls with no duration from samples. Their\n   * purpose is to be merged with the trace event array being parsed so\n   * that they can be traversed in order with them and their duration\n   * can be updated as the SampleIntegrator callbacks are invoked.\n   */\n  callsFromProfileSamples(): Types.Events.SyntheticProfileCall[] {\n    const samples = this.#profileModel.samples;\n    const timestamps = this.#profileModel.timestamps;\n    if (!samples) {\n      return [];\n    }\n    const calls: Types.Events.SyntheticProfileCall[] = [];\n    let prevNode;\n    for (let i = 0; i < samples.length; i++) {\n      const node = this.#profileModel.nodeByIndex(i);\n      const timestamp = milliToMicro(Types.Timing.Milli(timestamps[i]));\n      if (!node) {\n        continue;\n      }\n      const call = makeProfileCall(node, this.#profileId, i, timestamp, this.#processId, this.#threadId);\n      calls.push(call);\n\n      if (this.#engineConfig.debugMode) {\n        const traceId = this.#profileModel.traceIds?.[i];\n        this.jsSampleEvents.push(this.#makeJSSampleEvent(call, timestamp, traceId));\n      }\n      if (node.id === this.#profileModel.gcNode?.id && prevNode) {\n        // GC samples have no stack, so we just put GC node on top of the\n        // last recorded sample. Cache the previous sample for future\n        // reference.\n        this.#nodeForGC.set(call, prevNode);\n        continue;\n      }\n      prevNode = node;\n    }\n    return calls;\n  }\n\n  /**\n   * Given a synthetic profile call, returns an array of profile calls\n   * representing the stack trace that profile call belongs to based on\n   * its nodeId. The input profile call will be at the top of the\n   * returned stack (last position), meaning that any other frames that\n   * were effectively above it are omitted.\n   * @param profileCall\n   * @param overrideTimeStamp a custom timestamp to use for the returned\n   * profile calls. If not defined, the timestamp of the input\n   * profileCall is used instead. This param is useful for example when\n   * creating the profile calls for a sample with a trace id, since the\n   * timestamp of the corresponding trace event should be used instead\n   * of the sample's.\n   */\n\n  #makeProfileCallsForStack(profileCall: Types.Events.SyntheticProfileCall, overrideTimeStamp?: Types.Timing.Micro):\n      Types.Events.SyntheticProfileCall[] {\n    let node = this.#profileModel.nodeById(profileCall.nodeId);\n    const isGarbageCollection = node?.id === this.#profileModel.gcNode?.id;\n    if (isGarbageCollection) {\n      // Because GC don't have a stack, we use the stack of the previous\n      // sample.\n      node = this.#nodeForGC.get(profileCall) || null;\n    }\n    if (!node) {\n      return [];\n    }\n    // `node.depth` is 0 based, so to set the size of the array we need\n    // to add 1 to its value.\n    const callFrames = new Array<Types.Events.SyntheticProfileCall>(node.depth + 1 + Number(isGarbageCollection));\n    // Add the stack trace in reverse order (bottom first).\n    let i = callFrames.length - 1;\n    if (isGarbageCollection) {\n      // Place the garbage collection call frame on top of the stack.\n      callFrames[i--] = profileCall;\n    }\n\n    // Many of these ProfileCalls will be GC'd later when we estimate the frame\n    // durations\n    while (node) {\n      callFrames[i--] = makeProfileCall(\n          node, profileCall.profileId, profileCall.sampleIndex, overrideTimeStamp ?? profileCall.ts, this.#processId,\n          this.#threadId);\n      node = node.parent;\n    }\n    return callFrames;\n  }\n\n  #getStackForSampleTraceId(traceId: number, timestamp: Types.Timing.Micro): Types.Events.SyntheticProfileCall[]|null {\n    const nodeId = this.#profileModel.traceIds?.[traceId];\n    const node = nodeId && this.#profileModel.nodeById(nodeId);\n    const maybeCallForTraceId =\n        node && makeProfileCall(node, this.#profileId, -1, timestamp, this.#processId, this.#threadId);\n    if (!maybeCallForTraceId) {\n      return null;\n    }\n    if (this.#engineConfig.debugMode) {\n      this.jsSampleEvents.push(this.#makeJSSampleEvent(maybeCallForTraceId, timestamp, traceId));\n    }\n    return this.#makeProfileCallsForStack(maybeCallForTraceId);\n  }\n  /**\n   * Update tracked stack using this event's call stack.\n   */\n  #extractStackTrace(event: Types.Events.Event): void {\n    let stackTrace = this.#currentJSStack;\n    if (Types.Events.isProfileCall(event)) {\n      stackTrace = this.#makeProfileCallsForStack(event);\n    }\n    const traceId = extractSampleTraceId(event);\n    const maybeCallForTraceId = traceId && this.#getStackForSampleTraceId(traceId, event.ts);\n    if (maybeCallForTraceId) {\n      stackTrace = maybeCallForTraceId;\n    }\n\n    SamplesIntegrator.filterStackFrames(stackTrace, this.#engineConfig);\n\n    const endTime = event.ts + (event.dur || 0);\n    const minFrames = Math.min(stackTrace.length, this.#currentJSStack.length);\n    let i;\n    // Merge a sample's stack frames with the stack frames we have\n    // so far if we detect they are equivalent.\n    // Graphically\n    // This:\n    // Current stack trace       Sample\n    // [-------A------]          [A]\n    // [-------B------]          [B]\n    // [-------C------]          [C]\n    //                ^ t = x1    ^ t = x2\n\n    // Becomes this:\n    // New stack trace after merge\n    // [--------A-------]\n    // [--------B-------]\n    // [--------C-------]\n    //                  ^ t = x2\n    for (i = this.#lockedJsStackDepth.at(-1) || 0; i < minFrames; ++i) {\n      const newFrame = stackTrace[i].callFrame;\n      const oldFrame = this.#currentJSStack[i].callFrame;\n      if (!SamplesIntegrator.framesAreEqual(newFrame, oldFrame)) {\n        break;\n      }\n      // Scoot the right edge of this callFrame to the right\n      this.#currentJSStack[i].dur =\n          Types.Timing.Micro(Math.max(this.#currentJSStack[i].dur || 0, endTime - this.#currentJSStack[i].ts));\n    }\n\n    // If there are call frames in the sample that differ with the stack\n    // we have, update the stack, but keeping the common frames in place\n    // Graphically\n    // This:\n    // Current stack trace       Sample\n    // [-------A------]          [A]\n    // [-------B------]          [B]\n    // [-------C------]          [C]\n    // [-------D------]          [E]\n    //                ^ t = x1    ^ t = x2\n    // Becomes this:\n    // New stack trace after merge\n    // [--------A-------]\n    // [--------B-------]\n    // [--------C-------]\n    //                [E]\n    //                  ^ t = x2\n    this.#truncateJSStack(i, event.ts);\n\n    for (; i < stackTrace.length; ++i) {\n      const call = stackTrace[i];\n      if (call.nodeId === this.#profileModel.programNode?.id || call.nodeId === this.#profileModel.root?.id ||\n          call.nodeId === this.#profileModel.idleNode?.id || call.nodeId === this.#profileModel.gcNode?.id) {\n        // Skip (root), (program) and (idle) frames, since this are not\n        // relevant for web profiling and we don't want to show them in\n        // the timeline.\n        continue;\n      }\n      this.#currentJSStack.push(call);\n      this.#constructedProfileCalls.push(call);\n    }\n  }\n\n  /**\n   * When a call stack that differs from the one we are tracking has\n   * been detected in the samples, the latter is \"truncated\" by\n   * setting the ending time of its call frames and removing the top\n   * call frames that aren't shared with the new call stack. This way,\n   * we can update the tracked stack with the new call frames on top.\n   * @param depth the amount of call frames from bottom to top that\n   * should be kept in the tracking stack trace. AKA amount of shared\n   * call frames between two stacks.\n   * @param time the new end of the call frames in the stack.\n   */\n  #truncateJSStack(depth: number, time: Types.Timing.Micro): void {\n    if (this.#lockedJsStackDepth.length) {\n      const lockedDepth = this.#lockedJsStackDepth.at(-1);\n      if (lockedDepth && depth < lockedDepth) {\n        console.error(`Child stack is shallower (${depth}) than the parent stack (${lockedDepth}) at ${time}`);\n        depth = lockedDepth;\n      }\n    }\n    if (this.#currentJSStack.length < depth) {\n      console.error(`Trying to truncate higher than the current stack size at ${time}`);\n      depth = this.#currentJSStack.length;\n    }\n    for (let k = 0; k < this.#currentJSStack.length; ++k) {\n      this.#currentJSStack[k].dur = Types.Timing.Micro(Math.max(time - this.#currentJSStack[k].ts, 0));\n    }\n    this.#currentJSStack.length = depth;\n  }\n\n  #makeJSSampleEvent(call: Types.Events.SyntheticProfileCall, timestamp: Types.Timing.Micro, traceId?: number):\n      Types.Events.SyntheticJSSample {\n    const JSSampleEvent: Types.Events.SyntheticJSSample = {\n      name: Types.Events.Name.JS_SAMPLE,\n      cat: 'devtools.timeline',\n      args: {\n        data: {traceId, stackTrace: this.#makeProfileCallsForStack(call).map(e => e.callFrame)},\n      },\n      ph: Types.Events.Phase.INSTANT,\n      ts: timestamp,\n      dur: Types.Timing.Micro(0),\n      pid: this.#processId,\n      tid: this.#threadId,\n    };\n    return JSSampleEvent;\n  }\n\n  static framesAreEqual(frame1: Protocol.Runtime.CallFrame, frame2: Protocol.Runtime.CallFrame): boolean {\n    return frame1.scriptId === frame2.scriptId && frame1.functionName === frame2.functionName &&\n        frame1.lineNumber === frame2.lineNumber;\n  }\n\n  static showNativeName(name: string, runtimeCallStatsEnabled: boolean): boolean {\n    return runtimeCallStatsEnabled && Boolean(SamplesIntegrator.nativeGroup(name));\n  }\n\n  static nativeGroup(nativeName: string): SamplesIntegrator.NativeGroups|null {\n    if (nativeName.startsWith('Parse')) {\n      return SamplesIntegrator.NativeGroups.PARSE;\n    }\n    if (nativeName.startsWith('Compile') || nativeName.startsWith('Recompile')) {\n      return SamplesIntegrator.NativeGroups.COMPILE;\n    }\n    return null;\n  }\n\n  static isNativeRuntimeFrame(frame: Protocol.Runtime.CallFrame): boolean {\n    return frame.url === 'native V8Runtime';\n  }\n\n  static filterStackFrames(stack: Types.Events.SyntheticProfileCall[], engineConfig: Types.Configuration.Configuration):\n      void {\n    const showAllEvents = engineConfig.showAllEvents;\n    if (showAllEvents) {\n      return;\n    }\n    let previousNativeFrameName: string|null = null;\n    let j = 0;\n    for (let i = 0; i < stack.length; ++i) {\n      const frame = stack[i].callFrame;\n      const nativeRuntimeFrame = SamplesIntegrator.isNativeRuntimeFrame(frame);\n      if (nativeRuntimeFrame &&\n          !SamplesIntegrator.showNativeName(frame.functionName, engineConfig.includeRuntimeCallStats)) {\n        continue;\n      }\n      const nativeFrameName = nativeRuntimeFrame ? SamplesIntegrator.nativeGroup(frame.functionName) : null;\n      if (previousNativeFrameName && previousNativeFrameName === nativeFrameName) {\n        continue;\n      }\n      previousNativeFrameName = nativeFrameName;\n      stack[j++] = stack[i];\n    }\n    stack.length = j;\n  }\n\n  static createFakeTraceFromCpuProfile(profile: Protocol.Profiler.Profile, tid: Types.Events.ThreadID):\n      Types.File.TraceFile {\n    if (!profile) {\n      return {traceEvents: [], metadata: {}};\n    }\n    // The |Name.CPU_PROFILE| will let MetaHandler to set |traceIsGeneric| to false\n    // The start time and duration is important here because we'll use them to determine the traceBounds\n    // We use the start and end time of the profile (which is longer than all samples), so the Performance\n    // panel won't truncate this time period.\n    const cpuProfileEvent: Types.Events.SyntheticCpuProfile = {\n      cat: 'disabled-by-default-devtools.timeline',\n      name: Types.Events.Name.CPU_PROFILE,\n      ph: Types.Events.Phase.COMPLETE,\n      pid: Types.Events.ProcessID(1),\n      tid,\n      ts: Types.Timing.Micro(profile.startTime),\n      dur: Types.Timing.Micro(profile.endTime - profile.startTime),\n      args: {data: {cpuProfile: profile}},\n      // Create an arbitrary profile id.\n      id: '0x1' as Types.Events.ProfileID,\n    };\n\n    return {\n      traceEvents: [cpuProfileEvent],\n      metadata: {\n        dataOrigin: Types.File.DataOrigin.CPU_PROFILE,\n      }\n    };\n  }\n\n  static extractCpuProfileFromFakeTrace(traceEvents: readonly Types.Events.Event[]): Protocol.Profiler.Profile {\n    const profileEvent = traceEvents.find(e => Types.Events.isSyntheticCpuProfile(e));\n    const profile = profileEvent?.args.data.cpuProfile;\n    if (!profile) {\n      throw new Error('Missing cpuProfile data');\n    }\n    return profile;\n  }\n}\n\nexport namespace SamplesIntegrator {\n  export const enum NativeGroups {\n    COMPILE = 'Compile',\n    PARSE = 'Parse',\n  }\n}\n"]}