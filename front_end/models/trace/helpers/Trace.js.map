{"version":3,"file":"Trace.js","sourceRoot":"","sources":["../../../../../../../front_end/models/trace/helpers/Trace.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2022 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../../core/common/common.js';\nimport * as Platform from '../../../core/platform/platform.js';\nimport type * as Protocol from '../../../generated/protocol.js';\nimport type * as CPUProfile from '../../cpu_profile/cpu_profile.js';\nimport * as Types from '../types/types.js';\n\nimport {SyntheticEventsManager} from './SyntheticEvents.js';\nimport {eventTimingsMicroSeconds} from './Timing.js';\n\ninterface MatchingPairableAsyncEvents {\n  syntheticId: string;\n  begin: Types.Events.PairableAsyncBegin|null;\n  end: Types.Events.PairableAsyncEnd|null;\n  instant?: Types.Events.PairableAsyncInstant[];\n}\n\n/**\n * Extracts the raw stack trace in known trace events. Most likely than\n * not you want to use `getZeroIndexedStackTraceForEvent`, which returns\n * the stack with zero based numbering. Since some trace events are\n * one based this function can yield unexpected results when used\n * indiscriminately.\n *\n * Note: this only returns the stack trace contained in the payload of\n * an event, which only contains the synchronous portion of the call\n * stack. If you want to obtain the whole stack trace you might need to\n * use the @see Trace.Extras.StackTraceForEvent util.\n */\nexport function stackTraceInEvent(event: Types.Events.Event): Types.Events.CallFrame[]|null {\n  if (event.args?.data?.stackTrace) {\n    return event.args.data.stackTrace;\n  }\n  if (event.args?.stackTrace) {\n    return event.args.stackTrace;\n  }\n  if (Types.Events.isRecalcStyle(event)) {\n    return event.args.beginData?.stackTrace || null;\n  }\n  if (Types.Events.isLayout(event)) {\n    return event.args.beginData.stackTrace ?? null;\n  }\n  if (Types.Events.isFunctionCall(event)) {\n    const data = event.args.data;\n    if (!data) {\n      return null;\n    }\n    const {columnNumber, lineNumber, url, scriptId, functionName} = data;\n    if (lineNumber === undefined || functionName === undefined || columnNumber === undefined ||\n        scriptId === undefined || url === undefined) {\n      return null;\n    }\n    return [{columnNumber, lineNumber, url, scriptId, functionName}];\n  }\n  if (Types.Events.isProfileCall(event)) {\n    // Of type Protocol.Runtime.CallFrame, handle accordingly.\n    const callFrame = event.callFrame;\n    if (!callFrame) {\n      return null;\n    }\n    const {columnNumber, lineNumber, url, scriptId, functionName} = callFrame;\n    if (lineNumber === undefined || functionName === undefined || columnNumber === undefined ||\n        scriptId === undefined || url === undefined) {\n      return null;\n    }\n    return [{columnNumber, lineNumber, url, scriptId, functionName}];\n  }\n  return null;\n}\n\nexport function extractOriginFromTrace(firstNavigationURL: string): string|null {\n  const url = Common.ParsedURL.ParsedURL.fromString(firstNavigationURL);\n  if (url) {\n    // We do this to save some space in the toolbar - seeing the `www` is less\n    // useful than seeing `foo.com` if it's truncated at narrow widths\n    if (url.host.startsWith('www.')) {\n      return url.host.slice(4);\n    }\n    return url.host;\n  }\n  return null;\n}\n\nexport type EventsInThread<T extends Types.Events.Event> = Map<Types.Events.ThreadID, T[]>;\n/**\n * Each thread contains events. Events indicate the thread and process IDs, which are\n * used to store the event in the correct process thread entry below.\n **/\nexport function addEventToProcessThread<T extends Types.Events.Event>(\n    event: T,\n    eventsInProcessThread: Map<Types.Events.ProcessID, EventsInThread<T>>,\n    ): void {\n  const {tid, pid} = event;\n  let eventsInThread = eventsInProcessThread.get(pid);\n  if (!eventsInThread) {\n    eventsInThread = new Map<Types.Events.ThreadID, T[]>();\n  }\n\n  let events = eventsInThread.get(tid);\n  if (!events) {\n    events = [];\n  }\n\n  events.push(event);\n  eventsInThread.set(event.tid, events);\n  eventsInProcessThread.set(event.pid, eventsInThread);\n}\n\nexport function compareBeginAndEnd(aBeginTime: number, bBeginTime: number, aEndTime: number, bEndTime: number): -1|0|1 {\n  if (aBeginTime < bBeginTime) {\n    return -1;\n  }\n  if (aBeginTime > bBeginTime) {\n    return 1;\n  }\n\n  if (aEndTime > bEndTime) {\n    return -1;\n  }\n  if (aEndTime < bEndTime) {\n    return 1;\n  }\n\n  return 0;\n}\n\nexport function eventTimeComparator(a: Types.Events.Event, b: Types.Events.Event): -1|0|1 {\n  const aBeginTime = a.ts;\n  const bBeginTime = b.ts;\n  const aDuration = a.dur ?? 0;\n  const bDuration = b.dur ?? 0;\n  const aEndTime = aBeginTime + aDuration;\n  const bEndTime = bBeginTime + bDuration;\n  const timeDifference = compareBeginAndEnd(aBeginTime, bBeginTime, aEndTime, bEndTime);\n  if (timeDifference) {\n    return timeDifference;\n  }\n\n  // If times are equal, prioritize profile calls over trace events,\n  // since an exactly equal timestamp with a trace event is likely\n  // indicates that the SamplesIntegrator meant to parent the trace\n  // event with the profile call.\n  if (Types.Events.isProfileCall(a) && !Types.Events.isProfileCall(b)) {\n    return -1;\n  }\n  if (Types.Events.isProfileCall(b) && !Types.Events.isProfileCall(a)) {\n    return 1;\n  }\n  return 0;\n}\n/**\n * Sorts all the events in place, in order, by their start time. If they have\n * the same start time, orders them by longest first.\n */\nexport function sortTraceEventsInPlace(events: Types.Events.Event[]): void {\n  events.sort(eventTimeComparator);\n}\n\n/**\n * Returns an array of ordered events that results after merging the two\n * ordered input arrays.\n */\nexport function mergeEventsInOrder<T1 extends Types.Events.Event, T2 extends Types.Events.Event>(\n    eventsArray1: readonly T1[], eventsArray2: readonly T2[]): Array<T1|T2> {\n  const result = [];\n  let i = 0;\n  let j = 0;\n  while (i < eventsArray1.length && j < eventsArray2.length) {\n    const event1 = eventsArray1[i];\n    const event2 = eventsArray2[j];\n    const compareValue = eventTimeComparator(event1, event2);\n    if (compareValue <= 0) {\n      result.push(event1);\n      i++;\n    }\n    if (compareValue === 1) {\n      result.push(event2);\n      j++;\n    }\n  }\n  while (i < eventsArray1.length) {\n    result.push(eventsArray1[i++]);\n  }\n  while (j < eventsArray2.length) {\n    result.push(eventsArray2[j++]);\n  }\n  return result;\n}\n\nexport function parseDevtoolsDetails(timingDetail: string, key: string): Types.Extensions.DevToolsObj|\n    Types.Extensions.ExtensionTrackEntryPayloadDeeplink|null {\n  try {\n    // Attempt to parse the detail as an object that might be coming from a\n    // DevTools Perf extension.\n    // Wrapped in a try-catch because timingDetail might either:\n    // 1. Not be `json.parse`-able (it should, but just in case...)\n    // 2. Not be an object - in which case the `in` check will error.\n    // If we hit either of these cases, we just ignore this mark and move on.\n    const detailObj = JSON.parse(timingDetail);\n    if (!(key in detailObj)) {\n      return null;\n    }\n    if (!Types.Extensions.isValidExtensionPayload(detailObj[key])) {\n      return null;\n    }\n    return detailObj[key];\n  } catch {\n    // No need to worry about this error, just discard this event and don't\n    // treat it as having any useful information for the purposes of extensions.\n    return null;\n  }\n}\n\nexport function getNavigationForTraceEvent(\n    event: Types.Events.Event,\n    eventFrameId: string,\n    navigationsByFrameId: Map<string, Types.Events.NavigationStart[]>,\n    ): Types.Events.NavigationStart|null {\n  const navigations = navigationsByFrameId.get(eventFrameId);\n  if (!navigations || eventFrameId === '') {\n    // This event's navigation has been filtered out by the meta handler as a noise event\n    // or contains an empty frameId.\n    return null;\n  }\n\n  const eventNavigationIndex =\n      Platform.ArrayUtilities.nearestIndexFromEnd(navigations, navigation => navigation.ts <= event.ts);\n\n  if (eventNavigationIndex === null) {\n    // This event's navigation has been filtered out by the meta handler as a noise event.\n    return null;\n  }\n  return navigations[eventNavigationIndex];\n}\n\nexport function extractId(\n    event: Types.Events.PairableAsync|Types.Events.SyntheticEventPair<Types.Events.PairableAsync>): string|undefined {\n  return event.id ?? event.id2?.global ?? event.id2?.local;\n}\n\nexport function activeURLForFrameAtTime(\n    frameId: string, time: Types.Timing.Micro,\n    rendererProcessesByFrame: Map<\n        string,\n        Map<Types.Events.ProcessID, Array<{frame: Types.Events.TraceFrame, window: Types.Timing.TraceWindowMicro}>>>):\n    string|null {\n  const processData = rendererProcessesByFrame.get(frameId);\n  if (!processData) {\n    return null;\n  }\n  for (const processes of processData.values()) {\n    for (const processInfo of processes) {\n      if (processInfo.window.min > time || processInfo.window.max < time) {\n        continue;\n      }\n      return processInfo.frame.url;\n    }\n  }\n  return null;\n}\n\n/**\n * @param node the node attached to the profile call. Here a node represents a function in the call tree.\n * @param profileId the profile ID that the sample came from that backs this call.\n * @param sampleIndex the index of the sample in the given profile that this call was created from\n * @param ts the timestamp of the profile call\n * @param pid the process ID of the profile call\n * @param tid the thread ID of the profile call\n *\n * See `panels/timeline/docs/profile_calls.md` for more context on how these events are created.\n */\nexport function makeProfileCall(\n    node: CPUProfile.ProfileTreeModel.ProfileNode, profileId: Types.Events.ProfileID, sampleIndex: number,\n    ts: Types.Timing.Micro, pid: Types.Events.ProcessID,\n    tid: Types.Events.ThreadID): Types.Events.SyntheticProfileCall {\n  return {\n    cat: '',\n    name: 'ProfileCall',\n    nodeId: node.id,\n    args: {},\n    ph: Types.Events.Phase.COMPLETE,\n    pid,\n    tid,\n    ts,\n    dur: Types.Timing.Micro(0),\n    callFrame: node.callFrame,\n    sampleIndex,\n    profileId,\n  };\n}\n\n/**\n * Matches beginning events with PairableAsyncEnd and PairableAsyncInstant\n * if provided. Traces may contain multiple instant events so we need to\n * account for that. Additionally we have seen cases where we might only have a\n * begin event & instant event(s), with no end event. So we account for that\n * situation also.\n *\n * You might also like to read the models/trace/README.md which has some\n * documentation on trace IDs. This is important as Perfetto will reuse trace\n * IDs when emitting events (if they do not overlap). This means it's not as\n * simple as grouping events by IDs. Instead, we group begin & instant events\n * by ID as we find them. When we find end events, we then pop any matching\n * begin/instant events off the stack and group those. That way, if we meet the\n * same ID later on it doesn't cause us collisions.\n *\n * @returns An array of all the matched event groups, along with their ID. Note\n * that two event groups can have the same ID if they were non-overlapping\n * events. You cannot rely on ID being unique across a trace. The returned set\n * of groups are NOT SORTED in any order.\n */\nfunction matchEvents(unpairedEvents: Types.Events.PairableAsync[]): MatchingPairableAsyncEvents[] {\n  sortTraceEventsInPlace(unpairedEvents);\n  // map to store begin and end of the event\n  const matches: MatchingPairableAsyncEvents[] = [];\n\n  const beginEventsById = new Map<string, Types.Events.PairableAsyncBegin[]>();\n  const instantEventsById = new Map<string, Types.Events.PairableAsyncInstant[]>();\n  for (const event of unpairedEvents) {\n    const id = getSyntheticId(event);\n    if (id === undefined) {\n      continue;\n    }\n    if (Types.Events.isPairableAsyncBegin(event)) {\n      const existingEvents = beginEventsById.get(id) ?? [];\n      existingEvents.push(event);\n      beginEventsById.set(id, existingEvents);\n    } else if (Types.Events.isPairableAsyncInstant(event)) {\n      const existingEvents = instantEventsById.get(id) ?? [];\n      existingEvents.push(event);\n      instantEventsById.set(id, existingEvents);\n    } else if (Types.Events.isPairableAsyncEnd(event)) {\n      // Find matching begin event by ID\n      const beginEventsWithMatchingId = beginEventsById.get(id) ?? [];\n      const beginEvent = beginEventsWithMatchingId.pop();\n      if (!beginEvent) {\n        continue;\n      }\n      const instantEventsWithMatchingId = instantEventsById.get(id) ?? [];\n      // Find all instant events after the begin event ts.\n      const instantEventsForThisGroup: Types.Events.PairableAsyncInstant[] = [];\n      while (instantEventsWithMatchingId.length > 0) {\n        if (instantEventsWithMatchingId[0].ts >= beginEvent.ts) {\n          const event = instantEventsWithMatchingId.pop();\n          if (event) {\n            instantEventsForThisGroup.push(event);\n          }\n        } else {\n          break;\n        }\n      }\n      const matchingGroup: MatchingPairableAsyncEvents = {\n        begin: beginEvent,\n        end: event,\n        instant: instantEventsForThisGroup,\n        syntheticId: id,\n      };\n      matches.push(matchingGroup);\n    }\n  }\n\n  // At this point we know we have paired up all the Begin & End & Instant\n  // events. But it is possible to see only begin & instant events with the\n  // same ID, and no end event. So now we do a second pass through our begin\n  // events to find any that did not have an end event. If we find some\n  // instant events for the begin event, we create a new group.\n  // Also, because there were no end events, we know that the IDs will be\n  // unique now; e.g. each key in the map should have no more than one item in\n  // it.\n  for (const [id, beginEvents] of beginEventsById) {\n    const beginEvent = beginEvents.pop();\n    if (!beginEvent) {\n      continue;\n    }\n    const matchingInstantEvents = instantEventsById.get(id);\n    if (matchingInstantEvents?.length) {\n      matches.push({\n        syntheticId: id,\n        begin: beginEvent,\n        end: null,\n        instant: matchingInstantEvents,\n      });\n    }\n  }\n\n  return matches;\n}\n\nexport function getSyntheticId(event: Types.Events.PairableAsync): string|undefined {\n  const id = extractId(event);\n  return id && `${event.cat}:${id}:${event.name}`;\n}\n\nfunction createSortedSyntheticEvents<T extends Types.Events.PairableAsync>(\n    matchedPairs: MatchingPairableAsyncEvents[],\n    ): Array<Types.Events.SyntheticEventPair<T>> {\n  const syntheticEvents: Array<Types.Events.SyntheticEventPair<T>> = [];\n  for (const eventsTriplet of matchedPairs) {\n    const id = eventsTriplet.syntheticId;\n    const beginEvent = eventsTriplet.begin;\n    const endEvent = eventsTriplet.end;\n    const instantEvents = eventsTriplet.instant;\n    if (!beginEvent || !(endEvent || instantEvents)) {\n      // This should never happen, the backend only creates the events once it\n      // has them both (beginEvent & endEvent/instantEvents), so we should never get into this state.\n      // If we do, something is very wrong, so let's just drop that problematic event.\n      continue;\n    }\n    const triplet = {beginEvent, endEvent, instantEvents};\n    /**\n     * When trying to pair events with instant events present, there are times when these\n     * ASYNC_NESTABLE_INSTANT ('n') don't have a corresponding ASYNC_NESTABLE_END ('e') event.\n     * In these cases, pair without needing the endEvent.\n     */\n    function eventsArePairable(data: {\n      beginEvent: Types.Events.PairableAsyncBegin,\n      endEvent: Types.Events.PairableAsyncEnd|null,\n      instantEvents?: Types.Events.PairableAsyncInstant[],\n    }): data is Types.Events.SyntheticEventPair<T>['args']['data'] {\n      const instantEventsMatch = data.instantEvents ? data.instantEvents.some(e => id === getSyntheticId(e)) : false;\n      const endEventMatch = data.endEvent ? id === getSyntheticId(data.endEvent) : false;\n      return Boolean(id) && (instantEventsMatch || endEventMatch);\n    }\n    if (!eventsArePairable(triplet)) {\n      continue;\n    }\n    const targetEvent = endEvent || beginEvent;\n\n    const event = SyntheticEventsManager.registerSyntheticEvent<Types.Events.SyntheticEventPair<T>>({\n      rawSourceEvent: triplet.beginEvent,\n      cat: targetEvent.cat,\n      ph: targetEvent.ph,\n      pid: targetEvent.pid,\n      tid: targetEvent.tid,\n      id,\n      // Both events have the same name, so it doesn't matter which we pick to\n      // use as the description\n      name: beginEvent.name,\n      dur: Types.Timing.Micro(targetEvent.ts - beginEvent.ts),\n      ts: beginEvent.ts,\n      args: {\n        data: triplet,\n      },\n    });\n\n    if (event.dur < 0) {\n      // We have seen in the backend that sometimes animation events get\n      // generated with multiple begin entries, or multiple end entries, and this\n      // can cause invalid data on the performance panel, so we drop them.\n      // crbug.com/1472375\n      continue;\n    }\n    syntheticEvents.push(event);\n  }\n  sortTraceEventsInPlace(syntheticEvents);\n  return syntheticEvents;\n}\n\n/**\n * Groups up sets of async events into synthetic events.\n * @param unpairedAsyncEvents the raw array of begin, end and async instant\n * events. These MUST be sorted in timestamp ASC order.\n */\nexport function createMatchedSortedSyntheticEvents<T extends Types.Events.PairableAsync>(unpairedAsyncEvents: T[]):\n    Array<Types.Events.SyntheticEventPair<T>> {\n  const matchedPairs = matchEvents(unpairedAsyncEvents);\n  const syntheticEvents = createSortedSyntheticEvents<T>(matchedPairs);\n  return syntheticEvents;\n}\n\n/**\n * Different trace events return line/column numbers that are 1 or 0 indexed.\n * This function knows which events return 1 indexed numbers and normalizes\n * them. The UI expects 0 indexed line numbers, so that is what we return.\n */\nexport function getZeroIndexedLineAndColumnForEvent(event: Types.Events.Event): {\n  lineNumber?: number,\n  columnNumber?: number,\n} {\n  // Some events emit line numbers that are 1 indexed, but the UI layer expects\n  // numbers to be 0 indexed. So here, if the event matches a known 1-indexed\n  // number event, we subtract one from the line and column numbers.\n  // Otherwise, if the event has args.data.lineNumber/colNumber, we return it\n  // as is.\n  const numbers = getRawLineAndColumnNumbersForEvent(event);\n  const {lineNumber, columnNumber} = numbers;\n\n  switch (event.name) {\n    // All these events have line/column numbers which are 1 indexed; so we\n    // subtract to make them 0 indexed.\n    case Types.Events.Name.FUNCTION_CALL:\n    case Types.Events.Name.EVALUATE_SCRIPT:\n    case Types.Events.Name.COMPILE:\n    case Types.Events.Name.CACHE_SCRIPT: {\n      return {\n        lineNumber: typeof lineNumber === 'number' ? lineNumber - 1 : undefined,\n        columnNumber: typeof columnNumber === 'number' ? columnNumber - 1 : undefined,\n      };\n    }\n    case Types.Events.Name.PROFILE_CALL: {\n      const callFrame = (event as Types.Events.SyntheticProfileCall).callFrame;\n      return {\n        lineNumber: typeof lineNumber === 'number' ? callFrame.lineNumber - 1 : undefined,\n        columnNumber: typeof columnNumber === 'number' ? callFrame.columnNumber - 1 : undefined,\n      };\n    }\n    default: {\n      return numbers;\n    }\n  }\n}\n\n/**\n * Different trace events contain stack traces with line/column numbers\n * that are 1 or 0 indexed.\n * This function knows which events return 1 indexed numbers and normalizes\n * them. The UI expects 0 indexed line numbers, so that is what we return.\n *\n * Note: this only returns the stack trace contained in the payload of\n * an event, which only contains the synchronous portion of the call\n * stack. If you want to obtain the whole stack trace you might need to\n * use the @see Trace.Extras.StackTraceForEvent util.\n */\nexport function getZeroIndexedStackTraceInEventPayload(event: Types.Events.Event): Types.Events.CallFrame[]|null {\n  const stack = stackTraceInEvent(event);\n  if (!stack) {\n    return null;\n  }\n\n  switch (event.name) {\n    case Types.Events.Name.SCHEDULE_STYLE_RECALCULATION:\n    case Types.Events.Name.INVALIDATE_LAYOUT:\n    case Types.Events.Name.FUNCTION_CALL:\n    case Types.Events.Name.LAYOUT:\n    case Types.Events.Name.RECALC_STYLE: {\n      return stack.map(makeZeroBasedCallFrame);\n    }\n\n    default: {\n      if (Types.Events.isUserTiming(event) || Types.Extensions.isSyntheticExtensionEntry(event)) {\n        return stack.map(makeZeroBasedCallFrame);\n      }\n\n      return stack;\n    }\n  }\n}\n\n/**\n * Same as getZeroIndexedStackTraceInEventPayload, but only returns the top call frame.\n */\nexport function getStackTraceTopCallFrameInEventPayload(event: Types.Events.Event): Types.Events.CallFrame|null {\n  const stack = stackTraceInEvent(event);\n  if (!stack || stack.length === 0) {\n    return null;\n  }\n\n  switch (event.name) {\n    case Types.Events.Name.SCHEDULE_STYLE_RECALCULATION:\n    case Types.Events.Name.INVALIDATE_LAYOUT:\n    case Types.Events.Name.FUNCTION_CALL:\n    case Types.Events.Name.LAYOUT:\n    case Types.Events.Name.RECALC_STYLE: {\n      return makeZeroBasedCallFrame(stack[0]);\n    }\n\n    default: {\n      if (Types.Events.isUserTiming(event) || Types.Extensions.isSyntheticExtensionEntry(event)) {\n        return makeZeroBasedCallFrame(stack[0]);\n      }\n\n      return stack[0];\n    }\n  }\n}\n\n/**\n * Given a 1-based call frame creates a 0-based one.\n */\nexport function makeZeroBasedCallFrame(callFrame: Types.Events.CallFrame): Types.Events.CallFrame {\n  const normalizedCallFrame = {...callFrame};\n\n  normalizedCallFrame.lineNumber = callFrame.lineNumber && callFrame.lineNumber - 1;\n  normalizedCallFrame.columnNumber = callFrame.columnNumber && callFrame.columnNumber - 1;\n  return normalizedCallFrame;\n}\n\n/**\n * NOTE: you probably do not want this function! (Which is why it is not exported).\n *\n * Some trace events have 0 indexed line/column numbers, and others have 1\n * indexed. This function does NOT normalize them, but\n * `getZeroIndexedLineAndColumnNumbersForEvent` does. It is best to use that!\n *\n * @see {@link getZeroIndexedLineAndColumnForEvent}\n **/\nfunction getRawLineAndColumnNumbersForEvent(event: Types.Events.Event): {\n  lineNumber?: number,\n  columnNumber?: number,\n} {\n  if (!event.args?.data) {\n    return {\n      lineNumber: undefined,\n      columnNumber: undefined,\n    };\n  }\n  let lineNumber: number|undefined = undefined;\n  let columnNumber: number|undefined = undefined;\n  if ('lineNumber' in event.args.data && typeof event.args.data.lineNumber === 'number') {\n    lineNumber = event.args.data.lineNumber;\n  }\n  if ('columnNumber' in event.args.data && typeof event.args.data.columnNumber === 'number') {\n    columnNumber = event.args.data.columnNumber;\n  }\n\n  return {lineNumber, columnNumber};\n}\n\nexport function frameIDForEvent(event: Types.Events.Event): string|null {\n  // There are a few events (for example RecalcStyle, ParseHTML) that have\n  // the frame stored in args.beginData\n  // Rather than list them all we just check for the presence of the field, so\n  // we are robust against future trace events also doing this.\n  // This check seems very robust, but it also helps satisfy TypeScript and\n  // prevents us against unexpected data.\n  if (event.args && 'beginData' in event.args && typeof event.args.beginData === 'object' &&\n      event.args.beginData !== null && 'frame' in event.args.beginData &&\n      typeof event.args.beginData.frame === 'string') {\n    return event.args.beginData.frame;\n  }\n  // Otherwise, we expect frame to be in args.data\n  if (event.args?.data?.frame) {\n    return event.args.data.frame;\n  }\n\n  // No known frame for this event.\n  return null;\n}\n\nconst DevToolsTimelineEventCategory = 'disabled-by-default-devtools.timeline';\nexport function isTopLevelEvent(event: Types.Events.Event): boolean {\n  return event.cat.includes(DevToolsTimelineEventCategory) && event.name === Types.Events.Name.RUN_TASK;\n}\n\nexport function isExtensionUrl(url: string): boolean {\n  return url.startsWith('extensions:') || url.startsWith('chrome-extension:');\n}\n\nfunction topLevelEventIndexEndingAfter(events: Types.Events.Event[], time: Types.Timing.Micro): number {\n  let index = Platform.ArrayUtilities.upperBound(events, time, (time, event) => time - event.ts) - 1;\n  while (index > 0 && !isTopLevelEvent(events[index])) {\n    index--;\n  }\n  return Math.max(index, 0);\n}\nexport function findRecalcStyleEvents(\n    events: Types.Events.Event[], startTime: Types.Timing.Micro,\n    endTime?: Types.Timing.Micro): Types.Events.RecalcStyle[] {\n  const foundEvents: Types.Events.RecalcStyle[] = [];\n  const startEventIndex = topLevelEventIndexEndingAfter(events, startTime);\n  for (let i = startEventIndex; i < events.length; i++) {\n    const event = events[i];\n    if (!Types.Events.isRecalcStyle(event)) {\n      continue;\n    }\n    if (event.ts >= (endTime || Infinity)) {\n      continue;\n    }\n    foundEvents.push(event);\n  }\n  return foundEvents;\n}\n\nexport function findNextEventAfterTimestamp<T extends Types.Events.Event>(candidates: T[], ts: Types.Timing.Micro): T|\n    null {\n  const index = Platform.ArrayUtilities.nearestIndexFromBeginning(candidates, candidate => ts < candidate.ts);\n  return index === null ? null : candidates[index];\n}\n\nexport function findPreviousEventBeforeTimestamp<T extends Types.Events.Event>(\n    candidates: T[], ts: Types.Timing.Micro): T|null {\n  const index = Platform.ArrayUtilities.nearestIndexFromEnd(candidates, candidate => candidate.ts < ts);\n  return index === null ? null : candidates[index];\n}\n\nexport interface ForEachEventConfig {\n  onStartEvent: (event: Types.Events.Event) => void;\n  onEndEvent: (event: Types.Events.Event) => void;\n  onInstantEvent?: (event: Types.Events.Event) => void;\n  eventFilter?: (event: Types.Events.Event) => boolean;\n  startTime?: Types.Timing.Micro;\n  endTime?: Types.Timing.Micro;\n  /* If async events should be skipped. Defaults to true */\n  ignoreAsyncEvents?: boolean;\n}\n\n/**\n * Iterates events in a tree hierarchically, from top to bottom,\n * calling back on every event's start and end in the order\n * dictated by the corresponding timestamp.\n *\n * Events are assumed to be in ascendent order by timestamp.\n *\n * Events with 0 duration are treated as instant events. These do not have a\n * begin and end, but will be passed to the config.onInstantEvent callback as\n * they are discovered. Do not provide this callback if you are not interested\n * in them.\n *\n * For example, given this tree, the following callbacks\n * are expected to be made in the following order\n * |---------------A---------------|\n *  |------B------||-------D------|\n *    |---C---|\n *\n * 1. Start A\n * 3. Start B\n * 4. Start C\n * 5. End C\n * 6. End B\n * 7. Start D\n * 8. End D\n * 9. End A\n *\n * By default, async events are skipped. This behaviour can be\n * overridden making use of the config.ignoreAsyncEvents parameter.\n */\nexport function forEachEvent(\n    events: Types.Events.Event[],\n    config: ForEachEventConfig,\n    ): void {\n  const globalStartTime = config.startTime ?? Types.Timing.Micro(0);\n  const globalEndTime = config.endTime || Types.Timing.Micro(Infinity);\n  const ignoreAsyncEvents = config.ignoreAsyncEvents === false ? false : true;\n\n  const stack: Types.Events.Event[] = [];\n  const startEventIndex = topLevelEventIndexEndingAfter(events, globalStartTime);\n  for (let i = startEventIndex; i < events.length; i++) {\n    const currentEvent = events[i];\n    const currentEventTimings = eventTimingsMicroSeconds(currentEvent);\n    if (currentEventTimings.endTime < globalStartTime) {\n      continue;\n    }\n    if (currentEventTimings.startTime > globalEndTime) {\n      break;\n    }\n\n    const isIgnoredAsyncEvent = ignoreAsyncEvents && Types.Events.isPhaseAsync(currentEvent.ph);\n    if (isIgnoredAsyncEvent || Types.Events.isFlowPhase(currentEvent.ph)) {\n      continue;\n    }\n\n    // If we have now reached an event that is after a bunch of events, we need\n    // to call the onEndEvent callback for those events before moving on.\n    let lastEventOnStack = stack.at(-1);\n    let lastEventEndTime = lastEventOnStack ? eventTimingsMicroSeconds(lastEventOnStack).endTime : null;\n    while (lastEventOnStack && lastEventEndTime && lastEventEndTime <= currentEventTimings.startTime) {\n      stack.pop();\n      config.onEndEvent(lastEventOnStack);\n      lastEventOnStack = stack.at(-1);\n      lastEventEndTime = lastEventOnStack ? eventTimingsMicroSeconds(lastEventOnStack).endTime : null;\n    }\n\n    // Now we have dealt with all events prior to this one, see if we need to care about this one.\n    if (config.eventFilter && !config.eventFilter(currentEvent)) {\n      // The user has chosen to filter this event out, so continue on and do nothing\n      continue;\n    }\n\n    if (currentEventTimings.duration) {\n      config.onStartEvent(currentEvent);\n      stack.push(currentEvent);\n    } else if (config.onInstantEvent) {\n      // An event with 0 duration is an instant event.\n      config.onInstantEvent(currentEvent);\n    }\n  }\n\n  // Now we have finished looping over all events; any events remaining on the\n  // stack need to have their onEndEvent called.\n  while (stack.length) {\n    const last = stack.pop();\n    if (last) {\n      config.onEndEvent(last);\n    }\n  }\n}\n\n// Parsed categories are cached to prevent calling cat.split()\n// multiple times on the same categories string.\nconst parsedCategories = new Map<string, Set<string>>();\nexport function eventHasCategory(event: Types.Events.Event, category: string): boolean {\n  let parsedCategoriesForEvent = parsedCategories.get(event.cat);\n  if (!parsedCategoriesForEvent) {\n    parsedCategoriesForEvent = new Set(event.cat.split(',') || []);\n  }\n  return parsedCategoriesForEvent.has(category);\n}\n\n/**\n * This compares Types.Events.CallFrame with Protocol.Runtime.CallFrame and checks for equality.\n */\nexport function isMatchingCallFrame(\n    eventFrame: Types.Events.CallFrame, nodeFrame: Protocol.Runtime.CallFrame): boolean {\n  return eventFrame.columnNumber === nodeFrame.columnNumber && eventFrame.lineNumber === nodeFrame.lineNumber &&\n      String(eventFrame.scriptId) === nodeFrame.scriptId && eventFrame.url === nodeFrame.url &&\n      eventFrame.functionName === nodeFrame.functionName;\n}\n\nexport function eventContainsTimestamp(event: Types.Events.Event, ts: Types.Timing.Micro): boolean {\n  return event.ts <= ts && event.ts + (event.dur || 0) >= ts;\n}\n\nexport function extractSampleTraceId(event: Types.Events.Event): number|null {\n  if (!event.args) {\n    return null;\n  }\n  if ('beginData' in event.args) {\n    const beginData = event.args['beginData'] as {sampleTraceId?: number};\n    return beginData.sampleTraceId ?? null;\n  }\n  return event.args?.sampleTraceId ?? event.args?.data?.sampleTraceId ?? null;\n}\n\n/**\n * This exactly matches Trace.Styles.visibleTypes. See the runtime verification in maybeInitStylesMap.\n * TODO(crbug.com/410884528)\n **/\nexport const VISIBLE_TRACE_EVENT_TYPES = new Set<Types.Events.Name>([\n  Types.Events.Name.ABORT_POST_TASK_CALLBACK,\n  Types.Events.Name.ANIMATION,\n  Types.Events.Name.ASYNC_TASK,\n  Types.Events.Name.BACKGROUND_DESERIALIZE,\n  Types.Events.Name.CACHE_MODULE,\n  Types.Events.Name.CACHE_SCRIPT,\n  Types.Events.Name.CANCEL_ANIMATION_FRAME,\n  Types.Events.Name.CANCEL_IDLE_CALLBACK,\n  Types.Events.Name.COMMIT,\n  Types.Events.Name.COMPILE_CODE,\n  Types.Events.Name.COMPILE_MODULE,\n  Types.Events.Name.COMPILE,\n  Types.Events.Name.COMPOSITE_LAYERS,\n  Types.Events.Name.COMPUTE_INTERSECTION,\n  Types.Events.Name.CONSOLE_TIME,\n  Types.Events.Name.CPPGC_SWEEP,\n  Types.Events.Name.CRYPTO_DO_DECRYPT_REPLY,\n  Types.Events.Name.CRYPTO_DO_DECRYPT,\n  Types.Events.Name.CRYPTO_DO_DIGEST_REPLY,\n  Types.Events.Name.CRYPTO_DO_DIGEST,\n  Types.Events.Name.CRYPTO_DO_ENCRYPT_REPLY,\n  Types.Events.Name.CRYPTO_DO_ENCRYPT,\n  Types.Events.Name.CRYPTO_DO_SIGN_REPLY,\n  Types.Events.Name.CRYPTO_DO_SIGN,\n  Types.Events.Name.CRYPTO_DO_VERIFY_REPLY,\n  Types.Events.Name.CRYPTO_DO_VERIFY,\n  Types.Events.Name.DECODE_IMAGE,\n  Types.Events.Name.EMBEDDER_CALLBACK,\n  Types.Events.Name.EVALUATE_MODULE,\n  Types.Events.Name.EVALUATE_SCRIPT,\n  Types.Events.Name.EVENT_DISPATCH,\n  Types.Events.Name.EVENT_TIMING,\n  Types.Events.Name.FINALIZE_DESERIALIZATION,\n  Types.Events.Name.FIRE_ANIMATION_FRAME,\n  Types.Events.Name.FIRE_IDLE_CALLBACK,\n  Types.Events.Name.FUNCTION_CALL,\n  Types.Events.Name.GC_COLLECT_GARBARGE,\n  Types.Events.Name.GC,\n  Types.Events.Name.GPU_TASK,\n  Types.Events.Name.HANDLE_POST_MESSAGE,\n  Types.Events.Name.HIT_TEST,\n  Types.Events.Name.JS_SAMPLE,\n  Types.Events.Name.LAYERIZE,\n  Types.Events.Name.LAYOUT,\n  Types.Events.Name.MAJOR_GC,\n  Types.Events.Name.MINOR_GC,\n  Types.Events.Name.OPTIMIZE_CODE,\n  Types.Events.Name.PAINT_SETUP,\n  Types.Events.Name.PAINT,\n  Types.Events.Name.PARSE_AUTHOR_STYLE_SHEET,\n  Types.Events.Name.PARSE_HTML,\n  Types.Events.Name.PRE_PAINT,\n  Types.Events.Name.PROFILE_CALL,\n  Types.Events.Name.PROGRAM,\n  Types.Events.Name.RASTER_TASK,\n  Types.Events.Name.REQUEST_ANIMATION_FRAME,\n  Types.Events.Name.REQUEST_IDLE_CALLBACK,\n  Types.Events.Name.RESOURCE_FINISH,\n  Types.Events.Name.RESOURCE_RECEIVE_DATA,\n  Types.Events.Name.RESOURCE_RECEIVE_RESPONSE,\n  Types.Events.Name.RESOURCE_SEND_REQUEST,\n  Types.Events.Name.RESOURCE_WILL_SEND_REQUEST,\n  Types.Events.Name.RUN_MICROTASKS,\n  Types.Events.Name.RUN_POST_TASK_CALLBACK,\n  Types.Events.Name.RUN_TASK,\n  Types.Events.Name.SCHEDULE_POST_MESSAGE,\n  Types.Events.Name.SCHEDULE_POST_TASK_CALLBACK,\n  Types.Events.Name.SCHEDULE_STYLE_RECALCULATION,\n  Types.Events.Name.SCROLL_LAYER,\n  Types.Events.Name.START_PROFILING,\n  Types.Events.Name.STREAMING_COMPILE_SCRIPT_PARSING,\n  Types.Events.Name.STREAMING_COMPILE_SCRIPT_WAITING,\n  Types.Events.Name.STREAMING_COMPILE_SCRIPT,\n  Types.Events.Name.SYNTHETIC_LAYOUT_SHIFT_CLUSTER,\n  Types.Events.Name.SYNTHETIC_LAYOUT_SHIFT,\n  Types.Events.Name.TIME_STAMP,\n  Types.Events.Name.TIMER_FIRE,\n  Types.Events.Name.TIMER_INSTALL,\n  Types.Events.Name.TIMER_REMOVE,\n  Types.Events.Name.UPDATE_LAYER_TREE,\n  Types.Events.Name.RECALC_STYLE,\n  Types.Events.Name.USER_TIMING,\n  Types.Events.Name.V8_CONSOLE_RUN_TASK,\n  Types.Events.Name.WASM_CACHED_MODULE,\n  Types.Events.Name.WASM_COMPILED_MODULE,\n  Types.Events.Name.WASM_MODULE_CACHE_HIT,\n  Types.Events.Name.WASM_MODULE_CACHE_INVALID,\n  Types.Events.Name.WASM_STREAM_FROM_RESPONSE_CALLBACK,\n  Types.Events.Name.WEB_SOCKET_CREATE,\n  Types.Events.Name.WEB_SOCKET_DESTROY,\n  Types.Events.Name.WEB_SOCKET_RECEIVE_HANDSHAKE_REQUEST,\n  Types.Events.Name.WEB_SOCKET_RECEIVE,\n  Types.Events.Name.WEB_SOCKET_SEND_HANDSHAKE_REQUEST,\n  Types.Events.Name.WEB_SOCKET_SEND,\n  Types.Events.Name.XHR_LOAD,\n  Types.Events.Name.XHR_READY_STATE_CHANGED,\n]);\n"]}