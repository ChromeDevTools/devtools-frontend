{
  "version": 3,
  "sources": ["../../../../../../../front_end/models/trace/helpers/Extensions.ts", "../../../../../../../front_end/models/trace/helpers/Trace.ts", "../../../../../../../front_end/models/trace/helpers/SyntheticEvents.ts", "../../../../../../../front_end/models/trace/helpers/Timing.ts", "../../../../../../../front_end/models/trace/helpers/TreeHelpers.ts", "../../../../../../../front_end/models/trace/helpers/Network.ts", "../../../../../../../front_end/models/trace/helpers/SamplesIntegrator.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport type * as Types from '../types/types.js';\n\nimport {sortTraceEventsInPlace} from './Trace.js';\nimport {canBuildTreesFromEvents, type TraceEntryNode, treify} from './TreeHelpers.js';\n\nexport function buildTrackDataFromExtensionEntries(\n    extensionEntries: Types.Extensions.SyntheticExtensionTrackEntry[],\n    extensionTrackData: Types.Extensions.ExtensionTrackData[],\n    entryToNode: Map<Types.Events.Event, TraceEntryNode>,\n    ): {\n  extensionTrackData: Types.Extensions.ExtensionTrackData[],\n  entryToNode?: Map<Types.Events.Event, TraceEntryNode>,\n} {\n  const dataByTrack = new Map<string, Types.Extensions.ExtensionTrackData>();\n  for (const entry of extensionEntries) {\n    // Batch data by track group. For each batch, add the data of every\n    // track in the group. In cases where no track group is provided,\n    // we use the standalone track data, but use a fixed prefix in the\n    // batch key to prevent collisions where a track group has the\n    // same name as a standalone track.\n    const key = entry.devtoolsObj.trackGroup || `track-name-${entry.devtoolsObj.track}`;\n    const batchedData = Platform.MapUtilities.getWithDefault(\n        dataByTrack, key, () => ({\n                            name: entry.devtoolsObj.trackGroup || entry.devtoolsObj.track,\n                            isTrackGroup: Boolean(entry.devtoolsObj.trackGroup),\n                            entriesByTrack: {[entry.devtoolsObj.track]: []},\n                          }));\n\n    if (!batchedData.entriesByTrack[entry.devtoolsObj.track]) {\n      batchedData.entriesByTrack[entry.devtoolsObj.track] = [];\n    }\n    const entriesInTrack = batchedData.entriesByTrack[entry.devtoolsObj.track];\n    entriesInTrack.push(entry);\n  }\n  // Calculate self time if possible for track entries, on a track\n  // by track basis.\n  for (const trackData of dataByTrack.values()) {\n    for (const entries of Object.values(trackData.entriesByTrack)) {\n      sortTraceEventsInPlace(entries);\n      if (canBuildTreesFromEvents(entries)) {\n        for (const [entry, node] of treify(entries).entryToNode) {\n          entryToNode.set(entry, node);\n        }\n      }\n    }\n    extensionTrackData.push(trackData);\n  }\n  return {extensionTrackData, entryToNode};\n}\n", "// Copyright 2022 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../../core/common/common.js';\nimport * as Platform from '../../../core/platform/platform.js';\nimport type * as Protocol from '../../../generated/protocol.js';\nimport type * as CPUProfile from '../../cpu_profile/cpu_profile.js';\nimport * as Types from '../types/types.js';\n\nimport {SyntheticEventsManager} from './SyntheticEvents.js';\nimport {eventTimingsMicroSeconds} from './Timing.js';\n\ninterface MatchingPairableAsyncEvents {\n  syntheticId: string;\n  begin: Types.Events.PairableAsyncBegin|null;\n  end: Types.Events.PairableAsyncEnd|null;\n  instant?: Types.Events.PairableAsyncInstant[];\n}\n\n/**\n * Extracts the raw stack trace in known trace events. Most likely than\n * not you want to use `getZeroIndexedStackTraceForEvent`, which returns\n * the stack with zero based numbering. Since some trace events are\n * one based this function can yield unexpected results when used\n * indiscriminately.\n *\n * Note: this only returns the stack trace contained in the payload of\n * an event, which only contains the synchronous portion of the call\n * stack. If you want to obtain the whole stack trace you might need to\n * use the @see Trace.Extras.StackTraceForEvent util.\n */\nexport function stackTraceInEvent(event: Types.Events.Event): Types.Events.CallFrame[]|null {\n  if (event.args?.data?.stackTrace) {\n    return event.args.data.stackTrace;\n  }\n  if (event.args?.stackTrace) {\n    return event.args.stackTrace;\n  }\n  if (Types.Events.isRecalcStyle(event)) {\n    return event.args.beginData?.stackTrace || null;\n  }\n  if (Types.Events.isLayout(event)) {\n    return event.args.beginData.stackTrace ?? null;\n  }\n  if (Types.Events.isFunctionCall(event)) {\n    const data = event.args.data;\n    if (!data) {\n      return null;\n    }\n    const {columnNumber, lineNumber, url, scriptId, functionName} = data;\n    if (lineNumber === undefined || functionName === undefined || columnNumber === undefined ||\n        scriptId === undefined || url === undefined) {\n      return null;\n    }\n    return [{columnNumber, lineNumber, url, scriptId, functionName}];\n  }\n  if (Types.Events.isProfileCall(event)) {\n    // Of type Protocol.Runtime.CallFrame, handle accordingly.\n    const callFrame = event.callFrame;\n    if (!callFrame) {\n      return null;\n    }\n    const {columnNumber, lineNumber, url, scriptId, functionName} = callFrame;\n    if (lineNumber === undefined || functionName === undefined || columnNumber === undefined ||\n        scriptId === undefined || url === undefined) {\n      return null;\n    }\n    return [{columnNumber, lineNumber, url, scriptId, functionName}];\n  }\n  return null;\n}\n\nexport function extractOriginFromTrace(firstNavigationURL: string): string|null {\n  const url = Common.ParsedURL.ParsedURL.fromString(firstNavigationURL);\n  if (url) {\n    // We do this to save some space in the toolbar - seeing the `www` is less\n    // useful than seeing `foo.com` if it's truncated at narrow widths\n    if (url.host.startsWith('www.')) {\n      return url.host.slice(4);\n    }\n    return url.host;\n  }\n  return null;\n}\n\nexport type EventsInThread<T extends Types.Events.Event> = Map<Types.Events.ThreadID, T[]>;\n/**\n * Each thread contains events. Events indicate the thread and process IDs, which are\n * used to store the event in the correct process thread entry below.\n **/\nexport function addEventToProcessThread<T extends Types.Events.Event>(\n    event: T,\n    eventsInProcessThread: Map<Types.Events.ProcessID, EventsInThread<T>>,\n    ): void {\n  const {tid, pid} = event;\n  let eventsInThread = eventsInProcessThread.get(pid);\n  if (!eventsInThread) {\n    eventsInThread = new Map<Types.Events.ThreadID, T[]>();\n  }\n\n  let events = eventsInThread.get(tid);\n  if (!events) {\n    events = [];\n  }\n\n  events.push(event);\n  eventsInThread.set(event.tid, events);\n  eventsInProcessThread.set(event.pid, eventsInThread);\n}\n\nexport function compareBeginAndEnd(aBeginTime: number, bBeginTime: number, aEndTime: number, bEndTime: number): -1|0|1 {\n  if (aBeginTime < bBeginTime) {\n    return -1;\n  }\n  if (aBeginTime > bBeginTime) {\n    return 1;\n  }\n\n  if (aEndTime > bEndTime) {\n    return -1;\n  }\n  if (aEndTime < bEndTime) {\n    return 1;\n  }\n\n  return 0;\n}\n\nexport function eventTimeComparator(a: Types.Events.Event, b: Types.Events.Event): -1|0|1 {\n  const aBeginTime = a.ts;\n  const bBeginTime = b.ts;\n  const aDuration = a.dur ?? 0;\n  const bDuration = b.dur ?? 0;\n  const aEndTime = aBeginTime + aDuration;\n  const bEndTime = bBeginTime + bDuration;\n  const timeDifference = compareBeginAndEnd(aBeginTime, bBeginTime, aEndTime, bEndTime);\n  if (timeDifference) {\n    return timeDifference;\n  }\n\n  // If times are equal, prioritize profile calls over trace events,\n  // since an exactly equal timestamp with a trace event is likely\n  // indicates that the SamplesIntegrator meant to parent the trace\n  // event with the profile call.\n  if (Types.Events.isProfileCall(a) && !Types.Events.isProfileCall(b)) {\n    return -1;\n  }\n  if (Types.Events.isProfileCall(b) && !Types.Events.isProfileCall(a)) {\n    return 1;\n  }\n  return 0;\n}\n/**\n * Sorts all the events in place, in order, by their start time. If they have\n * the same start time, orders them by longest first.\n */\nexport function sortTraceEventsInPlace(events: Types.Events.Event[]): void {\n  events.sort(eventTimeComparator);\n}\n\n/**\n * Returns an array of ordered events that results after merging the two\n * ordered input arrays.\n */\nexport function mergeEventsInOrder<T1 extends Types.Events.Event, T2 extends Types.Events.Event>(\n    eventsArray1: readonly T1[], eventsArray2: readonly T2[]): Array<T1|T2> {\n  const result = [];\n  let i = 0;\n  let j = 0;\n  while (i < eventsArray1.length && j < eventsArray2.length) {\n    const event1 = eventsArray1[i];\n    const event2 = eventsArray2[j];\n    const compareValue = eventTimeComparator(event1, event2);\n    if (compareValue <= 0) {\n      result.push(event1);\n      i++;\n    }\n    if (compareValue === 1) {\n      result.push(event2);\n      j++;\n    }\n  }\n  while (i < eventsArray1.length) {\n    result.push(eventsArray1[i++]);\n  }\n  while (j < eventsArray2.length) {\n    result.push(eventsArray2[j++]);\n  }\n  return result;\n}\n\nexport function parseDevtoolsDetails(timingDetail: string, key: string): Types.Extensions.DevToolsObj|\n    Types.Extensions.ExtensionTrackEntryPayloadDeeplink|null {\n  try {\n    // Attempt to parse the detail as an object that might be coming from a\n    // DevTools Perf extension.\n    // Wrapped in a try-catch because timingDetail might either:\n    // 1. Not be `json.parse`-able (it should, but just in case...)\n    // 2. Not be an object - in which case the `in` check will error.\n    // If we hit either of these cases, we just ignore this mark and move on.\n    const detailObj = JSON.parse(timingDetail);\n    if (!(key in detailObj)) {\n      return null;\n    }\n    if (!Types.Extensions.isValidExtensionPayload(detailObj[key])) {\n      return null;\n    }\n    return detailObj[key];\n  } catch {\n    // No need to worry about this error, just discard this event and don't\n    // treat it as having any useful information for the purposes of extensions.\n    return null;\n  }\n}\n\nexport function getNavigationForTraceEvent(\n    event: Types.Events.Event,\n    eventFrameId: string,\n    navigationsByFrameId: Map<string, Types.Events.NavigationStart[]>,\n    ): Types.Events.NavigationStart|null {\n  const navigations = navigationsByFrameId.get(eventFrameId);\n  if (!navigations || eventFrameId === '') {\n    // This event's navigation has been filtered out by the meta handler as a noise event\n    // or contains an empty frameId.\n    return null;\n  }\n\n  const eventNavigationIndex =\n      Platform.ArrayUtilities.nearestIndexFromEnd(navigations, navigation => navigation.ts <= event.ts);\n\n  if (eventNavigationIndex === null) {\n    // This event's navigation has been filtered out by the meta handler as a noise event.\n    return null;\n  }\n  return navigations[eventNavigationIndex];\n}\n\nexport function extractId(\n    event: Types.Events.PairableAsync|Types.Events.SyntheticEventPair<Types.Events.PairableAsync>): string|undefined {\n  return event.id ?? event.id2?.global ?? event.id2?.local;\n}\n\nexport function activeURLForFrameAtTime(\n    frameId: string, time: Types.Timing.Micro,\n    rendererProcessesByFrame: Map<\n        string,\n        Map<Types.Events.ProcessID, Array<{frame: Types.Events.TraceFrame, window: Types.Timing.TraceWindowMicro}>>>):\n    string|null {\n  const processData = rendererProcessesByFrame.get(frameId);\n  if (!processData) {\n    return null;\n  }\n  for (const processes of processData.values()) {\n    for (const processInfo of processes) {\n      if (processInfo.window.min > time || processInfo.window.max < time) {\n        continue;\n      }\n      return processInfo.frame.url;\n    }\n  }\n  return null;\n}\n\n/**\n * @param node the node attached to the profile call. Here a node represents a function in the call tree.\n * @param profileId the profile ID that the sample came from that backs this call.\n * @param sampleIndex the index of the sample in the given profile that this call was created from\n * @param ts the timestamp of the profile call\n * @param pid the process ID of the profile call\n * @param tid the thread ID of the profile call\n *\n * See `panels/timeline/docs/profile_calls.md` for more context on how these events are created.\n */\nexport function makeProfileCall(\n    node: CPUProfile.ProfileTreeModel.ProfileNode, profileId: Types.Events.ProfileID, sampleIndex: number,\n    ts: Types.Timing.Micro, pid: Types.Events.ProcessID,\n    tid: Types.Events.ThreadID): Types.Events.SyntheticProfileCall {\n  return {\n    cat: '',\n    name: 'ProfileCall',\n    nodeId: node.id,\n    args: {},\n    ph: Types.Events.Phase.COMPLETE,\n    pid,\n    tid,\n    ts,\n    dur: Types.Timing.Micro(0),\n    callFrame: node.callFrame,\n    sampleIndex,\n    profileId,\n  };\n}\n\n/**\n * Matches beginning events with PairableAsyncEnd and PairableAsyncInstant\n * if provided. Traces may contain multiple instant events so we need to\n * account for that. Additionally we have seen cases where we might only have a\n * begin event & instant event(s), with no end event. So we account for that\n * situation also.\n *\n * You might also like to read the models/trace/README.md which has some\n * documentation on trace IDs. This is important as Perfetto will reuse trace\n * IDs when emitting events (if they do not overlap). This means it's not as\n * simple as grouping events by IDs. Instead, we group begin & instant events\n * by ID as we find them. When we find end events, we then pop any matching\n * begin/instant events off the stack and group those. That way, if we meet the\n * same ID later on it doesn't cause us collisions.\n *\n * @returns An array of all the matched event groups, along with their ID. Note\n * that two event groups can have the same ID if they were non-overlapping\n * events. You cannot rely on ID being unique across a trace. The returned set\n * of groups are NOT SORTED in any order.\n */\nfunction matchEvents(unpairedEvents: Types.Events.PairableAsync[]): MatchingPairableAsyncEvents[] {\n  sortTraceEventsInPlace(unpairedEvents);\n  // map to store begin and end of the event\n  const matches: MatchingPairableAsyncEvents[] = [];\n\n  const beginEventsById = new Map<string, Types.Events.PairableAsyncBegin[]>();\n  const instantEventsById = new Map<string, Types.Events.PairableAsyncInstant[]>();\n  for (const event of unpairedEvents) {\n    const id = getSyntheticId(event);\n    if (id === undefined) {\n      continue;\n    }\n    if (Types.Events.isPairableAsyncBegin(event)) {\n      const existingEvents = beginEventsById.get(id) ?? [];\n      existingEvents.push(event);\n      beginEventsById.set(id, existingEvents);\n    } else if (Types.Events.isPairableAsyncInstant(event)) {\n      const existingEvents = instantEventsById.get(id) ?? [];\n      existingEvents.push(event);\n      instantEventsById.set(id, existingEvents);\n    } else if (Types.Events.isPairableAsyncEnd(event)) {\n      // Find matching begin event by ID\n      const beginEventsWithMatchingId = beginEventsById.get(id) ?? [];\n      const beginEvent = beginEventsWithMatchingId.pop();\n      if (!beginEvent) {\n        continue;\n      }\n      const instantEventsWithMatchingId = instantEventsById.get(id) ?? [];\n      // Find all instant events after the begin event ts.\n      const instantEventsForThisGroup: Types.Events.PairableAsyncInstant[] = [];\n      while (instantEventsWithMatchingId.length > 0) {\n        if (instantEventsWithMatchingId[0].ts >= beginEvent.ts) {\n          const event = instantEventsWithMatchingId.pop();\n          if (event) {\n            instantEventsForThisGroup.push(event);\n          }\n        } else {\n          break;\n        }\n      }\n      const matchingGroup: MatchingPairableAsyncEvents = {\n        begin: beginEvent,\n        end: event,\n        instant: instantEventsForThisGroup,\n        syntheticId: id,\n      };\n      matches.push(matchingGroup);\n    }\n  }\n\n  // At this point we know we have paired up all the Begin & End & Instant\n  // events. But it is possible to see only begin & instant events with the\n  // same ID, and no end event. So now we do a second pass through our begin\n  // events to find any that did not have an end event. If we find some\n  // instant events for the begin event, we create a new group.\n  // Also, because there were no end events, we know that the IDs will be\n  // unique now; e.g. each key in the map should have no more than one item in\n  // it.\n  for (const [id, beginEvents] of beginEventsById) {\n    const beginEvent = beginEvents.pop();\n    if (!beginEvent) {\n      continue;\n    }\n    const matchingInstantEvents = instantEventsById.get(id);\n    if (matchingInstantEvents?.length) {\n      matches.push({\n        syntheticId: id,\n        begin: beginEvent,\n        end: null,\n        instant: matchingInstantEvents,\n      });\n    }\n  }\n\n  return matches;\n}\n\nexport function getSyntheticId(event: Types.Events.PairableAsync): string|undefined {\n  const id = extractId(event);\n  return id && `${event.cat}:${id}:${event.name}`;\n}\n\nfunction createSortedSyntheticEvents<T extends Types.Events.PairableAsync>(\n    matchedPairs: MatchingPairableAsyncEvents[],\n    ): Array<Types.Events.SyntheticEventPair<T>> {\n  const syntheticEvents: Array<Types.Events.SyntheticEventPair<T>> = [];\n  for (const eventsTriplet of matchedPairs) {\n    const id = eventsTriplet.syntheticId;\n    const beginEvent = eventsTriplet.begin;\n    const endEvent = eventsTriplet.end;\n    const instantEvents = eventsTriplet.instant;\n    if (!beginEvent || !(endEvent || instantEvents)) {\n      // This should never happen, the backend only creates the events once it\n      // has them both (beginEvent & endEvent/instantEvents), so we should never get into this state.\n      // If we do, something is very wrong, so let's just drop that problematic event.\n      continue;\n    }\n    const triplet = {beginEvent, endEvent, instantEvents};\n    /**\n     * When trying to pair events with instant events present, there are times when these\n     * ASYNC_NESTABLE_INSTANT ('n') don't have a corresponding ASYNC_NESTABLE_END ('e') event.\n     * In these cases, pair without needing the endEvent.\n     */\n    function eventsArePairable(data: {\n      beginEvent: Types.Events.PairableAsyncBegin,\n      endEvent: Types.Events.PairableAsyncEnd|null,\n      instantEvents?: Types.Events.PairableAsyncInstant[],\n    }): data is Types.Events.SyntheticEventPair<T>['args']['data'] {\n      const instantEventsMatch = data.instantEvents ? data.instantEvents.some(e => id === getSyntheticId(e)) : false;\n      const endEventMatch = data.endEvent ? id === getSyntheticId(data.endEvent) : false;\n      return Boolean(id) && (instantEventsMatch || endEventMatch);\n    }\n    if (!eventsArePairable(triplet)) {\n      continue;\n    }\n    const targetEvent = endEvent || beginEvent;\n\n    const event = SyntheticEventsManager.registerSyntheticEvent<Types.Events.SyntheticEventPair<T>>({\n      rawSourceEvent: triplet.beginEvent,\n      cat: targetEvent.cat,\n      ph: targetEvent.ph,\n      pid: targetEvent.pid,\n      tid: targetEvent.tid,\n      id,\n      // Both events have the same name, so it doesn't matter which we pick to\n      // use as the description\n      name: beginEvent.name,\n      dur: Types.Timing.Micro(targetEvent.ts - beginEvent.ts),\n      ts: beginEvent.ts,\n      args: {\n        data: triplet,\n      },\n    });\n\n    if (event.dur < 0) {\n      // We have seen in the backend that sometimes animation events get\n      // generated with multiple begin entries, or multiple end entries, and this\n      // can cause invalid data on the performance panel, so we drop them.\n      // crbug.com/1472375\n      continue;\n    }\n    syntheticEvents.push(event);\n  }\n  sortTraceEventsInPlace(syntheticEvents);\n  return syntheticEvents;\n}\n\n/**\n * Groups up sets of async events into synthetic events.\n * @param unpairedAsyncEvents the raw array of begin, end and async instant\n * events. These MUST be sorted in timestamp ASC order.\n */\nexport function createMatchedSortedSyntheticEvents<T extends Types.Events.PairableAsync>(unpairedAsyncEvents: T[]):\n    Array<Types.Events.SyntheticEventPair<T>> {\n  const matchedPairs = matchEvents(unpairedAsyncEvents);\n  const syntheticEvents = createSortedSyntheticEvents<T>(matchedPairs);\n  return syntheticEvents;\n}\n\n/**\n * Different trace events return line/column numbers that are 1 or 0 indexed.\n * This function knows which events return 1 indexed numbers and normalizes\n * them. The UI expects 0 indexed line numbers, so that is what we return.\n */\nexport function getZeroIndexedLineAndColumnForEvent(event: Types.Events.Event): {\n  lineNumber?: number,\n  columnNumber?: number,\n} {\n  // Some events emit line numbers that are 1 indexed, but the UI layer expects\n  // numbers to be 0 indexed. So here, if the event matches a known 1-indexed\n  // number event, we subtract one from the line and column numbers.\n  // Otherwise, if the event has args.data.lineNumber/colNumber, we return it\n  // as is.\n  const numbers = getRawLineAndColumnNumbersForEvent(event);\n  const {lineNumber, columnNumber} = numbers;\n\n  switch (event.name) {\n    // All these events have line/column numbers which are 1 indexed; so we\n    // subtract to make them 0 indexed.\n    case Types.Events.Name.FUNCTION_CALL:\n    case Types.Events.Name.EVALUATE_SCRIPT:\n    case Types.Events.Name.COMPILE:\n    case Types.Events.Name.CACHE_SCRIPT: {\n      return {\n        lineNumber: typeof lineNumber === 'number' ? lineNumber - 1 : undefined,\n        columnNumber: typeof columnNumber === 'number' ? columnNumber - 1 : undefined,\n      };\n    }\n    case Types.Events.Name.PROFILE_CALL: {\n      const callFrame = (event as Types.Events.SyntheticProfileCall).callFrame;\n      return {\n        lineNumber: typeof lineNumber === 'number' ? callFrame.lineNumber - 1 : undefined,\n        columnNumber: typeof columnNumber === 'number' ? callFrame.columnNumber - 1 : undefined,\n      };\n    }\n    default: {\n      return numbers;\n    }\n  }\n}\n\n/**\n * Different trace events contain stack traces with line/column numbers\n * that are 1 or 0 indexed.\n * This function knows which events return 1 indexed numbers and normalizes\n * them. The UI expects 0 indexed line numbers, so that is what we return.\n *\n * Note: this only returns the stack trace contained in the payload of\n * an event, which only contains the synchronous portion of the call\n * stack. If you want to obtain the whole stack trace you might need to\n * use the @see Trace.Extras.StackTraceForEvent util.\n */\nexport function getZeroIndexedStackTraceInEventPayload(event: Types.Events.Event): Types.Events.CallFrame[]|null {\n  const stack = stackTraceInEvent(event);\n  if (!stack) {\n    return null;\n  }\n\n  switch (event.name) {\n    case Types.Events.Name.SCHEDULE_STYLE_RECALCULATION:\n    case Types.Events.Name.INVALIDATE_LAYOUT:\n    case Types.Events.Name.FUNCTION_CALL:\n    case Types.Events.Name.LAYOUT:\n    case Types.Events.Name.RECALC_STYLE: {\n      return stack.map(makeZeroBasedCallFrame);\n    }\n\n    default: {\n      if (Types.Events.isUserTiming(event) || Types.Extensions.isSyntheticExtensionEntry(event)) {\n        return stack.map(makeZeroBasedCallFrame);\n      }\n\n      return stack;\n    }\n  }\n}\n\n/**\n * Same as getZeroIndexedStackTraceInEventPayload, but only returns the top call frame.\n */\nexport function getStackTraceTopCallFrameInEventPayload(event: Types.Events.Event): Types.Events.CallFrame|null {\n  const stack = stackTraceInEvent(event);\n  if (!stack || stack.length === 0) {\n    return null;\n  }\n\n  switch (event.name) {\n    case Types.Events.Name.SCHEDULE_STYLE_RECALCULATION:\n    case Types.Events.Name.INVALIDATE_LAYOUT:\n    case Types.Events.Name.FUNCTION_CALL:\n    case Types.Events.Name.LAYOUT:\n    case Types.Events.Name.RECALC_STYLE: {\n      return makeZeroBasedCallFrame(stack[0]);\n    }\n\n    default: {\n      if (Types.Events.isUserTiming(event) || Types.Extensions.isSyntheticExtensionEntry(event)) {\n        return makeZeroBasedCallFrame(stack[0]);\n      }\n\n      return stack[0];\n    }\n  }\n}\n\n/**\n * Given a 1-based call frame creates a 0-based one.\n */\nexport function makeZeroBasedCallFrame(callFrame: Types.Events.CallFrame): Types.Events.CallFrame {\n  const normalizedCallFrame = {...callFrame};\n\n  normalizedCallFrame.lineNumber = callFrame.lineNumber && callFrame.lineNumber - 1;\n  normalizedCallFrame.columnNumber = callFrame.columnNumber && callFrame.columnNumber - 1;\n  return normalizedCallFrame;\n}\n\n/**\n * NOTE: you probably do not want this function! (Which is why it is not exported).\n *\n * Some trace events have 0 indexed line/column numbers, and others have 1\n * indexed. This function does NOT normalize them, but\n * `getZeroIndexedLineAndColumnNumbersForEvent` does. It is best to use that!\n *\n * @see {@link getZeroIndexedLineAndColumnForEvent}\n **/\nfunction getRawLineAndColumnNumbersForEvent(event: Types.Events.Event): {\n  lineNumber?: number,\n  columnNumber?: number,\n} {\n  if (!event.args?.data) {\n    return {\n      lineNumber: undefined,\n      columnNumber: undefined,\n    };\n  }\n  let lineNumber: number|undefined = undefined;\n  let columnNumber: number|undefined = undefined;\n  if ('lineNumber' in event.args.data && typeof event.args.data.lineNumber === 'number') {\n    lineNumber = event.args.data.lineNumber;\n  }\n  if ('columnNumber' in event.args.data && typeof event.args.data.columnNumber === 'number') {\n    columnNumber = event.args.data.columnNumber;\n  }\n\n  return {lineNumber, columnNumber};\n}\n\nexport function frameIDForEvent(event: Types.Events.Event): string|null {\n  // There are a few events (for example RecalcStyle, ParseHTML) that have\n  // the frame stored in args.beginData\n  // Rather than list them all we just check for the presence of the field, so\n  // we are robust against future trace events also doing this.\n  // This check seems very robust, but it also helps satisfy TypeScript and\n  // prevents us against unexpected data.\n  if (event.args && 'beginData' in event.args && typeof event.args.beginData === 'object' &&\n      event.args.beginData !== null && 'frame' in event.args.beginData &&\n      typeof event.args.beginData.frame === 'string') {\n    return event.args.beginData.frame;\n  }\n  // Otherwise, we expect frame to be in args.data\n  if (event.args?.data?.frame) {\n    return event.args.data.frame;\n  }\n\n  // No known frame for this event.\n  return null;\n}\n\nconst DevToolsTimelineEventCategory = 'disabled-by-default-devtools.timeline';\nexport function isTopLevelEvent(event: Types.Events.Event): boolean {\n  return event.cat.includes(DevToolsTimelineEventCategory) && event.name === Types.Events.Name.RUN_TASK;\n}\n\nexport function isExtensionUrl(url: string): boolean {\n  return url.startsWith('extensions:') || url.startsWith('chrome-extension:');\n}\n\nfunction topLevelEventIndexEndingAfter(events: Types.Events.Event[], time: Types.Timing.Micro): number {\n  let index = Platform.ArrayUtilities.upperBound(events, time, (time, event) => time - event.ts) - 1;\n  while (index > 0 && !isTopLevelEvent(events[index])) {\n    index--;\n  }\n  return Math.max(index, 0);\n}\nexport function findRecalcStyleEvents(\n    events: Types.Events.Event[], startTime: Types.Timing.Micro,\n    endTime?: Types.Timing.Micro): Types.Events.RecalcStyle[] {\n  const foundEvents: Types.Events.RecalcStyle[] = [];\n  const startEventIndex = topLevelEventIndexEndingAfter(events, startTime);\n  for (let i = startEventIndex; i < events.length; i++) {\n    const event = events[i];\n    if (!Types.Events.isRecalcStyle(event)) {\n      continue;\n    }\n    if (event.ts >= (endTime || Infinity)) {\n      continue;\n    }\n    foundEvents.push(event);\n  }\n  return foundEvents;\n}\n\nexport function findNextEventAfterTimestamp<T extends Types.Events.Event>(candidates: T[], ts: Types.Timing.Micro): T|\n    null {\n  const index = Platform.ArrayUtilities.nearestIndexFromBeginning(candidates, candidate => ts < candidate.ts);\n  return index === null ? null : candidates[index];\n}\n\nexport function findPreviousEventBeforeTimestamp<T extends Types.Events.Event>(\n    candidates: T[], ts: Types.Timing.Micro): T|null {\n  const index = Platform.ArrayUtilities.nearestIndexFromEnd(candidates, candidate => candidate.ts < ts);\n  return index === null ? null : candidates[index];\n}\n\nexport interface ForEachEventConfig {\n  onStartEvent: (event: Types.Events.Event) => void;\n  onEndEvent: (event: Types.Events.Event) => void;\n  onInstantEvent?: (event: Types.Events.Event) => void;\n  eventFilter?: (event: Types.Events.Event) => boolean;\n  startTime?: Types.Timing.Micro;\n  endTime?: Types.Timing.Micro;\n  /* If async events should be skipped. Defaults to true */\n  ignoreAsyncEvents?: boolean;\n}\n\n/**\n * Iterates events in a tree hierarchically, from top to bottom,\n * calling back on every event's start and end in the order\n * dictated by the corresponding timestamp.\n *\n * Events are assumed to be in ascendent order by timestamp.\n *\n * Events with 0 duration are treated as instant events. These do not have a\n * begin and end, but will be passed to the config.onInstantEvent callback as\n * they are discovered. Do not provide this callback if you are not interested\n * in them.\n *\n * For example, given this tree, the following callbacks\n * are expected to be made in the following order\n * |---------------A---------------|\n *  |------B------||-------D------|\n *    |---C---|\n *\n * 1. Start A\n * 3. Start B\n * 4. Start C\n * 5. End C\n * 6. End B\n * 7. Start D\n * 8. End D\n * 9. End A\n *\n * By default, async events are skipped. This behaviour can be\n * overridden making use of the config.ignoreAsyncEvents parameter.\n */\nexport function forEachEvent(\n    events: Types.Events.Event[],\n    config: ForEachEventConfig,\n    ): void {\n  const globalStartTime = config.startTime ?? Types.Timing.Micro(0);\n  const globalEndTime = config.endTime || Types.Timing.Micro(Infinity);\n  const ignoreAsyncEvents = config.ignoreAsyncEvents === false ? false : true;\n\n  const stack: Types.Events.Event[] = [];\n  const startEventIndex = topLevelEventIndexEndingAfter(events, globalStartTime);\n  for (let i = startEventIndex; i < events.length; i++) {\n    const currentEvent = events[i];\n    const currentEventTimings = eventTimingsMicroSeconds(currentEvent);\n    if (currentEventTimings.endTime < globalStartTime) {\n      continue;\n    }\n    if (currentEventTimings.startTime > globalEndTime) {\n      break;\n    }\n\n    const isIgnoredAsyncEvent = ignoreAsyncEvents && Types.Events.isPhaseAsync(currentEvent.ph);\n    if (isIgnoredAsyncEvent || Types.Events.isFlowPhase(currentEvent.ph)) {\n      continue;\n    }\n\n    // If we have now reached an event that is after a bunch of events, we need\n    // to call the onEndEvent callback for those events before moving on.\n    let lastEventOnStack = stack.at(-1);\n    let lastEventEndTime = lastEventOnStack ? eventTimingsMicroSeconds(lastEventOnStack).endTime : null;\n    while (lastEventOnStack && lastEventEndTime && lastEventEndTime <= currentEventTimings.startTime) {\n      stack.pop();\n      config.onEndEvent(lastEventOnStack);\n      lastEventOnStack = stack.at(-1);\n      lastEventEndTime = lastEventOnStack ? eventTimingsMicroSeconds(lastEventOnStack).endTime : null;\n    }\n\n    // Now we have dealt with all events prior to this one, see if we need to care about this one.\n    if (config.eventFilter && !config.eventFilter(currentEvent)) {\n      // The user has chosen to filter this event out, so continue on and do nothing\n      continue;\n    }\n\n    if (currentEventTimings.duration) {\n      config.onStartEvent(currentEvent);\n      stack.push(currentEvent);\n    } else if (config.onInstantEvent) {\n      // An event with 0 duration is an instant event.\n      config.onInstantEvent(currentEvent);\n    }\n  }\n\n  // Now we have finished looping over all events; any events remaining on the\n  // stack need to have their onEndEvent called.\n  while (stack.length) {\n    const last = stack.pop();\n    if (last) {\n      config.onEndEvent(last);\n    }\n  }\n}\n\n// Parsed categories are cached to prevent calling cat.split()\n// multiple times on the same categories string.\nconst parsedCategories = new Map<string, Set<string>>();\nexport function eventHasCategory(event: Types.Events.Event, category: string): boolean {\n  let parsedCategoriesForEvent = parsedCategories.get(event.cat);\n  if (!parsedCategoriesForEvent) {\n    parsedCategoriesForEvent = new Set(event.cat.split(',') || []);\n  }\n  return parsedCategoriesForEvent.has(category);\n}\n\n/**\n * This compares Types.Events.CallFrame with Protocol.Runtime.CallFrame and checks for equality.\n */\nexport function isMatchingCallFrame(\n    eventFrame: Types.Events.CallFrame, nodeFrame: Protocol.Runtime.CallFrame): boolean {\n  return eventFrame.columnNumber === nodeFrame.columnNumber && eventFrame.lineNumber === nodeFrame.lineNumber &&\n      String(eventFrame.scriptId) === nodeFrame.scriptId && eventFrame.url === nodeFrame.url &&\n      eventFrame.functionName === nodeFrame.functionName;\n}\n\nexport function eventContainsTimestamp(event: Types.Events.Event, ts: Types.Timing.Micro): boolean {\n  return event.ts <= ts && event.ts + (event.dur || 0) >= ts;\n}\n\nexport function extractSampleTraceId(event: Types.Events.Event): number|null {\n  if (!event.args) {\n    return null;\n  }\n  if ('beginData' in event.args) {\n    const beginData = event.args['beginData'] as {sampleTraceId?: number};\n    return beginData.sampleTraceId ?? null;\n  }\n  return event.args?.sampleTraceId ?? event.args?.data?.sampleTraceId ?? null;\n}\n\n/**\n * This exactly matches Trace.Styles.visibleTypes. See the runtime verification in maybeInitStylesMap.\n * TODO(crbug.com/410884528)\n **/\nexport const VISIBLE_TRACE_EVENT_TYPES = new Set<Types.Events.Name>([\n  Types.Events.Name.ABORT_POST_TASK_CALLBACK,\n  Types.Events.Name.ANIMATION,\n  Types.Events.Name.ASYNC_TASK,\n  Types.Events.Name.BACKGROUND_DESERIALIZE,\n  Types.Events.Name.CACHE_MODULE,\n  Types.Events.Name.CACHE_SCRIPT,\n  Types.Events.Name.CANCEL_ANIMATION_FRAME,\n  Types.Events.Name.CANCEL_IDLE_CALLBACK,\n  Types.Events.Name.COMMIT,\n  Types.Events.Name.COMPILE_CODE,\n  Types.Events.Name.COMPILE_MODULE,\n  Types.Events.Name.COMPILE,\n  Types.Events.Name.COMPOSITE_LAYERS,\n  Types.Events.Name.COMPUTE_INTERSECTION,\n  Types.Events.Name.CONSOLE_TIME,\n  Types.Events.Name.CPPGC_SWEEP,\n  Types.Events.Name.CRYPTO_DO_DECRYPT_REPLY,\n  Types.Events.Name.CRYPTO_DO_DECRYPT,\n  Types.Events.Name.CRYPTO_DO_DIGEST_REPLY,\n  Types.Events.Name.CRYPTO_DO_DIGEST,\n  Types.Events.Name.CRYPTO_DO_ENCRYPT_REPLY,\n  Types.Events.Name.CRYPTO_DO_ENCRYPT,\n  Types.Events.Name.CRYPTO_DO_SIGN_REPLY,\n  Types.Events.Name.CRYPTO_DO_SIGN,\n  Types.Events.Name.CRYPTO_DO_VERIFY_REPLY,\n  Types.Events.Name.CRYPTO_DO_VERIFY,\n  Types.Events.Name.DECODE_IMAGE,\n  Types.Events.Name.EMBEDDER_CALLBACK,\n  Types.Events.Name.EVALUATE_MODULE,\n  Types.Events.Name.EVALUATE_SCRIPT,\n  Types.Events.Name.EVENT_DISPATCH,\n  Types.Events.Name.EVENT_TIMING,\n  Types.Events.Name.FINALIZE_DESERIALIZATION,\n  Types.Events.Name.FIRE_ANIMATION_FRAME,\n  Types.Events.Name.FIRE_IDLE_CALLBACK,\n  Types.Events.Name.FUNCTION_CALL,\n  Types.Events.Name.GC_COLLECT_GARBARGE,\n  Types.Events.Name.GC,\n  Types.Events.Name.GPU_TASK,\n  Types.Events.Name.HANDLE_POST_MESSAGE,\n  Types.Events.Name.HIT_TEST,\n  Types.Events.Name.JS_SAMPLE,\n  Types.Events.Name.LAYERIZE,\n  Types.Events.Name.LAYOUT,\n  Types.Events.Name.MAJOR_GC,\n  Types.Events.Name.MINOR_GC,\n  Types.Events.Name.OPTIMIZE_CODE,\n  Types.Events.Name.PAINT_SETUP,\n  Types.Events.Name.PAINT,\n  Types.Events.Name.PARSE_AUTHOR_STYLE_SHEET,\n  Types.Events.Name.PARSE_HTML,\n  Types.Events.Name.PRE_PAINT,\n  Types.Events.Name.PROFILE_CALL,\n  Types.Events.Name.PROGRAM,\n  Types.Events.Name.RASTER_TASK,\n  Types.Events.Name.REQUEST_ANIMATION_FRAME,\n  Types.Events.Name.REQUEST_IDLE_CALLBACK,\n  Types.Events.Name.RESOURCE_FINISH,\n  Types.Events.Name.RESOURCE_RECEIVE_DATA,\n  Types.Events.Name.RESOURCE_RECEIVE_RESPONSE,\n  Types.Events.Name.RESOURCE_SEND_REQUEST,\n  Types.Events.Name.RESOURCE_WILL_SEND_REQUEST,\n  Types.Events.Name.RUN_MICROTASKS,\n  Types.Events.Name.RUN_POST_TASK_CALLBACK,\n  Types.Events.Name.RUN_TASK,\n  Types.Events.Name.SCHEDULE_POST_MESSAGE,\n  Types.Events.Name.SCHEDULE_POST_TASK_CALLBACK,\n  Types.Events.Name.SCHEDULE_STYLE_RECALCULATION,\n  Types.Events.Name.SCROLL_LAYER,\n  Types.Events.Name.START_PROFILING,\n  Types.Events.Name.STREAMING_COMPILE_SCRIPT_PARSING,\n  Types.Events.Name.STREAMING_COMPILE_SCRIPT_WAITING,\n  Types.Events.Name.STREAMING_COMPILE_SCRIPT,\n  Types.Events.Name.SYNTHETIC_LAYOUT_SHIFT_CLUSTER,\n  Types.Events.Name.SYNTHETIC_LAYOUT_SHIFT,\n  Types.Events.Name.TIME_STAMP,\n  Types.Events.Name.TIMER_FIRE,\n  Types.Events.Name.TIMER_INSTALL,\n  Types.Events.Name.TIMER_REMOVE,\n  Types.Events.Name.UPDATE_LAYER_TREE,\n  Types.Events.Name.RECALC_STYLE,\n  Types.Events.Name.USER_TIMING,\n  Types.Events.Name.V8_CONSOLE_RUN_TASK,\n  Types.Events.Name.WASM_CACHED_MODULE,\n  Types.Events.Name.WASM_COMPILED_MODULE,\n  Types.Events.Name.WASM_MODULE_CACHE_HIT,\n  Types.Events.Name.WASM_MODULE_CACHE_INVALID,\n  Types.Events.Name.WASM_STREAM_FROM_RESPONSE_CALLBACK,\n  Types.Events.Name.WEB_SOCKET_CREATE,\n  Types.Events.Name.WEB_SOCKET_DESTROY,\n  Types.Events.Name.WEB_SOCKET_RECEIVE_HANDSHAKE_REQUEST,\n  Types.Events.Name.WEB_SOCKET_RECEIVE,\n  Types.Events.Name.WEB_SOCKET_SEND_HANDSHAKE_REQUEST,\n  Types.Events.Name.WEB_SOCKET_SEND,\n  Types.Events.Name.XHR_LOAD,\n  Types.Events.Name.XHR_READY_STATE_CHANGED,\n]);\n", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Types from '../types/types.js';\n\nlet activeManager: SyntheticEventsManager|null = null;\n\nexport class SyntheticEventsManager {\n  /**\n   * All synthetic entries created in a trace from a corresponding trace events.\n   * (ProfileCalls are excluded because they are not based on a real trace event)\n   */\n  #syntheticTraces: Types.Events.SyntheticBased[] = [];\n  /**\n   * All raw entries from a trace.\n   */\n  #rawTraceEvents: readonly Types.Events.Event[] = [];\n\n  static activate(manager: SyntheticEventsManager): void {\n    activeManager = manager;\n  }\n\n  static createAndActivate(rawEvents: readonly Types.Events.Event[]): SyntheticEventsManager {\n    const manager = new SyntheticEventsManager(rawEvents);\n    SyntheticEventsManager.activate(manager);\n    return manager;\n  }\n\n  static getActiveManager(): SyntheticEventsManager {\n    if (!activeManager) {\n      throw new Error('Attempted to get a SyntheticEventsManager without initializing');\n    }\n    return activeManager;\n  }\n\n  static reset(): void {\n    activeManager = null;\n  }\n\n  static registerSyntheticEvent<T extends Types.Events.SyntheticBased>(syntheticEvent: Omit<T, '_tag'>): T {\n    try {\n      return SyntheticEventsManager.getActiveManager().#registerSyntheticEvent(syntheticEvent);\n    } catch {\n      // If no active manager has been initialized, we assume the trace engine is\n      // not running as part of the Performance panel. In this case we don't\n      // register synthetic events because we don't need to support timeline\n      // modifications serialization.\n      return syntheticEvent as T;\n    }\n  }\n\n  private constructor(rawEvents: readonly Types.Events.Event[]) {\n    this.#rawTraceEvents = rawEvents;\n  }\n\n  /**\n   * Registers and returns a branded synthetic event. Synthetic events need to\n   * be created with this method to ensure they are registered and made\n   * available to load events using serialized keys.\n   */\n  #registerSyntheticEvent<T extends Types.Events.SyntheticBased>(syntheticEvent: Omit<T, '_tag'>): T {\n    const rawIndex = this.#rawTraceEvents.indexOf(syntheticEvent.rawSourceEvent);\n    if (rawIndex < 0) {\n      throw new Error('Attempted to register a synthetic event paired to an unknown raw event.');\n    }\n    const eventAsSynthetic = syntheticEvent as T;\n    this.#syntheticTraces[rawIndex] = eventAsSynthetic;\n    return eventAsSynthetic;\n  }\n\n  syntheticEventForRawEventIndex(rawEventIndex: number): Types.Events.SyntheticBased {\n    const syntheticEvent = this.#syntheticTraces.at(rawEventIndex);\n    if (!syntheticEvent) {\n      throw new Error(`Attempted to get a synthetic event from an unknown raw event index: ${rawEventIndex}`);\n    }\n    return syntheticEvent;\n  }\n\n  getSyntheticTraces(): Types.Events.SyntheticBased[] {\n    return this.#syntheticTraces;\n  }\n\n  getRawTraceEvents(): readonly Types.Events.Event[] {\n    return this.#rawTraceEvents;\n  }\n}\n", "// Copyright 2022 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Types from '../types/types.js';\n\nimport {getNavigationForTraceEvent} from './Trace.js';\n\nexport const milliToMicro = (value: Types.Timing.Milli): Types.Timing.Micro => Types.Timing.Micro(value * 1000);\n\nexport const secondsToMilli = (value: Types.Timing.Seconds): Types.Timing.Milli => Types.Timing.Milli(value * 1000);\n\nexport const secondsToMicro = (value: Types.Timing.Seconds): Types.Timing.Micro => milliToMicro(secondsToMilli(value));\n\nexport const microToMilli = (value: Types.Timing.Micro): Types.Timing.Milli => Types.Timing.Milli(value / 1000);\n\nexport const microToSeconds = (value: Types.Timing.Micro): Types.Timing.Seconds =>\n    Types.Timing.Seconds(value / 1000 / 1000);\n\nexport function timeStampForEventAdjustedByClosestNavigation(\n    event: Types.Events.Event,\n    traceBounds: Types.Timing.TraceWindowMicro,\n    navigationsByNavigationId: Map<string, Types.Events.NavigationStart>,\n    navigationsByFrameId: Map<string, Types.Events.NavigationStart[]>,\n    ): Types.Timing.Micro {\n  let eventTimeStamp = event.ts - traceBounds.min;\n  if (event.args?.data?.navigationId) {\n    const navigationForEvent = navigationsByNavigationId.get(event.args.data.navigationId);\n    if (navigationForEvent) {\n      eventTimeStamp = event.ts - navigationForEvent.ts;\n    }\n  } else if (event.args?.data?.frame) {\n    const navigationForEvent = getNavigationForTraceEvent(event, event.args.data.frame, navigationsByFrameId);\n    if (navigationForEvent) {\n      eventTimeStamp = event.ts - navigationForEvent.ts;\n    }\n  }\n  return Types.Timing.Micro(eventTimeStamp);\n}\n\n/**\n * Expands the trace window by a provided percentage or, if it the expanded window is smaller than 1 millisecond, expands it to 1 millisecond.\n * If the expanded window is outside of the max trace window, cut the overflowing bound to the max trace window bound.\n **/\nexport function expandWindowByPercentOrToOneMillisecond(\n    annotationWindow: Types.Timing.TraceWindowMicro, maxTraceWindow: Types.Timing.TraceWindowMicro,\n    percentage: number): Types.Timing.TraceWindowMicro {\n  // Expand min and max of the window by half of the provided percentage. That way, in total, the window will be expanded by the provided percentage.\n  let newMin = annotationWindow.min - annotationWindow.range * (percentage / 100) / 2;\n  let newMax = annotationWindow.max + annotationWindow.range * (percentage / 100) / 2;\n\n  if (newMax - newMin < 1_000) {\n    const rangeMiddle = (annotationWindow.min + annotationWindow.max) / 2;\n    newMin = rangeMiddle - 500;\n    newMax = rangeMiddle + 500;\n  }\n\n  newMin = Math.max(newMin, maxTraceWindow.min);\n  newMax = Math.min(newMax, maxTraceWindow.max);\n\n  const expandedWindow: Types.Timing.TraceWindowMicro = {\n    min: Types.Timing.Micro(newMin),\n    max: Types.Timing.Micro(newMax),\n    range: Types.Timing.Micro(newMax - newMin),\n  };\n\n  return expandedWindow;\n}\n\nexport interface EventTimingsData<ValueType extends Types.Timing.Micro|Types.Timing.Milli|Types.Timing.Seconds, > {\n  startTime: ValueType;\n  endTime: ValueType;\n  duration: ValueType;\n}\n\nexport function eventTimingsMicroSeconds(event: Types.Events.Event): EventTimingsData<Types.Timing.Micro> {\n  return {\n    startTime: event.ts,\n    endTime: (event.ts + (event.dur ?? 0)) as Types.Timing.Micro,\n    duration: (event.dur || 0) as Types.Timing.Micro,\n  };\n}\nexport function eventTimingsMilliSeconds(event: Types.Events.Event): EventTimingsData<Types.Timing.Milli> {\n  return {\n    startTime: (event.ts / 1000) as Types.Timing.Milli,\n    endTime: (event.ts + (event.dur ?? 0)) / 1000 as Types.Timing.Milli,\n    duration: (event.dur || 0) / 1000 as Types.Timing.Milli,\n  };\n}\n\nexport function traceWindowMilliSeconds(bounds: Types.Timing.TraceWindowMicro): Types.Timing.TraceWindowMilli {\n  return {\n    min: microToMilli(bounds.min),\n    max: microToMilli(bounds.max),\n    range: microToMilli(bounds.range),\n  };\n}\n\nexport function traceWindowMicroSecondsToMilliSeconds(bounds: Types.Timing.TraceWindowMicro):\n    Types.Timing.TraceWindowMilli {\n  return {\n    min: microToMilli(bounds.min),\n    max: microToMilli(bounds.max),\n    range: microToMilli(bounds.range),\n  };\n}\n\nexport function traceWindowFromMilliSeconds(\n    min: Types.Timing.Milli, max: Types.Timing.Milli): Types.Timing.TraceWindowMicro {\n  const traceWindow: Types.Timing.TraceWindowMicro = {\n    min: milliToMicro(min),\n    max: milliToMicro(max),\n    range: Types.Timing.Micro(milliToMicro(max) - milliToMicro(min)),\n  };\n  return traceWindow;\n}\n\nexport function traceWindowFromMicroSeconds(\n    min: Types.Timing.Micro, max: Types.Timing.Micro): Types.Timing.TraceWindowMicro {\n  const traceWindow: Types.Timing.TraceWindowMicro = {\n    min,\n    max,\n    range: (max - min) as Types.Timing.Micro,\n  };\n  return traceWindow;\n}\n\nexport function traceWindowFromEvent(event: Types.Events.Event): Types.Timing.TraceWindowMicro {\n  return {\n    min: event.ts,\n    max: event.ts + (event.dur ?? 0) as Types.Timing.Micro,\n    range: event.dur ?? 0 as Types.Timing.Micro,\n  };\n}\n\nexport function traceWindowFromOverlay(overlay: Types.Overlays.Overlay): Types.Timing.TraceWindowMicro|null {\n  switch (overlay.type) {\n    case 'ENTRY_LABEL':\n    case 'ENTRY_OUTLINE':\n    case 'ENTRY_SELECTED': {\n      return traceWindowFromEvent(overlay.entry);\n    }\n\n    case 'TIMESPAN_BREAKDOWN': {\n      const windows = overlay.sections.map(s => s.bounds);\n      if (overlay.entry) {\n        windows.push(traceWindowFromEvent(overlay.entry));\n      }\n      return combineTraceWindowsMicro(windows);\n    }\n\n    case 'CANDY_STRIPED_TIME_RANGE':\n    case 'TIME_RANGE': {\n      return structuredClone(overlay.bounds);\n    }\n\n    case 'ENTRIES_LINK': {\n      const from = traceWindowFromEvent(overlay.entryFrom);\n      if (!overlay.entryTo) {\n        return from;\n      }\n\n      const to = traceWindowFromEvent(overlay.entryTo);\n      return combineTraceWindowsMicro([from, to]);\n    }\n\n    case 'TIMESTAMP_MARKER':\n      return traceWindowFromMicroSeconds(overlay.timestamp, overlay.timestamp);\n    case 'TIMINGS_MARKER':\n      return traceWindowFromMicroSeconds(overlay.adjustedTimestamp, overlay.adjustedTimestamp);\n    case 'BOTTOM_INFO_BAR':\n      return null;\n\n    default:\n      Platform.TypeScriptUtilities.assertNever(overlay, `Unexpected overlay ${overlay}`);\n  }\n}\n\n/**\n * Combines (as in a union) multiple windows into one.\n */\nexport function combineTraceWindowsMicro(windows: Types.Timing.TraceWindowMicro[]): Types.Timing.TraceWindowMicro|null {\n  if (!windows.length) {\n    return null;\n  }\n\n  const result: Types.Timing.TraceWindowMicro = structuredClone(windows[0]);\n  for (const bounds of windows.slice(1)) {\n    result.min = Math.min(result.min, bounds.min) as Types.Timing.Micro;\n    result.max = Math.max(result.max, bounds.max) as Types.Timing.Micro;\n  }\n\n  result.range = result.max - result.min as Types.Timing.Micro;\n\n  return result;\n}\n\nexport interface BoundsIncludeTimeRange {\n  timeRange: Types.Timing.TraceWindowMicro;\n  bounds: Types.Timing.TraceWindowMicro;\n}\n\n/**\n * Checks to see if the timeRange is within the bounds. By \"within\" we mean\n * \"has any overlap\":\n *         |------------------------|\n *      ==                                     no overlap (entirely before)\n *       =========                             overlap\n *            =========                        overlap\n *                             =========       overlap\n *                                     ====    no overlap (entirely after)\n *        ==============================       overlap (time range is larger than bounds)\n *         |------------------------|\n */\nexport function boundsIncludeTimeRange(data: BoundsIncludeTimeRange): boolean {\n  const {min: visibleMin, max: visibleMax} = data.bounds;\n  const {min: rangeMin, max: rangeMax} = data.timeRange;\n\n  return visibleMin <= rangeMax && visibleMax >= rangeMin;\n}\n\n/** Checks to see if the event is within or overlaps the bounds */\nexport function eventIsInBounds(event: Types.Events.Event, bounds: Types.Timing.TraceWindowMicro): boolean {\n  const startTime = event.ts;\n  return startTime <= bounds.max && bounds.min < (startTime + (event.dur ?? 0));\n}\n\nexport function timestampIsInBounds(bounds: Types.Timing.TraceWindowMicro, timestamp: Types.Timing.Micro): boolean {\n  return timestamp >= bounds.min && timestamp <= bounds.max;\n}\n\nexport interface WindowFitsInsideBounds {\n  window: Types.Timing.TraceWindowMicro;\n  bounds: Types.Timing.TraceWindowMicro;\n}\n\n/**\n * Returns true if the window fits entirely within the bounds.\n * Note that if the window is equivalent to the bounds, that is considered to fit\n */\nexport function windowFitsInsideBounds(data: WindowFitsInsideBounds): boolean {\n  return data.window.min >= data.bounds.min && data.window.max <= data.bounds.max;\n}\n\nexport function windowsEqual(w1: Types.Timing.TraceWindowMicro, w2: Types.Timing.TraceWindowMicro): boolean {\n  return w1.min === w2.min && w1.max === w2.max;\n}\n", "// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Platform from '../../../core/platform/platform.js';\nimport * as Types from '../types/types.js';\n\nimport {eventIsInBounds} from './Timing.js';\n\nlet nodeIdCount = 0;\nexport const makeTraceEntryNodeId = (): TraceEntryNodeId => (++nodeIdCount) as TraceEntryNodeId;\n\nexport const makeEmptyTraceEntryTree = (): TraceEntryTree => ({\n  roots: new Set(),\n  maxDepth: 0,\n});\n\nexport const makeEmptyTraceEntryNode = (entry: Types.Events.Event, id: TraceEntryNodeId): TraceEntryNode => ({\n  entry,\n  id,\n  parent: null,\n  children: [],\n  depth: 0,\n});\n\nexport interface TraceEntryTree {\n  roots: Set<TraceEntryNode>;\n  maxDepth: number;\n}\n\n/** Node in the graph that defines all parent/child relationships. */\nexport interface TraceEntryNode {\n  entry: Types.Events.Event;\n  depth: number;\n  selfTime?: Types.Timing.Micro;\n  id: TraceEntryNodeId;\n  parent: TraceEntryNode|null;\n  children: TraceEntryNode[];\n}\n\nexport type TraceEntryNodeId = Platform.Brand.Brand<number, 'traceEntryNodeIdTag'>;\n\n/**\n * Builds a hierarchy of the entries (trace events and profile calls) in\n * a particular thread of a particular process, assuming that they're\n * sorted, by iterating through all of the events in order.\n *\n * The approach is analogous to how a parser would be implemented. A\n * stack maintains local context. A scanner peeks and pops from the data\n * stream. Various \"tokens\" (events) are treated as \"whitespace\"\n * (ignored).\n *\n * The tree starts out empty and is populated as the hierarchy is built.\n * The nodes are also assumed to be created empty, with no known parent\n * or children.\n *\n * Complexity: O(n), where n = number of events\n */\nexport function treify(entries: readonly Types.Events.Event[], options?: {\n  filter: {has: (name: Types.Events.Name) => boolean},\n}): {tree: TraceEntryTree, entryToNode: Map<Types.Events.Event, TraceEntryNode>} {\n  // As we construct the tree, store a map of each entry to its node. This\n  // means if you are iterating over a list of RendererEntry events you can\n  // easily look up that node in the tree.\n  const entryToNode = new Map<Types.Events.Event, TraceEntryNode>();\n\n  const stack = [];\n  // Reset the node id counter for every new renderer.\n  nodeIdCount = -1;\n  const tree = makeEmptyTraceEntryTree();\n\n  for (let i = 0; i < entries.length; i++) {\n    const event = entries[i];\n    // If the current event should not be part of the tree, then simply proceed\n    // with the next event.\n    if (options && !options.filter.has(event.name as Types.Events.Name)) {\n      continue;\n    }\n\n    const duration = event.dur || 0;\n    const nodeId = makeTraceEntryNodeId();\n    const node = makeEmptyTraceEntryNode(event, nodeId);\n\n    // If the parent stack is empty, then the current event is a root. Create a\n    // node for it, mark it as a root, then proceed with the next event.\n    if (stack.length === 0) {\n      tree.roots.add(node);\n      node.selfTime = Types.Timing.Micro(duration);\n      stack.push(node);\n      tree.maxDepth = Math.max(tree.maxDepth, stack.length);\n      entryToNode.set(event, node);\n      continue;\n    }\n\n    const parentNode = stack.at(-1);\n    if (parentNode === undefined) {\n      throw new Error('Impossible: no parent node found in the stack');\n    }\n\n    const parentEvent = parentNode.entry;\n\n    const begin = event.ts;\n    const parentBegin = parentEvent.ts;\n    const parentDuration = parentEvent.dur || 0;\n    const end = begin + duration;\n    const parentEnd = parentBegin + parentDuration;\n    // Check the relationship between the parent event at the top of the stack,\n    // and the current event being processed. There are only 4 distinct\n    // possibilities, only 2 of them actually valid, given the assumed sorting:\n    // 1. Current event starts before the parent event, ends whenever. (invalid)\n    // 2. Current event starts after the parent event, ends whenever. (valid)\n    // 3. Current event starts during the parent event, ends after. (invalid)\n    // 4. Current event starts and ends during the parent event. (valid)\n\n    // 1. If the current event starts before the parent event, then the data is\n    //    not sorted properly, messed up some way, or this logic is incomplete.\n    const startsBeforeParent = begin < parentBegin;\n    if (startsBeforeParent) {\n      throw new Error('Impossible: current event starts before the parent event');\n    }\n\n    // 2. If the current event starts after the parent event, then it's a new\n    //    parent. Pop, then handle current event again.\n    const startsAfterParent = begin >= parentEnd;\n    if (startsAfterParent) {\n      stack.pop();\n      i--;\n      // The last created node has been discarded, so discard this id.\n      nodeIdCount--;\n      continue;\n    }\n    // 3. If the current event starts during the parent event, but ends\n    //    after it, then the data is messed up some way, for example a\n    //    profile call was sampled too late after its start, ignore the\n    //    problematic event.\n    const endsAfterParent = end > parentEnd;\n    if (endsAfterParent) {\n      continue;\n    }\n\n    // 4. The only remaining case is the common case, where the current event is\n    //    contained within the parent event. Create a node for the current\n    //    event, establish the parent/child relationship, then proceed with the\n    //    next event.\n    node.depth = stack.length;\n    node.parent = parentNode;\n    parentNode.children.push(node);\n    node.selfTime = Types.Timing.Micro(duration);\n    if (parentNode.selfTime !== undefined) {\n      parentNode.selfTime = Types.Timing.Micro(parentNode.selfTime - (event.dur || 0));\n    }\n    stack.push(node);\n    tree.maxDepth = Math.max(tree.maxDepth, stack.length);\n    entryToNode.set(event, node);\n  }\n  return {tree, entryToNode};\n}\n\n/**\n * Iterates events in a tree hierarchically, from top to bottom,\n * calling back on every event's start and end in the order\n * as it traverses down and then up the tree.\n *\n * For example, given this tree, the following callbacks\n * are expected to be made in the following order\n * |---------------A---------------|\n *  |------B------||-------D------|\n *    |---C---|\n *\n * 1. Start A\n * 3. Start B\n * 4. Start C\n * 5. End C\n * 6. End B\n * 7. Start D\n * 8. End D\n * 9. End A\n *\n */\nexport function walkTreeFromEntry(\n    entryToNode: Map<Types.Events.Event, TraceEntryNode>,\n    rootEntry: Types.Events.Event,\n    onEntryStart: (entry: Types.Events.Event) => void,\n    onEntryEnd: (entry: Types.Events.Event) => void,\n    ): void {\n  const startNode = entryToNode.get(rootEntry);\n  if (!startNode) {\n    return;\n  }\n  walkTreeByNode(entryToNode, startNode, onEntryStart, onEntryEnd);\n}\n\n/**\n * Given a Helpers.TreeHelpers.RendererTree, this will iterates events in hierarchically, visiting\n * each root node and working from top to bottom, calling back on every event's\n * start and end in the order as it traverses down and then up the tree.\n *\n * For example, given this tree, the following callbacks\n * are expected to be made in the following order\n * |------------- Task A -------------||-- Task E --|\n *  |-- Task B --||-- Task D --|\n *   |- Task C -|\n *\n * 1. Start A\n * 3. Start B\n * 4. Start C\n * 5. End C\n * 6. End B\n * 7. Start D\n * 8. End D\n * 9. End A\n * 10. Start E\n * 11. End E\n *\n */\n\nexport function walkEntireTree(\n    entryToNode: Map<Types.Events.Event, TraceEntryNode>,\n    tree: TraceEntryTree,\n    onEntryStart: (entry: Types.Events.Event) => void,\n    onEntryEnd: (entry: Types.Events.Event) => void,\n    traceWindowToInclude?: Types.Timing.TraceWindowMicro,\n    minDuration?: Types.Timing.Micro,\n    ): void {\n  for (const rootNode of tree.roots) {\n    walkTreeByNode(entryToNode, rootNode, onEntryStart, onEntryEnd, traceWindowToInclude, minDuration);\n  }\n}\n\nfunction walkTreeByNode(\n    entryToNode: Map<Types.Events.Event, TraceEntryNode>,\n    rootNode: TraceEntryNode,\n    onEntryStart: (entry: Types.Events.Event) => void,\n    onEntryEnd: (entry: Types.Events.Event) => void,\n    traceWindowToInclude?: Types.Timing.TraceWindowMicro,\n    minDuration?: Types.Timing.Micro,\n    ): void {\n  if (traceWindowToInclude && !treeNodeIsInWindow(rootNode, traceWindowToInclude)) {\n    // If this node is not within the provided window, we can skip it. We also\n    // can skip all its children too, as we know they won't be in the window if\n    // their parent is not.\n    return;\n  }\n\n  if (typeof minDuration !== 'undefined') {\n    const duration = Types.Timing.Micro(\n        rootNode.entry.ts + Types.Timing.Micro(rootNode.entry.dur ?? 0),\n    );\n    if (duration < minDuration) {\n      return;\n    }\n  }\n\n  onEntryStart(rootNode.entry);\n  for (const child of rootNode.children) {\n    walkTreeByNode(entryToNode, child, onEntryStart, onEntryEnd, traceWindowToInclude, minDuration);\n  }\n  onEntryEnd(rootNode.entry);\n}\n\n/**\n * Returns true if the provided node is partially or fully within the trace\n * window. The entire node does not have to fit inside the window, but it does\n * have to partially intersect it.\n */\nfunction treeNodeIsInWindow(node: TraceEntryNode, traceWindow: Types.Timing.TraceWindowMicro): boolean {\n  return eventIsInBounds(node.entry, traceWindow);\n}\n\n/**\n * Determines if the given events, which are assumed to be ordered can\n * be organized into tree structures.\n * This condition is met if there is *not* a pair of async events\n * e1 and e2 where:\n *\n * e1.startTime < e2.startTime && e1.endTime > e2.startTime && e1.endTime < e2.endTime.\n * or, graphically:\n * |------- e1 ------|\n *   |------- e2 --------|\n *\n * Because a parent-child relationship cannot be made from the example\n * above, a tree cannot be made from the set of events.\n *\n * Sync events from the same thread are tree-able by definition.\n *\n * Note that this will also return true if multiple trees can be\n * built, for example if none of the events overlap with each other.\n */\nexport function canBuildTreesFromEvents(events: readonly Types.Events.Event[]): boolean {\n  const stack: Types.Events.Event[] = [];\n  for (const event of events) {\n    const startTime = event.ts;\n    const endTime = event.ts + (event.dur ?? 0);\n    let parent = stack.at(-1);\n    if (parent === undefined) {\n      stack.push(event);\n      continue;\n    }\n    let parentEndTime = parent.ts + (parent.dur ?? 0);\n    // Discard events that are not parents for this event. The parent\n    // is one whose end time is after this event start time.\n    while (stack.length && startTime >= parentEndTime) {\n      stack.pop();\n      parent = stack.at(-1);\n\n      if (parent === undefined) {\n        break;\n      }\n      parentEndTime = parent.ts + (parent.dur ?? 0);\n    }\n    if (stack.length && endTime > parentEndTime) {\n      // If such an event exists but its end time is before this\n      // event's end time, then a tree cannot be made using this\n      // events.\n      return false;\n    }\n    stack.push(event);\n  }\n  return true;\n}\n", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Protocol from '../../../generated/protocol.js';\nimport type {RenderBlocking, SyntheticNetworkRequest} from '../types/TraceEvents.js';\n\n// Important: we purposefully treat `potentially_blocking` as\n// non-render-blocking here because:\n// 1. An async script can run on the main thread at any point, including before\n//    the page is loaded\n// 2. An async script will never block the parsing and rendering process of the\n//    browser.\n// 3. Therefore, from a developer's point of view, there is nothing more they\n//    can do if they've put `async` on, and within the context of Insights, we\n//    shouldn't report an async script as render blocking.\n// In the future we may want to consider suggesting the use of `defer` over\n// `async`, as it doesn't have this concern, but for now we'll allow `async`\n// and not report it as an issue.\nconst NON_RENDER_BLOCKING_VALUES = new Set<RenderBlocking>([\n  'non_blocking',\n  'dynamically_injected_non_blocking',\n  'potentially_blocking',\n]);\n\nexport function isSyntheticNetworkRequestEventRenderBlocking(event: SyntheticNetworkRequest): boolean {\n  return !NON_RENDER_BLOCKING_VALUES.has(event.args.data.renderBlocking);\n}\n\nconst HIGH_NETWORK_PRIORITIES = new Set<Protocol.Network.ResourcePriority>([\n  Protocol.Network.ResourcePriority.VeryHigh,\n  Protocol.Network.ResourcePriority.High,\n  Protocol.Network.ResourcePriority.Medium,\n]);\n\nexport function isSyntheticNetworkRequestHighPriority(event: SyntheticNetworkRequest): boolean {\n  return HIGH_NETWORK_PRIORITIES.has(event.args.data.priority);\n}\n\nexport interface CacheControl {\n  'max-age'?: number;\n  'no-cache'?: boolean;\n  'no-store'?: boolean;\n  'must-revalidate'?: boolean;\n  // eslint-disable-next-line @stylistic/quote-props\n  'private'?: boolean;\n}\n\nexport const CACHEABLE_STATUS_CODES = new Set([200, 203, 206]);\n\n/** @type {Set<LH.Crdp.Network.ResourceType>} */\nexport const STATIC_RESOURCE_TYPES = new Set([\n  Protocol.Network.ResourceType.Font,\n  Protocol.Network.ResourceType.Image,\n  Protocol.Network.ResourceType.Media,\n  Protocol.Network.ResourceType.Script,\n  Protocol.Network.ResourceType.Stylesheet,\n]);\n\nexport const NON_NETWORK_SCHEMES = [\n  'blob',        // @see https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL\n  'data',        // @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\n  'intent',      // @see https://developer.chrome.com/docs/multidevice/android/intents/\n  'file',        // @see https://en.wikipedia.org/wiki/File_URI_scheme\n  'filesystem',  // @see https://developer.mozilla.org/en-US/docs/Web/API/FileSystem\n  'chrome-extension',\n];\n\n/**\n * Parses Cache-Control directives based on https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control\n * eg. 'no-cache, no-store, max-age=0, no-transform, private' will return\n * {no-cache: true, no-store: true, max-age: 0, no-transform: true, private: true}\n */\nexport function parseCacheControl(header: string|null): CacheControl|null {\n  if (!header) {\n    return null;\n  }\n\n  const directives = header.split(',').map(directive => directive.trim());\n  const cacheControlOptions: CacheControl = {};\n\n  for (const directive of directives) {\n    const [key, value] = directive.split('=').map(part => part.trim());\n\n    switch (key) {\n      case 'max-age': {\n        const maxAge = parseInt(value, 10);\n        if (!isNaN(maxAge)) {\n          cacheControlOptions['max-age'] = maxAge;\n        }\n        break;\n      }\n      case 'no-cache':\n        cacheControlOptions['no-cache'] = true;\n        break;\n      case 'no-store':\n        cacheControlOptions['no-store'] = true;\n        break;\n      case 'must-revalidate':\n        cacheControlOptions['must-revalidate'] = true;\n        break;\n      case 'private':\n        cacheControlOptions['private'] = true;\n        break;\n      default:\n        // Ignore unknown directives\n        break;\n    }\n  }\n\n  return cacheControlOptions;\n}\n\nconst SECURE_LOCALHOST_DOMAINS = ['localhost', '127.0.0.1'];\n\n/**\n * Is the host localhost-enough to satisfy the \"secure context\" definition\n * https://github.com/GoogleChrome/lighthouse/pull/11766#discussion_r582340683\n */\nexport function isSyntheticNetworkRequestLocalhost(event: SyntheticNetworkRequest): boolean {\n  try {\n    const hostname = new URL(event.args.data.url).hostname;\n    // Any hostname terminating in `.localhost` is considered to be local.\n    // https://w3c.github.io/webappsec-secure-contexts/#localhost\n    // This method doesn't consider IPs that resolve to loopback, IPv6 or other loopback edgecases\n    return SECURE_LOCALHOST_DOMAINS.includes(hostname) || hostname.endsWith('.localhost');\n  } catch {\n    return false;\n  }\n}\n", "// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Protocol from '../../../generated/protocol.js';\nimport type * as CPUProfile from '../../cpu_profile/cpu_profile.js';\nimport * as Types from '../types/types.js';\n\nimport {milliToMicro} from './Timing.js';\nimport {extractSampleTraceId, makeProfileCall, mergeEventsInOrder, sortTraceEventsInPlace} from './Trace.js';\n\n/**\n * This is a helper that integrates CPU profiling data coming in the\n * shape of samples, with trace events. Samples indicate what the JS\n * stack trace looked at a given point in time, but they don't have\n * duration. The SamplesIntegrator task is to make an approximation\n * of what the duration of each JS call was, given the sample data and\n * given the trace events profiled during that time. At the end of its\n * execution, the SamplesIntegrator returns an array of ProfileCalls\n * (under SamplesIntegrator::buildProfileCalls()), which\n * represent JS calls, with a call frame and duration. These calls have\n * the shape of a complete trace events and can be treated as flame\n * chart entries in the timeline.\n *\n * The approach to build the profile calls consists in tracking the\n * current stack as the following events happen (in order):\n * 1. A sample was done.\n * 2. A trace event started.\n * 3. A trace event ended.\n * Depending on the event and on the data that's coming with it the\n * stack is updated by adding or removing JS calls to it and updating\n * the duration of the calls in the tracking stack.\n *\n * note: Although this approach has been implemented since long ago, and\n * is relatively efficient (adds a complexity over the trace parsing of\n * O(n) where n is the number of samples) it has proven to be faulty.\n * It might be worthwhile experimenting with improvements or with a\n * completely different approach. Improving the approach is tracked in\n * crbug.com/1417439\n */\nexport class SamplesIntegrator {\n  /**\n   * The result of running the samples integrator. Holds the JS calls\n   * with their approximated duration after integrating samples into the\n   * trace event tree.\n   */\n  #constructedProfileCalls: Types.Events.SyntheticProfileCall[] = [];\n  /**\n   * tracks the state of the JS stack at each point in time to update\n   * the profile call durations as new events arrive. This doesn't only\n   * happen with new profile calls (in which case we would compare the\n   * stack in them) but also with trace events (in which case we would\n   * update the duration of the events we are tracking at the moment).\n   */\n  #currentJSStack: Types.Events.SyntheticProfileCall[] = [];\n  /**\n   * Process holding the CPU profile and trace events.\n   */\n  #processId: Types.Events.ProcessID;\n  /**\n   * Thread holding the CPU profile and trace events.\n   */\n  #threadId: Types.Events.ThreadID;\n  /**\n   * Tracks the depth of the JS stack at the moment a trace event starts\n   * or ends. It is assumed that for the duration of a trace event, the\n   * JS stack's depth cannot decrease, since JS calls that started\n   * before a trace event cannot end during the trace event. So as trace\n   * events arrive, we store the \"locked\" amount of JS frames that were\n   * in the stack before the event came.\n   */\n  #lockedJsStackDepth: number[] = [];\n  /**\n   * Used to keep track when samples should be integrated even if they\n   * are not children of invocation trace events. This is useful in\n   * cases where we can be missing the start of JS invocation events if\n   * we start tracing half-way through.\n   */\n  #fakeJSInvocation = false;\n  /**\n   * The parsed CPU profile, holding the tree hierarchy of JS frames and\n   * the sample data.\n   */\n  #profileModel: CPUProfile.CPUProfileDataModel.CPUProfileDataModel;\n  /**\n   * Because GC nodes don't have a stack, we artificially add a stack to\n   * them which corresponds to that of the previous sample. This map\n   * tracks which node is used for the stack of a GC call.\n   * Note that GC samples are not shown in the flamechart, however they\n   * are used during the construction of for profile calls, as we can\n   * infer information about the duration of the executed code when a\n   * GC node is sampled.\n   */\n  #nodeForGC = new Map<Types.Events.SyntheticProfileCall, CPUProfile.ProfileTreeModel.ProfileNode>();\n\n  #engineConfig: Types.Configuration.Configuration;\n  #profileId: Types.Events.ProfileID;\n\n  /**\n   * Keeps track of the individual samples from the CPU Profile.\n   * Only used with Debug Mode experiment enabled.\n   */\n  jsSampleEvents: Types.Events.SyntheticJSSample[] = [];\n\n  constructor(\n      profileModel: CPUProfile.CPUProfileDataModel.CPUProfileDataModel, profileId: Types.Events.ProfileID,\n      pid: Types.Events.ProcessID, tid: Types.Events.ThreadID, configuration?: Types.Configuration.Configuration) {\n    this.#profileModel = profileModel;\n    this.#threadId = tid;\n    this.#processId = pid;\n    this.#engineConfig = configuration || Types.Configuration.defaults();\n    this.#profileId = profileId;\n  }\n\n  buildProfileCalls(traceEvents: Types.Events.Event[]): Types.Events.SyntheticProfileCall[] {\n    const mergedEvents = mergeEventsInOrder(traceEvents, this.callsFromProfileSamples());\n    const stack = [];\n    for (let i = 0; i < mergedEvents.length; i++) {\n      const event = mergedEvents[i];\n      // Because instant trace events have no duration, they don't provide\n      // useful information for possible changes in the duration of calls\n      // in the JS stack.\n      if (event.ph === Types.Events.Phase.INSTANT && !extractSampleTraceId(event)) {\n        continue;\n      }\n      if (stack.length === 0) {\n        if (Types.Events.isProfileCall(event)) {\n          this.#onProfileCall(event);\n          continue;\n        }\n        stack.push(event);\n        this.#onTraceEventStart(event);\n        continue;\n      }\n\n      const parentEvent = stack.at(-1);\n      if (parentEvent === undefined) {\n        continue;\n      }\n      const begin = event.ts;\n      const parentBegin = parentEvent.ts;\n      const parentDuration = parentEvent.dur || 0;\n      const parentEnd = parentBegin + parentDuration;\n\n      const startsAfterParent = begin >= parentEnd;\n      if (startsAfterParent) {\n        this.#onTraceEventEnd(parentEvent);\n        stack.pop();\n        i--;\n        continue;\n      }\n      if (Types.Events.isProfileCall(event)) {\n        this.#onProfileCall(event, parentEvent);\n        continue;\n      }\n      this.#onTraceEventStart(event);\n      stack.push(event);\n    }\n    while (stack.length) {\n      const last = stack.pop();\n      if (last) {\n        this.#onTraceEventEnd(last);\n      }\n    }\n    sortTraceEventsInPlace(this.jsSampleEvents);\n    return this.#constructedProfileCalls;\n  }\n\n  #onTraceEventStart(event: Types.Events.Event): void {\n    // Top level events cannot be nested into JS frames so we reset\n    // the stack when we find one.\n    if (event.name === Types.Events.Name.RUN_MICROTASKS || event.name === Types.Events.Name.RUN_TASK) {\n      this.#lockedJsStackDepth = [];\n      this.#truncateJSStack(0, event.ts);\n      this.#fakeJSInvocation = false;\n    }\n\n    if (this.#fakeJSInvocation) {\n      this.#truncateJSStack(this.#lockedJsStackDepth.pop() || 0, event.ts);\n      this.#fakeJSInvocation = false;\n    }\n    this.#extractStackTrace(event);\n    // Keep track of the call frames in the stack before the event\n    // happened. For the duration of this event, these frames cannot\n    // change (none can be terminated before this event finishes).\n    //\n    // Also, every frame that is opened after this event, is considered\n    // to be a descendant of the event. So once the event finishes, the\n    // frames that were opened after it, need to be closed (see\n    // onEndEvent).\n    //\n    // TODO(crbug.com/1417439):\n    // The assumption that every frame opened after an event is a\n    // descendant of the event is incorrect. For example, a JS call that\n    // parents a trace event might have been sampled after the event was\n    // dispatched. In this case the JS call would be discarded if this\n    // event isn't an invocation event, otherwise the call will be\n    // considered a child of the event. In both cases, the result would\n    // be incorrect.\n    this.#lockedJsStackDepth.push(this.#currentJSStack.length);\n  }\n\n  #onProfileCall(event: Types.Events.SyntheticProfileCall, parent?: Types.Events.Event): void {\n    if ((parent && Types.Events.isJSInvocationEvent(parent)) || this.#fakeJSInvocation) {\n      this.#extractStackTrace(event);\n    } else if (Types.Events.isProfileCall(event) && this.#currentJSStack.length === 0) {\n      // Force JS Samples to show up even if we are not inside a JS\n      // invocation event, because we can be missing the start of JS\n      // invocation events if we start tracing half-way through. Pretend\n      // we have a top-level JS invocation event.\n      this.#fakeJSInvocation = true;\n      const stackDepthBefore = this.#currentJSStack.length;\n      this.#extractStackTrace(event);\n      this.#lockedJsStackDepth.push(stackDepthBefore);\n    }\n  }\n\n  #onTraceEventEnd(event: Types.Events.Event): void {\n    // Because the event has ended, any frames that happened after\n    // this event are terminated. Frames that are ancestors to this\n    // event are extended to cover its ending.\n    const endTime = Types.Timing.Micro(event.ts + (event.dur ?? 0));\n    this.#truncateJSStack(this.#lockedJsStackDepth.pop() || 0, endTime);\n  }\n\n  /**\n   * Builds the initial calls with no duration from samples. Their\n   * purpose is to be merged with the trace event array being parsed so\n   * that they can be traversed in order with them and their duration\n   * can be updated as the SampleIntegrator callbacks are invoked.\n   */\n  callsFromProfileSamples(): Types.Events.SyntheticProfileCall[] {\n    const samples = this.#profileModel.samples;\n    const timestamps = this.#profileModel.timestamps;\n    if (!samples) {\n      return [];\n    }\n    const calls: Types.Events.SyntheticProfileCall[] = [];\n    let prevNode;\n    for (let i = 0; i < samples.length; i++) {\n      const node = this.#profileModel.nodeByIndex(i);\n      const timestamp = milliToMicro(Types.Timing.Milli(timestamps[i]));\n      if (!node) {\n        continue;\n      }\n      const call = makeProfileCall(node, this.#profileId, i, timestamp, this.#processId, this.#threadId);\n      calls.push(call);\n\n      if (this.#engineConfig.debugMode) {\n        const traceId = this.#profileModel.traceIds?.[i];\n        this.jsSampleEvents.push(this.#makeJSSampleEvent(call, timestamp, traceId));\n      }\n      if (node.id === this.#profileModel.gcNode?.id && prevNode) {\n        // GC samples have no stack, so we just put GC node on top of the\n        // last recorded sample. Cache the previous sample for future\n        // reference.\n        this.#nodeForGC.set(call, prevNode);\n        continue;\n      }\n      prevNode = node;\n    }\n    return calls;\n  }\n\n  /**\n   * Given a synthetic profile call, returns an array of profile calls\n   * representing the stack trace that profile call belongs to based on\n   * its nodeId. The input profile call will be at the top of the\n   * returned stack (last position), meaning that any other frames that\n   * were effectively above it are omitted.\n   * @param profileCall\n   * @param overrideTimeStamp a custom timestamp to use for the returned\n   * profile calls. If not defined, the timestamp of the input\n   * profileCall is used instead. This param is useful for example when\n   * creating the profile calls for a sample with a trace id, since the\n   * timestamp of the corresponding trace event should be used instead\n   * of the sample's.\n   */\n\n  #makeProfileCallsForStack(profileCall: Types.Events.SyntheticProfileCall, overrideTimeStamp?: Types.Timing.Micro):\n      Types.Events.SyntheticProfileCall[] {\n    let node = this.#profileModel.nodeById(profileCall.nodeId);\n    const isGarbageCollection = node?.id === this.#profileModel.gcNode?.id;\n    if (isGarbageCollection) {\n      // Because GC don't have a stack, we use the stack of the previous\n      // sample.\n      node = this.#nodeForGC.get(profileCall) || null;\n    }\n    if (!node) {\n      return [];\n    }\n    // `node.depth` is 0 based, so to set the size of the array we need\n    // to add 1 to its value.\n    const callFrames = new Array<Types.Events.SyntheticProfileCall>(node.depth + 1 + Number(isGarbageCollection));\n    // Add the stack trace in reverse order (bottom first).\n    let i = callFrames.length - 1;\n    if (isGarbageCollection) {\n      // Place the garbage collection call frame on top of the stack.\n      callFrames[i--] = profileCall;\n    }\n\n    // Many of these ProfileCalls will be GC'd later when we estimate the frame\n    // durations\n    while (node) {\n      callFrames[i--] = makeProfileCall(\n          node, profileCall.profileId, profileCall.sampleIndex, overrideTimeStamp ?? profileCall.ts, this.#processId,\n          this.#threadId);\n      node = node.parent;\n    }\n    return callFrames;\n  }\n\n  #getStackForSampleTraceId(traceId: number, timestamp: Types.Timing.Micro): Types.Events.SyntheticProfileCall[]|null {\n    const nodeId = this.#profileModel.traceIds?.[traceId];\n    const node = nodeId && this.#profileModel.nodeById(nodeId);\n    const maybeCallForTraceId =\n        node && makeProfileCall(node, this.#profileId, -1, timestamp, this.#processId, this.#threadId);\n    if (!maybeCallForTraceId) {\n      return null;\n    }\n    if (this.#engineConfig.debugMode) {\n      this.jsSampleEvents.push(this.#makeJSSampleEvent(maybeCallForTraceId, timestamp, traceId));\n    }\n    return this.#makeProfileCallsForStack(maybeCallForTraceId);\n  }\n  /**\n   * Update tracked stack using this event's call stack.\n   */\n  #extractStackTrace(event: Types.Events.Event): void {\n    let stackTrace = this.#currentJSStack;\n    if (Types.Events.isProfileCall(event)) {\n      stackTrace = this.#makeProfileCallsForStack(event);\n    }\n    const traceId = extractSampleTraceId(event);\n    const maybeCallForTraceId = traceId && this.#getStackForSampleTraceId(traceId, event.ts);\n    if (maybeCallForTraceId) {\n      stackTrace = maybeCallForTraceId;\n    }\n\n    SamplesIntegrator.filterStackFrames(stackTrace, this.#engineConfig);\n\n    const endTime = event.ts + (event.dur || 0);\n    const minFrames = Math.min(stackTrace.length, this.#currentJSStack.length);\n    let i;\n    // Merge a sample's stack frames with the stack frames we have\n    // so far if we detect they are equivalent.\n    // Graphically\n    // This:\n    // Current stack trace       Sample\n    // [-------A------]          [A]\n    // [-------B------]          [B]\n    // [-------C------]          [C]\n    //                ^ t = x1    ^ t = x2\n\n    // Becomes this:\n    // New stack trace after merge\n    // [--------A-------]\n    // [--------B-------]\n    // [--------C-------]\n    //                  ^ t = x2\n    for (i = this.#lockedJsStackDepth.at(-1) || 0; i < minFrames; ++i) {\n      const newFrame = stackTrace[i].callFrame;\n      const oldFrame = this.#currentJSStack[i].callFrame;\n      if (!SamplesIntegrator.framesAreEqual(newFrame, oldFrame)) {\n        break;\n      }\n      // Scoot the right edge of this callFrame to the right\n      this.#currentJSStack[i].dur =\n          Types.Timing.Micro(Math.max(this.#currentJSStack[i].dur || 0, endTime - this.#currentJSStack[i].ts));\n    }\n\n    // If there are call frames in the sample that differ with the stack\n    // we have, update the stack, but keeping the common frames in place\n    // Graphically\n    // This:\n    // Current stack trace       Sample\n    // [-------A------]          [A]\n    // [-------B------]          [B]\n    // [-------C------]          [C]\n    // [-------D------]          [E]\n    //                ^ t = x1    ^ t = x2\n    // Becomes this:\n    // New stack trace after merge\n    // [--------A-------]\n    // [--------B-------]\n    // [--------C-------]\n    //                [E]\n    //                  ^ t = x2\n    this.#truncateJSStack(i, event.ts);\n\n    for (; i < stackTrace.length; ++i) {\n      const call = stackTrace[i];\n      if (call.nodeId === this.#profileModel.programNode?.id || call.nodeId === this.#profileModel.root?.id ||\n          call.nodeId === this.#profileModel.idleNode?.id || call.nodeId === this.#profileModel.gcNode?.id) {\n        // Skip (root), (program) and (idle) frames, since this are not\n        // relevant for web profiling and we don't want to show them in\n        // the timeline.\n        continue;\n      }\n      this.#currentJSStack.push(call);\n      this.#constructedProfileCalls.push(call);\n    }\n  }\n\n  /**\n   * When a call stack that differs from the one we are tracking has\n   * been detected in the samples, the latter is \"truncated\" by\n   * setting the ending time of its call frames and removing the top\n   * call frames that aren't shared with the new call stack. This way,\n   * we can update the tracked stack with the new call frames on top.\n   * @param depth the amount of call frames from bottom to top that\n   * should be kept in the tracking stack trace. AKA amount of shared\n   * call frames between two stacks.\n   * @param time the new end of the call frames in the stack.\n   */\n  #truncateJSStack(depth: number, time: Types.Timing.Micro): void {\n    if (this.#lockedJsStackDepth.length) {\n      const lockedDepth = this.#lockedJsStackDepth.at(-1);\n      if (lockedDepth && depth < lockedDepth) {\n        console.error(`Child stack is shallower (${depth}) than the parent stack (${lockedDepth}) at ${time}`);\n        depth = lockedDepth;\n      }\n    }\n    if (this.#currentJSStack.length < depth) {\n      console.error(`Trying to truncate higher than the current stack size at ${time}`);\n      depth = this.#currentJSStack.length;\n    }\n    for (let k = 0; k < this.#currentJSStack.length; ++k) {\n      this.#currentJSStack[k].dur = Types.Timing.Micro(Math.max(time - this.#currentJSStack[k].ts, 0));\n    }\n    this.#currentJSStack.length = depth;\n  }\n\n  #makeJSSampleEvent(call: Types.Events.SyntheticProfileCall, timestamp: Types.Timing.Micro, traceId?: number):\n      Types.Events.SyntheticJSSample {\n    const JSSampleEvent: Types.Events.SyntheticJSSample = {\n      name: Types.Events.Name.JS_SAMPLE,\n      cat: 'devtools.timeline',\n      args: {\n        data: {traceId, stackTrace: this.#makeProfileCallsForStack(call).map(e => e.callFrame)},\n      },\n      ph: Types.Events.Phase.INSTANT,\n      ts: timestamp,\n      dur: Types.Timing.Micro(0),\n      pid: this.#processId,\n      tid: this.#threadId,\n    };\n    return JSSampleEvent;\n  }\n\n  static framesAreEqual(frame1: Protocol.Runtime.CallFrame, frame2: Protocol.Runtime.CallFrame): boolean {\n    return frame1.scriptId === frame2.scriptId && frame1.functionName === frame2.functionName &&\n        frame1.lineNumber === frame2.lineNumber;\n  }\n\n  static showNativeName(name: string, runtimeCallStatsEnabled: boolean): boolean {\n    return runtimeCallStatsEnabled && Boolean(SamplesIntegrator.nativeGroup(name));\n  }\n\n  static nativeGroup(nativeName: string): SamplesIntegrator.NativeGroups|null {\n    if (nativeName.startsWith('Parse')) {\n      return SamplesIntegrator.NativeGroups.PARSE;\n    }\n    if (nativeName.startsWith('Compile') || nativeName.startsWith('Recompile')) {\n      return SamplesIntegrator.NativeGroups.COMPILE;\n    }\n    return null;\n  }\n\n  static isNativeRuntimeFrame(frame: Protocol.Runtime.CallFrame): boolean {\n    return frame.url === 'native V8Runtime';\n  }\n\n  static filterStackFrames(stack: Types.Events.SyntheticProfileCall[], engineConfig: Types.Configuration.Configuration):\n      void {\n    const showAllEvents = engineConfig.showAllEvents;\n    if (showAllEvents) {\n      return;\n    }\n    let previousNativeFrameName: string|null = null;\n    let j = 0;\n    for (let i = 0; i < stack.length; ++i) {\n      const frame = stack[i].callFrame;\n      const nativeRuntimeFrame = SamplesIntegrator.isNativeRuntimeFrame(frame);\n      if (nativeRuntimeFrame &&\n          !SamplesIntegrator.showNativeName(frame.functionName, engineConfig.includeRuntimeCallStats)) {\n        continue;\n      }\n      const nativeFrameName = nativeRuntimeFrame ? SamplesIntegrator.nativeGroup(frame.functionName) : null;\n      if (previousNativeFrameName && previousNativeFrameName === nativeFrameName) {\n        continue;\n      }\n      previousNativeFrameName = nativeFrameName;\n      stack[j++] = stack[i];\n    }\n    stack.length = j;\n  }\n\n  static createFakeTraceFromCpuProfile(profile: Protocol.Profiler.Profile, tid: Types.Events.ThreadID):\n      Types.File.TraceFile {\n    if (!profile) {\n      return {traceEvents: [], metadata: {}};\n    }\n    // The |Name.CPU_PROFILE| will let MetaHandler to set |traceIsGeneric| to false\n    // The start time and duration is important here because we'll use them to determine the traceBounds\n    // We use the start and end time of the profile (which is longer than all samples), so the Performance\n    // panel won't truncate this time period.\n    const cpuProfileEvent: Types.Events.SyntheticCpuProfile = {\n      cat: 'disabled-by-default-devtools.timeline',\n      name: Types.Events.Name.CPU_PROFILE,\n      ph: Types.Events.Phase.COMPLETE,\n      pid: Types.Events.ProcessID(1),\n      tid,\n      ts: Types.Timing.Micro(profile.startTime),\n      dur: Types.Timing.Micro(profile.endTime - profile.startTime),\n      args: {data: {cpuProfile: profile}},\n      // Create an arbitrary profile id.\n      id: '0x1' as Types.Events.ProfileID,\n    };\n\n    return {\n      traceEvents: [cpuProfileEvent],\n      metadata: {\n        dataOrigin: Types.File.DataOrigin.CPU_PROFILE,\n      }\n    };\n  }\n\n  static extractCpuProfileFromFakeTrace(traceEvents: readonly Types.Events.Event[]): Protocol.Profiler.Profile {\n    const profileEvent = traceEvents.find(e => Types.Events.isSyntheticCpuProfile(e));\n    const profile = profileEvent?.args.data.cpuProfile;\n    if (!profile) {\n      throw new Error('Missing cpuProfile data');\n    }\n    return profile;\n  }\n}\n\nexport namespace SamplesIntegrator {\n  export const enum NativeGroups {\n    COMPILE = 'Compile',\n    PARSE = 'Parse',\n  }\n}\n"],
  "mappings": "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",
  "names": ["Platform", "Platform", "Types", "event", "time", "Types", "Types"]
}
