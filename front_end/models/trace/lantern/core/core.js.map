{
  "version": 3,
  "sources": ["../../../../../../../../front_end/models/trace/lantern/core/LanternError.ts", "../../../../../../../../front_end/models/trace/lantern/core/NetworkAnalyzer.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nclass LanternError extends Error {}\n\nexport {LanternError};\n", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Lantern from '../types/types.js';\n\nimport {LanternError} from './LanternError.js';\n\nclass UrlUtils {\n  /**\n   * There is fancy URL rewriting logic for the chrome://settings page that we need to work around.\n   * Why? Special handling was added by Chrome team to allow a pushState transition between chrome:// pages.\n   * As a result, the network URL (chrome://chrome/settings/) doesn't match the final document URL (chrome://settings/).\n   */\n  static rewriteChromeInternalUrl(url: string): string {\n    if (!url?.startsWith('chrome://')) {\n      return url;\n    }\n    // Chrome adds a trailing slash to `chrome://` URLs, but the spec does not.\n    //   https://github.com/GoogleChrome/lighthouse/pull/3941#discussion_r154026009\n    if (url.endsWith('/')) {\n      url = url.replace(/\\/$/, '');\n    }\n    return url.replace(/^chrome:\\/\\/chrome\\//, 'chrome://');\n  }\n\n  /**\n   * Determine if url1 equals url2, ignoring URL fragments.\n   */\n  static equalWithExcludedFragments(url1: string, url2: string): boolean {\n    [url1, url2] = [url1, url2].map(this.rewriteChromeInternalUrl);\n    try {\n      const urla = new URL(url1);\n      urla.hash = '';\n\n      const urlb = new URL(url2);\n      urlb.hash = '';\n\n      return urla.href === urlb.href;\n    } catch {\n      return false;\n    }\n  }\n}\n\ninterface Summary {\n  min: number;\n  max: number;\n  avg: number;\n  median: number;\n}\n\ninterface RTTEstimateOptions {\n  /**\n   * TCP connection handshake information will be used when available, but in\n   * some circumstances this data can be unreliable. This flag exposes an\n   * option to ignore the handshake data and use the coarse download/TTFB timing data.\n   */\n  forceCoarseEstimates?: boolean;\n  /**\n   * Coarse estimates include lots of extra time and noise multiply by some factor\n   * to deflate the estimates a bit.\n   */\n  coarseEstimateMultiplier?: number;\n  /** Useful for testing to isolate the different methods of estimation. */\n  useDownloadEstimates?: boolean;\n  /** Useful for testing to isolate the different methods of estimation. */\n  useSendStartEstimates?: boolean;\n  /** Useful for testing to isolate the different methods of estimation. */\n  useHeadersEndEstimates?: boolean;\n}\n\ninterface RequestInfo {\n  request: Lantern.NetworkRequest;\n  timing: Lantern.ResourceTiming;\n  connectionReused?: boolean;\n}\n\nconst INITIAL_CWD = 14 * 1024;\n\n// Assume that 40% of TTFB was server response time by default for static assets\nconst DEFAULT_SERVER_RESPONSE_PERCENTAGE = 0.4;\n\n/**\n * For certain resource types, server response time takes up a greater percentage of TTFB (dynamic\n * assets like HTML documents, XHR/API calls, etc)\n */\nconst SERVER_RESPONSE_PERCENTAGE_OF_TTFB: Partial<Record<Lantern.ResourceType, number>> = {\n  Document: 0.9,\n  XHR: 0.9,\n  Fetch: 0.9,\n};\n\nclass NetworkAnalyzer {\n  static get summary(): string {\n    return '__SUMMARY__';\n  }\n\n  static groupByOrigin(records: Lantern.NetworkRequest[]): Map<string, Lantern.NetworkRequest[]> {\n    const grouped = new Map();\n    records.forEach(item => {\n      const key = item.parsedURL.securityOrigin;\n      const group = grouped.get(key) || [];\n      group.push(item);\n      grouped.set(key, group);\n    });\n    return grouped;\n  }\n\n  static getSummary(values: number[]): Summary {\n    values.sort((a, b) => a - b);\n\n    let median;\n    if (values.length === 0) {\n      median = values[0];\n    } else if (values.length % 2 === 0) {\n      const a = values[Math.floor((values.length - 1) / 2)];\n      const b = values[Math.floor((values.length - 1) / 2) + 1];\n      median = (a + b) / 2;\n    } else {\n      median = values[Math.floor((values.length - 1) / 2)];\n    }\n\n    return {\n      min: values[0],\n      max: values[values.length - 1],\n      avg: values.reduce((a, b) => a + b, 0) / values.length,\n      median,\n    };\n  }\n\n  static summarize(values: Map<string, number[]>): Map<string, Summary> {\n    const summaryByKey = new Map();\n    const allEstimates = [];\n    for (const [key, estimates] of values) {\n      summaryByKey.set(key, NetworkAnalyzer.getSummary(estimates));\n      allEstimates.push(...estimates);\n    }\n\n    summaryByKey.set(NetworkAnalyzer.summary, NetworkAnalyzer.getSummary(allEstimates));\n    return summaryByKey;\n  }\n\n  static estimateValueByOrigin(\n      requests: Lantern.NetworkRequest[],\n      iteratee: (e: RequestInfo) => number | number[] | undefined): Map<string, number[]> {\n    const connectionWasReused = NetworkAnalyzer.estimateIfConnectionWasReused(requests);\n    const groupedByOrigin = NetworkAnalyzer.groupByOrigin(requests);\n\n    const estimates = new Map();\n    for (const [origin, originRequests] of groupedByOrigin.entries()) {\n      let originEstimates: number[] = [];\n\n      for (const request of originRequests) {\n        const timing = request.timing;\n        if (!timing) {\n          continue;\n        }\n\n        const value = iteratee({\n          request,\n          timing,\n          connectionReused: connectionWasReused.get(request.requestId),\n        });\n        if (typeof value !== 'undefined') {\n          originEstimates = originEstimates.concat(value);\n        }\n      }\n\n      if (!originEstimates.length) {\n        continue;\n      }\n      estimates.set(origin, originEstimates);\n    }\n\n    return estimates;\n  }\n\n  /**\n   * Estimates the observed RTT to each origin based on how long the connection setup.\n   * For h1 and h2, this could includes two estimates - one for the TCP handshake, another for\n   * SSL negotiation.\n   * For h3, we get only one estimate since QUIC establishes a secure connection in a\n   * single handshake.\n   * This is the most accurate and preferred method of measurement when the data is available.\n   */\n  static estimateRTTViaConnectionTiming(info: RequestInfo): number[]|number|undefined {\n    const {timing, connectionReused, request} = info;\n    if (connectionReused) {\n      return;\n    }\n\n    const {connectStart, sslStart, sslEnd, connectEnd} = timing;\n    if (connectEnd >= 0 && connectStart >= 0 && request.protocol.startsWith('h3')) {\n      // These values are equal to sslStart and sslEnd for h3.\n      return connectEnd - connectStart;\n    }\n    if (sslStart >= 0 && sslEnd >= 0 && sslStart !== connectStart) {\n      // SSL can also be more than 1 RT but assume False Start was used.\n      return [connectEnd - sslStart, sslStart - connectStart];\n    }\n    if (connectStart >= 0 && connectEnd >= 0) {\n      return connectEnd - connectStart;\n    }\n\n    return;\n  }\n\n  /**\n   * Estimates the observed RTT to each origin based on how long a download took on a fresh connection.\n   * NOTE: this will tend to overestimate the actual RTT quite significantly as the download can be\n   * slow for other reasons as well such as bandwidth constraints.\n   */\n  static estimateRTTViaDownloadTiming(info: RequestInfo): number|undefined {\n    const {timing, connectionReused, request} = info;\n    if (connectionReused) {\n      return;\n    }\n\n    // Only look at downloads that went past the initial congestion window\n    if (request.transferSize <= INITIAL_CWD) {\n      return;\n    }\n    if (!Number.isFinite(timing.receiveHeadersEnd) || timing.receiveHeadersEnd < 0) {\n      return;\n    }\n\n    // Compute the amount of time downloading everything after the first congestion window took\n    const totalTime = request.networkEndTime - request.networkRequestTime;\n    const downloadTimeAfterFirstByte = totalTime - timing.receiveHeadersEnd;\n    const numberOfRoundTrips = Math.log2(request.transferSize / INITIAL_CWD);\n\n    // Ignore requests that required a high number of round trips since bandwidth starts to play\n    // a larger role than latency\n    if (numberOfRoundTrips > 5) {\n      return;\n    }\n\n    return downloadTimeAfterFirstByte / numberOfRoundTrips;\n  }\n\n  /**\n   * Estimates the observed RTT to each origin based on how long it took until Chrome could\n   * start sending the actual request when a new connection was required.\n   * NOTE: this will tend to overestimate the actual RTT as the request can be delayed for other\n   * reasons as well such as more SSL handshakes if TLS False Start is not enabled.\n   */\n  static estimateRTTViaSendStartTiming(info: RequestInfo): number|undefined {\n    const {timing, connectionReused, request} = info;\n    if (connectionReused) {\n      return;\n    }\n\n    if (!Number.isFinite(timing.sendStart) || timing.sendStart < 0) {\n      return;\n    }\n\n    // Assume everything before sendStart was just DNS + (SSL)? + TCP handshake\n    // 1 RT for DNS, 1 RT (maybe) for SSL, 1 RT for TCP\n    let roundTrips = 1;\n    // TCP\n    if (!request.protocol.startsWith('h3')) {\n      roundTrips += 1;\n    }\n    if (request.parsedURL.scheme === 'https') {\n      roundTrips += 1;\n    }\n    return timing.sendStart / roundTrips;\n  }\n\n  /**\n   * Estimates the observed RTT to each origin based on how long it took until Chrome received the\n   * headers of the response (~TTFB).\n   * NOTE: this is the most inaccurate way to estimate the RTT, but in some environments it's all\n   * we have access to :(\n   */\n  static estimateRTTViaHeadersEndTiming(info: RequestInfo): number|undefined {\n    const {timing, connectionReused, request} = info;\n    if (!Number.isFinite(timing.receiveHeadersEnd) || timing.receiveHeadersEnd < 0) {\n      return;\n    }\n    if (!request.resourceType) {\n      return;\n    }\n\n    const serverResponseTimePercentage =\n        SERVER_RESPONSE_PERCENTAGE_OF_TTFB[request.resourceType] || DEFAULT_SERVER_RESPONSE_PERCENTAGE;\n    const estimatedServerResponseTime = timing.receiveHeadersEnd * serverResponseTimePercentage;\n\n    // When connection was reused...\n    // TTFB = 1 RT for request + server response time\n    let roundTrips = 1;\n\n    // When connection was fresh...\n    // TTFB = DNS + (SSL)? + TCP handshake + 1 RT for request + server response time\n    if (!connectionReused) {\n      roundTrips += 1;  // DNS\n      if (!request.protocol.startsWith('h3')) {\n        roundTrips += 1;  // TCP\n      }\n      if (request.parsedURL.scheme === 'https') {\n        roundTrips += 1;  // SSL\n      }\n    }\n\n    // subtract out our estimated server response time\n    return Math.max((timing.receiveHeadersEnd - estimatedServerResponseTime) / roundTrips, 3);\n  }\n\n  /**\n   * Given the RTT to each origin, estimates the observed server response times.\n   */\n  static estimateResponseTimeByOrigin(records: Lantern.NetworkRequest[], rttByOrigin: Map<string, number>):\n      Map<string, number[]> {\n    return NetworkAnalyzer.estimateValueByOrigin(records, ({request, timing}) => {\n      if (request.serverResponseTime !== undefined) {\n        return request.serverResponseTime;\n      }\n\n      if (!Number.isFinite(timing.receiveHeadersEnd) || timing.receiveHeadersEnd < 0) {\n        return;\n      }\n      if (!Number.isFinite(timing.sendEnd) || timing.sendEnd < 0) {\n        return;\n      }\n\n      const ttfb = timing.receiveHeadersEnd - timing.sendEnd;\n      const origin = request.parsedURL.securityOrigin;\n      const rtt = rttByOrigin.get(origin) || rttByOrigin.get(NetworkAnalyzer.summary) || 0;\n      return Math.max(ttfb - rtt, 0);\n    });\n  }\n\n  static canTrustConnectionInformation(requests: Lantern.NetworkRequest[]): boolean {\n    const connectionIdWasStarted = new Map();\n    for (const request of requests) {\n      const started = connectionIdWasStarted.get(request.connectionId) || !request.connectionReused;\n      connectionIdWasStarted.set(request.connectionId, started);\n    }\n\n    // We probably can't trust the network information if all the connection IDs were the same\n    if (connectionIdWasStarted.size <= 1) {\n      return false;\n    }\n    // Or if there were connections that were always reused (a connection had to have started at some point)\n    return Array.from(connectionIdWasStarted.values()).every(started => started);\n  }\n\n  /**\n   * Returns a map of requestId -> connectionReused, estimating the information if the information\n   * available in the records themselves appears untrustworthy.\n   */\n  static estimateIfConnectionWasReused(records: Lantern.NetworkRequest[], options?: {forceCoarseEstimates: boolean}):\n      Map<string, boolean> {\n    const {forceCoarseEstimates = false} = options || {};\n\n    // Check if we can trust the connection information coming from the protocol\n    if (!forceCoarseEstimates && NetworkAnalyzer.canTrustConnectionInformation(records)) {\n      return new Map(records.map(request => [request.requestId, Boolean(request.connectionReused)]));\n    }\n\n    // Otherwise we're on our own, a request may not have needed a fresh connection if...\n    //   - It was not the first request to the domain\n    //   - It was H2\n    //   - It was after the first request to the domain ended\n    const connectionWasReused = new Map();\n    const groupedByOrigin = NetworkAnalyzer.groupByOrigin(records);\n    for (const originRecords of groupedByOrigin.values()) {\n      const earliestReusePossible =\n          originRecords.map(request => request.networkEndTime).reduce((a, b) => Math.min(a, b), Infinity);\n\n      for (const request of originRecords) {\n        connectionWasReused.set(\n            request.requestId,\n            request.networkRequestTime >= earliestReusePossible || request.protocol === 'h2',\n        );\n      }\n\n      const firstRecord = originRecords.reduce((a, b) => {\n        return a.networkRequestTime > b.networkRequestTime ? b : a;\n      });\n      connectionWasReused.set(firstRecord.requestId, false);\n    }\n\n    return connectionWasReused;\n  }\n\n  /**\n   * Estimates the RTT to each origin by examining observed network timing information.\n   * Attempts to use the most accurate information first and falls back to coarser estimates when it\n   * is unavailable.\n   */\n  static estimateRTTByOrigin(records: Lantern.NetworkRequest[], options?: RTTEstimateOptions): Map<string, Summary> {\n    const {\n      forceCoarseEstimates = false,\n      // coarse estimates include lots of extra time and noise\n      // multiply by some factor to deflate the estimates a bit.\n      coarseEstimateMultiplier = 0.3,\n      useDownloadEstimates = true,\n      useSendStartEstimates = true,\n      useHeadersEndEstimates = true,\n    } = options || {};\n\n    const connectionWasReused = NetworkAnalyzer.estimateIfConnectionWasReused(records);\n    const groupedByOrigin = NetworkAnalyzer.groupByOrigin(records);\n\n    const estimatesByOrigin = new Map();\n    for (const [origin, originRequests] of groupedByOrigin.entries()) {\n      const originEstimates: number[] = [];\n\n      function collectEstimates(estimator: (e: RequestInfo) => number[] | number | undefined, multiplier = 1): void {\n        for (const request of originRequests) {\n          const timing = request.timing;\n          if (!timing || !request.transferSize) {\n            continue;\n          }\n\n          const estimates = estimator({\n            request,\n            timing,\n            connectionReused: connectionWasReused.get(request.requestId),\n          });\n          if (estimates === undefined) {\n            continue;\n          }\n\n          if (!Array.isArray(estimates)) {\n            originEstimates.push(estimates * multiplier);\n          } else {\n            originEstimates.push(...estimates.map(e => e * multiplier));\n          }\n        }\n      }\n\n      if (!forceCoarseEstimates) {\n        collectEstimates(this.estimateRTTViaConnectionTiming);\n      }\n\n      // Connection timing can be missing for a few reasons:\n      // - Origin was preconnected, which we don't have instrumentation for.\n      // - Trace began recording after a connection has already been established (for example, in timespan mode)\n      // - Perhaps Chrome established a connection already in the background (service worker? Just guessing here)\n      // - Not provided in LR netstack.\n      if (!originEstimates.length) {\n        if (useDownloadEstimates) {\n          collectEstimates(this.estimateRTTViaDownloadTiming, coarseEstimateMultiplier);\n        }\n        if (useSendStartEstimates) {\n          collectEstimates(this.estimateRTTViaSendStartTiming, coarseEstimateMultiplier);\n        }\n        if (useHeadersEndEstimates) {\n          collectEstimates(this.estimateRTTViaHeadersEndTiming, coarseEstimateMultiplier);\n        }\n      }\n\n      if (originEstimates.length) {\n        estimatesByOrigin.set(origin, originEstimates);\n      }\n    }\n\n    if (!estimatesByOrigin.size) {\n      throw new LanternError('No timing information available');\n    }\n    return NetworkAnalyzer.summarize(estimatesByOrigin);\n  }\n\n  /**\n   * Estimates the server response time of each origin. RTT times can be passed in or will be\n   * estimated automatically if not provided.\n   */\n  static estimateServerResponseTimeByOrigin(records: Lantern.NetworkRequest[], options?: RTTEstimateOptions&{\n    rttByOrigin?: Map<string, number>,\n  }): Map<string, Summary> {\n    let rttByOrigin = options?.rttByOrigin;\n    if (!rttByOrigin) {\n      rttByOrigin = new Map();\n\n      const rttSummaryByOrigin = NetworkAnalyzer.estimateRTTByOrigin(records, options);\n      for (const [origin, summary] of rttSummaryByOrigin.entries()) {\n        rttByOrigin.set(origin, summary.min);\n      }\n    }\n\n    const estimatesByOrigin = NetworkAnalyzer.estimateResponseTimeByOrigin(records, rttByOrigin);\n    return NetworkAnalyzer.summarize(estimatesByOrigin);\n  }\n\n  /**\n   * Computes the average throughput for the given requests in bits/second.\n   * Excludes data URI, failed or otherwise incomplete, and cached requests.\n   * Returns null if there were no analyzable network requests.\n   */\n  static estimateThroughput(records: Lantern.NetworkRequest[]): number|null {\n    let totalBytes = 0;\n\n    // We will measure throughput by summing the total bytes downloaded by the total time spent\n    // downloading those bytes. We slice up all the network requests into start/end boundaries, so\n    // it's easier to deal with the gaps in downloading.\n    const timeBoundaries = records\n                               .reduce(\n                                   (boundaries, request) => {\n                                     const scheme = request.parsedURL?.scheme;\n                                     // Requests whose bodies didn't come over the network or didn't completely finish will mess\n                                     // with the computation, just skip over them.\n                                     if (scheme === 'data' || request.failed || !request.finished ||\n                                         request.statusCode > 300 || !request.transferSize) {\n                                       return boundaries;\n                                     }\n\n                                     // If we've made it this far, all the times we need should be valid (i.e. not undefined/-1).\n                                     totalBytes += request.transferSize;\n                                     boundaries.push({time: request.responseHeadersEndTime / 1000, isStart: true});\n                                     boundaries.push({time: request.networkEndTime / 1000, isStart: false});\n                                     return boundaries;\n                                   },\n                                   [] as Array<{time: number, isStart: boolean}>)\n                               .sort((a, b) => a.time - b.time);\n\n    if (!timeBoundaries.length) {\n      return null;\n    }\n\n    let inflight = 0;\n    let currentStart = 0;\n    let totalDuration = 0;\n\n    timeBoundaries.forEach(boundary => {\n      if (boundary.isStart) {\n        if (inflight === 0) {\n          // We just ended a quiet period, keep track of when the download period started\n          currentStart = boundary.time;\n        }\n        inflight++;\n      } else {\n        inflight--;\n        if (inflight === 0) {\n          // We just entered a quiet period, update our duration with the time we spent downloading\n          totalDuration += boundary.time - currentStart;\n        }\n      }\n    });\n\n    return totalBytes * 8 / totalDuration;\n  }\n\n  static computeRTTAndServerResponseTime(records: Lantern.NetworkRequest[]):\n      {rtt: number, additionalRttByOrigin: Map<string, number>, serverResponseTimeByOrigin: Map<string, number>} {\n    // First pass compute the estimated observed RTT to each origin's servers.\n    const rttByOrigin = new Map<string, number>();\n    for (const [origin, summary] of NetworkAnalyzer.estimateRTTByOrigin(records).entries()) {\n      rttByOrigin.set(origin, summary.min);\n    }\n\n    // We'll use the minimum RTT as the assumed connection latency since we care about how much addt'l\n    // latency each origin introduces as Lantern will be simulating with its own connection latency.\n    const minimumRtt = Math.min(...Array.from(rttByOrigin.values()));\n    // We'll use the observed RTT information to help estimate the server response time\n    const responseTimeSummaries = NetworkAnalyzer.estimateServerResponseTimeByOrigin(records, {\n      rttByOrigin,\n    });\n\n    const additionalRttByOrigin = new Map<string, number>();\n    const serverResponseTimeByOrigin = new Map<string, number>();\n    for (const [origin, summary] of responseTimeSummaries.entries()) {\n      // Not all origins have usable timing data, we'll default to using no additional latency.\n      const rttForOrigin = rttByOrigin.get(origin) || minimumRtt;\n      additionalRttByOrigin.set(origin, rttForOrigin - minimumRtt);\n      serverResponseTimeByOrigin.set(origin, summary.median);\n    }\n\n    return {\n      rtt: minimumRtt,\n      additionalRttByOrigin,\n      serverResponseTimeByOrigin,\n    };\n  }\n\n  static analyze(records: Lantern.NetworkRequest[]): Lantern.Simulation.Settings['networkAnalysis']|null {\n    const throughput = NetworkAnalyzer.estimateThroughput(records);\n    if (throughput === null) {\n      return null;\n    }\n\n    return {\n      throughput,\n      ...NetworkAnalyzer.computeRTTAndServerResponseTime(records),\n    };\n  }\n\n  static findResourceForUrl<T extends Lantern.NetworkRequest>(records: T[], resourceUrl: string): T|undefined {\n    // equalWithExcludedFragments is expensive, so check that the resourceUrl starts with the request url first\n    return records.find(\n        request => resourceUrl.startsWith(request.url) && UrlUtils.equalWithExcludedFragments(request.url, resourceUrl),\n    );\n  }\n\n  static findLastDocumentForUrl<T extends Lantern.NetworkRequest>(records: T[], resourceUrl: string): T|undefined {\n    // equalWithExcludedFragments is expensive, so check that the resourceUrl starts with the request url first\n    const matchingRequests = records.filter(\n        request => request.resourceType === 'Document' && !request.failed &&\n            // Note: `request.url` should never have a fragment, else this optimization gives wrong results.\n            resourceUrl.startsWith(request.url) && UrlUtils.equalWithExcludedFragments(request.url, resourceUrl),\n    );\n    return matchingRequests[matchingRequests.length - 1];\n  }\n\n  /**\n   * Resolves redirect chain given a main document.\n   * See: {@link NetworkAnalyzer.findLastDocumentForUrl} for how to retrieve main document.\n   */\n  static resolveRedirects<T extends Lantern.NetworkRequest>(request: T): T {\n    while (request.redirectDestination) {\n      request = request.redirectDestination as T;\n    }\n    return request;\n  }\n}\n\nexport {NetworkAnalyzer};\n"],
  "mappings": "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",
  "names": []
}
