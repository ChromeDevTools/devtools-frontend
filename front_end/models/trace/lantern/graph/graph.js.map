{
  "version": 3,
  "sources": ["../../../../../../../../front_end/models/trace/lantern/graph/BaseNode.ts", "../../../../../../../../front_end/models/trace/lantern/graph/CPUNode.ts", "../../../../../../../../front_end/models/trace/lantern/graph/NetworkNode.ts", "../../../../../../../../front_end/models/trace/lantern/graph/PageDependencyGraph.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Core from '../core/core.js';\nimport type * as Lantern from '../types/types.js';\n\nimport type {CPUNode} from './CPUNode.js';\nimport type {NetworkNode} from './NetworkNode.js';\n\n/**\n * A union of all types derived from BaseNode, allowing type check discrimination\n * based on `node.type`. If a new node type is created, it should be added here.\n */\nexport type Node<T = Lantern.AnyNetworkObject> = CPUNode<T>|NetworkNode<T>;\n\n/**\n * @file This class encapsulates logic for handling resources and tasks used to model the\n * execution dependency graph of the page. A node has a unique identifier and can depend on other\n * nodes/be depended on. The construction of the graph maintains some important invariants that are\n * inherent to the model:\n *\n *    1. The graph is a DAG, there are no cycles.\n *    2. There is always a root node upon which all other nodes eventually depend.\n *\n * This allows particular optimizations in this class so that we do no need to check for cycles as\n * these methods are called and we can always start traversal at the root node.\n */\n\nclass BaseNode<T = Lantern.AnyNetworkObject> {\n  static types = {\n    NETWORK: 'network',\n    CPU: 'cpu',\n  } as const;\n\n  _id: string;\n  _isMainDocument: boolean;\n  dependents: Node[];\n  dependencies: Node[];\n\n  constructor(id: string) {\n    this._id = id;\n    this._isMainDocument = false;\n    this.dependents = [];\n    this.dependencies = [];\n  }\n\n  get id(): string {\n    return this._id;\n  }\n\n  get type(): 'network'|'cpu' {\n    throw new Core.LanternError('Unimplemented');\n  }\n\n  /**\n   * In microseconds\n   */\n  get startTime(): number {\n    throw new Core.LanternError('Unimplemented');\n  }\n\n  /**\n   * In microseconds\n   */\n  get endTime(): number {\n    throw new Core.LanternError('Unimplemented');\n  }\n\n  setIsMainDocument(value: boolean): void {\n    this._isMainDocument = value;\n  }\n\n  isMainDocument(): boolean {\n    return this._isMainDocument;\n  }\n\n  getDependents(): Node[] {\n    return this.dependents.slice();\n  }\n\n  getNumberOfDependents(): number {\n    return this.dependents.length;\n  }\n\n  getDependencies(): Node[] {\n    return this.dependencies.slice();\n  }\n\n  getNumberOfDependencies(): number {\n    return this.dependencies.length;\n  }\n\n  getRootNode(): Node<T> {\n    let rootNode = this as BaseNode as Node;\n    while (rootNode.dependencies.length) {\n      rootNode = rootNode.dependencies[0];\n    }\n\n    return rootNode;\n  }\n\n  addDependent(node: Node): void {\n    node.addDependency(this as BaseNode as Node);\n  }\n\n  addDependency(node: Node): void {\n    // @ts-expect-error - in checkJs, ts doesn't know that CPUNode and NetworkNode *are* BaseNodes.\n    if (node === this) {\n      throw new Core.LanternError('Cannot add dependency on itself');\n    }\n\n    if (this.dependencies.includes(node)) {\n      return;\n    }\n\n    node.dependents.push(this as BaseNode as Node);\n    this.dependencies.push(node);\n  }\n\n  removeDependent(node: Node): void {\n    node.removeDependency(this as BaseNode as Node);\n  }\n\n  removeDependency(node: Node): void {\n    if (!this.dependencies.includes(node)) {\n      return;\n    }\n\n    const thisIndex = node.dependents.indexOf(this as BaseNode as Node);\n    node.dependents.splice(thisIndex, 1);\n    this.dependencies.splice(this.dependencies.indexOf(node), 1);\n  }\n\n  // Unused in devtools, but used in LH.\n  removeAllDependencies(): void {\n    for (const node of this.dependencies.slice()) {\n      this.removeDependency(node);\n    }\n  }\n\n  /**\n   * Computes whether the given node is anywhere in the dependency graph of this node.\n   * While this method can prevent cycles, it walks the graph and should be used sparingly.\n   * Nodes are always considered dependent on themselves for the purposes of cycle detection.\n   */\n  isDependentOn(node: BaseNode<T>): boolean {\n    let isDependentOnNode = false;\n    this.traverse(\n        currentNode => {\n          if (isDependentOnNode) {\n            return;\n          }\n          isDependentOnNode = currentNode === node;\n        },\n        currentNode => {\n          // If we've already found the dependency, don't traverse further.\n          if (isDependentOnNode) {\n            return [];\n          }\n          // Otherwise, traverse the dependencies.\n          return currentNode.getDependencies();\n        });\n\n    return isDependentOnNode;\n  }\n\n  /**\n   * Clones the node's information without adding any dependencies/dependents.\n   */\n  cloneWithoutRelationships(): Node<T> {\n    const node = new BaseNode(this.id) as Node<T>;\n    node.setIsMainDocument(this._isMainDocument);\n    return node;\n  }\n\n  /**\n   * Clones the entire graph connected to this node filtered by the optional predicate. If a node is\n   * included by the predicate, all nodes along the paths between the node and the root will be included. If the\n   * node this was called on is not included in the resulting filtered graph, the method will throw.\n   *\n   * This does not clone NetworkNode's `record` or `rawRecord` fields. It may be reasonable to clone the former,\n   * to assist in graph construction, but the latter should never be cloned as one constraint of Lantern is that\n   * the underlying data records are accessible for plain object reference equality checks.\n   */\n  cloneWithRelationships(predicate?: (arg0: Node) => boolean): Node {\n    const rootNode = this.getRootNode();\n\n    const idsToIncludedClones = new Map<string, Node>();\n\n    // Walk down dependents.\n    rootNode.traverse(node => {\n      if (idsToIncludedClones.has(node.id)) {\n        return;\n      }\n\n      if (predicate === undefined) {\n        // No condition for entry, so clone every node.\n        idsToIncludedClones.set(node.id, node.cloneWithoutRelationships());\n        return;\n      }\n\n      if (predicate(node)) {\n        // Node included, so walk back up dependencies, cloning nodes from here back to the root.\n        node.traverse(\n            node => idsToIncludedClones.set(node.id, node.cloneWithoutRelationships()),\n            // Dependencies already cloned have already cloned ancestors, so no need to visit again.\n            node => node.dependencies.filter(parent => !idsToIncludedClones.has(parent.id)),\n        );\n      }\n    });\n\n    // Copy dependencies between nodes.\n    rootNode.traverse(originalNode => {\n      const clonedNode = idsToIncludedClones.get(originalNode.id);\n      if (!clonedNode) {\n        return;\n      }\n\n      for (const dependency of originalNode.dependencies) {\n        const clonedDependency = idsToIncludedClones.get(dependency.id);\n        if (!clonedDependency) {\n          throw new Core.LanternError('Dependency somehow not cloned');\n        }\n        clonedNode.addDependency(clonedDependency);\n      }\n    });\n\n    const clonedThisNode = idsToIncludedClones.get(this.id);\n    if (!clonedThisNode) {\n      throw new Core.LanternError('Cloned graph missing node');\n    }\n    return clonedThisNode;\n  }\n\n  /**\n   * Traverses all connected nodes in BFS order, calling `callback` exactly once\n   * on each. `traversalPath` is the shortest (though not necessarily unique)\n   * path from `node` to the root of the iteration.\n   *\n   * The `getNextNodes` function takes a visited node and returns which nodes to\n   * visit next. It defaults to returning the node's dependents.\n   */\n  traverse(\n      callback: (node: Node<T>, traversalPath: Array<Node<T>>) => void,\n      getNextNodes?: (arg0: Node<T>) => Array<Node<T>>): void {\n    for (const {node, traversalPath} of this.traverseGenerator(getNextNodes)) {\n      callback(node, traversalPath);\n    }\n  }\n\n  /**\n   * @see BaseNode.traverse\n   */\n  // clang-format off\n  *traverseGenerator(getNextNodes?: (arg0: Node) => Node[]):\n      Generator<{node: Node, traversalPath: Node[]}, void, unknown> {\n    // clang-format on\n    if (!getNextNodes) {\n      getNextNodes = node => node.getDependents();\n    }\n\n    // @ts-expect-error - only traverses graphs of Node, so force tsc to treat `this` as one\n    const queue: Node[][] = [[this]];\n    const visited = new Set([this.id]);\n\n    while (queue.length) {\n      // @ts-expect-error - queue has length so it's guaranteed to have an item\n      const traversalPath: Node[] = queue.shift();\n      const node = traversalPath[0];\n      yield {node, traversalPath};\n\n      for (const nextNode of getNextNodes(node)) {\n        if (visited.has(nextNode.id)) {\n          continue;\n        }\n        visited.add(nextNode.id);\n\n        queue.push([nextNode, ...traversalPath]);\n      }\n    }\n  }\n\n  /**\n   * If the given node has a cycle, returns a path representing that cycle.\n   * Else returns null.\n   *\n   * Does a DFS on in its dependent graph.\n   */\n  static findCycle(node: Node, direction: 'dependents'|'dependencies'|'both' = 'both'): BaseNode[]|null {\n    // Checking 'both' is the default entrypoint to recursively check both directions\n    if (direction === 'both') {\n      return BaseNode.findCycle(node, 'dependents') || BaseNode.findCycle(node, 'dependencies');\n    }\n\n    const visited = new Set();\n    const currentPath: BaseNode[] = [];\n    const toVisit = [node];\n    const depthAdded = new Map([[node, 0]]);\n\n    // Keep going while we have nodes to visit in the stack\n    while (toVisit.length) {\n      // Get the last node in the stack (DFS uses stack, not queue)\n      // @ts-expect-error - toVisit has length so it's guaranteed to have an item\n      const currentNode: BaseNode = toVisit.pop();\n\n      // We've hit a cycle if the node we're visiting is in our current dependency path\n      if (currentPath.includes(currentNode)) {\n        return currentPath;\n      }\n      // If we've already visited the node, no need to revisit it\n      if (visited.has(currentNode)) {\n        continue;\n      }\n\n      // Since we're visiting this node, clear out any nodes in our path that we had to backtrack\n      // @ts-expect-error\n      while (currentPath.length > depthAdded.get(currentNode)) {\n        currentPath.pop();\n      }\n\n      // Update our data structures to reflect that we're adding this node to our path\n      visited.add(currentNode);\n      currentPath.push(currentNode);\n\n      // Add all of its dependents to our toVisit stack\n      const nodesToExplore = direction === 'dependents' ? currentNode.dependents : currentNode.dependencies;\n      for (const nextNode of nodesToExplore) {\n        if (toVisit.includes(nextNode)) {\n          continue;\n        }\n        toVisit.push(nextNode);\n        depthAdded.set(nextNode, currentPath.length);\n      }\n    }\n\n    return null;\n  }\n\n  canDependOn(node: Node): boolean {\n    return node.startTime <= this.startTime;\n  }\n}\n\nexport {BaseNode};\n", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Lantern from '../types/types.js';\n\nimport {BaseNode} from './BaseNode.js';\n\nclass CPUNode<T = Lantern.AnyNetworkObject> extends BaseNode<T> {\n  _event: Lantern.TraceEvent;\n  _childEvents: Lantern.TraceEvent[];\n  correctedEndTs: number|undefined;\n\n  constructor(parentEvent: Lantern.TraceEvent, childEvents: Lantern.TraceEvent[] = [], correctedEndTs?: number) {\n    const nodeId = `${parentEvent.tid}.${parentEvent.ts}`;\n    super(nodeId);\n\n    this._event = parentEvent;\n    this._childEvents = childEvents;\n    this.correctedEndTs = correctedEndTs;\n  }\n\n  override get type(): 'cpu' {\n    return BaseNode.types.CPU;\n  }\n\n  override get startTime(): number {\n    return this._event.ts;\n  }\n\n  override get endTime(): number {\n    if (this.correctedEndTs) {\n      return this.correctedEndTs;\n    }\n    return this._event.ts + this._event.dur;\n  }\n\n  get duration(): number {\n    return this.endTime - this.startTime;\n  }\n\n  get event(): Lantern.TraceEvent {\n    return this._event;\n  }\n\n  get childEvents(): Lantern.TraceEvent[] {\n    return this._childEvents;\n  }\n\n  /**\n   * Returns true if this node contains a Layout task.\n   */\n  didPerformLayout(): boolean {\n    return this._childEvents.some(evt => evt.name === 'Layout');\n  }\n\n  /**\n   * Returns the script URLs that had their EvaluateScript events occur in this task.\n   */\n  getEvaluateScriptURLs(): Set<string> {\n    const urls = new Set<string>();\n    for (const event of this._childEvents) {\n      if (event.name !== 'EvaluateScript') {\n        continue;\n      }\n      if (!event.args.data?.url) {\n        continue;\n      }\n      urls.add(event.args.data.url);\n    }\n\n    return urls;\n  }\n\n  override cloneWithoutRelationships(): CPUNode {\n    return new CPUNode(this._event, this._childEvents, this.correctedEndTs);\n  }\n}\n\nexport {CPUNode};\n", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Lantern from '../types/types.js';\n\nimport {BaseNode} from './BaseNode.js';\n\nconst NON_NETWORK_SCHEMES = [\n  'blob',        // @see https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL\n  'data',        // @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\n  'intent',      // @see https://developer.chrome.com/docs/multidevice/android/intents/\n  'file',        // @see https://en.wikipedia.org/wiki/File_URI_scheme\n  'filesystem',  // @see https://developer.mozilla.org/en-US/docs/Web/API/FileSystem\n  'chrome-extension',\n];\n\n/**\n * Note: the `protocol` field from CDP can be 'h2', 'http', (not 'https'!) or it'll be url's scheme.\n *   https://source.chromium.org/chromium/chromium/src/+/main:content/browser/devtools/protocol/network_handler.cc;l=598-611;drc=56d4a9a9deb30be73adcee8737c73bcb2a5ab64f\n * However, a `new URL(href).protocol` has a colon suffix.\n *   https://url.spec.whatwg.org/#dom-url-protocol\n * A URL's `scheme` is specced as the `protocol` sans-colon, but isn't exposed on a URL object.\n * This method can take all 3 of these string types as a parameter.\n *\n * @param protocol Either a networkRequest's `protocol` per CDP or a `new URL(href).protocol`\n */\nfunction isNonNetworkProtocol(protocol: string): boolean {\n  // Strip off any colon\n  const urlScheme = protocol.includes(':') ? protocol.slice(0, protocol.indexOf(':')) : protocol;\n  return NON_NETWORK_SCHEMES.includes(urlScheme);\n}\n\nclass NetworkNode<T = Lantern.AnyNetworkObject> extends BaseNode<T> {\n  _request: Lantern.NetworkRequest<T>;\n\n  constructor(networkRequest: Lantern.NetworkRequest<T>) {\n    super(networkRequest.requestId);\n    this._request = networkRequest;\n  }\n\n  override get type(): 'network' {\n    return BaseNode.types.NETWORK;\n  }\n\n  override get startTime(): number {\n    return this._request.rendererStartTime * 1000;\n  }\n\n  override get endTime(): number {\n    return this._request.networkEndTime * 1000;\n  }\n\n  get rawRequest(): Readonly<T> {\n    return this._request.rawRequest as Required<T>;\n  }\n\n  get request(): Lantern.NetworkRequest<T> {\n    return this._request;\n  }\n\n  get initiatorType(): string {\n    return this._request.initiator.type;\n  }\n\n  get fromDiskCache(): boolean {\n    return Boolean(this._request.fromDiskCache);\n  }\n\n  get isNonNetworkProtocol(): boolean {\n    // The 'protocol' field in devtools a string more like a `scheme`\n    return isNonNetworkProtocol(this.request.protocol) ||\n        // But `protocol` can fail to be populated if the request fails, so fallback to scheme.\n        isNonNetworkProtocol(this.request.parsedURL.scheme);\n  }\n\n  /**\n   * Returns whether this network request can be downloaded without a TCP connection.\n   * During simulation we treat data coming in over a network connection separately from on-device data.\n   */\n  get isConnectionless(): boolean {\n    return this.fromDiskCache || this.isNonNetworkProtocol;\n  }\n\n  hasRenderBlockingPriority(): boolean {\n    const priority = this._request.priority;\n    const isScript = this._request.resourceType === 'Script';\n    const isDocument = this._request.resourceType === 'Document';\n    const isBlockingScript = priority === 'High' && isScript;\n    const isBlockingHtmlImport = priority === 'High' && isDocument;\n    return priority === 'VeryHigh' || isBlockingScript || isBlockingHtmlImport;\n  }\n\n  override cloneWithoutRelationships(): NetworkNode<T> {\n    const node = new NetworkNode(this._request);\n    node.setIsMainDocument(this._isMainDocument);\n    return node;\n  }\n}\n\nexport {NetworkNode};\n", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Core from '../core/core.js';\nimport type * as Lantern from '../types/types.js';\n\nimport type {BaseNode, Node} from './BaseNode.js';\nimport {CPUNode} from './CPUNode.js';\nimport {NetworkNode} from './NetworkNode.js';\n\n// COMPAT: m71+ We added RunTask to `disabled-by-default-lighthouse`\nconst SCHEDULABLE_TASK_TITLE_LH = 'RunTask';\n// m69-70 DoWork is different and we now need RunTask, see https://bugs.chromium.org/p/chromium/issues/detail?id=871204#c11\nconst SCHEDULABLE_TASK_TITLE_ALT1 = 'ThreadControllerImpl::RunTask';\n// In m66-68 refactored to this task title, https://crrev.com/c/883346\nconst SCHEDULABLE_TASK_TITLE_ALT2 = 'ThreadControllerImpl::DoWork';\n// m65 and earlier\nconst SCHEDULABLE_TASK_TITLE_ALT3 = 'TaskQueueManager::ProcessTaskFromWorkQueue';\n\ninterface NetworkNodeOutput {\n  nodes: NetworkNode[];\n  idToNodeMap: Map<string, NetworkNode>;\n  urlToNodeMap: Map<string, NetworkNode[]>;\n  frameIdToNodeMap: Map<string, NetworkNode|null>;\n}\n\n// Shorter tasks have negligible impact on simulation results.\nconst SIGNIFICANT_DUR_THRESHOLD_MS = 10;\n\n// TODO: video files tend to be enormous and throw off all graph traversals, move this ignore\n//    into estimation logic when we use the dependency graph for other purposes.\nconst IGNORED_MIME_TYPES_REGEX = /^video/;\n\nclass PageDependencyGraph {\n  static getNetworkInitiators(request: Lantern.NetworkRequest): string[] {\n    if (!request.initiator) {\n      return [];\n    }\n    if (request.initiator.url) {\n      return [request.initiator.url];\n    }\n    if (request.initiator.type === 'script') {\n      // Script initiators have the stack of callFrames from all functions that led to this request.\n      // If async stacks are enabled, then the stack will also have the parent functions that asynchronously\n      // led to this request chained in the `parent` property.\n      const scriptURLs = new Set<string>();\n      let stack = request.initiator.stack;\n      while (stack) {\n        const callFrames = stack.callFrames || [];\n        for (const frame of callFrames) {\n          if (frame.url) {\n            scriptURLs.add(frame.url);\n          }\n        }\n\n        stack = stack.parent;\n      }\n\n      return Array.from(scriptURLs);\n    }\n\n    return [];\n  }\n\n  static getNetworkNodeOutput(networkRequests: Lantern.NetworkRequest[]): NetworkNodeOutput {\n    const nodes: NetworkNode[] = [];\n    const idToNodeMap = new Map<string, NetworkNode>();\n    const urlToNodeMap = new Map<string, NetworkNode[]>();\n    const frameIdToNodeMap = new Map<string, NetworkNode|null>();\n\n    networkRequests.forEach(request => {\n      if (IGNORED_MIME_TYPES_REGEX.test(request.mimeType)) {\n        return;\n      }\n      if (request.fromWorker) {\n        return;\n      }\n\n      // Network requestIds can be duplicated for an unknown reason\n      // Suffix all subsequent requests with `:duplicate` until it's unique\n      // NOTE: This should never happen with modern NetworkRequest library, but old fixtures\n      // might still have this issue.\n      while (idToNodeMap.has(request.requestId)) {\n        request.requestId += ':duplicate';\n      }\n\n      const node = new NetworkNode(request);\n      nodes.push(node);\n\n      const urlList = urlToNodeMap.get(request.url) || [];\n      urlList.push(node);\n\n      idToNodeMap.set(request.requestId, node);\n      urlToNodeMap.set(request.url, urlList);\n\n      // If the request was for the root document of an iframe, save an entry in our\n      // map so we can link up the task `args.data.frame` dependencies later in graph creation.\n      if (request.frameId && request.resourceType === 'Document' && request.documentURL === request.url) {\n        // If there's ever any ambiguity, permanently set the value to `false` to avoid loops in the graph.\n        const value = frameIdToNodeMap.has(request.frameId) ? null : node;\n        frameIdToNodeMap.set(request.frameId, value);\n      }\n    });\n\n    return {nodes, idToNodeMap, urlToNodeMap, frameIdToNodeMap};\n  }\n\n  static isScheduleableTask(evt: Lantern.TraceEvent): boolean {\n    return evt.name === SCHEDULABLE_TASK_TITLE_LH || evt.name === SCHEDULABLE_TASK_TITLE_ALT1 ||\n        evt.name === SCHEDULABLE_TASK_TITLE_ALT2 || evt.name === SCHEDULABLE_TASK_TITLE_ALT3;\n  }\n\n  /**\n   * There should *always* be at least one top level event, having 0 typically means something is\n   * drastically wrong with the trace and we should just give up early and loudly.\n   */\n  static assertHasToplevelEvents(events: Lantern.TraceEvent[]): void {\n    const hasToplevelTask = events.some(this.isScheduleableTask);\n    if (!hasToplevelTask) {\n      throw new Core.LanternError('Could not find any top level events');\n    }\n  }\n\n  static getCPUNodes(mainThreadEvents: Lantern.TraceEvent[]): CPUNode[] {\n    const nodes: CPUNode[] = [];\n    let i = 0;\n\n    PageDependencyGraph.assertHasToplevelEvents(mainThreadEvents);\n\n    while (i < mainThreadEvents.length) {\n      const evt = mainThreadEvents[i];\n      i++;\n\n      // Skip all trace events that aren't schedulable tasks with sizable duration\n      if (!PageDependencyGraph.isScheduleableTask(evt) || !evt.dur) {\n        continue;\n      }\n\n      let correctedEndTs: number|undefined = undefined;\n\n      // Capture all events that occurred within the task\n      const children: Lantern.TraceEvent[] = [];\n      for (const endTime = evt.ts + evt.dur; i < mainThreadEvents.length && mainThreadEvents[i].ts < endTime; i++) {\n        const event = mainThreadEvents[i];\n\n        // Temporary fix for a Chrome bug where some RunTask events can be overlapping.\n        // We correct that here be ensuring each RunTask ends at least 1 microsecond before the next\n        // https://github.com/GoogleChrome/lighthouse/issues/15896\n        // https://issues.chromium.org/issues/329678173\n        if (PageDependencyGraph.isScheduleableTask(event) && event.dur) {\n          correctedEndTs = event.ts - 1;\n          break;\n        }\n\n        children.push(event);\n      }\n\n      nodes.push(new CPUNode(evt, children, correctedEndTs));\n    }\n\n    return nodes;\n  }\n\n  static linkNetworkNodes(rootNode: NetworkNode, networkNodeOutput: NetworkNodeOutput): void {\n    networkNodeOutput.nodes.forEach(node => {\n      const directInitiatorRequest = node.request.initiatorRequest || rootNode.request;\n      const directInitiatorNode = networkNodeOutput.idToNodeMap.get(directInitiatorRequest.requestId) || rootNode;\n      const canDependOnInitiator = !directInitiatorNode.isDependentOn(node) && node.canDependOn(directInitiatorNode);\n      const initiators = PageDependencyGraph.getNetworkInitiators(node.request);\n      if (initiators.length) {\n        initiators.forEach(initiator => {\n          const parentCandidates = networkNodeOutput.urlToNodeMap.get(initiator) || [];\n          // Only add the edge if the parent is unambiguous with valid timing and isn't circular.\n          if (parentCandidates.length === 1 && parentCandidates[0].startTime <= node.startTime &&\n              !parentCandidates[0].isDependentOn(node)) {\n            node.addDependency(parentCandidates[0]);\n          } else if (canDependOnInitiator) {\n            directInitiatorNode.addDependent(node);\n          }\n        });\n      } else if (canDependOnInitiator) {\n        directInitiatorNode.addDependent(node);\n      }\n\n      // Make sure the nodes are attached to the graph if the initiator information was invalid.\n      if (node !== rootNode && node.getDependencies().length === 0 && node.canDependOn(rootNode)) {\n        node.addDependency(rootNode);\n      }\n\n      if (!node.request.redirects) {\n        return;\n      }\n\n      const redirects = [...node.request.redirects, node.request];\n      for (let i = 1; i < redirects.length; i++) {\n        const redirectNode = networkNodeOutput.idToNodeMap.get(redirects[i - 1].requestId);\n        const actualNode = networkNodeOutput.idToNodeMap.get(redirects[i].requestId);\n        if (actualNode && redirectNode) {\n          actualNode.addDependency(redirectNode);\n        }\n      }\n    });\n  }\n\n  static linkCPUNodes(rootNode: Node, networkNodeOutput: NetworkNodeOutput, cpuNodes: CPUNode[]): void {\n    const linkableResourceTypes = new Set<Lantern.ResourceType|undefined>([\n      'XHR',\n      'Fetch',\n      'Script',\n    ]);\n\n    function addDependentNetworkRequest(cpuNode: CPUNode, reqId: string): void {\n      const networkNode = networkNodeOutput.idToNodeMap.get(reqId);\n      if (!networkNode ||\n          // Ignore all network nodes that started before this CPU task started\n          // A network request that started earlier could not possibly have been started by this task\n          networkNode.startTime <= cpuNode.startTime) {\n        return;\n      }\n      const {request} = networkNode;\n      const resourceType = request.resourceType || request.redirectDestination?.resourceType;\n      if (!linkableResourceTypes.has(resourceType)) {\n        // We only link some resources to CPU nodes because we observe LCP simulation\n        // regressions when including images, etc.\n        return;\n      }\n      cpuNode.addDependent(networkNode);\n    }\n\n    /**\n     * If the node has an associated frameId, then create a dependency on the root document request\n     * for the frame. The task obviously couldn't have started before the frame was even downloaded.\n     */\n    function addDependencyOnFrame(cpuNode: CPUNode, frameId: string|undefined): void {\n      if (!frameId) {\n        return;\n      }\n      const networkNode = networkNodeOutput.frameIdToNodeMap.get(frameId);\n      if (!networkNode) {\n        return;\n      }\n      // Ignore all network nodes that started after this CPU task started\n      // A network request that started after could not possibly be required this task\n      if (networkNode.startTime >= cpuNode.startTime) {\n        return;\n      }\n      cpuNode.addDependency(networkNode);\n    }\n\n    function addDependencyOnUrl(cpuNode: CPUNode, url: string): void {\n      if (!url) {\n        return;\n      }\n      // Allow network requests that end up to 100ms before the task started\n      // Some script evaluations can start before the script finishes downloading\n      const minimumAllowableTimeSinceNetworkNodeEnd = -100 * 1000;\n      const candidates = networkNodeOutput.urlToNodeMap.get(url) || [];\n\n      let minCandidate = null;\n      let minDistance = Infinity;\n      // Find the closest request that finished before this CPU task started\n      for (const candidate of candidates) {\n        // Explicitly ignore all requests that started after this CPU node\n        // A network request that started after this task started cannot possibly be a dependency\n        if (cpuNode.startTime <= candidate.startTime) {\n          return;\n        }\n\n        const distance = cpuNode.startTime - candidate.endTime;\n        if (distance >= minimumAllowableTimeSinceNetworkNodeEnd && distance < minDistance) {\n          minCandidate = candidate;\n          minDistance = distance;\n        }\n      }\n\n      if (!minCandidate) {\n        return;\n      }\n      cpuNode.addDependency(minCandidate);\n    }\n\n    const timers = new Map<string, CPUNode>();\n    for (const node of cpuNodes) {\n      for (const evt of node.childEvents) {\n        if (!evt.args.data) {\n          continue;\n        }\n\n        const argsUrl = evt.args.data.url;\n        const stackTraceUrls = (evt.args.data.stackTrace || []).map(l => l.url).filter(Boolean);\n\n        switch (evt.name) {\n          case 'TimerInstall':\n            // @ts-expect-error - 'TimerInstall' event means timerId exists.\n            timers.set(evt.args.data.timerId, node);\n            stackTraceUrls.forEach(url => addDependencyOnUrl(node, url));\n            break;\n          case 'TimerFire': {\n            // @ts-expect-error - 'TimerFire' event means timerId exists.\n            const installer = timers.get(evt.args.data.timerId);\n            if (!installer || installer.endTime > node.startTime) {\n              break;\n            }\n            installer.addDependent(node);\n            break;\n          }\n\n          case 'InvalidateLayout':\n          case 'ScheduleStyleRecalculation':\n            addDependencyOnFrame(node, evt.args.data.frame);\n            stackTraceUrls.forEach(url => addDependencyOnUrl(node, url));\n            break;\n\n          case 'EvaluateScript':\n            addDependencyOnFrame(node, evt.args.data.frame);\n            // @ts-expect-error - 'EvaluateScript' event means argsUrl is defined.\n            addDependencyOnUrl(node, argsUrl);\n            stackTraceUrls.forEach(url => addDependencyOnUrl(node, url));\n            break;\n\n          case 'XHRReadyStateChange':\n            // Only create the dependency if the request was completed\n            // 'XHRReadyStateChange' event means readyState is defined.\n            if (evt.args.data.readyState !== 4) {\n              break;\n            }\n\n            // @ts-expect-error - 'XHRReadyStateChange' event means argsUrl is defined.\n            addDependencyOnUrl(node, argsUrl);\n            stackTraceUrls.forEach(url => addDependencyOnUrl(node, url));\n            break;\n\n          case 'FunctionCall':\n          case 'v8.compile':\n            addDependencyOnFrame(node, evt.args.data.frame);\n            // @ts-expect-error - events mean argsUrl is defined.\n            addDependencyOnUrl(node, argsUrl);\n            break;\n\n          case 'ParseAuthorStyleSheet':\n            addDependencyOnFrame(node, evt.args.data.frame);\n            // @ts-expect-error - 'ParseAuthorStyleSheet' event means styleSheetUrl is defined.\n            addDependencyOnUrl(node, evt.args.data.styleSheetUrl);\n            break;\n\n          case 'ResourceSendRequest':\n            addDependencyOnFrame(node, evt.args.data.frame);\n            // @ts-expect-error - 'ResourceSendRequest' event means requestId is defined.\n            addDependentNetworkRequest(node, evt.args.data.requestId);\n            stackTraceUrls.forEach(url => addDependencyOnUrl(node, url));\n            break;\n        }\n      }\n\n      // Nodes starting before the root node cannot depend on it.\n      if (node.getNumberOfDependencies() === 0 && node.canDependOn(rootNode)) {\n        node.addDependency(rootNode);\n      }\n    }\n\n    // Second pass to prune the graph of short tasks.\n    const minimumEvtDur = SIGNIFICANT_DUR_THRESHOLD_MS * 1000;\n    let foundFirstLayout = false;\n    let foundFirstPaint = false;\n    let foundFirstParse = false;\n\n    for (const node of cpuNodes) {\n      // Don't prune if event is the first ParseHTML/Layout/Paint.\n      // See https://github.com/GoogleChrome/lighthouse/issues/9627#issuecomment-526699524 for more.\n      let isFirst = false;\n      if (!foundFirstLayout && node.childEvents.some(evt => evt.name === 'Layout')) {\n        isFirst = foundFirstLayout = true;\n      }\n      if (!foundFirstPaint && node.childEvents.some(evt => evt.name === 'Paint')) {\n        isFirst = foundFirstPaint = true;\n      }\n      if (!foundFirstParse && node.childEvents.some(evt => evt.name === 'ParseHTML')) {\n        isFirst = foundFirstParse = true;\n      }\n\n      if (isFirst || node.duration >= minimumEvtDur) {\n        // Don't prune this node. The task is long / important so it will impact simulation.\n        continue;\n      }\n\n      // Prune the node if it isn't highly connected to minimize graph size. Rewiring the graph\n      // here replaces O(M + N) edges with (M * N) edges, which is fine if either  M or N is at\n      // most 1.\n      if (node.getNumberOfDependencies() === 1 || node.getNumberOfDependents() <= 1) {\n        PageDependencyGraph.pruneNode(node);\n      }\n    }\n  }\n\n  /**\n   * Removes the given node from the graph, but retains all paths between its dependencies and\n   * dependents.\n   */\n  static pruneNode(node: Node): void {\n    const dependencies = node.getDependencies();\n    const dependents = node.getDependents();\n    for (const dependency of dependencies) {\n      node.removeDependency(dependency);\n      for (const dependent of dependents) {\n        dependency.addDependent(dependent);\n      }\n    }\n    for (const dependent of dependents) {\n      node.removeDependent(dependent);\n    }\n  }\n\n  /**\n   * TODO: remove when CDT backend in Lighthouse is gone. Until then, this is a useful debugging tool\n   * to find delta between using CDP or the trace to create the network requests.\n   *\n   * When a test fails using the trace backend, I enabled this debug method and copied the network\n   * requests when CDP was used, then when trace is used, and diff'd them. This method helped\n   * remove non-logical differences from the comparison (order of properties, slight rounding\n   * discrepancies, removing object cycles, etc).\n   *\n   * When using for a unit test, make sure to do `.only` so you are getting what you expect.\n   */\n  static debugNormalizeRequests(lanternRequests: Lantern.NetworkRequest[]): void {\n    for (const request of lanternRequests) {\n      request.rendererStartTime = Math.round(request.rendererStartTime * 1000) / 1000;\n      request.networkRequestTime = Math.round(request.networkRequestTime * 1000) / 1000;\n      request.responseHeadersEndTime = Math.round(request.responseHeadersEndTime * 1000) / 1000;\n      request.networkEndTime = Math.round(request.networkEndTime * 1000) / 1000;\n    }\n\n    for (const r of lanternRequests) {\n      delete r.rawRequest;\n      if (r.initiatorRequest) {\n        // @ts-expect-error\n        r.initiatorRequest = {id: r.initiatorRequest.requestId};\n      }\n      if (r.redirectDestination) {\n        // @ts-expect-error\n        r.redirectDestination = {id: r.redirectDestination.requestId};\n      }\n      if (r.redirectSource) {\n        // @ts-expect-error\n        r.redirectSource = {id: r.redirectSource.requestId};\n      }\n      if (r.redirects) {\n        // @ts-expect-error\n        r.redirects = r.redirects.map(r2 => r2.requestId);\n      }\n    }\n    const requests: Lantern.NetworkRequest[] = lanternRequests\n                                                   .map(r => ({\n                                                          requestId: r.requestId,\n                                                          connectionId: r.connectionId,\n                                                          connectionReused: r.connectionReused,\n                                                          url: r.url,\n                                                          protocol: r.protocol,\n                                                          parsedURL: r.parsedURL,\n                                                          documentURL: r.documentURL,\n                                                          rendererStartTime: r.rendererStartTime,\n                                                          networkRequestTime: r.networkRequestTime,\n                                                          responseHeadersEndTime: r.responseHeadersEndTime,\n                                                          networkEndTime: r.networkEndTime,\n                                                          transferSize: r.transferSize,\n                                                          resourceSize: r.resourceSize,\n                                                          fromDiskCache: r.fromDiskCache,\n                                                          fromMemoryCache: r.fromMemoryCache,\n                                                          finished: r.finished,\n                                                          statusCode: r.statusCode,\n                                                          redirectSource: r.redirectSource,\n                                                          redirectDestination: r.redirectDestination,\n                                                          redirects: r.redirects,\n                                                          failed: r.failed,\n                                                          initiator: r.initiator,\n                                                          timing: r.timing ? {\n                                                            requestTime: r.timing.requestTime,\n                                                            proxyStart: r.timing.proxyStart,\n                                                            proxyEnd: r.timing.proxyEnd,\n                                                            dnsStart: r.timing.dnsStart,\n                                                            dnsEnd: r.timing.dnsEnd,\n                                                            connectStart: r.timing.connectStart,\n                                                            connectEnd: r.timing.connectEnd,\n                                                            sslStart: r.timing.sslStart,\n                                                            sslEnd: r.timing.sslEnd,\n                                                            workerStart: r.timing.workerStart,\n                                                            workerReady: r.timing.workerReady,\n                                                            workerFetchStart: r.timing.workerFetchStart,\n                                                            workerRespondWithSettled: r.timing.workerRespondWithSettled,\n                                                            sendStart: r.timing.sendStart,\n                                                            sendEnd: r.timing.sendEnd,\n                                                            pushStart: r.timing.pushStart,\n                                                            pushEnd: r.timing.pushEnd,\n                                                            receiveHeadersStart: r.timing.receiveHeadersStart,\n                                                            receiveHeadersEnd: r.timing.receiveHeadersEnd,\n                                                          } :\n                                                                             r.timing,\n                                                          resourceType: r.resourceType,\n                                                          mimeType: r.mimeType,\n                                                          priority: r.priority,\n                                                          initiatorRequest: r.initiatorRequest,\n                                                          frameId: r.frameId,\n                                                          fromWorker: r.fromWorker,\n                                                          isLinkPreload: r.isLinkPreload,\n                                                          serverResponseTime: r.serverResponseTime,\n                                                        }))\n                                                   .filter(r => !r.fromWorker);\n\n    const debug = requests;\n    // Set breakpoint here.\n    // Copy `debug` and compare with https://www.diffchecker.com/text-compare/\n    // eslint-disable-next-line no-console\n    console.log(debug);\n  }\n\n  static createGraph(\n      mainThreadEvents: Lantern.TraceEvent[], networkRequests: Lantern.NetworkRequest[],\n      url: Lantern.Simulation.URL): Node {\n    // This is for debugging trace/devtoolslog network records.\n    // const debug = PageDependencyGraph.debugNormalizeRequests(networkRequests);\n    const networkNodeOutput = PageDependencyGraph.getNetworkNodeOutput(networkRequests);\n    const cpuNodes = PageDependencyGraph.getCPUNodes(mainThreadEvents);\n    const {requestedUrl, mainDocumentUrl} = url;\n    if (!requestedUrl) {\n      throw new Core.LanternError('requestedUrl is required to get the root request');\n    }\n    if (!mainDocumentUrl) {\n      throw new Core.LanternError('mainDocumentUrl is required to get the main resource');\n    }\n\n    const rootRequest = Core.NetworkAnalyzer.findResourceForUrl(networkRequests, requestedUrl);\n    if (!rootRequest) {\n      throw new Core.LanternError('rootRequest not found');\n    }\n    const rootNode = networkNodeOutput.idToNodeMap.get(rootRequest.requestId);\n    if (!rootNode) {\n      throw new Core.LanternError('rootNode not found');\n    }\n    const mainDocumentRequest = Core.NetworkAnalyzer.findLastDocumentForUrl(networkRequests, mainDocumentUrl);\n    if (!mainDocumentRequest) {\n      throw new Core.LanternError('mainDocumentRequest not found');\n    }\n    const mainDocumentNode = networkNodeOutput.idToNodeMap.get(mainDocumentRequest.requestId);\n    if (!mainDocumentNode) {\n      throw new Core.LanternError('mainDocumentNode not found');\n    }\n\n    PageDependencyGraph.linkNetworkNodes(rootNode, networkNodeOutput);\n    PageDependencyGraph.linkCPUNodes(rootNode, networkNodeOutput, cpuNodes);\n    mainDocumentNode.setIsMainDocument(true);\n\n    if (NetworkNode.findCycle(rootNode)) {\n      // Uncomment the following if you are debugging cycles.\n      // this.printGraph(rootNode);\n      throw new Core.LanternError('Invalid dependency graph created, cycle detected');\n    }\n\n    return rootNode;\n  }\n\n  // Unused, but useful for debugging.\n  static printGraph(rootNode: Node, widthInCharacters = 80): void {\n    function padRight(str: string, target: number, padChar = ' '): string {\n      return str + padChar.repeat(Math.max(target - str.length, 0));\n    }\n\n    const nodes: Node[] = [];\n    rootNode.traverse(node => nodes.push(node));\n    nodes.sort((a, b) => a.startTime - b.startTime);\n\n    // Assign labels (A, B, C, ..., Z, Z1, Z2, ...) for each node.\n    const nodeToLabel = new Map<BaseNode, string>();\n    rootNode.traverse(node => {\n      const ascii = 65 + nodeToLabel.size;\n      let label;\n      if (ascii > 90) {\n        label = `Z${ascii - 90}`;\n      } else {\n        label = String.fromCharCode(ascii);\n      }\n      nodeToLabel.set(node, label);\n    });\n\n    const min = nodes[0].startTime;\n    const max = nodes.reduce((max, node) => Math.max(max, node.endTime), 0);\n\n    const totalTime = max - min;\n    const timePerCharacter = totalTime / widthInCharacters;\n    nodes.forEach(node => {\n      const offset = Math.round((node.startTime - min) / timePerCharacter);\n      const length = Math.ceil((node.endTime - node.startTime) / timePerCharacter);\n      const bar = padRight('', offset) + padRight('', length, '=');\n\n      // @ts-expect-error -- disambiguate displayName from across possible Node types.\n      const displayName = node.request ? node.request.url : node.type;\n      // eslint-disable-next-line\n      console.log(padRight(bar, widthInCharacters), `| ${displayName.slice(0, 50)}`);\n    });\n\n    // Print labels for each node.\n\n    // eslint-disable-next-line\n    console.log();\n\n    // Print dependencies.\n    nodes.forEach(node => {\n      // @ts-expect-error -- disambiguate displayName from across possible Node types.\n      const displayName = node.request ? node.request.url : node.type;\n      // eslint-disable-next-line\n      console.log(nodeToLabel.get(node), displayName.slice(0, widthInCharacters - 5));\n\n      for (const child of node.dependents) {\n        // @ts-expect-error -- disambiguate displayName from across possible Node types.\n        const displayName = child.request ? child.request.url : child.type;\n        // eslint-disable-next-line\n        console.log('  ->', nodeToLabel.get(child), displayName.slice(0, widthInCharacters - 10));\n      }\n\n      // eslint-disable-next-line\n      console.log();\n    });\n\n    // Show cycle.\n    const cyclePath = NetworkNode.findCycle(rootNode);\n    // eslint-disable-next-line\n    console.log('Cycle?', cyclePath ? 'yes' : 'no');\n    if (cyclePath) {\n      const path = [...cyclePath];\n      path.push(path[0]);\n      // eslint-disable-next-line\n      console.log(path.map(node => nodeToLabel.get(node)).join(' -> '));\n    }\n  }\n}\n\nexport {PageDependencyGraph};\n"],
  "mappings": ";AAIA,YAAY,UAAU;AAyBtB,IAAM,WAAN,MAAM,UAAQ;EACZ,OAAO,QAAQ;IACb,SAAS;IACT,KAAK;;EAGP;EACA;EACA;EACA;EAEA,YAAY,IAAU;AACpB,SAAK,MAAM;AACX,SAAK,kBAAkB;AACvB,SAAK,aAAa,CAAA;AAClB,SAAK,eAAe,CAAA;EACtB;EAEA,IAAI,KAAE;AACJ,WAAO,KAAK;EACd;EAEA,IAAI,OAAI;AACN,UAAM,IAAS,kBAAa,eAAe;EAC7C;;;;EAKA,IAAI,YAAS;AACX,UAAM,IAAS,kBAAa,eAAe;EAC7C;;;;EAKA,IAAI,UAAO;AACT,UAAM,IAAS,kBAAa,eAAe;EAC7C;EAEA,kBAAkB,OAAc;AAC9B,SAAK,kBAAkB;EACzB;EAEA,iBAAc;AACZ,WAAO,KAAK;EACd;EAEA,gBAAa;AACX,WAAO,KAAK,WAAW,MAAK;EAC9B;EAEA,wBAAqB;AACnB,WAAO,KAAK,WAAW;EACzB;EAEA,kBAAe;AACb,WAAO,KAAK,aAAa,MAAK;EAChC;EAEA,0BAAuB;AACrB,WAAO,KAAK,aAAa;EAC3B;EAEA,cAAW;AACT,QAAI,WAAW;AACf,WAAO,SAAS,aAAa,QAAQ;AACnC,iBAAW,SAAS,aAAa,CAAC;IACpC;AAEA,WAAO;EACT;EAEA,aAAa,MAAU;AACrB,SAAK,cAAc,IAAwB;EAC7C;EAEA,cAAc,MAAU;AAEtB,QAAI,SAAS,MAAM;AACjB,YAAM,IAAS,kBAAa,iCAAiC;IAC/D;AAEA,QAAI,KAAK,aAAa,SAAS,IAAI,GAAG;AACpC;IACF;AAEA,SAAK,WAAW,KAAK,IAAwB;AAC7C,SAAK,aAAa,KAAK,IAAI;EAC7B;EAEA,gBAAgB,MAAU;AACxB,SAAK,iBAAiB,IAAwB;EAChD;EAEA,iBAAiB,MAAU;AACzB,QAAI,CAAC,KAAK,aAAa,SAAS,IAAI,GAAG;AACrC;IACF;AAEA,UAAM,YAAY,KAAK,WAAW,QAAQ,IAAwB;AAClE,SAAK,WAAW,OAAO,WAAW,CAAC;AACnC,SAAK,aAAa,OAAO,KAAK,aAAa,QAAQ,IAAI,GAAG,CAAC;EAC7D;;EAGA,wBAAqB;AACnB,eAAW,QAAQ,KAAK,aAAa,MAAK,GAAI;AAC5C,WAAK,iBAAiB,IAAI;IAC5B;EACF;;;;;;EAOA,cAAc,MAAiB;AAC7B,QAAI,oBAAoB;AACxB,SAAK,SACD,iBAAc;AACZ,UAAI,mBAAmB;AACrB;MACF;AACA,0BAAoB,gBAAgB;IACtC,GACA,iBAAc;AAEZ,UAAI,mBAAmB;AACrB,eAAO,CAAA;MACT;AAEA,aAAO,YAAY,gBAAe;IACpC,CAAC;AAEL,WAAO;EACT;;;;EAKA,4BAAyB;AACvB,UAAM,OAAO,IAAI,UAAS,KAAK,EAAE;AACjC,SAAK,kBAAkB,KAAK,eAAe;AAC3C,WAAO;EACT;;;;;;;;;;EAWA,uBAAuB,WAAmC;AACxD,UAAM,WAAW,KAAK,YAAW;AAEjC,UAAM,sBAAsB,oBAAI,IAAG;AAGnC,aAAS,SAAS,UAAO;AACvB,UAAI,oBAAoB,IAAI,KAAK,EAAE,GAAG;AACpC;MACF;AAEA,UAAI,cAAc,QAAW;AAE3B,4BAAoB,IAAI,KAAK,IAAI,KAAK,0BAAyB,CAAE;AACjE;MACF;AAEA,UAAI,UAAU,IAAI,GAAG;AAEnB,aAAK;UACD,CAAAA,UAAQ,oBAAoB,IAAIA,MAAK,IAAIA,MAAK,0BAAyB,CAAE;;UAEzE,CAAAA,UAAQA,MAAK,aAAa,OAAO,YAAU,CAAC,oBAAoB,IAAI,OAAO,EAAE,CAAC;QAAC;MAErF;IACF,CAAC;AAGD,aAAS,SAAS,kBAAe;AAC/B,YAAM,aAAa,oBAAoB,IAAI,aAAa,EAAE;AAC1D,UAAI,CAAC,YAAY;AACf;MACF;AAEA,iBAAW,cAAc,aAAa,cAAc;AAClD,cAAM,mBAAmB,oBAAoB,IAAI,WAAW,EAAE;AAC9D,YAAI,CAAC,kBAAkB;AACrB,gBAAM,IAAS,kBAAa,+BAA+B;QAC7D;AACA,mBAAW,cAAc,gBAAgB;MAC3C;IACF,CAAC;AAED,UAAM,iBAAiB,oBAAoB,IAAI,KAAK,EAAE;AACtD,QAAI,CAAC,gBAAgB;AACnB,YAAM,IAAS,kBAAa,2BAA2B;IACzD;AACA,WAAO;EACT;;;;;;;;;EAUA,SACI,UACA,cAAgD;AAClD,eAAW,EAAC,MAAM,cAAa,KAAK,KAAK,kBAAkB,YAAY,GAAG;AACxE,eAAS,MAAM,aAAa;IAC9B;EACF;;;;;EAMA,CAAC,kBAAkB,cAAqC;AAGtD,QAAI,CAAC,cAAc;AACjB,qBAAe,UAAQ,KAAK,cAAa;IAC3C;AAGA,UAAM,QAAkB,CAAC,CAAC,IAAI,CAAC;AAC/B,UAAM,UAAU,oBAAI,IAAI,CAAC,KAAK,EAAE,CAAC;AAEjC,WAAO,MAAM,QAAQ;AAEnB,YAAM,gBAAwB,MAAM,MAAK;AACzC,YAAM,OAAO,cAAc,CAAC;AAC5B,YAAM,EAAC,MAAM,cAAa;AAE1B,iBAAW,YAAY,aAAa,IAAI,GAAG;AACzC,YAAI,QAAQ,IAAI,SAAS,EAAE,GAAG;AAC5B;QACF;AACA,gBAAQ,IAAI,SAAS,EAAE;AAEvB,cAAM,KAAK,CAAC,UAAU,GAAG,aAAa,CAAC;MACzC;IACF;EACF;;;;;;;EAQA,OAAO,UAAU,MAAY,YAAgD,QAAM;AAEjF,QAAI,cAAc,QAAQ;AACxB,aAAO,UAAS,UAAU,MAAM,YAAY,KAAK,UAAS,UAAU,MAAM,cAAc;IAC1F;AAEA,UAAM,UAAU,oBAAI,IAAG;AACvB,UAAM,cAA0B,CAAA;AAChC,UAAM,UAAU,CAAC,IAAI;AACrB,UAAM,aAAa,oBAAI,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;AAGtC,WAAO,QAAQ,QAAQ;AAGrB,YAAM,cAAwB,QAAQ,IAAG;AAGzC,UAAI,YAAY,SAAS,WAAW,GAAG;AACrC,eAAO;MACT;AAEA,UAAI,QAAQ,IAAI,WAAW,GAAG;AAC5B;MACF;AAIA,aAAO,YAAY,SAAS,WAAW,IAAI,WAAW,GAAG;AACvD,oBAAY,IAAG;MACjB;AAGA,cAAQ,IAAI,WAAW;AACvB,kBAAY,KAAK,WAAW;AAG5B,YAAM,iBAAiB,cAAc,eAAe,YAAY,aAAa,YAAY;AACzF,iBAAW,YAAY,gBAAgB;AACrC,YAAI,QAAQ,SAAS,QAAQ,GAAG;AAC9B;QACF;AACA,gBAAQ,KAAK,QAAQ;AACrB,mBAAW,IAAI,UAAU,YAAY,MAAM;MAC7C;IACF;AAEA,WAAO;EACT;EAEA,YAAY,MAAU;AACpB,WAAO,KAAK,aAAa,KAAK;EAChC;;;;AC7UF,IAAM,UAAN,MAAM,iBAA8C,SAAW;EAC7D;EACA;EACA;EAEA,YAAY,aAAiC,cAAoC,CAAA,GAAI,gBAAuB;AAC1G,UAAM,SAAS,GAAG,YAAY,GAAG,IAAI,YAAY,EAAE;AACnD,UAAM,MAAM;AAEZ,SAAK,SAAS;AACd,SAAK,eAAe;AACpB,SAAK,iBAAiB;EACxB;EAEA,IAAa,OAAI;AACf,WAAO,SAAS,MAAM;EACxB;EAEA,IAAa,YAAS;AACpB,WAAO,KAAK,OAAO;EACrB;EAEA,IAAa,UAAO;AAClB,QAAI,KAAK,gBAAgB;AACvB,aAAO,KAAK;IACd;AACA,WAAO,KAAK,OAAO,KAAK,KAAK,OAAO;EACtC;EAEA,IAAI,WAAQ;AACV,WAAO,KAAK,UAAU,KAAK;EAC7B;EAEA,IAAI,QAAK;AACP,WAAO,KAAK;EACd;EAEA,IAAI,cAAW;AACb,WAAO,KAAK;EACd;;;;EAKA,mBAAgB;AACd,WAAO,KAAK,aAAa,KAAK,SAAO,IAAI,SAAS,QAAQ;EAC5D;;;;EAKA,wBAAqB;AACnB,UAAM,OAAO,oBAAI,IAAG;AACpB,eAAW,SAAS,KAAK,cAAc;AACrC,UAAI,MAAM,SAAS,kBAAkB;AACnC;MACF;AACA,UAAI,CAAC,MAAM,KAAK,MAAM,KAAK;AACzB;MACF;AACA,WAAK,IAAI,MAAM,KAAK,KAAK,GAAG;IAC9B;AAEA,WAAO;EACT;EAES,4BAAyB;AAChC,WAAO,IAAI,SAAQ,KAAK,QAAQ,KAAK,cAAc,KAAK,cAAc;EACxE;;;;ACpEF,IAAM,sBAAsB;EAC1B;;EACA;;EACA;;EACA;;EACA;;EACA;;AAaF,SAAS,qBAAqB,UAAgB;AAE5C,QAAM,YAAY,SAAS,SAAS,GAAG,IAAI,SAAS,MAAM,GAAG,SAAS,QAAQ,GAAG,CAAC,IAAI;AACtF,SAAO,oBAAoB,SAAS,SAAS;AAC/C;AAEA,IAAM,cAAN,MAAM,qBAAkD,SAAW;EACjE;EAEA,YAAY,gBAAyC;AACnD,UAAM,eAAe,SAAS;AAC9B,SAAK,WAAW;EAClB;EAEA,IAAa,OAAI;AACf,WAAO,SAAS,MAAM;EACxB;EAEA,IAAa,YAAS;AACpB,WAAO,KAAK,SAAS,oBAAoB;EAC3C;EAEA,IAAa,UAAO;AAClB,WAAO,KAAK,SAAS,iBAAiB;EACxC;EAEA,IAAI,aAAU;AACZ,WAAO,KAAK,SAAS;EACvB;EAEA,IAAI,UAAO;AACT,WAAO,KAAK;EACd;EAEA,IAAI,gBAAa;AACf,WAAO,KAAK,SAAS,UAAU;EACjC;EAEA,IAAI,gBAAa;AACf,WAAO,QAAQ,KAAK,SAAS,aAAa;EAC5C;EAEA,IAAI,uBAAoB;AAEtB,WAAO,qBAAqB,KAAK,QAAQ,QAAQ;IAE7C,qBAAqB,KAAK,QAAQ,UAAU,MAAM;EACxD;;;;;EAMA,IAAI,mBAAgB;AAClB,WAAO,KAAK,iBAAiB,KAAK;EACpC;EAEA,4BAAyB;AACvB,UAAM,WAAW,KAAK,SAAS;AAC/B,UAAM,WAAW,KAAK,SAAS,iBAAiB;AAChD,UAAM,aAAa,KAAK,SAAS,iBAAiB;AAClD,UAAM,mBAAmB,aAAa,UAAU;AAChD,UAAM,uBAAuB,aAAa,UAAU;AACpD,WAAO,aAAa,cAAc,oBAAoB;EACxD;EAES,4BAAyB;AAChC,UAAM,OAAO,IAAI,aAAY,KAAK,QAAQ;AAC1C,SAAK,kBAAkB,KAAK,eAAe;AAC3C,WAAO;EACT;;;;AC7FF,YAAYC,WAAU;AAQtB,IAAM,4BAA4B;AAElC,IAAM,8BAA8B;AAEpC,IAAM,8BAA8B;AAEpC,IAAM,8BAA8B;AAUpC,IAAM,+BAA+B;AAIrC,IAAM,2BAA2B;AAEjC,IAAM,sBAAN,MAAM,qBAAmB;EACvB,OAAO,qBAAqB,SAA+B;AACzD,QAAI,CAAC,QAAQ,WAAW;AACtB,aAAO,CAAA;IACT;AACA,QAAI,QAAQ,UAAU,KAAK;AACzB,aAAO,CAAC,QAAQ,UAAU,GAAG;IAC/B;AACA,QAAI,QAAQ,UAAU,SAAS,UAAU;AAIvC,YAAM,aAAa,oBAAI,IAAG;AAC1B,UAAI,QAAQ,QAAQ,UAAU;AAC9B,aAAO,OAAO;AACZ,cAAM,aAAa,MAAM,cAAc,CAAA;AACvC,mBAAW,SAAS,YAAY;AAC9B,cAAI,MAAM,KAAK;AACb,uBAAW,IAAI,MAAM,GAAG;UAC1B;QACF;AAEA,gBAAQ,MAAM;MAChB;AAEA,aAAO,MAAM,KAAK,UAAU;IAC9B;AAEA,WAAO,CAAA;EACT;EAEA,OAAO,qBAAqB,iBAAyC;AACnE,UAAM,QAAuB,CAAA;AAC7B,UAAM,cAAc,oBAAI,IAAG;AAC3B,UAAM,eAAe,oBAAI,IAAG;AAC5B,UAAM,mBAAmB,oBAAI,IAAG;AAEhC,oBAAgB,QAAQ,aAAU;AAChC,UAAI,yBAAyB,KAAK,QAAQ,QAAQ,GAAG;AACnD;MACF;AACA,UAAI,QAAQ,YAAY;AACtB;MACF;AAMA,aAAO,YAAY,IAAI,QAAQ,SAAS,GAAG;AACzC,gBAAQ,aAAa;MACvB;AAEA,YAAM,OAAO,IAAI,YAAY,OAAO;AACpC,YAAM,KAAK,IAAI;AAEf,YAAM,UAAU,aAAa,IAAI,QAAQ,GAAG,KAAK,CAAA;AACjD,cAAQ,KAAK,IAAI;AAEjB,kBAAY,IAAI,QAAQ,WAAW,IAAI;AACvC,mBAAa,IAAI,QAAQ,KAAK,OAAO;AAIrC,UAAI,QAAQ,WAAW,QAAQ,iBAAiB,cAAc,QAAQ,gBAAgB,QAAQ,KAAK;AAEjG,cAAM,QAAQ,iBAAiB,IAAI,QAAQ,OAAO,IAAI,OAAO;AAC7D,yBAAiB,IAAI,QAAQ,SAAS,KAAK;MAC7C;IACF,CAAC;AAED,WAAO,EAAC,OAAO,aAAa,cAAc,iBAAgB;EAC5D;EAEA,OAAO,mBAAmB,KAAuB;AAC/C,WAAO,IAAI,SAAS,6BAA6B,IAAI,SAAS,+BAC1D,IAAI,SAAS,+BAA+B,IAAI,SAAS;EAC/D;;;;;EAMA,OAAO,wBAAwB,QAA4B;AACzD,UAAM,kBAAkB,OAAO,KAAK,KAAK,kBAAkB;AAC3D,QAAI,CAAC,iBAAiB;AACpB,YAAM,IAAS,mBAAa,qCAAqC;IACnE;EACF;EAEA,OAAO,YAAY,kBAAsC;AACvD,UAAM,QAAmB,CAAA;AACzB,QAAI,IAAI;AAER,yBAAoB,wBAAwB,gBAAgB;AAE5D,WAAO,IAAI,iBAAiB,QAAQ;AAClC,YAAM,MAAM,iBAAiB,CAAC;AAC9B;AAGA,UAAI,CAAC,qBAAoB,mBAAmB,GAAG,KAAK,CAAC,IAAI,KAAK;AAC5D;MACF;AAEA,UAAI,iBAAmC;AAGvC,YAAM,WAAiC,CAAA;AACvC,iBAAW,UAAU,IAAI,KAAK,IAAI,KAAK,IAAI,iBAAiB,UAAU,iBAAiB,CAAC,EAAE,KAAK,SAAS,KAAK;AAC3G,cAAM,QAAQ,iBAAiB,CAAC;AAMhC,YAAI,qBAAoB,mBAAmB,KAAK,KAAK,MAAM,KAAK;AAC9D,2BAAiB,MAAM,KAAK;AAC5B;QACF;AAEA,iBAAS,KAAK,KAAK;MACrB;AAEA,YAAM,KAAK,IAAI,QAAQ,KAAK,UAAU,cAAc,CAAC;IACvD;AAEA,WAAO;EACT;EAEA,OAAO,iBAAiB,UAAuB,mBAAoC;AACjF,sBAAkB,MAAM,QAAQ,UAAO;AACrC,YAAM,yBAAyB,KAAK,QAAQ,oBAAoB,SAAS;AACzE,YAAM,sBAAsB,kBAAkB,YAAY,IAAI,uBAAuB,SAAS,KAAK;AACnG,YAAM,uBAAuB,CAAC,oBAAoB,cAAc,IAAI,KAAK,KAAK,YAAY,mBAAmB;AAC7G,YAAM,aAAa,qBAAoB,qBAAqB,KAAK,OAAO;AACxE,UAAI,WAAW,QAAQ;AACrB,mBAAW,QAAQ,eAAY;AAC7B,gBAAM,mBAAmB,kBAAkB,aAAa,IAAI,SAAS,KAAK,CAAA;AAE1E,cAAI,iBAAiB,WAAW,KAAK,iBAAiB,CAAC,EAAE,aAAa,KAAK,aACvE,CAAC,iBAAiB,CAAC,EAAE,cAAc,IAAI,GAAG;AAC5C,iBAAK,cAAc,iBAAiB,CAAC,CAAC;UACxC,WAAW,sBAAsB;AAC/B,gCAAoB,aAAa,IAAI;UACvC;QACF,CAAC;MACH,WAAW,sBAAsB;AAC/B,4BAAoB,aAAa,IAAI;MACvC;AAGA,UAAI,SAAS,YAAY,KAAK,gBAAe,EAAG,WAAW,KAAK,KAAK,YAAY,QAAQ,GAAG;AAC1F,aAAK,cAAc,QAAQ;MAC7B;AAEA,UAAI,CAAC,KAAK,QAAQ,WAAW;AAC3B;MACF;AAEA,YAAM,YAAY,CAAC,GAAG,KAAK,QAAQ,WAAW,KAAK,OAAO;AAC1D,eAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACzC,cAAM,eAAe,kBAAkB,YAAY,IAAI,UAAU,IAAI,CAAC,EAAE,SAAS;AACjF,cAAM,aAAa,kBAAkB,YAAY,IAAI,UAAU,CAAC,EAAE,SAAS;AAC3E,YAAI,cAAc,cAAc;AAC9B,qBAAW,cAAc,YAAY;QACvC;MACF;IACF,CAAC;EACH;EAEA,OAAO,aAAa,UAAgB,mBAAsC,UAAmB;AAC3F,UAAM,wBAAwB,oBAAI,IAAoC;MACpE;MACA;MACA;KACD;AAED,aAAS,2BAA2B,SAAkB,OAAa;AACjE,YAAM,cAAc,kBAAkB,YAAY,IAAI,KAAK;AAC3D,UAAI,CAAC;;MAGD,YAAY,aAAa,QAAQ,WAAW;AAC9C;MACF;AACA,YAAM,EAAC,QAAO,IAAI;AAClB,YAAM,eAAe,QAAQ,gBAAgB,QAAQ,qBAAqB;AAC1E,UAAI,CAAC,sBAAsB,IAAI,YAAY,GAAG;AAG5C;MACF;AACA,cAAQ,aAAa,WAAW;IAClC;AAMA,aAAS,qBAAqB,SAAkB,SAAyB;AACvE,UAAI,CAAC,SAAS;AACZ;MACF;AACA,YAAM,cAAc,kBAAkB,iBAAiB,IAAI,OAAO;AAClE,UAAI,CAAC,aAAa;AAChB;MACF;AAGA,UAAI,YAAY,aAAa,QAAQ,WAAW;AAC9C;MACF;AACA,cAAQ,cAAc,WAAW;IACnC;AAEA,aAAS,mBAAmB,SAAkB,KAAW;AACvD,UAAI,CAAC,KAAK;AACR;MACF;AAGA,YAAM,0CAA0C,OAAO;AACvD,YAAM,aAAa,kBAAkB,aAAa,IAAI,GAAG,KAAK,CAAA;AAE9D,UAAI,eAAe;AACnB,UAAI,cAAc;AAElB,iBAAW,aAAa,YAAY;AAGlC,YAAI,QAAQ,aAAa,UAAU,WAAW;AAC5C;QACF;AAEA,cAAM,WAAW,QAAQ,YAAY,UAAU;AAC/C,YAAI,YAAY,2CAA2C,WAAW,aAAa;AACjF,yBAAe;AACf,wBAAc;QAChB;MACF;AAEA,UAAI,CAAC,cAAc;AACjB;MACF;AACA,cAAQ,cAAc,YAAY;IACpC;AAEA,UAAM,SAAS,oBAAI,IAAG;AACtB,eAAW,QAAQ,UAAU;AAC3B,iBAAW,OAAO,KAAK,aAAa;AAClC,YAAI,CAAC,IAAI,KAAK,MAAM;AAClB;QACF;AAEA,cAAM,UAAU,IAAI,KAAK,KAAK;AAC9B,cAAM,kBAAkB,IAAI,KAAK,KAAK,cAAc,CAAA,GAAI,IAAI,OAAK,EAAE,GAAG,EAAE,OAAO,OAAO;AAEtF,gBAAQ,IAAI,MAAM;UAChB,KAAK;AAEH,mBAAO,IAAI,IAAI,KAAK,KAAK,SAAS,IAAI;AACtC,2BAAe,QAAQ,SAAO,mBAAmB,MAAM,GAAG,CAAC;AAC3D;UACF,KAAK,aAAa;AAEhB,kBAAM,YAAY,OAAO,IAAI,IAAI,KAAK,KAAK,OAAO;AAClD,gBAAI,CAAC,aAAa,UAAU,UAAU,KAAK,WAAW;AACpD;YACF;AACA,sBAAU,aAAa,IAAI;AAC3B;UACF;UAEA,KAAK;UACL,KAAK;AACH,iCAAqB,MAAM,IAAI,KAAK,KAAK,KAAK;AAC9C,2BAAe,QAAQ,SAAO,mBAAmB,MAAM,GAAG,CAAC;AAC3D;UAEF,KAAK;AACH,iCAAqB,MAAM,IAAI,KAAK,KAAK,KAAK;AAE9C,+BAAmB,MAAM,OAAO;AAChC,2BAAe,QAAQ,SAAO,mBAAmB,MAAM,GAAG,CAAC;AAC3D;UAEF,KAAK;AAGH,gBAAI,IAAI,KAAK,KAAK,eAAe,GAAG;AAClC;YACF;AAGA,+BAAmB,MAAM,OAAO;AAChC,2BAAe,QAAQ,SAAO,mBAAmB,MAAM,GAAG,CAAC;AAC3D;UAEF,KAAK;UACL,KAAK;AACH,iCAAqB,MAAM,IAAI,KAAK,KAAK,KAAK;AAE9C,+BAAmB,MAAM,OAAO;AAChC;UAEF,KAAK;AACH,iCAAqB,MAAM,IAAI,KAAK,KAAK,KAAK;AAE9C,+BAAmB,MAAM,IAAI,KAAK,KAAK,aAAa;AACpD;UAEF,KAAK;AACH,iCAAqB,MAAM,IAAI,KAAK,KAAK,KAAK;AAE9C,uCAA2B,MAAM,IAAI,KAAK,KAAK,SAAS;AACxD,2BAAe,QAAQ,SAAO,mBAAmB,MAAM,GAAG,CAAC;AAC3D;QACJ;MACF;AAGA,UAAI,KAAK,wBAAuB,MAAO,KAAK,KAAK,YAAY,QAAQ,GAAG;AACtE,aAAK,cAAc,QAAQ;MAC7B;IACF;AAGA,UAAM,gBAAgB,+BAA+B;AACrD,QAAI,mBAAmB;AACvB,QAAI,kBAAkB;AACtB,QAAI,kBAAkB;AAEtB,eAAW,QAAQ,UAAU;AAG3B,UAAI,UAAU;AACd,UAAI,CAAC,oBAAoB,KAAK,YAAY,KAAK,SAAO,IAAI,SAAS,QAAQ,GAAG;AAC5E,kBAAU,mBAAmB;MAC/B;AACA,UAAI,CAAC,mBAAmB,KAAK,YAAY,KAAK,SAAO,IAAI,SAAS,OAAO,GAAG;AAC1E,kBAAU,kBAAkB;MAC9B;AACA,UAAI,CAAC,mBAAmB,KAAK,YAAY,KAAK,SAAO,IAAI,SAAS,WAAW,GAAG;AAC9E,kBAAU,kBAAkB;MAC9B;AAEA,UAAI,WAAW,KAAK,YAAY,eAAe;AAE7C;MACF;AAKA,UAAI,KAAK,wBAAuB,MAAO,KAAK,KAAK,sBAAqB,KAAM,GAAG;AAC7E,6BAAoB,UAAU,IAAI;MACpC;IACF;EACF;;;;;EAMA,OAAO,UAAU,MAAU;AACzB,UAAM,eAAe,KAAK,gBAAe;AACzC,UAAM,aAAa,KAAK,cAAa;AACrC,eAAW,cAAc,cAAc;AACrC,WAAK,iBAAiB,UAAU;AAChC,iBAAW,aAAa,YAAY;AAClC,mBAAW,aAAa,SAAS;MACnC;IACF;AACA,eAAW,aAAa,YAAY;AAClC,WAAK,gBAAgB,SAAS;IAChC;EACF;;;;;;;;;;;;EAaA,OAAO,uBAAuB,iBAAyC;AACrE,eAAW,WAAW,iBAAiB;AACrC,cAAQ,oBAAoB,KAAK,MAAM,QAAQ,oBAAoB,GAAI,IAAI;AAC3E,cAAQ,qBAAqB,KAAK,MAAM,QAAQ,qBAAqB,GAAI,IAAI;AAC7E,cAAQ,yBAAyB,KAAK,MAAM,QAAQ,yBAAyB,GAAI,IAAI;AACrF,cAAQ,iBAAiB,KAAK,MAAM,QAAQ,iBAAiB,GAAI,IAAI;IACvE;AAEA,eAAW,KAAK,iBAAiB;AAC/B,aAAO,EAAE;AACT,UAAI,EAAE,kBAAkB;AAEtB,UAAE,mBAAmB,EAAC,IAAI,EAAE,iBAAiB,UAAS;MACxD;AACA,UAAI,EAAE,qBAAqB;AAEzB,UAAE,sBAAsB,EAAC,IAAI,EAAE,oBAAoB,UAAS;MAC9D;AACA,UAAI,EAAE,gBAAgB;AAEpB,UAAE,iBAAiB,EAAC,IAAI,EAAE,eAAe,UAAS;MACpD;AACA,UAAI,EAAE,WAAW;AAEf,UAAE,YAAY,EAAE,UAAU,IAAI,QAAM,GAAG,SAAS;MAClD;IACF;AACA,UAAM,WAAqC,gBACK,IAAI,QAAM;MACJ,WAAW,EAAE;MACb,cAAc,EAAE;MAChB,kBAAkB,EAAE;MACpB,KAAK,EAAE;MACP,UAAU,EAAE;MACZ,WAAW,EAAE;MACb,aAAa,EAAE;MACf,mBAAmB,EAAE;MACrB,oBAAoB,EAAE;MACtB,wBAAwB,EAAE;MAC1B,gBAAgB,EAAE;MAClB,cAAc,EAAE;MAChB,cAAc,EAAE;MAChB,eAAe,EAAE;MACjB,iBAAiB,EAAE;MACnB,UAAU,EAAE;MACZ,YAAY,EAAE;MACd,gBAAgB,EAAE;MAClB,qBAAqB,EAAE;MACvB,WAAW,EAAE;MACb,QAAQ,EAAE;MACV,WAAW,EAAE;MACb,QAAQ,EAAE,SAAS;QACjB,aAAa,EAAE,OAAO;QACtB,YAAY,EAAE,OAAO;QACrB,UAAU,EAAE,OAAO;QACnB,UAAU,EAAE,OAAO;QACnB,QAAQ,EAAE,OAAO;QACjB,cAAc,EAAE,OAAO;QACvB,YAAY,EAAE,OAAO;QACrB,UAAU,EAAE,OAAO;QACnB,QAAQ,EAAE,OAAO;QACjB,aAAa,EAAE,OAAO;QACtB,aAAa,EAAE,OAAO;QACtB,kBAAkB,EAAE,OAAO;QAC3B,0BAA0B,EAAE,OAAO;QACnC,WAAW,EAAE,OAAO;QACpB,SAAS,EAAE,OAAO;QAClB,WAAW,EAAE,OAAO;QACpB,SAAS,EAAE,OAAO;QAClB,qBAAqB,EAAE,OAAO;QAC9B,mBAAmB,EAAE,OAAO;UAEX,EAAE;MACrB,cAAc,EAAE;MAChB,UAAU,EAAE;MACZ,UAAU,EAAE;MACZ,kBAAkB,EAAE;MACpB,SAAS,EAAE;MACX,YAAY,EAAE;MACd,eAAe,EAAE;MACjB,oBAAoB,EAAE;MACtB,EACN,OAAO,OAAK,CAAC,EAAE,UAAU;AAEzE,UAAM,QAAQ;AAId,YAAQ,IAAI,KAAK;EACnB;EAEA,OAAO,YACH,kBAAwC,iBACxC,KAA2B;AAG7B,UAAM,oBAAoB,qBAAoB,qBAAqB,eAAe;AAClF,UAAM,WAAW,qBAAoB,YAAY,gBAAgB;AACjE,UAAM,EAAC,cAAc,gBAAe,IAAI;AACxC,QAAI,CAAC,cAAc;AACjB,YAAM,IAAS,mBAAa,kDAAkD;IAChF;AACA,QAAI,CAAC,iBAAiB;AACpB,YAAM,IAAS,mBAAa,sDAAsD;IACpF;AAEA,UAAM,cAAmB,sBAAgB,mBAAmB,iBAAiB,YAAY;AACzF,QAAI,CAAC,aAAa;AAChB,YAAM,IAAS,mBAAa,uBAAuB;IACrD;AACA,UAAM,WAAW,kBAAkB,YAAY,IAAI,YAAY,SAAS;AACxE,QAAI,CAAC,UAAU;AACb,YAAM,IAAS,mBAAa,oBAAoB;IAClD;AACA,UAAM,sBAA2B,sBAAgB,uBAAuB,iBAAiB,eAAe;AACxG,QAAI,CAAC,qBAAqB;AACxB,YAAM,IAAS,mBAAa,+BAA+B;IAC7D;AACA,UAAM,mBAAmB,kBAAkB,YAAY,IAAI,oBAAoB,SAAS;AACxF,QAAI,CAAC,kBAAkB;AACrB,YAAM,IAAS,mBAAa,4BAA4B;IAC1D;AAEA,yBAAoB,iBAAiB,UAAU,iBAAiB;AAChE,yBAAoB,aAAa,UAAU,mBAAmB,QAAQ;AACtE,qBAAiB,kBAAkB,IAAI;AAEvC,QAAI,YAAY,UAAU,QAAQ,GAAG;AAGnC,YAAM,IAAS,mBAAa,kDAAkD;IAChF;AAEA,WAAO;EACT;;EAGA,OAAO,WAAW,UAAgB,oBAAoB,IAAE;AACtD,aAAS,SAAS,KAAa,QAAgB,UAAU,KAAG;AAC1D,aAAO,MAAM,QAAQ,OAAO,KAAK,IAAI,SAAS,IAAI,QAAQ,CAAC,CAAC;IAC9D;AAEA,UAAM,QAAgB,CAAA;AACtB,aAAS,SAAS,UAAQ,MAAM,KAAK,IAAI,CAAC;AAC1C,UAAM,KAAK,CAAC,GAAG,MAAM,EAAE,YAAY,EAAE,SAAS;AAG9C,UAAM,cAAc,oBAAI,IAAG;AAC3B,aAAS,SAAS,UAAO;AACvB,YAAM,QAAQ,KAAK,YAAY;AAC/B,UAAI;AACJ,UAAI,QAAQ,IAAI;AACd,gBAAQ,IAAI,QAAQ,EAAE;MACxB,OAAO;AACL,gBAAQ,OAAO,aAAa,KAAK;MACnC;AACA,kBAAY,IAAI,MAAM,KAAK;IAC7B,CAAC;AAED,UAAM,MAAM,MAAM,CAAC,EAAE;AACrB,UAAM,MAAM,MAAM,OAAO,CAACC,MAAK,SAAS,KAAK,IAAIA,MAAK,KAAK,OAAO,GAAG,CAAC;AAEtE,UAAM,YAAY,MAAM;AACxB,UAAM,mBAAmB,YAAY;AACrC,UAAM,QAAQ,UAAO;AACnB,YAAM,SAAS,KAAK,OAAO,KAAK,YAAY,OAAO,gBAAgB;AACnE,YAAM,SAAS,KAAK,MAAM,KAAK,UAAU,KAAK,aAAa,gBAAgB;AAC3E,YAAM,MAAM,SAAS,IAAI,MAAM,IAAI,SAAS,IAAI,QAAQ,GAAG;AAG3D,YAAM,cAAc,KAAK,UAAU,KAAK,QAAQ,MAAM,KAAK;AAE3D,cAAQ,IAAI,SAAS,KAAK,iBAAiB,GAAG,KAAK,YAAY,MAAM,GAAG,EAAE,CAAC,EAAE;IAC/E,CAAC;AAKD,YAAQ,IAAG;AAGX,UAAM,QAAQ,UAAO;AAEnB,YAAM,cAAc,KAAK,UAAU,KAAK,QAAQ,MAAM,KAAK;AAE3D,cAAQ,IAAI,YAAY,IAAI,IAAI,GAAG,YAAY,MAAM,GAAG,oBAAoB,CAAC,CAAC;AAE9E,iBAAW,SAAS,KAAK,YAAY;AAEnC,cAAMC,eAAc,MAAM,UAAU,MAAM,QAAQ,MAAM,MAAM;AAE9D,gBAAQ,IAAI,QAAQ,YAAY,IAAI,KAAK,GAAGA,aAAY,MAAM,GAAG,oBAAoB,EAAE,CAAC;MAC1F;AAGA,cAAQ,IAAG;IACb,CAAC;AAGD,UAAM,YAAY,YAAY,UAAU,QAAQ;AAEhD,YAAQ,IAAI,UAAU,YAAY,QAAQ,IAAI;AAC9C,QAAI,WAAW;AACb,YAAM,OAAO,CAAC,GAAG,SAAS;AAC1B,WAAK,KAAK,KAAK,CAAC,CAAC;AAEjB,cAAQ,IAAI,KAAK,IAAI,UAAQ,YAAY,IAAI,IAAI,CAAC,EAAE,KAAK,MAAM,CAAC;IAClE;EACF;;",
  "names": ["node", "Core", "max", "displayName"]
}
