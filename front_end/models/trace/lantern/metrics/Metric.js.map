{"version":3,"file":"Metric.js","sourceRoot":"","sources":["../../../../../../../../front_end/models/trace/lantern/metrics/Metric.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Core from '../core/core.js';\nimport * as Graph from '../graph/graph.js';\nimport type * as Simulation from '../simulation/simulation.js';\nimport type * as Types from '../types/types.js';\n\nexport interface MetricComputationDataInput {\n  simulator: Simulation.Simulator;\n  graph: Graph.Node<unknown>;\n  processedNavigation: Types.Simulation.ProcessedNavigation;\n}\n\nexport interface MetricCoefficients {\n  intercept: number;\n  optimistic: number;\n  pessimistic: number;\n}\n\nexport interface MetricResult<T = Types.AnyNetworkObject> {\n  timing: number;\n  timestamp?: never;\n  optimisticEstimate: Simulation.Result<T>;\n  pessimisticEstimate: Simulation.Result<T>;\n  optimisticGraph: Graph.Node<T>;\n  pessimisticGraph: Graph.Node;\n}\n\nexport interface Extras {\n  optimistic: boolean;\n  fcpResult?: MetricResult;\n  lcpResult?: MetricResult;\n  interactiveResult?: MetricResult;\n  observedSpeedIndex?: number;\n}\n\nclass Metric {\n  static getScriptUrls(dependencyGraph: Graph.Node, treatNodeAsRenderBlocking?: (node: Graph.NetworkNode) => boolean):\n      Set<string> {\n    const scriptUrls = new Set<string>();\n\n    dependencyGraph.traverse(node => {\n      if (node.type !== Graph.BaseNode.types.NETWORK) {\n        return;\n      }\n      if (node.request.resourceType !== 'Script') {\n        return;\n      }\n      if (treatNodeAsRenderBlocking?.(node)) {\n        scriptUrls.add(node.request.url);\n      }\n    });\n\n    return scriptUrls;\n  }\n\n  static get coefficients(): MetricCoefficients {\n    throw new Core.LanternError('coefficients unimplemented!');\n  }\n\n  /**\n   * Returns the coefficients, scaled by the throttling settings if needed by the metric.\n   * Some lantern metrics (speed-index) use components in their estimate that are not\n   * from the simulator. In this case, we need to adjust the coefficients as the target throttling\n   * settings change.\n   */\n  static getScaledCoefficients(_rttMs: number): MetricCoefficients {\n    return this.coefficients;\n  }\n\n  static getOptimisticGraph(_dependencyGraph: Graph.Node, _processedNavigation: Types.Simulation.ProcessedNavigation):\n      Graph.Node {\n    throw new Core.LanternError('Optimistic graph unimplemented!');\n  }\n\n  static getPessimisticGraph(_dependencyGraph: Graph.Node, _processedNavigation: Types.Simulation.ProcessedNavigation):\n      Graph.Node {\n    throw new Core.LanternError('Pessmistic graph unimplemented!');\n  }\n\n  static getEstimateFromSimulation(simulationResult: Simulation.Result, _extras: Extras): Simulation.Result {\n    return simulationResult;\n  }\n\n  static compute(data: MetricComputationDataInput, extras?: Omit<Extras, 'optimistic'>): MetricResult {\n    const {simulator, graph, processedNavigation} = data;\n\n    const metricName = this.name.replace('Lantern', '');\n    const optimisticGraph = this.getOptimisticGraph(graph, processedNavigation);\n    const pessimisticGraph = this.getPessimisticGraph(graph, processedNavigation);\n\n    let simulateOptions = {label: `optimistic${metricName}`};\n    const optimisticSimulation = simulator.simulate(optimisticGraph, simulateOptions);\n\n    simulateOptions = {label: `pessimistic${metricName}`};\n    const pessimisticSimulation = simulator.simulate(pessimisticGraph, simulateOptions);\n\n    const optimisticEstimate = this.getEstimateFromSimulation(\n        optimisticSimulation,\n        {...extras, optimistic: true},\n    );\n\n    const pessimisticEstimate = this.getEstimateFromSimulation(\n        pessimisticSimulation,\n        {...extras, optimistic: false},\n    );\n\n    const coefficients = this.getScaledCoefficients(simulator.rtt);\n    // Estimates under 1s don't really follow the normal curve fit, minimize the impact of the intercept\n    const interceptMultiplier = coefficients.intercept > 0 ? Math.min(1, optimisticEstimate.timeInMs / 1000) : 1;\n    const timing = coefficients.intercept * interceptMultiplier +\n        coefficients.optimistic * optimisticEstimate.timeInMs + coefficients.pessimistic * pessimisticEstimate.timeInMs;\n\n    return {\n      timing,\n      optimisticEstimate,\n      pessimisticEstimate,\n      optimisticGraph,\n      pessimisticGraph,\n    };\n  }\n}\n\nexport {Metric};\n"]}