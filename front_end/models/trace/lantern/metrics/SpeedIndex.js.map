{"version":3,"file":"SpeedIndex.js","sourceRoot":"","sources":["../../../../../../../../front_end/models/trace/lantern/metrics/SpeedIndex.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Core from '../core/core.js';\nimport * as Graph from '../graph/graph.js';\nimport type * as Simulation from '../simulation/simulation.js';\n\nimport {\n  type Extras,\n  Metric,\n  type MetricCoefficients,\n  type MetricComputationDataInput,\n  type MetricResult,\n} from './Metric.js';\n\nconst mobileSlow4GRtt = 150;\n\nclass SpeedIndex extends Metric {\n  static override get coefficients(): MetricCoefficients {\n    return {\n      // Note that the optimistic estimate is based on the real observed speed index rather than a\n      // real lantern graph (and the final estimate will be Math.max(FCP, Speed Index)).\n      intercept: 0,\n      optimistic: 1.4,\n      pessimistic: 0.4,\n    };\n  }\n\n  static override getScaledCoefficients(rttMs: number): MetricCoefficients {\n    // We want to scale our default coefficients based on the speed of the connection.\n    // We will linearly interpolate coefficients for the passed-in rttMs based on two pre-determined points:\n    //   1. Baseline point of 30 ms RTT where Speed Index should be a ~50/50 blend of optimistic/pessimistic.\n    //      30 ms was based on a typical home WiFi connection's actual RTT.\n    //      Coefficients here follow from the fact that the optimistic estimate should be very close\n    //      to reality at this connection speed and the pessimistic estimate compensates for minor\n    //      connection speed differences.\n    //   2. Default throttled point of 150 ms RTT where the default coefficients have been determined to be most accurate.\n    //      Coefficients here were determined through thorough analysis and linear regression on the\n    //      lantern test data set. See core/scripts/test-lantern.sh for more detail.\n    // While the coefficients haven't been analyzed at the interpolated points, it's our current best effort.\n    const defaultCoefficients = this.coefficients;\n    const defaultRttExcess = mobileSlow4GRtt - 30;\n    const multiplier = Math.max((rttMs - 30) / defaultRttExcess, 0);\n\n    return {\n      intercept: defaultCoefficients.intercept * multiplier,\n      optimistic: 0.5 + (defaultCoefficients.optimistic - 0.5) * multiplier,\n      pessimistic: 0.5 + (defaultCoefficients.pessimistic - 0.5) * multiplier,\n    };\n  }\n\n  static override getOptimisticGraph(dependencyGraph: Graph.Node): Graph.Node {\n    return dependencyGraph;\n  }\n\n  static override getPessimisticGraph(dependencyGraph: Graph.Node): Graph.Node {\n    return dependencyGraph;\n  }\n\n  static override getEstimateFromSimulation(simulationResult: Simulation.Result, extras: Extras): Simulation.Result {\n    if (!extras.fcpResult) {\n      throw new Core.LanternError('missing fcpResult');\n    }\n    if (extras.observedSpeedIndex === undefined) {\n      throw new Core.LanternError('missing observedSpeedIndex');\n    }\n\n    const fcpTimeInMs = extras.fcpResult.pessimisticEstimate.timeInMs;\n    const estimate = extras.optimistic ?\n        extras.observedSpeedIndex :\n        SpeedIndex.computeLayoutBasedSpeedIndex(simulationResult.nodeTimings, fcpTimeInMs);\n    return {\n      timeInMs: estimate,\n      nodeTimings: simulationResult.nodeTimings,\n    };\n  }\n\n  static override compute(data: MetricComputationDataInput, extras?: Omit<Extras, 'optimistic'>): MetricResult {\n    const fcpResult = extras?.fcpResult;\n    if (!fcpResult) {\n      throw new Core.LanternError('FCP is required to calculate the SpeedIndex metric');\n    }\n\n    const metricResult = super.compute(data, extras);\n    metricResult.timing = Math.max(metricResult.timing, fcpResult.timing);\n    return metricResult;\n  }\n\n  /**\n   * Approximate speed index using layout events from the simulated node timings.\n   * The layout-based speed index is the weighted average of the endTime of CPU nodes that contained\n   * a 'Layout' task. log(duration) is used as the weight to stand for \"significance\" to the page.\n   *\n   * If no layout events can be found or the endTime of a CPU task is too early, FCP is used instead.\n   *\n   * This approach was determined after evaluating the accuracy/complexity tradeoff of many\n   * different methods. Read more in the evaluation doc.\n   *\n   * @see https://docs.google.com/document/d/1qJWXwxoyVLVadezIp_Tgdk867G3tDNkkVRvUJSH3K1E/edit#\n   */\n  static computeLayoutBasedSpeedIndex(nodeTimings: Simulation.Result['nodeTimings'], fcpTimeInMs: number): number {\n    const layoutWeights: Array<{time: number, weight: number}> = [];\n    for (const [node, timing] of nodeTimings.entries()) {\n      if (node.type !== Graph.BaseNode.types.CPU) {\n        continue;\n      }\n\n      if (node.childEvents.some(x => x.name === 'Layout')) {\n        const timingWeight = Math.max(Math.log2(timing.endTime - timing.startTime), 0);\n        layoutWeights.push({time: timing.endTime, weight: timingWeight});\n      }\n    }\n\n    const totalWeightedTime =\n        layoutWeights.map(evt => evt.weight * Math.max(evt.time, fcpTimeInMs)).reduce((a, b) => a + b, 0);\n    const totalWeight = layoutWeights.map(evt => evt.weight).reduce((a, b) => a + b, 0);\n\n    if (!totalWeight) {\n      return fcpTimeInMs;\n    }\n    return totalWeightedTime / totalWeight;\n  }\n}\n\nexport {SpeedIndex};\n"]}