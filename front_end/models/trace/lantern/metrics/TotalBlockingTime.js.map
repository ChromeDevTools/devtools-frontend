{"version":3,"file":"TotalBlockingTime.js","sourceRoot":"","sources":["../../../../../../../../front_end/models/trace/lantern/metrics/TotalBlockingTime.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Core from '../core/core.js';\nimport * as Graph from '../graph/graph.js';\nimport type * as Simulation from '../simulation/simulation.js';\n\nimport {\n  type Extras,\n  Metric,\n  type MetricCoefficients,\n  type MetricComputationDataInput,\n  type MetricResult,\n} from './Metric.js';\nimport {BLOCKING_TIME_THRESHOLD, calculateSumOfBlockingTime} from './TBTUtils.js';\n\nclass TotalBlockingTime extends Metric {\n  static override get coefficients(): MetricCoefficients {\n    return {\n      intercept: 0,\n      optimistic: 0.5,\n      pessimistic: 0.5,\n    };\n  }\n\n  static override getOptimisticGraph(dependencyGraph: Graph.Node): Graph.Node {\n    return dependencyGraph;\n  }\n\n  static override getPessimisticGraph(dependencyGraph: Graph.Node): Graph.Node {\n    return dependencyGraph;\n  }\n\n  static override getEstimateFromSimulation(simulation: Simulation.Result, extras: Extras): Simulation.Result {\n    if (!extras.fcpResult) {\n      throw new Core.LanternError('missing fcpResult');\n    }\n    if (!extras.interactiveResult) {\n      throw new Core.LanternError('missing interactiveResult');\n    }\n\n    // Intentionally use the opposite FCP estimate. A pessimistic FCP is higher than equal to an\n    // optimistic FCP, which means potentially more tasks are excluded from the Total Blocking Time\n    // computation. So a more pessimistic FCP gives a more optimistic Total Blocking Time for the\n    // same work.\n    const fcpTimeInMs = extras.optimistic ? extras.fcpResult.pessimisticEstimate.timeInMs :\n                                            extras.fcpResult.optimisticEstimate.timeInMs;\n\n    // Similarly, we always have pessimistic TTI >= optimistic TTI. Therefore, picking optimistic\n    // TTI means our window of interest is smaller and thus potentially more tasks are excluded from\n    // Total Blocking Time computation, yielding a lower (more optimistic) Total Blocking Time value\n    // for the same work.\n    const interactiveTimeMs = extras.optimistic ? extras.interactiveResult.optimisticEstimate.timeInMs :\n                                                  extras.interactiveResult.pessimisticEstimate.timeInMs;\n\n    const minDurationMs = BLOCKING_TIME_THRESHOLD;\n\n    const events = TotalBlockingTime.getTopLevelEvents(\n        simulation.nodeTimings,\n        minDurationMs,\n    );\n\n    return {\n      timeInMs: calculateSumOfBlockingTime(\n          events,\n          fcpTimeInMs,\n          interactiveTimeMs,\n          ),\n      nodeTimings: simulation.nodeTimings,\n    };\n  }\n\n  static override compute(data: MetricComputationDataInput, extras?: Omit<Extras, 'optimistic'>): MetricResult {\n    const fcpResult = extras?.fcpResult;\n    if (!fcpResult) {\n      throw new Core.LanternError('FCP is required to calculate the TBT metric');\n    }\n\n    const interactiveResult = extras?.fcpResult;\n    if (!interactiveResult) {\n      throw new Core.LanternError('Interactive is required to calculate the TBT metric');\n    }\n\n    return super.compute(data, extras);\n  }\n\n  static getTopLevelEvents(nodeTimings: Simulation.Result['nodeTimings'], minDurationMs: number):\n      Array<{start: number, end: number, duration: number}> {\n    const events: Array<{start: number, end: number, duration: number}> = [];\n\n    for (const [node, timing] of nodeTimings.entries()) {\n      if (node.type !== Graph.BaseNode.types.CPU) {\n        continue;\n      }\n      // Filtering out events below minimum duration.\n      if (timing.duration < minDurationMs) {\n        continue;\n      }\n\n      events.push({\n        start: timing.startTime,\n        end: timing.endTime,\n        duration: timing.duration,\n      });\n    }\n\n    return events;\n  }\n}\n\nexport {TotalBlockingTime};\n"]}