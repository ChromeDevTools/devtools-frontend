{
  "version": 3,
  "sources": ["../../../../../../../../front_end/models/trace/lantern/metrics/FirstContentfulPaint.ts", "../../../../../../../../front_end/models/trace/lantern/metrics/Metric.ts", "../../../../../../../../front_end/models/trace/lantern/metrics/Interactive.ts", "../../../../../../../../front_end/models/trace/lantern/metrics/LargestContentfulPaint.ts", "../../../../../../../../front_end/models/trace/lantern/metrics/MaxPotentialFID.ts", "../../../../../../../../front_end/models/trace/lantern/metrics/SpeedIndex.ts", "../../../../../../../../front_end/models/trace/lantern/metrics/TotalBlockingTime.ts", "../../../../../../../../front_end/models/trace/lantern/metrics/TBTUtils.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Graph from '../graph/graph.js';\nimport type * as Types from '../types/types.js';\n\nimport {Metric, type MetricCoefficients} from './Metric.js';\n\ninterface FirstPaintBasedGraphOpts<T> {\n  /**\n   * The timestamp used to filter out tasks that occurred after our paint of interest.\n   * Typically this is First Contentful Paint or First Meaningful Paint.\n   */\n  cutoffTimestamp: number;\n  /**\n   * The function that determines which resources should be considered *possibly*\n   * render-blocking.\n   */\n  treatNodeAsRenderBlocking: (node: Graph.NetworkNode<T>) => boolean;\n  /**\n   * The function that determines which CPU nodes should also be included in our\n   * blocking node IDs set, beyond what getRenderBlockingNodeData() already includes.\n   */\n  additionalCpuNodesToTreatAsRenderBlocking?: (node: Graph.CPUNode) => boolean;\n}\n\nclass FirstContentfulPaint extends Metric {\n  static override get coefficients(): MetricCoefficients {\n    return {\n      intercept: 0,\n      optimistic: 0.5,\n      pessimistic: 0.5,\n    };\n  }\n\n  /**\n   * Computes the set of URLs that *appeared* to be render-blocking based on our filter,\n   * *but definitely were not* render-blocking based on the timing of their EvaluateScript task.\n   * It also computes the set of corresponding CPU node ids that were needed for the paint at the\n   * given timestamp.\n   */\n  static getRenderBlockingNodeData<T = unknown>(\n      graph: Graph.Node,\n      {cutoffTimestamp, treatNodeAsRenderBlocking, additionalCpuNodesToTreatAsRenderBlocking}:\n          FirstPaintBasedGraphOpts<T>,\n      ): {definitelyNotRenderBlockingScriptUrls: Set<string>, renderBlockingCpuNodeIds: Set<string>} {\n    /** A map of blocking script URLs to the earliest EvaluateScript task node that executed them. */\n    const scriptUrlToNodeMap = new Map<string, Graph.CPUNode>();\n\n    const cpuNodes: Graph.CPUNode[] = [];\n    graph.traverse(node => {\n      if (node.type === Graph.BaseNode.types.CPU) {\n        // A task is *possibly* render blocking if it *started* before cutoffTimestamp.\n        // We use startTime here because the paint event can be *inside* the task that was render blocking.\n        if (node.startTime <= cutoffTimestamp) {\n          cpuNodes.push(node);\n        }\n\n        // Build our script URL map to find the earliest EvaluateScript task node.\n        const scriptUrls = node.getEvaluateScriptURLs();\n        for (const url of scriptUrls) {\n          // Use the earliest CPU node we find.\n          const existing = scriptUrlToNodeMap.get(url) || node;\n          scriptUrlToNodeMap.set(url, node.startTime < existing.startTime ? node : existing);\n        }\n      }\n    });\n\n    cpuNodes.sort((a, b) => a.startTime - b.startTime);\n\n    // A script is *possibly* render blocking if it finished loading before cutoffTimestamp.\n    const possiblyRenderBlockingScriptUrls = Metric.getScriptUrls(graph, node => {\n      // The optimistic LCP treatNodeAsRenderBlocking fn wants to exclude some images in the graph,\n      // but here it only receives scripts to evaluate. It's a no-op in this case, but it will\n      // matter below in the getFirstPaintBasedGraph clone operation.\n      return node.endTime <= cutoffTimestamp && treatNodeAsRenderBlocking(node);\n    });\n\n    // A script is *definitely not* render blocking if its EvaluateScript task started after cutoffTimestamp.\n    const definitelyNotRenderBlockingScriptUrls = new Set<string>();\n    const renderBlockingCpuNodeIds = new Set<string>();\n    for (const url of possiblyRenderBlockingScriptUrls) {\n      // Lookup the CPU node that had the earliest EvaluateScript for this URL.\n      const cpuNodeForUrl = scriptUrlToNodeMap.get(url);\n\n      // If we can't find it at all, we can't conclude anything, so just skip it.\n      if (!cpuNodeForUrl) {\n        continue;\n      }\n\n      // If we found it and it was in our `cpuNodes` set that means it finished before cutoffTimestamp, so it really is render-blocking.\n      if (cpuNodes.includes(cpuNodeForUrl)) {\n        renderBlockingCpuNodeIds.add(cpuNodeForUrl.id);\n        continue;\n      }\n\n      // We couldn't find the evaluate script in the set of CPU nodes that ran before our paint, so\n      // it must not have been necessary for the paint.\n      definitelyNotRenderBlockingScriptUrls.add(url);\n    }\n\n    // The first layout, first paint, and first ParseHTML are almost always necessary for first paint,\n    // so we always include those CPU nodes.\n    const firstLayout = cpuNodes.find(node => node.didPerformLayout());\n    if (firstLayout) {\n      renderBlockingCpuNodeIds.add(firstLayout.id);\n    }\n    const firstPaint = cpuNodes.find(node => node.childEvents.some(e => e.name === 'Paint'));\n    if (firstPaint) {\n      renderBlockingCpuNodeIds.add(firstPaint.id);\n    }\n    const firstParse = cpuNodes.find(node => node.childEvents.some(e => e.name === 'ParseHTML'));\n    if (firstParse) {\n      renderBlockingCpuNodeIds.add(firstParse.id);\n    }\n\n    // If a CPU filter was passed in, we also want to include those extra nodes.\n    if (additionalCpuNodesToTreatAsRenderBlocking) {\n      cpuNodes.filter(additionalCpuNodesToTreatAsRenderBlocking).forEach(node => renderBlockingCpuNodeIds.add(node.id));\n    }\n\n    return {\n      definitelyNotRenderBlockingScriptUrls,\n      renderBlockingCpuNodeIds,\n    };\n  }\n\n  /**\n   * Computes the graph required for the first paint of interest.\n   */\n  static getFirstPaintBasedGraph<T>(\n      dependencyGraph: Graph.Node,\n      {cutoffTimestamp, treatNodeAsRenderBlocking, additionalCpuNodesToTreatAsRenderBlocking}:\n          FirstPaintBasedGraphOpts<T>,\n      ): Graph.Node<T> {\n    const rbData = this.getRenderBlockingNodeData(dependencyGraph, {\n      cutoffTimestamp,\n      treatNodeAsRenderBlocking,\n      additionalCpuNodesToTreatAsRenderBlocking,\n    });\n    const {definitelyNotRenderBlockingScriptUrls, renderBlockingCpuNodeIds} = rbData;\n\n    return dependencyGraph.cloneWithRelationships(node => {\n      if (node.type === Graph.BaseNode.types.NETWORK) {\n        // Exclude all nodes that ended after cutoffTimestamp (except for the main document which we always consider necessary)\n        // endTime is negative if request does not finish, make sure startTime isn't after cutoffTimestamp in this case.\n        const endedAfterPaint = node.endTime > cutoffTimestamp || node.startTime > cutoffTimestamp;\n        if (endedAfterPaint && !node.isMainDocument()) {\n          return false;\n        }\n\n        const url = node.request.url;\n        // If the URL definitely wasn't render-blocking then we filter it out.\n        if (definitelyNotRenderBlockingScriptUrls.has(url)) {\n          return false;\n        }\n\n        // Lastly, build up the FCP graph of all nodes we consider render blocking\n        return treatNodeAsRenderBlocking(node);\n      }\n      // If it's a CPU node, just check if it was blocking.\n      return renderBlockingCpuNodeIds.has(node.id);\n    });\n  }\n\n  static override getOptimisticGraph<T>(\n      dependencyGraph: Graph.Node<T>, processedNavigation: Types.Simulation.ProcessedNavigation): Graph.Node<T> {\n    return this.getFirstPaintBasedGraph(dependencyGraph, {\n      cutoffTimestamp: processedNavigation.timestamps.firstContentfulPaint,\n      // In the optimistic graph we exclude resources that appeared to be render blocking but were\n      // initiated by a script. While they typically have a very high importance and tend to have a\n      // significant impact on the page's content, these resources don't technically block rendering.\n      treatNodeAsRenderBlocking: node => node.hasRenderBlockingPriority() && node.initiatorType !== 'script',\n    });\n  }\n\n  static override getPessimisticGraph<T>(\n      dependencyGraph: Graph.Node<T>, processedNavigation: Types.Simulation.ProcessedNavigation): Graph.Node<T> {\n    return this.getFirstPaintBasedGraph(dependencyGraph, {\n      cutoffTimestamp: processedNavigation.timestamps.firstContentfulPaint,\n      treatNodeAsRenderBlocking: node => node.hasRenderBlockingPriority(),\n    });\n  }\n}\n\nexport {FirstContentfulPaint};\n", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Core from '../core/core.js';\nimport * as Graph from '../graph/graph.js';\nimport type * as Simulation from '../simulation/simulation.js';\nimport type * as Types from '../types/types.js';\n\nexport interface MetricComputationDataInput {\n  simulator: Simulation.Simulator;\n  graph: Graph.Node<unknown>;\n  processedNavigation: Types.Simulation.ProcessedNavigation;\n}\n\nexport interface MetricCoefficients {\n  intercept: number;\n  optimistic: number;\n  pessimistic: number;\n}\n\nexport interface MetricResult<T = Types.AnyNetworkObject> {\n  timing: number;\n  timestamp?: never;\n  optimisticEstimate: Simulation.Result<T>;\n  pessimisticEstimate: Simulation.Result<T>;\n  optimisticGraph: Graph.Node<T>;\n  pessimisticGraph: Graph.Node;\n}\n\nexport interface Extras {\n  optimistic: boolean;\n  fcpResult?: MetricResult;\n  lcpResult?: MetricResult;\n  interactiveResult?: MetricResult;\n  observedSpeedIndex?: number;\n}\n\nclass Metric {\n  static getScriptUrls(dependencyGraph: Graph.Node, treatNodeAsRenderBlocking?: (node: Graph.NetworkNode) => boolean):\n      Set<string> {\n    const scriptUrls = new Set<string>();\n\n    dependencyGraph.traverse(node => {\n      if (node.type !== Graph.BaseNode.types.NETWORK) {\n        return;\n      }\n      if (node.request.resourceType !== 'Script') {\n        return;\n      }\n      if (treatNodeAsRenderBlocking?.(node)) {\n        scriptUrls.add(node.request.url);\n      }\n    });\n\n    return scriptUrls;\n  }\n\n  static get coefficients(): MetricCoefficients {\n    throw new Core.LanternError('coefficients unimplemented!');\n  }\n\n  /**\n   * Returns the coefficients, scaled by the throttling settings if needed by the metric.\n   * Some lantern metrics (speed-index) use components in their estimate that are not\n   * from the simulator. In this case, we need to adjust the coefficients as the target throttling\n   * settings change.\n   */\n  static getScaledCoefficients(_rttMs: number): MetricCoefficients {\n    return this.coefficients;\n  }\n\n  static getOptimisticGraph(_dependencyGraph: Graph.Node, _processedNavigation: Types.Simulation.ProcessedNavigation):\n      Graph.Node {\n    throw new Core.LanternError('Optimistic graph unimplemented!');\n  }\n\n  static getPessimisticGraph(_dependencyGraph: Graph.Node, _processedNavigation: Types.Simulation.ProcessedNavigation):\n      Graph.Node {\n    throw new Core.LanternError('Pessmistic graph unimplemented!');\n  }\n\n  static getEstimateFromSimulation(simulationResult: Simulation.Result, _extras: Extras): Simulation.Result {\n    return simulationResult;\n  }\n\n  static compute(data: MetricComputationDataInput, extras?: Omit<Extras, 'optimistic'>): MetricResult {\n    const {simulator, graph, processedNavigation} = data;\n\n    const metricName = this.name.replace('Lantern', '');\n    const optimisticGraph = this.getOptimisticGraph(graph, processedNavigation);\n    const pessimisticGraph = this.getPessimisticGraph(graph, processedNavigation);\n\n    let simulateOptions = {label: `optimistic${metricName}`};\n    const optimisticSimulation = simulator.simulate(optimisticGraph, simulateOptions);\n\n    simulateOptions = {label: `pessimistic${metricName}`};\n    const pessimisticSimulation = simulator.simulate(pessimisticGraph, simulateOptions);\n\n    const optimisticEstimate = this.getEstimateFromSimulation(\n        optimisticSimulation,\n        {...extras, optimistic: true},\n    );\n\n    const pessimisticEstimate = this.getEstimateFromSimulation(\n        pessimisticSimulation,\n        {...extras, optimistic: false},\n    );\n\n    const coefficients = this.getScaledCoefficients(simulator.rtt);\n    // Estimates under 1s don't really follow the normal curve fit, minimize the impact of the intercept\n    const interceptMultiplier = coefficients.intercept > 0 ? Math.min(1, optimisticEstimate.timeInMs / 1000) : 1;\n    const timing = coefficients.intercept * interceptMultiplier +\n        coefficients.optimistic * optimisticEstimate.timeInMs + coefficients.pessimistic * pessimisticEstimate.timeInMs;\n\n    return {\n      timing,\n      optimisticEstimate,\n      pessimisticEstimate,\n      optimisticGraph,\n      pessimisticGraph,\n    };\n  }\n}\n\nexport {Metric};\n", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Core from '../core/core.js';\nimport * as Graph from '../graph/graph.js';\nimport type * as Simulation from '../simulation/simulation.js';\n\nimport {\n  type Extras,\n  Metric,\n  type MetricCoefficients,\n  type MetricComputationDataInput,\n  type MetricResult,\n} from './Metric.js';\n\n// Any CPU task of 20 ms or more will end up being a critical long task on mobile\nconst CRITICAL_LONG_TASK_THRESHOLD = 20;\n\nclass Interactive extends Metric {\n  static override get coefficients(): MetricCoefficients {\n    return {\n      intercept: 0,\n      optimistic: 0.45,\n      pessimistic: 0.55,\n    };\n  }\n\n  static override getOptimisticGraph<T>(dependencyGraph: Graph.Node<T>): Graph.Node<T> {\n    // Adjust the critical long task threshold for microseconds\n    const minimumCpuTaskDuration = CRITICAL_LONG_TASK_THRESHOLD * 1000;\n\n    return dependencyGraph.cloneWithRelationships(node => {\n      // Include everything that might be a long task\n      if (node.type === Graph.BaseNode.types.CPU) {\n        return node.duration > minimumCpuTaskDuration;\n      }\n\n      // Include all scripts and high priority requests, exclude all images\n      const isImage = node.request.resourceType === 'Image';\n      const isScript = node.request.resourceType === 'Script';\n      return (!isImage && (isScript || node.request.priority === 'High' || node.request.priority === 'VeryHigh'));\n    });\n  }\n\n  static override getPessimisticGraph<T>(dependencyGraph: Graph.Node<T>): Graph.Node<T> {\n    return dependencyGraph;\n  }\n\n  static override getEstimateFromSimulation(simulationResult: Simulation.Result, extras: Extras): Simulation.Result {\n    if (!extras.lcpResult) {\n      throw new Core.LanternError('missing lcpResult');\n    }\n\n    const lastTaskAt = Interactive.getLastLongTaskEndTime(simulationResult.nodeTimings);\n    const minimumTime = extras.optimistic ? extras.lcpResult.optimisticEstimate.timeInMs :\n                                            extras.lcpResult.pessimisticEstimate.timeInMs;\n    return {\n      timeInMs: Math.max(minimumTime, lastTaskAt),\n      nodeTimings: simulationResult.nodeTimings,\n    };\n  }\n\n  static override compute(data: MetricComputationDataInput, extras?: Omit<Extras, 'optimistic'>): MetricResult {\n    const lcpResult = extras?.lcpResult;\n    if (!lcpResult) {\n      throw new Core.LanternError('LCP is required to calculate the Interactive metric');\n    }\n\n    const metricResult = super.compute(data, extras);\n    metricResult.timing = Math.max(metricResult.timing, lcpResult.timing);\n    return metricResult;\n  }\n\n  static getLastLongTaskEndTime(nodeTimings: Simulation.Result['nodeTimings'], duration = 50): number {\n    return Array.from(nodeTimings.entries())\n        .filter(([node, timing]) => {\n          if (node.type !== Graph.BaseNode.types.CPU) {\n            return false;\n          }\n          return timing.duration > duration;\n        })\n        .map(([_, timing]) => timing.endTime)\n        .reduce((max, x) => Math.max(max || 0, x || 0), 0);\n  }\n}\n\nexport {Interactive};\n", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Core from '../core/core.js';\nimport type * as Graph from '../graph/graph.js';\nimport type * as Simulation from '../simulation/simulation.js';\nimport type * as Types from '../types/types.js';\n\nimport {FirstContentfulPaint} from './FirstContentfulPaint.js';\nimport {\n  type Extras,\n  Metric,\n  type MetricCoefficients,\n  type MetricComputationDataInput,\n  type MetricResult,\n} from './Metric.js';\n\nclass LargestContentfulPaint extends Metric {\n  static override get coefficients(): MetricCoefficients {\n    return {\n      intercept: 0,\n      optimistic: 0.5,\n      pessimistic: 0.5,\n    };\n  }\n\n  /**\n   * Low priority image nodes are usually offscreen and very unlikely to be the\n   * resource that is required for LCP. Our LCP graphs include everything except for these images.\n   */\n  static isNotLowPriorityImageNode(node: Graph.Node): boolean {\n    if (node.type !== 'network') {\n      return true;\n    }\n    const isImage = node.request.resourceType === 'Image';\n    const isLowPriority = node.request.priority === 'Low' || node.request.priority === 'VeryLow';\n    return !isImage || !isLowPriority;\n  }\n\n  static override getOptimisticGraph(\n      dependencyGraph: Graph.Node, processedNavigation: Types.Simulation.ProcessedNavigation): Graph.Node {\n    const lcp = processedNavigation.timestamps.largestContentfulPaint;\n    if (!lcp) {\n      throw new Core.LanternError('NO_LCP');\n    }\n\n    return FirstContentfulPaint.getFirstPaintBasedGraph(dependencyGraph, {\n      cutoffTimestamp: lcp,\n      treatNodeAsRenderBlocking: LargestContentfulPaint.isNotLowPriorityImageNode,\n    });\n  }\n\n  static override getPessimisticGraph(\n      dependencyGraph: Graph.Node, processedNavigation: Types.Simulation.ProcessedNavigation): Graph.Node {\n    const lcp = processedNavigation.timestamps.largestContentfulPaint;\n    if (!lcp) {\n      throw new Core.LanternError('NO_LCP');\n    }\n\n    return FirstContentfulPaint.getFirstPaintBasedGraph(dependencyGraph, {\n      cutoffTimestamp: lcp,\n      treatNodeAsRenderBlocking: _ => true,\n      // For pessimistic LCP we'll include *all* layout nodes\n      additionalCpuNodesToTreatAsRenderBlocking: node => node.didPerformLayout(),\n    });\n  }\n\n  static override getEstimateFromSimulation(simulationResult: Simulation.Result): Simulation.Result {\n    const nodeTimesNotOffscreenImages = Array.from(simulationResult.nodeTimings.entries())\n                                            .filter(entry => LargestContentfulPaint.isNotLowPriorityImageNode(entry[0]))\n                                            .map(entry => entry[1].endTime);\n\n    return {\n      timeInMs: Math.max(...nodeTimesNotOffscreenImages),\n      nodeTimings: simulationResult.nodeTimings,\n    };\n  }\n\n  static override compute(data: MetricComputationDataInput, extras?: Omit<Extras, 'optimistic'>): MetricResult {\n    const fcpResult = extras?.fcpResult;\n    if (!fcpResult) {\n      throw new Core.LanternError('FCP is required to calculate the LCP metric');\n    }\n\n    const metricResult = super.compute(data, extras);\n    metricResult.timing = Math.max(metricResult.timing, fcpResult.timing);\n    return metricResult;\n  }\n}\n\nexport {LargestContentfulPaint};\n", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Core from '../core/core.js';\nimport * as Graph from '../graph/graph.js';\nimport type * as Simulation from '../simulation/simulation.js';\n\nimport {\n  type Extras,\n  Metric,\n  type MetricCoefficients,\n  type MetricComputationDataInput,\n  type MetricResult,\n} from './Metric.js';\n\nclass MaxPotentialFID extends Metric {\n  static override get coefficients(): MetricCoefficients {\n    return {\n      intercept: 0,\n      optimistic: 0.5,\n      pessimistic: 0.5,\n    };\n  }\n\n  static override getOptimisticGraph(dependencyGraph: Graph.Node): Graph.Node {\n    return dependencyGraph;\n  }\n\n  static override getPessimisticGraph(dependencyGraph: Graph.Node): Graph.Node {\n    return dependencyGraph;\n  }\n\n  static override getEstimateFromSimulation(simulation: Simulation.Result, extras: Extras): Simulation.Result {\n    if (!extras.fcpResult) {\n      throw new Core.LanternError('missing fcpResult');\n    }\n\n    // Intentionally use the opposite FCP estimate, a more pessimistic FCP means that more tasks\n    // are excluded from the FID computation, so a higher FCP means lower FID for same work.\n    const fcpTimeInMs = extras.optimistic ? extras.fcpResult.pessimisticEstimate.timeInMs :\n                                            extras.fcpResult.optimisticEstimate.timeInMs;\n\n    const timings = MaxPotentialFID.getTimingsAfterFCP(\n        simulation.nodeTimings,\n        fcpTimeInMs,\n    );\n\n    return {\n      timeInMs: Math.max(...timings.map(timing => timing.duration), 16),\n      nodeTimings: simulation.nodeTimings,\n    };\n  }\n\n  static override compute(data: MetricComputationDataInput, extras?: Omit<Extras, 'optimistic'>): MetricResult {\n    const fcpResult = extras?.fcpResult;\n    if (!fcpResult) {\n      throw new Core.LanternError('FCP is required to calculate the Max Potential FID metric');\n    }\n\n    return super.compute(data, extras);\n  }\n\n  static getTimingsAfterFCP(nodeTimings: Simulation.Result['nodeTimings'], fcpTimeInMs: number):\n      Array<{duration: number}> {\n    return Array.from(nodeTimings.entries())\n        .filter(([node, timing]) => node.type === Graph.BaseNode.types.CPU && timing.endTime > fcpTimeInMs)\n        .map(([_, timing]) => timing);\n  }\n}\n\nexport {MaxPotentialFID};\n", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Core from '../core/core.js';\nimport * as Graph from '../graph/graph.js';\nimport type * as Simulation from '../simulation/simulation.js';\n\nimport {\n  type Extras,\n  Metric,\n  type MetricCoefficients,\n  type MetricComputationDataInput,\n  type MetricResult,\n} from './Metric.js';\n\nconst mobileSlow4GRtt = 150;\n\nclass SpeedIndex extends Metric {\n  static override get coefficients(): MetricCoefficients {\n    return {\n      // Note that the optimistic estimate is based on the real observed speed index rather than a\n      // real lantern graph (and the final estimate will be Math.max(FCP, Speed Index)).\n      intercept: 0,\n      optimistic: 1.4,\n      pessimistic: 0.4,\n    };\n  }\n\n  static override getScaledCoefficients(rttMs: number): MetricCoefficients {\n    // We want to scale our default coefficients based on the speed of the connection.\n    // We will linearly interpolate coefficients for the passed-in rttMs based on two pre-determined points:\n    //   1. Baseline point of 30 ms RTT where Speed Index should be a ~50/50 blend of optimistic/pessimistic.\n    //      30 ms was based on a typical home WiFi connection's actual RTT.\n    //      Coefficients here follow from the fact that the optimistic estimate should be very close\n    //      to reality at this connection speed and the pessimistic estimate compensates for minor\n    //      connection speed differences.\n    //   2. Default throttled point of 150 ms RTT where the default coefficients have been determined to be most accurate.\n    //      Coefficients here were determined through thorough analysis and linear regression on the\n    //      lantern test data set. See core/scripts/test-lantern.sh for more detail.\n    // While the coefficients haven't been analyzed at the interpolated points, it's our current best effort.\n    const defaultCoefficients = this.coefficients;\n    const defaultRttExcess = mobileSlow4GRtt - 30;\n    const multiplier = Math.max((rttMs - 30) / defaultRttExcess, 0);\n\n    return {\n      intercept: defaultCoefficients.intercept * multiplier,\n      optimistic: 0.5 + (defaultCoefficients.optimistic - 0.5) * multiplier,\n      pessimistic: 0.5 + (defaultCoefficients.pessimistic - 0.5) * multiplier,\n    };\n  }\n\n  static override getOptimisticGraph(dependencyGraph: Graph.Node): Graph.Node {\n    return dependencyGraph;\n  }\n\n  static override getPessimisticGraph(dependencyGraph: Graph.Node): Graph.Node {\n    return dependencyGraph;\n  }\n\n  static override getEstimateFromSimulation(simulationResult: Simulation.Result, extras: Extras): Simulation.Result {\n    if (!extras.fcpResult) {\n      throw new Core.LanternError('missing fcpResult');\n    }\n    if (extras.observedSpeedIndex === undefined) {\n      throw new Core.LanternError('missing observedSpeedIndex');\n    }\n\n    const fcpTimeInMs = extras.fcpResult.pessimisticEstimate.timeInMs;\n    const estimate = extras.optimistic ?\n        extras.observedSpeedIndex :\n        SpeedIndex.computeLayoutBasedSpeedIndex(simulationResult.nodeTimings, fcpTimeInMs);\n    return {\n      timeInMs: estimate,\n      nodeTimings: simulationResult.nodeTimings,\n    };\n  }\n\n  static override compute(data: MetricComputationDataInput, extras?: Omit<Extras, 'optimistic'>): MetricResult {\n    const fcpResult = extras?.fcpResult;\n    if (!fcpResult) {\n      throw new Core.LanternError('FCP is required to calculate the SpeedIndex metric');\n    }\n\n    const metricResult = super.compute(data, extras);\n    metricResult.timing = Math.max(metricResult.timing, fcpResult.timing);\n    return metricResult;\n  }\n\n  /**\n   * Approximate speed index using layout events from the simulated node timings.\n   * The layout-based speed index is the weighted average of the endTime of CPU nodes that contained\n   * a 'Layout' task. log(duration) is used as the weight to stand for \"significance\" to the page.\n   *\n   * If no layout events can be found or the endTime of a CPU task is too early, FCP is used instead.\n   *\n   * This approach was determined after evaluating the accuracy/complexity tradeoff of many\n   * different methods. Read more in the evaluation doc.\n   *\n   * @see https://docs.google.com/document/d/1qJWXwxoyVLVadezIp_Tgdk867G3tDNkkVRvUJSH3K1E/edit#\n   */\n  static computeLayoutBasedSpeedIndex(nodeTimings: Simulation.Result['nodeTimings'], fcpTimeInMs: number): number {\n    const layoutWeights: Array<{time: number, weight: number}> = [];\n    for (const [node, timing] of nodeTimings.entries()) {\n      if (node.type !== Graph.BaseNode.types.CPU) {\n        continue;\n      }\n\n      if (node.childEvents.some(x => x.name === 'Layout')) {\n        const timingWeight = Math.max(Math.log2(timing.endTime - timing.startTime), 0);\n        layoutWeights.push({time: timing.endTime, weight: timingWeight});\n      }\n    }\n\n    const totalWeightedTime =\n        layoutWeights.map(evt => evt.weight * Math.max(evt.time, fcpTimeInMs)).reduce((a, b) => a + b, 0);\n    const totalWeight = layoutWeights.map(evt => evt.weight).reduce((a, b) => a + b, 0);\n\n    if (!totalWeight) {\n      return fcpTimeInMs;\n    }\n    return totalWeightedTime / totalWeight;\n  }\n}\n\nexport {SpeedIndex};\n", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Core from '../core/core.js';\nimport * as Graph from '../graph/graph.js';\nimport type * as Simulation from '../simulation/simulation.js';\n\nimport {\n  type Extras,\n  Metric,\n  type MetricCoefficients,\n  type MetricComputationDataInput,\n  type MetricResult,\n} from './Metric.js';\nimport {BLOCKING_TIME_THRESHOLD, calculateSumOfBlockingTime} from './TBTUtils.js';\n\nclass TotalBlockingTime extends Metric {\n  static override get coefficients(): MetricCoefficients {\n    return {\n      intercept: 0,\n      optimistic: 0.5,\n      pessimistic: 0.5,\n    };\n  }\n\n  static override getOptimisticGraph(dependencyGraph: Graph.Node): Graph.Node {\n    return dependencyGraph;\n  }\n\n  static override getPessimisticGraph(dependencyGraph: Graph.Node): Graph.Node {\n    return dependencyGraph;\n  }\n\n  static override getEstimateFromSimulation(simulation: Simulation.Result, extras: Extras): Simulation.Result {\n    if (!extras.fcpResult) {\n      throw new Core.LanternError('missing fcpResult');\n    }\n    if (!extras.interactiveResult) {\n      throw new Core.LanternError('missing interactiveResult');\n    }\n\n    // Intentionally use the opposite FCP estimate. A pessimistic FCP is higher than equal to an\n    // optimistic FCP, which means potentially more tasks are excluded from the Total Blocking Time\n    // computation. So a more pessimistic FCP gives a more optimistic Total Blocking Time for the\n    // same work.\n    const fcpTimeInMs = extras.optimistic ? extras.fcpResult.pessimisticEstimate.timeInMs :\n                                            extras.fcpResult.optimisticEstimate.timeInMs;\n\n    // Similarly, we always have pessimistic TTI >= optimistic TTI. Therefore, picking optimistic\n    // TTI means our window of interest is smaller and thus potentially more tasks are excluded from\n    // Total Blocking Time computation, yielding a lower (more optimistic) Total Blocking Time value\n    // for the same work.\n    const interactiveTimeMs = extras.optimistic ? extras.interactiveResult.optimisticEstimate.timeInMs :\n                                                  extras.interactiveResult.pessimisticEstimate.timeInMs;\n\n    const minDurationMs = BLOCKING_TIME_THRESHOLD;\n\n    const events = TotalBlockingTime.getTopLevelEvents(\n        simulation.nodeTimings,\n        minDurationMs,\n    );\n\n    return {\n      timeInMs: calculateSumOfBlockingTime(\n          events,\n          fcpTimeInMs,\n          interactiveTimeMs,\n          ),\n      nodeTimings: simulation.nodeTimings,\n    };\n  }\n\n  static override compute(data: MetricComputationDataInput, extras?: Omit<Extras, 'optimistic'>): MetricResult {\n    const fcpResult = extras?.fcpResult;\n    if (!fcpResult) {\n      throw new Core.LanternError('FCP is required to calculate the TBT metric');\n    }\n\n    const interactiveResult = extras?.fcpResult;\n    if (!interactiveResult) {\n      throw new Core.LanternError('Interactive is required to calculate the TBT metric');\n    }\n\n    return super.compute(data, extras);\n  }\n\n  static getTopLevelEvents(nodeTimings: Simulation.Result['nodeTimings'], minDurationMs: number):\n      Array<{start: number, end: number, duration: number}> {\n    const events: Array<{start: number, end: number, duration: number}> = [];\n\n    for (const [node, timing] of nodeTimings.entries()) {\n      if (node.type !== Graph.BaseNode.types.CPU) {\n        continue;\n      }\n      // Filtering out events below minimum duration.\n      if (timing.duration < minDurationMs) {\n        continue;\n      }\n\n      events.push({\n        start: timing.startTime,\n        end: timing.endTime,\n        duration: timing.duration,\n      });\n    }\n\n    return events;\n  }\n}\n\nexport {TotalBlockingTime};\n", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nconst BLOCKING_TIME_THRESHOLD = 50;\n\n/**\n * For TBT, We only want to consider tasks that fall in our time range\n * - FCP and TTI for navigation mode\n * - Trace start and trace end for timespan mode\n *\n * FCP is picked as `startTimeMs` because there is little risk of user input happening\n * before FCP so Long Queuing Qelay regions do not harm user experience. Developers should be\n * optimizing to reach FCP as fast as possible without having to worry about task lengths.\n *\n * TTI is picked as `endTimeMs` because we want a well defined end point for page load.\n *\n * @param startTimeMs Should be FCP in navigation mode and the trace start time in timespan mode\n * @param endTimeMs Should be TTI in navigation mode and the trace end time in timespan mode\n * @param topLevelEvent Leave unset if `event` is top level. Has no effect if `event` has the same duration as `topLevelEvent`.\n */\nfunction calculateTbtImpactForEvent(\n    event: {start: number, end: number, duration: number}, startTimeMs: number, endTimeMs: number,\n    topLevelEvent?: {start: number, end: number, duration: number}): number {\n  let threshold = BLOCKING_TIME_THRESHOLD;\n\n  // If a task is not top level, it doesn't make sense to subtract the entire 50ms\n  // blocking threshold from the event.\n  //\n  // e.g. A 80ms top level task with two 40ms children should attribute some blocking\n  // time to the 40ms tasks even though they do not meet the 50ms threshold.\n  //\n  // The solution is to scale the threshold for child events to be considered blocking.\n  if (topLevelEvent) {\n    threshold *= (event.duration / topLevelEvent.duration);\n  }\n\n  if (event.duration < threshold) {\n    return 0;\n  }\n  if (event.end < startTimeMs) {\n    return 0;\n  }\n  if (event.start > endTimeMs) {\n    return 0;\n  }\n\n  // Perform the clipping and then calculate Blocking Region. So if we have a 150ms task\n  // [0, 150] and `startTimeMs` is at 50ms, we first clip the task to [50, 150], and then\n  // calculate the Blocking Region to be [100, 150]. The rational here is that tasks before\n  // the start time are unimportant, so we care whether the main thread is busy more than\n  // 50ms at a time only after the start time.\n  const clippedStart = Math.max(event.start, startTimeMs);\n  const clippedEnd = Math.min(event.end, endTimeMs);\n  const clippedDuration = clippedEnd - clippedStart;\n  if (clippedDuration < threshold) {\n    return 0;\n  }\n\n  return clippedDuration - threshold;\n}\n\nfunction calculateSumOfBlockingTime(\n    topLevelEvents: Array<{start: number, end: number, duration: number}>, startTimeMs: number,\n    endTimeMs: number): number {\n  if (endTimeMs <= startTimeMs) {\n    return 0;\n  }\n\n  let sumBlockingTime = 0;\n  for (const event of topLevelEvents) {\n    sumBlockingTime += calculateTbtImpactForEvent(event, startTimeMs, endTimeMs);\n  }\n\n  return sumBlockingTime;\n}\n\nexport {\n  BLOCKING_TIME_THRESHOLD,\n  calculateSumOfBlockingTime,\n  calculateTbtImpactForEvent,\n};\n"],
  "mappings": "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",
  "names": ["Graph", "Core", "Graph", "Core", "Core", "Graph", "Core", "Graph", "Core", "Graph"]
}
