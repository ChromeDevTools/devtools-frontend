{"version":3,"file":"SimulationTimingMap.js","sourceRoot":"","sources":["../../../../../../../../front_end/models/trace/lantern/simulation/SimulationTimingMap.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/**\n * @file\n *\n * This class encapsulates the type-related validation logic for moving timing information for nodes\n * through the different simulation phases. Methods here ensure that the invariants of simulation hold\n * as nodes are queued, partially simulated, and completed.\n */\n\nimport * as Core from '../core/core.js';\nimport * as Graph from '../graph/graph.js';\n\ninterface NodeTimingComplete {\n  startTime: number;\n  endTime: number;\n  queuedTime: number;\n  estimatedTimeElapsed: number;\n  timeElapsed: number;\n  timeElapsedOvershoot: number;\n  bytesDownloaded: number;\n}\n\ntype NodeTimingQueued = Pick<NodeTimingComplete, 'queuedTime'>;\n\ntype CpuNodeTimingStarted = NodeTimingQueued&Pick<NodeTimingComplete, 'startTime'|'timeElapsed'>;\ntype NetworkNodeTimingStarted = CpuNodeTimingStarted&Pick<NodeTimingComplete, 'timeElapsedOvershoot'|'bytesDownloaded'>;\n\ntype CpuNodeTimingInProgress = CpuNodeTimingStarted&Pick<NodeTimingComplete, 'estimatedTimeElapsed'>;\ntype NetworkNodeTimingInProgress = NetworkNodeTimingStarted&Pick<NodeTimingComplete, 'estimatedTimeElapsed'>;\n\nexport type CpuNodeTimingComplete = CpuNodeTimingInProgress&Pick<NodeTimingComplete, 'endTime'>;\nexport type NetworkNodeTimingComplete =\n    NetworkNodeTimingInProgress&Pick<NodeTimingComplete, 'endTime'>&{connectionTiming: ConnectionTiming};\nexport type CompleteNodeTiming = CpuNodeTimingComplete|NetworkNodeTimingComplete;\n\ntype NodeTimingData = NodeTimingQueued|CpuNodeTimingStarted|NetworkNodeTimingStarted|CpuNodeTimingInProgress|\n    NetworkNodeTimingInProgress|CpuNodeTimingComplete|NetworkNodeTimingComplete;\n\nexport interface ConnectionTiming {\n  dnsResolutionTime?: number;\n  connectionTime?: number;\n  sslTime?: number;\n  timeToFirstByte: number;\n}\n\nclass SimulatorTimingMap {\n  nodeTimings: Map<Graph.Node, NodeTimingData>;\n\n  constructor() {\n    this.nodeTimings = new Map<Graph.Node, NodeTimingData>();\n  }\n\n  getNodes(): Graph.Node[] {\n    return Array.from(this.nodeTimings.keys());\n  }\n\n  setReadyToStart(node: Graph.Node, values: {queuedTime: number}): void {\n    this.nodeTimings.set(node, values);\n  }\n\n  setInProgress(node: Graph.Node, values: {startTime: number}): void {\n    const nodeTiming = {\n      ...this.getQueued(node),\n      startTime: values.startTime,\n      timeElapsed: 0,\n    };\n\n    this.nodeTimings.set(\n        node,\n        node.type === Graph.BaseNode.types.NETWORK ? {...nodeTiming, timeElapsedOvershoot: 0, bytesDownloaded: 0} :\n                                                     nodeTiming,\n    );\n  }\n\n  setCompleted(node: Graph.Node, values: {endTime: number, connectionTiming?: ConnectionTiming}): void {\n    const nodeTiming = {\n      ...this.getInProgress(node),\n      endTime: values.endTime,\n      connectionTiming: values.connectionTiming,\n    };\n\n    this.nodeTimings.set(node, nodeTiming);\n  }\n\n  setCpu(node: Graph.CPUNode, values: {timeElapsed: number}): void {\n    const nodeTiming = {\n      ...this.getCpuStarted(node),\n      timeElapsed: values.timeElapsed,\n    };\n\n    this.nodeTimings.set(node, nodeTiming);\n  }\n\n  setCpuEstimated(node: Graph.CPUNode, values: {estimatedTimeElapsed: number}): void {\n    const nodeTiming = {\n      ...this.getCpuStarted(node),\n      estimatedTimeElapsed: values.estimatedTimeElapsed,\n    };\n\n    this.nodeTimings.set(node, nodeTiming);\n  }\n\n  setNetwork(\n      node: Graph.NetworkNode,\n      values: {timeElapsed: number, timeElapsedOvershoot: number, bytesDownloaded: number}): void {\n    const nodeTiming = {\n      ...this.getNetworkStarted(node),\n      timeElapsed: values.timeElapsed,\n      timeElapsedOvershoot: values.timeElapsedOvershoot,\n      bytesDownloaded: values.bytesDownloaded,\n    };\n\n    this.nodeTimings.set(node, nodeTiming);\n  }\n\n  setNetworkEstimated(node: Graph.NetworkNode, values: {estimatedTimeElapsed: number}): void {\n    const nodeTiming = {\n      ...this.getNetworkStarted(node),\n      estimatedTimeElapsed: values.estimatedTimeElapsed,\n    };\n\n    this.nodeTimings.set(node, nodeTiming);\n  }\n\n  getQueued(node: Graph.Node): NodeTimingData {\n    const timing = this.nodeTimings.get(node);\n    if (!timing) {\n      throw new Core.LanternError(`Node ${node.id} not yet queued`);\n    }\n    return timing;\n  }\n\n  getCpuStarted(node: Graph.CPUNode): CpuNodeTimingStarted {\n    const timing = this.nodeTimings.get(node);\n    if (!timing) {\n      throw new Core.LanternError(`Node ${node.id} not yet queued`);\n    }\n    if (!('startTime' in timing)) {\n      throw new Core.LanternError(`Node ${node.id} not yet started`);\n    }\n    if ('bytesDownloaded' in timing) {\n      throw new Core.LanternError(`Node ${node.id} timing not valid`);\n    }\n    return timing;\n  }\n\n  getNetworkStarted(node: Graph.NetworkNode): NetworkNodeTimingStarted {\n    const timing = this.nodeTimings.get(node);\n    if (!timing) {\n      throw new Core.LanternError(`Node ${node.id} not yet queued`);\n    }\n    if (!('startTime' in timing)) {\n      throw new Core.LanternError(`Node ${node.id} not yet started`);\n    }\n    if (!('bytesDownloaded' in timing)) {\n      throw new Core.LanternError(`Node ${node.id} timing not valid`);\n    }\n    return timing;\n  }\n\n  getInProgress(node: Graph.Node): CpuNodeTimingInProgress|NetworkNodeTimingInProgress {\n    const timing = this.nodeTimings.get(node);\n    if (!timing) {\n      throw new Core.LanternError(`Node ${node.id} not yet queued`);\n    }\n    if (!('startTime' in timing)) {\n      throw new Core.LanternError(`Node ${node.id} not yet started`);\n    }\n    if (!('estimatedTimeElapsed' in timing)) {\n      throw new Core.LanternError(`Node ${node.id} not yet in progress`);\n    }\n    return timing;\n  }\n\n  getCompleted(node: Graph.Node): CpuNodeTimingComplete|NetworkNodeTimingComplete {\n    const timing = this.nodeTimings.get(node);\n    if (!timing) {\n      throw new Core.LanternError(`Node ${node.id} not yet queued`);\n    }\n    if (!('startTime' in timing)) {\n      throw new Core.LanternError(`Node ${node.id} not yet started`);\n    }\n    if (!('estimatedTimeElapsed' in timing)) {\n      throw new Core.LanternError(`Node ${node.id} not yet in progress`);\n    }\n    if (!('endTime' in timing)) {\n      throw new Core.LanternError(`Node ${node.id} not yet completed`);\n    }\n    return timing;\n  }\n}\n\nexport {SimulatorTimingMap};\n"]}