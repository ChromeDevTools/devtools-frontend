{"version":3,"file":"DeviceBoundSessionsModel.js","sourceRoot":"","sources":["../../../../../../front_end/panels/application/DeviceBoundSessionsModel.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2026 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport type * as Protocol from '../../generated/protocol.js';\n\ninterface EventWithTimestamp {\n  event: Protocol.Network.DeviceBoundSessionEventOccurredEvent;\n  timestamp: Date;\n}\nexport interface SessionAndEvents {\n  session?: Protocol.Network.DeviceBoundSession;\n  isSessionTerminated: boolean;\n  hasErrors: boolean;\n  eventsById: Map<string, EventWithTimestamp>;\n}\ntype SessionIdToSessionMap = Map<string|undefined, SessionAndEvents>;\n\nexport class DeviceBoundSessionsModel extends Common.ObjectWrapper.ObjectWrapper<DeviceBoundSessionModelEventTypes>\n    implements SDK.TargetManager.SDKModelObserver<SDK.NetworkManager.NetworkManager> {\n  #siteSessions = new Map<string, SessionIdToSessionMap>();\n  #visibleSites = new Set<string>();\n\n  constructor() {\n    super();\n    SDK.TargetManager.TargetManager.instance().observeModels(SDK.NetworkManager.NetworkManager, this, {scoped: true});\n  }\n\n  modelAdded(networkManager: SDK.NetworkManager.NetworkManager): void {\n    networkManager.addEventListener(SDK.NetworkManager.Events.DeviceBoundSessionsAdded, this.#onSessionsSet, this);\n    networkManager.addEventListener(\n        SDK.NetworkManager.Events.DeviceBoundSessionEventOccurred, this.#onEventOccurred, this);\n    void networkManager.enableDeviceBoundSessions();\n  }\n\n  modelRemoved(networkManager: SDK.NetworkManager.NetworkManager): void {\n    networkManager.removeEventListener(SDK.NetworkManager.Events.DeviceBoundSessionsAdded, this.#onSessionsSet, this);\n    networkManager.removeEventListener(\n        SDK.NetworkManager.Events.DeviceBoundSessionEventOccurred, this.#onEventOccurred, this);\n  }\n\n  addVisibleSite(site: string): void {\n    if (this.#visibleSites.has(site)) {\n      return;\n    }\n    this.#visibleSites.add(site);\n    this.dispatchEventToListeners(DeviceBoundSessionModelEvents.ADD_VISIBLE_SITE, {site});\n  }\n\n  clearVisibleSites(): void {\n    if (this.getPreserveLogSetting().get()) {\n      return;\n    }\n    this.#visibleSites.clear();\n    this.dispatchEventToListeners(DeviceBoundSessionModelEvents.CLEAR_VISIBLE_SITES);\n  }\n\n  clearEvents(): void {\n    if (this.getPreserveLogSetting().get()) {\n      return;\n    }\n    const emptySessions = new Map<string, Array<string|undefined>>();\n    const noLongerFailedSessions = new Map<string, Array<string|undefined>>();\n    const emptySites = new Set<string>();\n    for (const [site, sessionIdToSessionMap] of [...this.#siteSessions]) {\n      let emptySessionsSiteEntry = emptySessions.get(site);\n      let noLongerFailedSessionsSiteEntry = noLongerFailedSessions.get(site);\n      for (const [sessionId, sessionAndEvents] of sessionIdToSessionMap) {\n        sessionAndEvents.eventsById.clear();\n        if (sessionAndEvents.hasErrors) {\n          sessionAndEvents.hasErrors = false;\n          if (!noLongerFailedSessionsSiteEntry) {\n            noLongerFailedSessionsSiteEntry = [];\n            noLongerFailedSessions.set(site, noLongerFailedSessionsSiteEntry);\n          }\n          noLongerFailedSessionsSiteEntry.push(sessionId);\n        }\n        if (sessionAndEvents.session) {\n          continue;\n        }\n        // Remove empty sessions.\n        sessionIdToSessionMap.delete(sessionId);\n        if (!emptySessionsSiteEntry) {\n          emptySessionsSiteEntry = [];\n          emptySessions.set(site, emptySessionsSiteEntry);\n        }\n        emptySessionsSiteEntry.push(sessionId);\n      }\n\n      // Remove empty sites.\n      if (sessionIdToSessionMap.size === 0) {\n        this.#siteSessions.delete(site);\n        emptySites.add(site);\n      }\n    }\n\n    this.dispatchEventToListeners(\n        DeviceBoundSessionModelEvents.CLEAR_EVENTS, {emptySessions, emptySites, noLongerFailedSessions});\n  }\n\n  isSiteVisible(site: string): boolean {\n    return this.#visibleSites.has(site);\n  }\n\n  isSessionTerminated(site: string, sessionId?: string): boolean {\n    const session = this.getSession(site, sessionId);\n    if (session === undefined) {\n      return false;\n    }\n    return session.isSessionTerminated;\n  }\n\n  sessionHasErrors(site: string, sessionId?: string): boolean {\n    const session = this.getSession(site, sessionId);\n    if (session === undefined) {\n      return false;\n    }\n    return session.hasErrors;\n  }\n\n  getSession(site: string, sessionId?: string): SessionAndEvents|undefined {\n    return this.#siteSessions.get(site)?.get(sessionId);\n  }\n\n  getPreserveLogSetting(): Common.Settings.Setting<boolean> {\n    return Common.Settings.Settings.instance().createSetting('device-bound-sessions-preserve-log', false);\n  }\n\n  #onSessionsSet({data: sessions}: {data: Protocol.Network.DeviceBoundSession[]}): void {\n    for (const session of sessions) {\n      const sessionAndEvents = this.#ensureSiteAndSessionInitialized(session.key.site, session.key.id);\n      sessionAndEvents.session = session;\n    }\n    this.dispatchEventToListeners(DeviceBoundSessionModelEvents.INITIALIZE_SESSIONS, {sessions});\n  }\n\n  #ensureSiteAndSessionInitialized(site: string, sessionId?: string): SessionAndEvents {\n    let sessionIdToSessionMap = this.#siteSessions.get(site);\n    if (!sessionIdToSessionMap) {\n      sessionIdToSessionMap = new Map();\n      this.#siteSessions.set(site, sessionIdToSessionMap);\n    }\n\n    let sessionAndEvent = sessionIdToSessionMap.get(sessionId);\n    if (!sessionAndEvent) {\n      sessionAndEvent = {\n        session: undefined,\n        isSessionTerminated: false,\n        hasErrors: false,\n        eventsById: new Map<string, EventWithTimestamp>()\n      };\n      sessionIdToSessionMap.set(sessionId, sessionAndEvent);\n    }\n    return sessionAndEvent;\n  }\n\n  #onEventOccurred({data: event}: {data: Protocol.Network.DeviceBoundSessionEventOccurredEvent}): void {\n    const sessionAndEvent = this.#ensureSiteAndSessionInitialized(event.site, event.sessionId);\n\n    // If this eventId has already been tracked, quit early.\n    if (sessionAndEvent.eventsById.has(event.eventId)) {\n      return;\n    }\n\n    // Add the new event.\n    const eventWithTimestamp = {event, timestamp: new Date()};\n    sessionAndEvent.eventsById.set(event.eventId, eventWithTimestamp);\n\n    // Add the new session if there is one.\n    const newSession = event.creationEventDetails?.newSession || event.refreshEventDetails?.newSession;\n    if (newSession) {\n      sessionAndEvent.session = newSession;\n    }\n\n    // Add the new challenge onto the session if there is one.\n    if (event.succeeded && sessionAndEvent.session && event.challengeEventDetails) {\n      sessionAndEvent.session.cachedChallenge = event.challengeEventDetails.challenge;\n    }\n\n    // Set the session's terminated status based on the event.\n    if (event.succeeded) {\n      if (event.terminationEventDetails) {\n        sessionAndEvent.isSessionTerminated = true;\n      } else if (event.creationEventDetails) {\n        sessionAndEvent.isSessionTerminated = false;\n      }\n    }\n\n    // Set that the session has errors if the latest event failed.\n    if (!event.succeeded) {\n      sessionAndEvent.hasErrors = true;\n    }\n\n    this.dispatchEventToListeners(\n        DeviceBoundSessionModelEvents.EVENT_OCCURRED,\n        {site: eventWithTimestamp.event.site, sessionId: eventWithTimestamp.event.sessionId});\n  }\n}\n\nexport const enum DeviceBoundSessionModelEvents {\n  INITIALIZE_SESSIONS = 'INITIALIZE_SESSIONS',\n  ADD_VISIBLE_SITE = 'ADD_VISIBLE_SITE',\n  CLEAR_VISIBLE_SITES = 'CLEAR_VISIBLE_SITES',\n  EVENT_OCCURRED = 'EVENT_OCCURRED',\n  CLEAR_EVENTS = 'CLEAR_EVENTS',\n}\n\nexport interface DeviceBoundSessionModelEventTypes {\n  [DeviceBoundSessionModelEvents.INITIALIZE_SESSIONS]: {sessions: Protocol.Network.DeviceBoundSession[]};\n  [DeviceBoundSessionModelEvents.ADD_VISIBLE_SITE]: {site: string};\n  [DeviceBoundSessionModelEvents.CLEAR_VISIBLE_SITES]: void;\n  [DeviceBoundSessionModelEvents.EVENT_OCCURRED]: {site: string, sessionId?: string};\n  [DeviceBoundSessionModelEvents.CLEAR_EVENTS]: {\n    emptySessions: Map<string, Array<string|undefined>>,\n    emptySites: Set<string>,\n    noLongerFailedSessions: Map<string, Array<string|undefined>>,\n  };\n}\n"]}