{"version":3,"file":"ValueInterpreterDisplayUtils.js","sourceRoot":"","sources":["../../../../../../../front_end/panels/linear_memory_inspector/components/ValueInterpreterDisplayUtils.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2020 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as i18n from '../../../core/i18n/i18n.js';\nimport * as Platform from '../../../core/platform/platform.js';\n\nconst UIStrings = {\n  /**\n   * @description Text that is shown in the LinearMemoryInspector if a value could not be correctly formatted\n   *             for the requested mode (e.g. we do not floats to be represented as hexadecimal numbers).\n   *             Abbreviation stands for 'not applicable'.\n   */\n  notApplicable: 'N/A',\n} as const;\nconst str_ =\n    i18n.i18n.registerUIStrings('panels/linear_memory_inspector/components/ValueInterpreterDisplayUtils.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\nexport const VALUE_INTEPRETER_MAX_NUM_BYTES = 8;\n\nexport const enum ValueType {\n  INT8 = 'Integer 8-bit',\n  INT16 = 'Integer 16-bit',\n  INT32 = 'Integer 32-bit',\n  INT64 = 'Integer 64-bit',\n  FLOAT32 = 'Float 32-bit',\n  FLOAT64 = 'Float 64-bit',\n  POINTER32 = 'Pointer 32-bit',\n  POINTER64 = 'Pointer 64-bit',\n}\n\nexport const enum Endianness {\n  LITTLE = 'Little Endian',\n  BIG = 'Big Endian',\n}\n\nexport const enum ValueTypeMode {\n  DECIMAL = 'dec',\n  HEXADECIMAL = 'hex',\n  OCTAL = 'oct',\n  SCIENTIFIC = 'sci',\n}\n\nexport function getDefaultValueTypeMapping(): Map<ValueType, ValueTypeMode> {\n  return new Map(DEFAULT_MODE_MAPPING);\n}\n\nconst DEFAULT_MODE_MAPPING = new Map([\n  [ValueType.INT8, ValueTypeMode.DECIMAL],\n  [ValueType.INT16, ValueTypeMode.DECIMAL],\n  [ValueType.INT32, ValueTypeMode.DECIMAL],\n  [ValueType.INT64, ValueTypeMode.DECIMAL],\n  [ValueType.FLOAT32, ValueTypeMode.DECIMAL],\n  [ValueType.FLOAT64, ValueTypeMode.DECIMAL],\n  [ValueType.POINTER32, ValueTypeMode.HEXADECIMAL],\n  [ValueType.POINTER64, ValueTypeMode.HEXADECIMAL],\n]);\n\nexport const VALUE_TYPE_MODE_LIST = [\n  ValueTypeMode.DECIMAL,\n  ValueTypeMode.HEXADECIMAL,\n  ValueTypeMode.OCTAL,\n  ValueTypeMode.SCIENTIFIC,\n];\n\nexport function valueTypeToLocalizedString(valueType: ValueType): string {\n  return i18n.i18n.lockedString(valueType);\n}\n\nexport function isValidMode(type: ValueType, mode: ValueTypeMode): boolean {\n  switch (type) {\n    case ValueType.INT8:\n    case ValueType.INT16:\n    case ValueType.INT32:\n    case ValueType.INT64:\n      return mode === ValueTypeMode.DECIMAL || mode === ValueTypeMode.HEXADECIMAL || mode === ValueTypeMode.OCTAL;\n    case ValueType.FLOAT32:\n    case ValueType.FLOAT64:\n      return mode === ValueTypeMode.SCIENTIFIC || mode === ValueTypeMode.DECIMAL;\n    case ValueType.POINTER32:  // fallthrough\n    case ValueType.POINTER64:\n      return mode === ValueTypeMode.HEXADECIMAL;\n    default:\n      return Platform.assertNever(type, `Unknown value type: ${type}`);\n  }\n}\n\nexport function isNumber(type: ValueType): boolean {\n  switch (type) {\n    case ValueType.INT8:\n    case ValueType.INT16:\n    case ValueType.INT32:\n    case ValueType.INT64:\n    case ValueType.FLOAT32:\n    case ValueType.FLOAT64:\n      return true;\n    default:\n      return false;\n  }\n}\n\nexport function getPointerAddress(type: ValueType, buffer: ArrayBuffer, endianness: Endianness): number|bigint {\n  if (!isPointer(type)) {\n    console.error(`Requesting address of a non-pointer type: ${type}.\\n`);\n    return NaN;\n  }\n  try {\n    const dataView = new DataView(buffer);\n    const isLittleEndian = endianness === Endianness.LITTLE;\n    return type === ValueType.POINTER32 ? dataView.getUint32(0, isLittleEndian) :\n                                          dataView.getBigUint64(0, isLittleEndian);\n  } catch {\n    return NaN;\n  }\n}\n\nexport function isPointer(type: ValueType): boolean {\n  return type === ValueType.POINTER32 || type === ValueType.POINTER64;\n}\nexport interface FormatData {\n  buffer: ArrayBuffer;\n  type: ValueType;\n  endianness: Endianness;\n  signed: boolean;\n  mode?: ValueTypeMode;\n}\n\nexport function format(formatData: FormatData): string {\n  if (!formatData.mode) {\n    console.error(`No known way of showing value for ${formatData.type}`);\n    return i18nString(UIStrings.notApplicable);\n  }\n  const valueView = new DataView(formatData.buffer);\n  const isLittleEndian = formatData.endianness === Endianness.LITTLE;\n  let value;\n\n  try {\n    switch (formatData.type) {\n      case ValueType.INT8:\n        value = formatData.signed ? valueView.getInt8(0) : valueView.getUint8(0);\n        return formatInteger(value, formatData.mode);\n      case ValueType.INT16:\n        value = formatData.signed ? valueView.getInt16(0, isLittleEndian) : valueView.getUint16(0, isLittleEndian);\n        return formatInteger(value, formatData.mode);\n      case ValueType.INT32:\n        value = formatData.signed ? valueView.getInt32(0, isLittleEndian) : valueView.getUint32(0, isLittleEndian);\n        return formatInteger(value, formatData.mode);\n      case ValueType.INT64:\n        value =\n            formatData.signed ? valueView.getBigInt64(0, isLittleEndian) : valueView.getBigUint64(0, isLittleEndian);\n        return formatInteger(value, formatData.mode);\n      case ValueType.FLOAT32:\n        value = valueView.getFloat32(0, isLittleEndian);\n        return formatFloat(value, formatData.mode);\n      case ValueType.FLOAT64:\n        value = valueView.getFloat64(0, isLittleEndian);\n        return formatFloat(value, formatData.mode);\n      case ValueType.POINTER32:\n        value = valueView.getUint32(0, isLittleEndian);\n        return formatInteger(value, ValueTypeMode.HEXADECIMAL);\n      case ValueType.POINTER64:\n        value = valueView.getBigUint64(0, isLittleEndian);\n        return formatInteger(value, ValueTypeMode.HEXADECIMAL);\n      default:\n        return Platform.assertNever(formatData.type, `Unknown value type: ${formatData.type}`);\n    }\n  } catch {\n    return i18nString(UIStrings.notApplicable);\n  }\n}\n\nexport function formatFloat(value: number, mode: ValueTypeMode): string {\n  switch (mode) {\n    case ValueTypeMode.DECIMAL:\n      return value.toFixed(2).toString();\n    case ValueTypeMode.SCIENTIFIC:\n      return value.toExponential(2).toString();\n    default:\n      throw new Error(`Unknown mode for floats: ${mode}.`);\n  }\n}\n\nexport function formatInteger(value: number|bigint, mode: ValueTypeMode): string {\n  switch (mode) {\n    case ValueTypeMode.DECIMAL:\n      return value.toString();\n    case ValueTypeMode.HEXADECIMAL:\n      if (value < 0) {\n        return i18nString(UIStrings.notApplicable);\n      }\n      return '0x' + value.toString(16).toUpperCase();\n    case ValueTypeMode.OCTAL:\n      if (value < 0) {\n        return i18nString(UIStrings.notApplicable);\n      }\n      return value.toString(8);\n    default:\n      throw new Error(`Unknown mode for integers: ${mode}.`);\n  }\n}\n"]}