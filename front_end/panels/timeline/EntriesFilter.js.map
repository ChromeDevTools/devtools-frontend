{"version":3,"file":"EntriesFilter.js","sourceRoot":"","sources":["../../../../../../front_end/panels/timeline/EntriesFilter.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Platform from '../../core/platform/platform.js';\nimport * as Trace from '../../models/trace/trace.js';\nimport * as PerfUI from '../../ui/legacy/components/perf_ui/perf_ui.js';\n\nimport {\n  entryIsVisibleInTimeline,\n} from './CompatibilityTracksAppender.js';\n\n/**\n * This class can take in a thread that has been generated by the\n * RendererHandler and apply certain actions to it in order to modify what is\n * shown to the user. These actions can be automatically applied by DevTools or\n * applied by the user.\n *\n * Once actions are applied, the invisibleEntries() method will return the\n * entries that are invisible, and this is the list of entries that should be\n * removed before rendering the resulting thread on the timeline.\n */\nexport class EntriesFilter {\n  #parsedTrace: Trace.TraceModel.ParsedTrace;\n  // Track the set of invisible entries.\n  #invisibleEntries: Trace.Types.Events.Event[] = [];\n  // List of entries whose children are hidden. This list is used to\n  // keep track of entries that should be identified in the UI as \"expandable\",\n  // since they can be clicked to reveal their hidden children.\n  #expandableEntries: Trace.Types.Events.Event[] = [];\n  // Cache for descendants of entry that have already been gathered. The descendants\n  // will never change so we can avoid running the potentially expensive search again.\n  #entryToDescendantsMap = new Map<Trace.Helpers.TreeHelpers.TraceEntryNode, Trace.Types.Events.Event[]>();\n\n  constructor(parsedTrace: Trace.TraceModel.ParsedTrace) {\n    this.#parsedTrace = parsedTrace;\n  }\n\n  #getEntryNode(entry: Trace.Types.Events.Event): Trace.Helpers.TreeHelpers.TraceEntryNode|undefined {\n    // The entry might be either from the Samples handler or Renderer handler. So we need to check both handlers to find\n    // the EntryNode.\n    return this.#parsedTrace.data.Samples.entryToNode.get(entry) ??\n        this.#parsedTrace.data.Renderer.entryToNode.get(entry);\n  }\n\n  /**\n   * Checks which actions can be applied on an entry. This allows us to only show possible actions in the Context Menu.\n   * For example, if an entry has no children, COLLAPSE_FUNCTION will not change the FlameChart, therefore there is no need to show this action as an option.\n   */\n  findPossibleActions(entry: Trace.Types.Events.Event): PerfUI.FlameChart.PossibleFilterActions {\n    const entryNode = this.#getEntryNode(entry);\n    if (!entryNode) {\n      // Invalid node was given, return no possible actions.\n      return {\n        [PerfUI.FlameChart.FilterAction.MERGE_FUNCTION]: false,\n        [PerfUI.FlameChart.FilterAction.COLLAPSE_FUNCTION]: false,\n        [PerfUI.FlameChart.FilterAction.COLLAPSE_REPEATING_DESCENDANTS]: false,\n        [PerfUI.FlameChart.FilterAction.RESET_CHILDREN]: false,\n        [PerfUI.FlameChart.FilterAction.UNDO_ALL_ACTIONS]: false,\n      };\n    }\n    const entryParent = entryNode.parent;\n    const allVisibleDescendants =\n        this.#findAllDescendantsOfNode(entryNode).filter(descendant => !this.#invisibleEntries.includes(descendant));\n    const allVisibleRepeatingDescendants = this.#findAllRepeatingDescendantsOfNext(entryNode).filter(\n        descendant => !this.#invisibleEntries.includes(descendant));\n    const allInVisibleDescendants =\n        this.#findAllDescendantsOfNode(entryNode).filter(descendant => this.#invisibleEntries.includes(descendant));\n\n    // If there are children to hide, indicate action as possible\n    const possibleActions: PerfUI.FlameChart.PossibleFilterActions = {\n      [PerfUI.FlameChart.FilterAction.MERGE_FUNCTION]: entryParent !== null,\n      [PerfUI.FlameChart.FilterAction.COLLAPSE_FUNCTION]: allVisibleDescendants.length > 0,\n      [PerfUI.FlameChart.FilterAction.COLLAPSE_REPEATING_DESCENDANTS]: allVisibleRepeatingDescendants.length > 0,\n      [PerfUI.FlameChart.FilterAction.RESET_CHILDREN]: allInVisibleDescendants.length > 0,\n      [PerfUI.FlameChart.FilterAction.UNDO_ALL_ACTIONS]: this.#invisibleEntries.length > 0,\n    };\n    return possibleActions;\n  }\n\n  /**\n   * Returns the amount of entry descendants that belong to the hidden entries array.\n   * */\n  findHiddenDescendantsAmount(entry: Trace.Types.Events.Event): number {\n    const entryNode = this.#getEntryNode(entry);\n    if (!entryNode) {\n      return 0;\n    }\n    const allDescendants = this.#findAllDescendantsOfNode(entryNode);\n    return allDescendants.filter(descendant => this.invisibleEntries().includes(descendant)).length;\n  }\n\n  /**\n   * Returns the set of entries that are invisible given the set of applied actions.\n   */\n  invisibleEntries(): Trace.Types.Events.Event[] {\n    return this.#invisibleEntries;\n  }\n\n  /**\n   * Sets hidden and expandable. Called when a trace with modifications is loaded and some entries are set as hidden and expandable.\n   * Both arrays are set together because if there is one, the other must be present too.\n   */\n  setHiddenAndExpandableEntries(\n      invisibleEntries: Trace.Types.Events.Event[], expandableEntries: Trace.Types.Events.Event[]): void {\n    this.#invisibleEntries.push(...invisibleEntries);\n    this.#expandableEntries.push(...expandableEntries);\n  }\n\n  entryIsInvisible(entry: Trace.Types.Events.Event): boolean {\n    return this.#invisibleEntries.includes(entry);\n  }\n\n  /**\n   * Returns the array of entries that have a sign indicating that entries below are hidden,\n   * and so that they can be \"expanded\" to reveal their hidden children.\n   */\n  expandableEntries(): Trace.Types.Events.Event[] {\n    return this.#expandableEntries;\n  }\n\n  /**\n   * Applies an action to hide entries or removes entries\n   * from hidden entries array depending on the action.\n   */\n  applyFilterAction(action: PerfUI.FlameChart.UserFilterAction): Trace.Types.Events.Event[] {\n    // We apply new user action to the set of all entries, and mark\n    // any that should be hidden by adding them to this set.\n    // Another approach would be to use splice() to remove items from the\n    // array, but doing this would be a mutation of the arry for every hidden\n    // event. Instead, we add entries to this set and return it as an array at the end.\n    const entriesToHide = new Set<Trace.Types.Events.Event>();\n\n    switch (action.type) {\n      case PerfUI.FlameChart.FilterAction.MERGE_FUNCTION: {\n        // The entry that was clicked on is merged into its parent. All its\n        // children remain visible, so we just have to hide the entry that was\n        // selected.\n        entriesToHide.add(action.entry);\n        // If parent node exists, add it to expandableEntries, so it would be possible to uncollapse its children.\n        const actionNode = this.#getEntryNode(action.entry) || null;\n        const parentNode = actionNode && this.#firstVisibleParentNodeForEntryNode(actionNode);\n        if (parentNode) {\n          this.#addExpandableEntry(parentNode.entry);\n        }\n        break;\n      }\n      case PerfUI.FlameChart.FilterAction.COLLAPSE_FUNCTION: {\n        // The entry itself remains visible, but all of its descendants are hidden.\n        const entryNode = this.#getEntryNode(action.entry);\n        if (!entryNode) {\n          // Invalid node was given, just ignore and move on.\n          break;\n        }\n        const allDescendants = this.#findAllDescendantsOfNode(entryNode);\n        allDescendants.forEach(descendant => entriesToHide.add(descendant));\n        this.#addExpandableEntry(action.entry);\n        break;\n      }\n      case PerfUI.FlameChart.FilterAction.COLLAPSE_REPEATING_DESCENDANTS: {\n        const entryNode = this.#getEntryNode(action.entry);\n        if (!entryNode) {\n          // Invalid node was given, just ignore and move on.\n          break;\n        }\n        const allRepeatingDescendants = this.#findAllRepeatingDescendantsOfNext(entryNode);\n        allRepeatingDescendants.forEach(descendant => entriesToHide.add(descendant));\n        if (entriesToHide.size > 0) {\n          this.#addExpandableEntry(action.entry);\n        }\n        break;\n      }\n      case PerfUI.FlameChart.FilterAction.UNDO_ALL_ACTIONS: {\n        this.#invisibleEntries = [];\n        this.#expandableEntries = [];\n        break;\n      }\n      case PerfUI.FlameChart.FilterAction.RESET_CHILDREN: {\n        this.#makeEntryChildrenVisible(action.entry);\n        break;\n      }\n      default:\n        Platform.assertNever(action.type, `Unknown EntriesFilter action: ${action.type}`);\n    }\n\n    this.#invisibleEntries.push(...entriesToHide);\n\n    return this.#invisibleEntries;\n  }\n\n  /**\n   * Add an entry to the array of entries that have a sign indicating that entries below are hidden.\n   * Also, remove all of the child entries of the new expandable entry from the expandable array. Do that because\n   * to draw the initiator from the closest visible entry, we need to get the closest entry that is\n   * marked as expandable and we do not want to get some that are hidden.\n   */\n  #addExpandableEntry(entry: Trace.Types.Events.Event): void {\n    this.#expandableEntries.push(entry);\n    const entryNode = this.#getEntryNode(entry);\n    if (!entryNode) {\n      // Invalid node was given, just ignore and move on.\n      return;\n    }\n    const allDescendants = this.#findAllDescendantsOfNode(entryNode);\n    if (allDescendants.length > 0) {\n      this.#expandableEntries = this.#expandableEntries.filter(entry => {\n        return !allDescendants.includes(entry);\n      });\n    }\n  }\n\n  firstVisibleParentEntryForEntry(entry: Trace.Types.Events.Event): Trace.Types.Events.Event|null {\n    const node = this.#getEntryNode(entry);\n    if (!node) {\n      return null;\n    }\n    const parent = this.#firstVisibleParentNodeForEntryNode(node);\n    return parent ? parent.entry : null;\n  }\n\n  // The direct parent might be hidden by other actions, therefore we look for the next visible parent.\n  #firstVisibleParentNodeForEntryNode(node: Trace.Helpers.TreeHelpers.TraceEntryNode):\n      Trace.Helpers.TreeHelpers.TraceEntryNode|null {\n    let parent = node.parent;\n    while ((parent && this.#invisibleEntries.includes(parent.entry)) ||\n           (parent && !entryIsVisibleInTimeline(parent.entry))) {\n      parent = parent.parent;\n    }\n    return parent;\n  }\n\n  #findAllDescendantsOfNode(root: Trace.Helpers.TreeHelpers.TraceEntryNode): Trace.Types.Events.Event[] {\n    const cachedDescendants = this.#entryToDescendantsMap.get(root);\n    if (cachedDescendants) {\n      return cachedDescendants;\n    }\n\n    const descendants: Trace.Types.Events.Event[] = [];\n\n    // Walk through all the descendants, starting at the root node.\n    const children: Trace.Helpers.TreeHelpers.TraceEntryNode[] = [...root.children];\n    while (children.length > 0) {\n      const childNode = children.shift();\n      if (childNode) {\n        descendants.push(childNode.entry);\n        const childNodeCachedDescendants = this.#entryToDescendantsMap.get(childNode);\n        // If the descendants of a child are cached, get them from the cache instead of iterating through them again\n        if (childNodeCachedDescendants) {\n          descendants.push(...childNodeCachedDescendants);\n        } else {\n          children.push(...childNode.children);\n        }\n      }\n    }\n\n    this.#entryToDescendantsMap.set(root, descendants);\n    return descendants;\n  }\n\n  #findAllRepeatingDescendantsOfNext(root: Trace.Helpers.TreeHelpers.TraceEntryNode): Trace.Types.Events.Event[] {\n    // Walk through all the ancestors, starting at the root node.\n    const children: Trace.Helpers.TreeHelpers.TraceEntryNode[] = [...root.children];\n    const repeatingNodes: Trace.Types.Events.Event[] = [];\n    const rootIsProfileCall = Trace.Types.Events.isProfileCall(root.entry);\n\n    while (children.length > 0) {\n      const childNode = children.shift();\n      if (childNode) {\n        const childIsProfileCall = Trace.Types.Events.isProfileCall(childNode.entry);\n        if (/* Handle SyntheticProfileCalls */ rootIsProfileCall && childIsProfileCall) {\n          const rootNodeEntry = root.entry as Trace.Types.Events.SyntheticProfileCall;\n          const childNodeEntry = childNode.entry as Trace.Types.Events.SyntheticProfileCall;\n\n          if (Trace.Helpers.SamplesIntegrator.SamplesIntegrator.framesAreEqual(\n                  rootNodeEntry.callFrame, childNodeEntry.callFrame)) {\n            repeatingNodes.push(childNode.entry);\n          }\n        } /* Handle Renderer events */ else if (!rootIsProfileCall && !childIsProfileCall) {\n          if (root.entry.name === childNode.entry.name) {\n            repeatingNodes.push(childNode.entry);\n          }\n        }\n        children.push(...childNode.children);\n      }\n    }\n\n    return repeatingNodes;\n  }\n\n  /**\n   * If an entry was selected from a link instead of clicking on it,\n   * it might be in the invisible entries array.\n   * If it is, reveal it by resetting clidren the closest expandable entry,\n   */\n  revealEntry(entry: Trace.Types.Events.Event): void {\n    const entryNode = this.#getEntryNode(entry);\n    if (!entryNode) {\n      // Invalid node was given, just ignore and move on.\n      return;\n    }\n    let closestExpandableParent = entryNode;\n    while (closestExpandableParent.parent && !this.#expandableEntries.includes(closestExpandableParent.entry)) {\n      closestExpandableParent = closestExpandableParent.parent;\n    }\n    this.#makeEntryChildrenVisible(closestExpandableParent.entry);\n  }\n\n  /**\n   * Removes all of the entry children from the\n   * invisible entries array to make them visible.\n   */\n  #makeEntryChildrenVisible(entry: Trace.Types.Events.Event): void {\n    const entryNode = this.#getEntryNode(entry);\n    if (!entryNode) {\n      // Invalid node was given, just ignore and move on.\n      return;\n    }\n    const descendants = this.#findAllDescendantsOfNode(entryNode);\n\n    /**\n     * Filter out all descendant of the node\n     * from the invisible entries list.\n     */\n    this.#invisibleEntries = this.#invisibleEntries.filter(entry => {\n      if (descendants.includes(entry)) {\n        return false;\n      }\n      return true;\n    });\n\n    /**\n     * Filter out all descentants and entry from expandable entries\n     * list to not show that some entries below those are hidden.\n     */\n    this.#expandableEntries = this.#expandableEntries.filter(iterEntry => {\n      if (descendants.includes(iterEntry) || iterEntry === entry) {\n        return false;\n      }\n      return true;\n    });\n  }\n\n  isEntryExpandable(event: Trace.Types.Events.Event): boolean {\n    return this.#expandableEntries.includes(event);\n  }\n}\n"]}