{"version":3,"file":"Initiators.js","sourceRoot":"","sources":["../../../../../../front_end/panels/timeline/Initiators.ts"],"names":[],"mappings":"AAAA,sCAAsC;AACtC,yEAAyE;AACzE,6BAA6B;AAqB7B,2EAA2E;AAC3E,uEAAuE;AACvE,+GAA+G;AAC/G,MAAM,+BAA+B,GAAG,EAAE,CAAC;AAE3C;;;;;;GAMG;AACH,MAAM,UAAU,oBAAoB,CAChC,WAAyC,EAAE,aAAuC,EAClF,aAAyC,EACzC,iBAA6C;IAC/C,MAAM,cAAc,GAAG;QACrB,GAAG,6BAA6B,CAAC,WAAW,EAAE,aAAa,EAAE,WAAW,CAAC,IAAI,CAAC,UAAU,CAAC,gBAAgB,CAAC;QAC1G,GAAG,iCAAiC,CAAC,aAAa,EAAE,WAAW,CAAC,IAAI,CAAC,UAAU,CAAC,iBAAiB,CAAC;KACnG,CAAC;IAEF,mHAAmH;IACnH,gFAAgF;IAChF,cAAc,CAAC,OAAO,CAClB,aAAa,CAAC,EAAE,CACZ,0CAA0C,CAAC,aAAa,EAAE,iBAAiB,EAAE,aAAa,EAAE,WAAW,CAAC,CAAC,CAAC;IAClH,OAAO,cAAc,CAAC;AACxB,CAAC;AAED,MAAM,UAAU,8BAA8B,CAC1C,WAAyC,EACzC,aAAuC;IAEzC,OAAO,6BAA6B,CAAC,WAAW,EAAE,aAAa,EAAE,WAAW,CAAC,IAAI,CAAC,eAAe,CAAC,gBAAgB,CAAC,CAAC;AACtH,CAAC;AAED,SAAS,6BAA6B,CAClC,WAAyC,EACzC,aAAuC,EACvC,gBAAyE;IAE3E,MAAM,cAAc,GAAoB,EAAE,CAAC;IAC3C,IAAI,YAAY,GAAkC,aAAa,CAAC;IAChE,MAAM,OAAO,GAAG,IAAI,GAAG,EAA4B,CAAC;IACpD,OAAO,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;IAE1B,oDAAoD;IACpD,OAAO,YAAY,IAAI,cAAc,CAAC,MAAM,GAAG,+BAA+B,EAAE,CAAC;QAC/E,MAAM,gBAAgB,GAAG,gBAAgB,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;QAE5D,IAAI,gBAAgB,EAAE,CAAC;YACrB,IAAI,OAAO,CAAC,GAAG,CAAC,gBAAgB,CAAC,EAAE,CAAC;gBAClC,MAAM;YACR,CAAC;YACD,kEAAkE;YAClE,oDAAoD;YACpD,wDAAwD;YACxD,QAAQ;YACR,cAAc,CAAC,IAAI,CAAC,EAAC,KAAK,EAAE,YAAY,EAAE,SAAS,EAAE,gBAAgB,EAAC,CAAC,CAAC;YACxE,YAAY,GAAG,gBAAgB,CAAC;YAChC,OAAO,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;YAC1B,SAAS;QACX,CAAC;QAED,MAAM,mBAAmB,GAAG,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;QACpF,IAAI,CAAC,mBAAmB,EAAE,CAAC;YACzB,wDAAwD;YACxD,uBAAuB;YACvB,YAAY,GAAG,IAAI,CAAC;YACpB,MAAM;QACR,CAAC;QAED,uCAAuC;QACvC,YAAY,GAAG,mBAAmB,CAAC,MAAM,EAAE,KAAK,IAAI,IAAI,CAAC;IAC3D,CAAC;IAED,OAAO,cAAc,CAAC;AACxB,CAAC;AAED,SAAS,iCAAiC,CACtC,aAAuC,EACvC,iBAA4E;IAE9E,MAAM,cAAc,GAAoB,EAAE,CAAC;IAE3C,+DAA+D;IAC/D,MAAM,wBAAwB,GAAG,iBAAiB,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC;IACtE,IAAI,wBAAwB,EAAE,CAAC;QAC7B,wBAAwB,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;YACvC,cAAc,CAAC,IAAI,CAAC,EAAC,KAAK,EAAE,SAAS,EAAE,aAAa,EAAC,CAAC,CAAC;QACzD,CAAC,CAAC,CAAC;IACL,CAAC;IAED,OAAO,cAAc,CAAC;AACxB,CAAC;AAED;;;;;GAKG;AACH,SAAS,0CAA0C,CAC/C,aAA4B,EAAE,iBAA6C,EAC3E,aAAyC,EAAE,WAAyC;IACtF,IAAI,aAAa,CAAC,QAAQ,CAAC,aAAa,CAAC,KAAK,CAAC,EAAE,CAAC;QAChD,IAAI,UAAU,GAAG,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,GAAG,CAAC,aAAa,CAAC,KAAK,CAAC,EAAE,MAAM,CAAC;QACxF,OAAO,UAAU,EAAE,KAAK,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,UAAU,EAAE,KAAK,CAAC,EAAE,CAAC;YAC3E,UAAU,GAAG,UAAU,CAAC,MAAM,IAAI,SAAS,CAAC;QAC9C,CAAC;QACD,aAAa,CAAC,KAAK,GAAG,UAAU,EAAE,KAAK,IAAI,aAAa,CAAC,KAAK,CAAC;QAC/D,aAAa,CAAC,aAAa,GAAG,IAAI,CAAC;IACrC,CAAC;IAED,IAAI,aAAa,CAAC,QAAQ,CAAC,aAAa,CAAC,SAAS,CAAC,EAAE,CAAC;QACpD,IAAI,UAAU,GAAG,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,GAAG,CAAC,aAAa,CAAC,SAAS,CAAC,EAAE,MAAM,CAAC;QAC5F,OAAO,UAAU,EAAE,KAAK,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,UAAU,EAAE,KAAK,CAAC,EAAE,CAAC;YAC3E,UAAU,GAAG,UAAU,CAAC,MAAM,IAAI,SAAS,CAAC;QAC9C,CAAC;QACD,aAAa,CAAC,SAAS,GAAG,UAAU,EAAE,KAAK,IAAI,aAAa,CAAC,SAAS,CAAC;QACvE,aAAa,CAAC,iBAAiB,GAAG,IAAI,CAAC;IACzC,CAAC;IAED,OAAO,aAAa,CAAC;AACvB,CAAC","sourcesContent":["// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Trace from '../../models/trace/trace.js';\n\nexport interface InitiatorData {\n  event: Trace.Types.Events.Event;\n  initiator: Trace.Types.Events.Event;\n  isEntryHidden?: boolean;\n  isInitiatorHidden?: boolean;\n}\n\nexport interface InitiatorDataOptions {\n  /**\n   * Used to limit how far back through the chain we go; some large JS apps can\n   * have vast amounts of initiator stacks and it's hard to render them\n   * efficiently, and also not very useful to the user if we just show loads of\n   * them.\n   */\n  predecessorLimit: number;\n}\n\n// We limit the amount of predecessors to 10; on large traces with large JS\n// stacks there can be a huge number of these. It's not super useful to\n// walk back too far and if we draw too many arrows on the timeline, the view becomes very cluttered and noisy.\nconst MAX_PREDECESSOR_INITIATOR_LIMIT = 10;\n\n/**\n * Given an event that the user has selected, this function returns all the\n * data of events and their initiators that need to be drawn on the flamechart.\n * The reason that this can return multiple InitiatorEntry objects is because we draw the\n * entire chain: for each, we see if it had an initiator, and\n * work backwards to draw each one, as well as the events initiated directly by the entry.\n */\nexport function initiatorsDataToDraw(\n    parsedTrace: Trace.TraceModel.ParsedTrace, selectedEvent: Trace.Types.Events.Event,\n    hiddenEntries: Trace.Types.Events.Event[],\n    expandableEntries: Trace.Types.Events.Event[]): readonly InitiatorData[] {\n  const initiatorsData = [\n    ...findInitiatorDataPredecessors(parsedTrace, selectedEvent, parsedTrace.data.Initiators.eventToInitiator),\n    ...findInitiatorDataDirectSuccessors(selectedEvent, parsedTrace.data.Initiators.initiatorToEvents),\n  ];\n\n  // For each InitiatorData, call a function that makes sure that neither the initiator or initiated entry is hidden.\n  // If they are, it will reassign the event or initiator to the closest ancestor.\n  initiatorsData.forEach(\n      initiatorData =>\n          getClosestVisibleInitiatorEntriesAncestors(initiatorData, expandableEntries, hiddenEntries, parsedTrace));\n  return initiatorsData;\n}\n\nexport function initiatorsDataToDrawForNetwork(\n    parsedTrace: Trace.TraceModel.ParsedTrace,\n    selectedEvent: Trace.Types.Events.Event,\n    ): readonly InitiatorData[] {\n  return findInitiatorDataPredecessors(parsedTrace, selectedEvent, parsedTrace.data.NetworkRequests.eventToInitiator);\n}\n\nfunction findInitiatorDataPredecessors(\n    parsedTrace: Trace.TraceModel.ParsedTrace,\n    selectedEvent: Trace.Types.Events.Event,\n    eventToInitiator: Map<Trace.Types.Events.Event, Trace.Types.Events.Event>,\n    ): readonly InitiatorData[] {\n  const initiatorsData: InitiatorData[] = [];\n  let currentEvent: Trace.Types.Events.Event|null = selectedEvent;\n  const visited = new Set<Trace.Types.Events.Event>();\n  visited.add(currentEvent);\n\n  // Build event initiator data up to the selected one\n  while (currentEvent && initiatorsData.length < MAX_PREDECESSOR_INITIATOR_LIMIT) {\n    const currentInitiator = eventToInitiator.get(currentEvent);\n\n    if (currentInitiator) {\n      if (visited.has(currentInitiator)) {\n        break;\n      }\n      // Store the current initiator data, and then set the initiator to\n      // be the current event, so we work back through the\n      // trace and find the initiator of the initiator, and so\n      // on...\n      initiatorsData.push({event: currentEvent, initiator: currentInitiator});\n      currentEvent = currentInitiator;\n      visited.add(currentEvent);\n      continue;\n    }\n\n    const nodeForCurrentEvent = parsedTrace.data.Renderer.entryToNode.get(currentEvent);\n    if (!nodeForCurrentEvent) {\n      // Should not happen - if it does something odd is going\n      // on so let's give up.\n      currentEvent = null;\n      break;\n    }\n\n    // Go up to the parent, and loop again.\n    currentEvent = nodeForCurrentEvent.parent?.entry || null;\n  }\n\n  return initiatorsData;\n}\n\nfunction findInitiatorDataDirectSuccessors(\n    selectedEvent: Trace.Types.Events.Event,\n    initiatorToEvents: Map<Trace.Types.Events.Event, Trace.Types.Events.Event[]>,\n    ): readonly InitiatorData[] {\n  const initiatorsData: InitiatorData[] = [];\n\n  // Add all of the initiated events to the initiatorsData array.\n  const eventsInitiatedByCurrent = initiatorToEvents.get(selectedEvent);\n  if (eventsInitiatedByCurrent) {\n    eventsInitiatedByCurrent.forEach(event => {\n      initiatorsData.push({event, initiator: selectedEvent});\n    });\n  }\n\n  return initiatorsData;\n}\n\n/**\n * Given an InitiatorData object that contains an initiator and event, this function returns\n * the closest visible ancestors. We need to apply this to each initiatorData because\n * the actual initiator or initiated event might be hidden form the flame chart.\n * If neither entry is hidden, this function returns the initial initiatorData object.\n */\nfunction getClosestVisibleInitiatorEntriesAncestors(\n    initiatorData: InitiatorData, expandableEntries: Trace.Types.Events.Event[],\n    hiddenEntries: Trace.Types.Events.Event[], parsedTrace: Trace.TraceModel.ParsedTrace): InitiatorData {\n  if (hiddenEntries.includes(initiatorData.event)) {\n    let nextParent = parsedTrace.data.Renderer.entryToNode.get(initiatorData.event)?.parent;\n    while (nextParent?.entry && !expandableEntries.includes(nextParent?.entry)) {\n      nextParent = nextParent.parent ?? undefined;\n    }\n    initiatorData.event = nextParent?.entry ?? initiatorData.event;\n    initiatorData.isEntryHidden = true;\n  }\n\n  if (hiddenEntries.includes(initiatorData.initiator)) {\n    let nextParent = parsedTrace.data.Renderer.entryToNode.get(initiatorData.initiator)?.parent;\n    while (nextParent?.entry && !expandableEntries.includes(nextParent?.entry)) {\n      nextParent = nextParent.parent ?? undefined;\n    }\n    initiatorData.initiator = nextParent?.entry ?? initiatorData.initiator;\n    initiatorData.isInitiatorHidden = true;\n  }\n\n  return initiatorData;\n}\n"]}