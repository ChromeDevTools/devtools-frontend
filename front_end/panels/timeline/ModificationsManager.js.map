{"version":3,"file":"ModificationsManager.js","sourceRoot":"","sources":["../../../../../../front_end/panels/timeline/ModificationsManager.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport * as Platform from '../../core/platform/platform.js';\nimport * as Trace from '../../models/trace/trace.js';\nimport * as TimelineComponents from '../../panels/timeline/components/components.js';\n\nimport * as AnnotationHelpers from './AnnotationHelpers.js';\nimport {EntriesFilter} from './EntriesFilter.js';\n\nconst modificationsManagerByTraceIndex: ModificationsManager[] = [];\nlet activeManager: ModificationsManager|null;\n\nexport type UpdateAction =\n    'Remove'|'Add'|'UpdateLabel'|'UpdateTimeRange'|'UpdateLinkToEntry'|'EnterLabelEditState'|'LabelBringForward';\n\n/**\n * Event dispatched after an annotation was added, removed or updated.\n * The event argument is the Overlay that needs to be created,removed\n * or updated by `Overlays.ts` and the action that needs to be applied to it.\n **/\nexport class AnnotationModifiedEvent extends Event {\n  static readonly eventName = 'annotationmodifiedevent';\n\n  constructor(\n      public overlay: Trace.Types.Overlays.Overlay, public action: UpdateAction, public muteAriaNotifications = false) {\n    super(AnnotationModifiedEvent.eventName);\n  }\n}\n\ninterface ModificationsManagerData {\n  parsedTrace: Trace.TraceModel.ParsedTrace;\n  traceBounds: Trace.Types.Timing.TraceWindowMicro;\n  rawTraceEvents: readonly Trace.Types.Events.Event[];\n  syntheticEvents: Trace.Types.Events.SyntheticBased[];\n  modifications?: Trace.Types.File.Modifications;\n}\n\nexport class ModificationsManager extends EventTarget {\n  #entriesFilter: EntriesFilter;\n  #timelineBreadcrumbs: TimelineComponents.Breadcrumbs.Breadcrumbs;\n  #modifications: Trace.Types.File.Modifications|null = null;\n  #parsedTrace: Trace.TraceModel.ParsedTrace;\n  #eventsSerializer: Trace.EventsSerializer.EventsSerializer;\n  #overlayForAnnotation: Map<Trace.Types.File.Annotation, Trace.Types.Overlays.Overlay>;\n  readonly #annotationsHiddenSetting: Common.Settings.Setting<boolean>;\n\n  /**\n   * Gets the ModificationsManager instance corresponding to a trace\n   * given its index used in Model#traces. If no index is passed gets\n   * the manager instance for the last trace. If no instance is found,\n   * throws.\n   */\n  static activeManager(): ModificationsManager|null {\n    return activeManager;\n  }\n\n  static reset(): void {\n    modificationsManagerByTraceIndex.length = 0;\n    activeManager = null;\n  }\n\n  /**\n   * Initializes a ModificationsManager instance for a parsed trace or changes the active manager for an existing one.\n   * This needs to be called if and a trace has been parsed or switched to.\n   */\n  static initAndActivateModificationsManager(traceModel: Trace.TraceModel.Model, traceIndex: number):\n      ModificationsManager|null {\n    // If a manager for a given index has already been created, active it.\n    if (modificationsManagerByTraceIndex[traceIndex]) {\n      if (activeManager === modificationsManagerByTraceIndex[traceIndex]) {\n        return activeManager;\n      }\n\n      activeManager = modificationsManagerByTraceIndex[traceIndex];\n      ModificationsManager.activeManager()?.applyModificationsIfPresent();\n    }\n\n    const parsedTrace = traceModel.parsedTrace(traceIndex);\n    if (!parsedTrace) {\n      throw new Error('ModificationsManager was initialized without a corresponding trace data');\n    }\n\n    const traceBounds = parsedTrace.data.Meta.traceBounds;\n    const newModificationsManager = new ModificationsManager({\n      parsedTrace,\n      traceBounds,\n      rawTraceEvents: parsedTrace.traceEvents,\n      modifications: parsedTrace.metadata.modifications,\n      syntheticEvents: parsedTrace.syntheticEventsManager.getSyntheticTraces(),\n    });\n    modificationsManagerByTraceIndex[traceIndex] = newModificationsManager;\n    activeManager = newModificationsManager;\n    ModificationsManager.activeManager()?.applyModificationsIfPresent();\n    return this.activeManager();\n  }\n\n  private constructor({parsedTrace, traceBounds, modifications}: ModificationsManagerData) {\n    super();\n    this.#entriesFilter = new EntriesFilter(parsedTrace);\n    // Create first breadcrumb from the initial full window\n    this.#timelineBreadcrumbs = new TimelineComponents.Breadcrumbs.Breadcrumbs(traceBounds);\n    this.#modifications = modifications || null;\n    this.#parsedTrace = parsedTrace;\n    this.#eventsSerializer = new Trace.EventsSerializer.EventsSerializer();\n    // This method is also called in SidebarAnnotationsTab, but calling this multiple times doesn't recreate the setting.\n    // Instead, after the second call, the cached setting is returned.\n    this.#annotationsHiddenSetting = Common.Settings.Settings.instance().moduleSetting('annotations-hidden');\n    // TODO: Assign annotations loaded from the trace file\n    this.#overlayForAnnotation = new Map();\n  }\n\n  getEntriesFilter(): EntriesFilter {\n    return this.#entriesFilter;\n  }\n\n  getTimelineBreadcrumbs(): TimelineComponents.Breadcrumbs.Breadcrumbs {\n    return this.#timelineBreadcrumbs;\n  }\n\n  deleteEmptyRangeAnnotations(): void {\n    for (const annotation of this.#overlayForAnnotation.keys()) {\n      if (annotation.type === 'TIME_RANGE' && annotation.label.length === 0) {\n        this.removeAnnotation(annotation);\n      }\n    }\n  }\n\n  /**\n   * Stores the annotation and creates its overlay.\n   * @returns the Overlay that gets created and associated with this annotation.\n   */\n  createAnnotation(newAnnotation: Trace.Types.File.Annotation, opts: {\n    loadedFromFile: boolean,\n    muteAriaNotifications: boolean,\n  }): Trace.Types.Overlays.Overlay {\n    // If a label already exists on an entry and a user is trying to create a new one, start editing an existing label instead.\n    if (newAnnotation.type === 'ENTRY_LABEL') {\n      const overlay = this.#findLabelOverlayForEntry(newAnnotation.entry);\n      if (overlay) {\n        this.dispatchEvent(new AnnotationModifiedEvent(overlay, 'EnterLabelEditState'));\n        return overlay;\n      }\n    }\n\n    // If the new annotation created was not loaded from the file, set the annotations visibility setting to true. That way we make sure\n    // the annotations are on when a new one is created.\n    if (!opts.loadedFromFile) {\n      // Time range annotation could also be used to check the length of a selection in the timeline. Therefore, only set the annotations\n      // hidden to true if annotations label is added. This is done in OverlaysImpl.\n      if (newAnnotation.type !== 'TIME_RANGE') {\n        this.#annotationsHiddenSetting.set(false);\n      }\n    }\n    const newOverlay = this.#createOverlayFromAnnotation(newAnnotation);\n    this.#overlayForAnnotation.set(newAnnotation, newOverlay);\n    this.dispatchEvent(new AnnotationModifiedEvent(newOverlay, 'Add', opts.muteAriaNotifications));\n    return newOverlay;\n  }\n\n  linkAnnotationBetweenEntriesExists(entryFrom: Trace.Types.Events.Event, entryTo: Trace.Types.Events.Event): boolean {\n    for (const annotation of this.#overlayForAnnotation.keys()) {\n      if (annotation.type === 'ENTRIES_LINK' &&\n          ((annotation.entryFrom === entryFrom && annotation.entryTo === entryTo) ||\n           (annotation.entryFrom === entryTo && annotation.entryTo === entryFrom))) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  #findLabelOverlayForEntry(entry: Trace.Types.Events.Event): Trace.Types.Overlays.Overlay|null {\n    for (const [annotation, overlay] of this.#overlayForAnnotation.entries()) {\n      if (annotation.type === 'ENTRY_LABEL' && annotation.entry === entry) {\n        return overlay;\n      }\n    }\n\n    return null;\n  }\n\n  bringEntryLabelForwardIfExists(entry: Trace.Types.Events.Event): void {\n    const overlay = this.#findLabelOverlayForEntry(entry);\n    if (overlay?.type === 'ENTRY_LABEL') {\n      this.dispatchEvent(new AnnotationModifiedEvent(overlay, 'LabelBringForward'));\n    }\n  }\n\n  #createOverlayFromAnnotation(annotation: Trace.Types.File.Annotation): Trace.Types.Overlays.EntryLabel\n      |Trace.Types.Overlays.TimeRangeLabel|Trace.Types.Overlays.EntriesLink {\n    switch (annotation.type) {\n      case 'ENTRY_LABEL':\n        return {\n          type: 'ENTRY_LABEL',\n          entry: annotation.entry,\n          label: annotation.label,\n        };\n      case 'TIME_RANGE':\n        return {\n          type: 'TIME_RANGE',\n          label: annotation.label,\n          showDuration: true,\n          bounds: annotation.bounds,\n        };\n      case 'ENTRIES_LINK':\n        return {\n          type: 'ENTRIES_LINK',\n          state: annotation.state,\n          entryFrom: annotation.entryFrom,\n          entryTo: annotation.entryTo,\n        };\n      default:\n        Platform.assertNever(annotation, 'Overlay for provided annotation cannot be created');\n    }\n  }\n\n  removeAnnotation(removedAnnotation: Trace.Types.File.Annotation): void {\n    const overlayToRemove = this.#overlayForAnnotation.get(removedAnnotation);\n    if (!overlayToRemove) {\n      console.warn('Overlay for deleted Annotation does not exist', removedAnnotation);\n      return;\n    }\n    this.#overlayForAnnotation.delete(removedAnnotation);\n    this.dispatchEvent(new AnnotationModifiedEvent(overlayToRemove, 'Remove'));\n  }\n\n  removeAnnotationOverlay(removedOverlay: Trace.Types.Overlays.Overlay): void {\n    const annotationForRemovedOverlay = this.getAnnotationByOverlay(removedOverlay);\n    if (!annotationForRemovedOverlay) {\n      console.warn('Annotation for deleted Overlay does not exist', removedOverlay);\n      return;\n    }\n    this.removeAnnotation(annotationForRemovedOverlay);\n  }\n\n  updateAnnotation(updatedAnnotation: Trace.Types.File.Annotation): void {\n    const overlay = this.#overlayForAnnotation.get(updatedAnnotation);\n\n    if (overlay && AnnotationHelpers.isTimeRangeLabel(overlay) &&\n        Trace.Types.File.isTimeRangeAnnotation(updatedAnnotation)) {\n      overlay.label = updatedAnnotation.label;\n      overlay.bounds = updatedAnnotation.bounds;\n      this.dispatchEvent(new AnnotationModifiedEvent(overlay, 'UpdateTimeRange'));\n\n    } else if (\n        overlay && AnnotationHelpers.isEntriesLink(overlay) &&\n        Trace.Types.File.isEntriesLinkAnnotation(updatedAnnotation)) {\n      overlay.state = updatedAnnotation.state;\n      overlay.entryFrom = updatedAnnotation.entryFrom;\n      overlay.entryTo = updatedAnnotation.entryTo;\n      this.dispatchEvent(new AnnotationModifiedEvent(overlay, 'UpdateLinkToEntry'));\n\n    } else {\n      console.error('Annotation could not be updated');\n    }\n  }\n\n  updateAnnotationOverlay(updatedOverlay: Trace.Types.Overlays.Overlay): void {\n    const annotationForUpdatedOverlay = this.getAnnotationByOverlay(updatedOverlay);\n    if (!annotationForUpdatedOverlay) {\n      console.warn('Annotation for updated Overlay does not exist');\n      return;\n    }\n\n    if ((updatedOverlay.type === 'ENTRY_LABEL' && annotationForUpdatedOverlay.type === 'ENTRY_LABEL') ||\n        (updatedOverlay.type === 'TIME_RANGE' && annotationForUpdatedOverlay.type === 'TIME_RANGE')) {\n      this.#annotationsHiddenSetting.set(false);\n      annotationForUpdatedOverlay.label = updatedOverlay.label;\n      this.dispatchEvent(new AnnotationModifiedEvent(updatedOverlay, 'UpdateLabel'));\n    }\n\n    if ((updatedOverlay.type === 'ENTRIES_LINK' && annotationForUpdatedOverlay.type === 'ENTRIES_LINK')) {\n      this.#annotationsHiddenSetting.set(false);\n      annotationForUpdatedOverlay.state = updatedOverlay.state;\n    }\n  }\n\n  getAnnotationByOverlay(overlay: Trace.Types.Overlays.Overlay): Trace.Types.File.Annotation|null {\n    for (const [annotation, currOverlay] of this.#overlayForAnnotation.entries()) {\n      if (currOverlay === overlay) {\n        return annotation;\n      }\n    }\n    return null;\n  }\n\n  getOverlaybyAnnotation(annotation: Trace.Types.File.Annotation): Trace.Types.Overlays.Overlay|null {\n    return this.#overlayForAnnotation.get(annotation) || null;\n  }\n\n  getAnnotations(): Trace.Types.File.Annotation[] {\n    return [...this.#overlayForAnnotation.keys()];\n  }\n\n  getOverlays(): Trace.Types.Overlays.Overlay[] {\n    return [...this.#overlayForAnnotation.values()];\n  }\n\n  applyAnnotationsFromCache(opts: {muteAriaNotifications: boolean}): void {\n    this.#modifications = this.toJSON();\n    // The cache is filled by applyModificationsIfPresent, so we clear\n    // it beforehand to prevent duplicate entries.\n    this.#overlayForAnnotation.clear();\n    this.#applyStoredAnnotations(this.#modifications.annotations, opts);\n  }\n\n  /**\n   * Builds all modifications into a serializable object written into\n   * the 'modifications' trace file metadata field.\n   */\n  toJSON(): Trace.Types.File.Modifications {\n    const hiddenEntries = this.#entriesFilter.invisibleEntries()\n                              .map(entry => this.#eventsSerializer.keyForEvent(entry))\n                              .filter(entry => entry !== null);\n    const expandableEntries = this.#entriesFilter.expandableEntries()\n                                  .map(entry => this.#eventsSerializer.keyForEvent(entry))\n                                  .filter(entry => entry !== null);\n    this.#modifications = {\n      entriesModifications: {\n        hiddenEntries,\n        expandableEntries,\n      },\n      initialBreadcrumb: this.#timelineBreadcrumbs.initialBreadcrumb,\n      annotations: this.#annotationsJSON(),\n    };\n    return this.#modifications;\n  }\n\n  #annotationsJSON(): Trace.Types.File.SerializedAnnotations {\n    const annotations = this.getAnnotations();\n    const entryLabelsSerialized: Trace.Types.File.EntryLabelAnnotationSerialized[] = [];\n    const labelledTimeRangesSerialized: Trace.Types.File.TimeRangeAnnotationSerialized[] = [];\n    const linksBetweenEntriesSerialized: Trace.Types.File.EntriesLinkAnnotationSerialized[] = [];\n\n    for (let i = 0; i < annotations.length; i++) {\n      const currAnnotation = annotations[i];\n      if (Trace.Types.File.isEntryLabelAnnotation(currAnnotation)) {\n        const serializedEvent = this.#eventsSerializer.keyForEvent(currAnnotation.entry);\n        if (serializedEvent) {\n          entryLabelsSerialized.push({\n            entry: serializedEvent,\n            label: currAnnotation.label,\n          });\n        }\n      } else if (Trace.Types.File.isTimeRangeAnnotation(currAnnotation)) {\n        labelledTimeRangesSerialized.push({\n          bounds: currAnnotation.bounds,\n          label: currAnnotation.label,\n        });\n      } else if (Trace.Types.File.isEntriesLinkAnnotation(currAnnotation)) {\n        // Only save the links between entries that are fully created and have the entry that it is pointing to set\n        if (currAnnotation.entryTo) {\n          const serializedFromEvent = this.#eventsSerializer.keyForEvent(currAnnotation.entryFrom);\n          const serializedToEvent = this.#eventsSerializer.keyForEvent(currAnnotation.entryTo);\n          if (serializedFromEvent && serializedToEvent) {\n            linksBetweenEntriesSerialized.push({\n              entryFrom: serializedFromEvent,\n              entryTo: serializedToEvent,\n            });\n          }\n        }\n      }\n    }\n\n    return {\n      entryLabels: entryLabelsSerialized,\n      labelledTimeRanges: labelledTimeRangesSerialized,\n      linksBetweenEntries: linksBetweenEntriesSerialized,\n    };\n  }\n\n  applyModificationsIfPresent(): void {\n    if (!this.#modifications || !this.#modifications.annotations) {\n      return;\n    }\n\n    const hiddenEntries = this.#modifications.entriesModifications.hiddenEntries;\n    const expandableEntries = this.#modifications.entriesModifications.expandableEntries;\n\n    this.#timelineBreadcrumbs.setInitialBreadcrumbFromLoadedModifications(this.#modifications.initialBreadcrumb);\n    this.#applyEntriesFilterModifications(hiddenEntries, expandableEntries);\n    this.#applyStoredAnnotations(this.#modifications.annotations, {\n      muteAriaNotifications: false,\n    });\n  }\n\n  #applyStoredAnnotations(annotations: Trace.Types.File.SerializedAnnotations, opts: {muteAriaNotifications: boolean}):\n      void {\n    try {\n      // Assign annotations to an empty array if they don't exist to not\n      // break the traces that were saved before those annotations were implemented\n      const entryLabels = annotations.entryLabels ?? [];\n      entryLabels.forEach(entryLabel => {\n        this.createAnnotation(\n            {\n              type: 'ENTRY_LABEL',\n              entry: this.#eventsSerializer.eventForKey(entryLabel.entry, this.#parsedTrace),\n              label: entryLabel.label,\n            },\n            {\n              loadedFromFile: true,\n              muteAriaNotifications: opts.muteAriaNotifications,\n            });\n      });\n\n      const timeRanges = annotations.labelledTimeRanges ?? [];\n      timeRanges.forEach(timeRange => {\n        this.createAnnotation(\n            {\n              type: 'TIME_RANGE',\n              bounds: timeRange.bounds,\n              label: timeRange.label,\n            },\n            {\n              loadedFromFile: true,\n              muteAriaNotifications: opts.muteAriaNotifications,\n            });\n      });\n\n      const linksBetweenEntries = annotations.linksBetweenEntries ?? [];\n      linksBetweenEntries.forEach(linkBetweenEntries => {\n        this.createAnnotation(\n            {\n              type: 'ENTRIES_LINK',\n              state: Trace.Types.File.EntriesLinkState.CONNECTED,\n              entryFrom: this.#eventsSerializer.eventForKey(linkBetweenEntries.entryFrom, this.#parsedTrace),\n              entryTo: this.#eventsSerializer.eventForKey(linkBetweenEntries.entryTo, this.#parsedTrace),\n            },\n            {\n              loadedFromFile: true,\n              muteAriaNotifications: opts.muteAriaNotifications,\n            });\n      });\n    } catch (err) {\n      // This function is wrapped in a try/catch just in case we get any incoming\n      // trace files with broken event keys. Shouldn't happen of course, but if\n      // it does, we can discard all the data and then continue loading the\n      // trace, rather than have the panel entirely break. This also prevents any\n      // issue where we accidentally break the event serializer and break people\n      // loading traces; let's at least make sure they can load the panel, even\n      // if their annotations are gone.\n      console.warn('Failed to apply stored annotations', err);\n    }\n  }\n\n  #applyEntriesFilterModifications(\n      hiddenEntriesKeys: Trace.Types.File.SerializableKey[],\n      expandableEntriesKeys: Trace.Types.File.SerializableKey[]): void {\n    try {\n      const hiddenEntries = hiddenEntriesKeys.map(key => this.#eventsSerializer.eventForKey(key, this.#parsedTrace));\n      const expandableEntries =\n          expandableEntriesKeys.map(key => this.#eventsSerializer.eventForKey(key, this.#parsedTrace));\n      this.#entriesFilter.setHiddenAndExpandableEntries(hiddenEntries, expandableEntries);\n    } catch (err) {\n      console.warn('Failed to apply entriesFilter modifications', err);\n      // If there was some invalid data, let's just back out and clear it\n      // entirely. This is better than applying a subset of all the hidden\n      // entries, which could cause an odd state in the flamechart.\n      this.#entriesFilter.setHiddenAndExpandableEntries([], []);\n    }\n  }\n}\n"]}