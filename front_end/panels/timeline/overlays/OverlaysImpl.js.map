{"version":3,"file":"OverlaysImpl.js","sourceRoot":"","sources":["../../../../../../../front_end/panels/timeline/overlays/OverlaysImpl.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n/* eslint-disable @devtools/no-imperative-dom-api */\n\nimport * as Common from '../../../core/common/common.js';\nimport * as i18n from '../../../core/i18n/i18n.js';\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as AIAssistance from '../../../models/ai_assistance/ai_assistance.js';\nimport * as Trace from '../../../models/trace/trace.js';\nimport type * as PerfUI from '../../../ui/legacy/components/perf_ui/perf_ui.js';\nimport * as VisualLogging from '../../../ui/visual_logging/visual_logging.js';\n\nimport * as Components from './components/components.js';\n\nconst UIStrings = {\n  /**\n   * @description Text for showing that a metric was observed in the local environment.\n   * @example {LCP} PH1\n   */\n  fieldMetricMarkerLocal: '{PH1} - Local',\n\n  /**\n   * @description Text for showing that a metric was observed in the field, from real use data (CrUX). Also denotes if from URL or Origin dataset.\n   * @example {LCP} PH1\n   * @example {URL} PH2\n   */\n  fieldMetricMarkerField: '{PH1} - Field ({PH2})',\n  /**\n   * @description Label for an option that selects the page's specific URL as opposed to it's entire origin/domain.\n   */\n  urlOption: 'URL',\n  /**\n   * @description Label for an option that selects the page's entire origin/domain as opposed to it's specific URL.\n   */\n  originOption: 'Origin',\n} as const;\nconst str_ = i18n.i18n.registerUIStrings('panels/timeline/overlays/OverlaysImpl.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\n/**\n * Below the network track there is a resize bar the user can click and drag.\n */\nconst NETWORK_RESIZE_ELEM_HEIGHT_PX = 8;\n\n/**\n * Represents which flamechart an entry is rendered in.\n * We need to know this because when we place an overlay for an entry we need\n * to adjust its Y value if it's in the main chart which is drawn below the\n * network chart\n */\nexport type EntryChartLocation = 'main'|'network';\n\n/**\n * Given a list of overlays, this method will calculate the smallest possible\n * trace window that will contain all of the overlays.\n * `overlays` is expected to be non-empty, and this will return `null` if it is empty.\n */\nexport function traceWindowContainingOverlays(overlays: Trace.Types.Overlays.Overlay[]):\n    Trace.Types.Timing.TraceWindowMicro|null {\n  const windows = overlays.map(Trace.Helpers.Timing.traceWindowFromOverlay).filter(b => !!b);\n  return Trace.Helpers.Timing.combineTraceWindowsMicro(windows);\n}\n\n/**\n * Get a list of entries for a given overlay.\n */\nexport function entriesForOverlay(overlay: Trace.Types.Overlays.Overlay): readonly Trace.Types.Overlays.OverlayEntry[] {\n  const entries: Trace.Types.Overlays.OverlayEntry[] = [];\n\n  switch (overlay.type) {\n    case 'ENTRY_SELECTED': {\n      entries.push(overlay.entry);\n      break;\n    }\n    case 'ENTRY_OUTLINE': {\n      entries.push(overlay.entry);\n      break;\n    }\n    case 'TIME_RANGE': {\n      // Time ranges are not associated with entries.\n      break;\n    }\n    case 'ENTRY_LABEL': {\n      entries.push(overlay.entry);\n      break;\n    }\n    case 'ENTRIES_LINK': {\n      entries.push(overlay.entryFrom);\n      if (overlay.entryTo) {\n        entries.push(overlay.entryTo);\n      }\n      break;\n    }\n    case 'TIMESPAN_BREAKDOWN': {\n      if (overlay.entry) {\n        entries.push(overlay.entry);\n      }\n      break;\n    }\n    case 'TIMESTAMP_MARKER': {\n      // This overlay type isn't associated to any entry, so just break here.\n      break;\n    }\n    case 'CANDY_STRIPED_TIME_RANGE': {\n      entries.push(overlay.entry);\n      break;\n    }\n    case 'TIMINGS_MARKER': {\n      entries.push(...overlay.entries);\n      break;\n    }\n    case 'BOTTOM_INFO_BAR':\n      break;\n    default:\n      Platform.assertNever(overlay, `Unknown overlay type ${JSON.stringify(overlay)}`);\n  }\n\n  return entries;\n}\nexport function chartForEntry(entry: Trace.Types.Overlays.OverlayEntry): EntryChartLocation {\n  if (Trace.Types.Events.isNetworkTrackEntry(entry)) {\n    return 'network';\n  }\n\n  return 'main';\n}\n\nexport interface TimelineOverlaySetOptions {\n  /** Whether to update the trace window. Defaults to false. */\n  updateTraceWindow?: boolean;\n  /**\n   * If updateTraceWindow is true, this is the total amount of space added as margins to the\n   * side of the bounds represented by the overlays, represented as a percentage relative to\n   * the width of the overlay bounds. The space is split evenly on either side of the overlay\n   * bounds. The intention is to neatly center the overlays in the middle of the viewport, with\n   * some additional context on either side.\n   *\n   * If 0, no margins will be added, and the precise bounds defined by the overlays will be used.\n   *\n   * If not provided, 100 is used (25% margin, 50% overlays, 25% margin).\n   */\n  updateTraceWindowPercentage?: number;\n}\n\n/**\n * Denotes overlays that are singletons; only one of these will be allowed to\n * exist at any given time. If one exists and the add() method is called, the\n * new overlay will replace the existing one.\n */\ntype SingletonOverlay = Trace.Types.Overlays.EntrySelected|Trace.Types.Overlays.TimestampMarker;\nexport function overlayIsSingleton(overlay: Trace.Types.Overlays.Overlay): overlay is SingletonOverlay {\n  return overlayTypeIsSingleton(overlay.type);\n}\n\nexport function overlayTypeIsSingleton(type: Trace.Types.Overlays.Overlay['type']): type is SingletonOverlay['type'] {\n  return type === 'TIMESTAMP_MARKER' || type === 'ENTRY_SELECTED' || type === 'BOTTOM_INFO_BAR';\n}\n\n/**\n * To be able to draw overlays accurately at the correct pixel position, we\n * need a variety of pixel values from both flame charts (Network and \"Rest\").\n * As each FlameChart draws, it emits an event with its latest set of\n * dimensions. That updates the Overlays and causes them to redraw.\n * Note that we can't use the visible trace window from the TraceBounds\n * service as that can get out of sync with rapid FlameChart draws. To ensure\n * we draw overlays smoothly as the FlameChart renders we use the latest values\n * provided to us from the FlameChart. In `FlameChart#draw` we dispatch an\n * event containing the latest dimensions, and those are passed into the\n * Overlays system via TimelineFlameChartView.\n */\ninterface ActiveDimensions {\n  trace: {\n    visibleWindow: Trace.Types.Timing.TraceWindowMicro|null,\n  };\n  charts: {\n    main: FlameChartDimensions|null,\n    network: FlameChartDimensions|null,\n  };\n}\n\n/**\n * The dimensions each flame chart reports. Note that in the current UI they\n * will always have the same width, so theoretically we could only gather that\n * from one chart, but we gather it from both for simplicity and to cover us in\n * the future should the UI change and the charts have different widths.\n */\ninterface FlameChartDimensions {\n  widthPixels: number;\n  heightPixels: number;\n  scrollOffsetPixels: number;\n  // If every single group (e.g. track) within the chart is collapsed or not.\n  // This matters because in the network track if every group (there is only\n  // one) is collapsed, there is no resizer bar shown, which impacts our pixel\n  // calculations for overlay positioning.\n  allGroupsCollapsed: boolean;\n}\n\nexport interface TimelineCharts {\n  mainChart: PerfUI.FlameChart.FlameChart;\n  mainProvider: PerfUI.FlameChart.FlameChartDataProvider;\n  networkChart: PerfUI.FlameChart.FlameChart;\n  networkProvider: PerfUI.FlameChart.FlameChartDataProvider;\n}\n\nexport interface OverlayEntryQueries {\n  parsedTrace: () => Trace.TraceModel.ParsedTrace | null;\n  isEntryCollapsedByUser: (entry: Trace.Types.Events.Event) => boolean;\n  firstVisibleParentForEntry: (entry: Trace.Types.Events.Event) => Trace.Types.Events.Event | null;\n}\n\n/**\n * An event dispatched when one of the Annotation Overlays (overlay created by the user,\n * ex. Trace.Types.Overlays.EntryLabel) is removed or updated. When one of the Annotation Overlays is removed or updated,\n * ModificationsManager listens to this event and updates the current annotations.\n **/\nexport type UpdateAction = 'Remove'|'Update';\nexport class AnnotationOverlayActionEvent extends Event {\n  static readonly eventName = 'annotationoverlayactionsevent';\n\n  constructor(public overlay: Trace.Types.Overlays.Overlay, public action: UpdateAction) {\n    super(AnnotationOverlayActionEvent.eventName);\n  }\n}\nexport class ConsentDialogVisibilityChange extends Event {\n  static readonly eventName = 'consentdialogvisibilitychange';\n  constructor(public isVisible: boolean) {\n    super(ConsentDialogVisibilityChange.eventName, {bubbles: true, composed: true});\n  }\n}\n\nexport class TimeRangeMouseOverEvent extends Event {\n  static readonly eventName = 'timerangemouseoverevent';\n\n  constructor(public overlay: Trace.Types.Overlays.TimeRangeLabel) {\n    super(TimeRangeMouseOverEvent.eventName, {bubbles: true});\n  }\n}\n\nexport class TimeRangeMouseOutEvent extends Event {\n  static readonly eventName = 'timerangemouseoutevent';\n\n  constructor() {\n    super(TimeRangeMouseOutEvent.eventName, {bubbles: true});\n  }\n}\n\nexport class EntryLabelMouseClick extends Event {\n  static readonly eventName = 'entrylabelmouseclick';\n  constructor(public overlay: Trace.Types.Overlays.EntryLabel) {\n    super(EntryLabelMouseClick.eventName, {composed: true, bubbles: true});\n  }\n}\n\ninterface EntriesLinkVisibleEntries {\n  entryFrom: Trace.Types.Events.Event;\n  entryTo: Trace.Types.Events.Event|undefined;\n  entryFromIsSource: boolean;\n  entryToIsSource: boolean;\n}\n\nexport class EventReferenceClick extends Event {\n  static readonly eventName = 'eventreferenceclick';\n\n  constructor(public event: Trace.Types.Events.Event) {\n    super(EventReferenceClick.eventName, {bubbles: true, composed: true});\n  }\n}\n\n/**\n * This class manages all the overlays that get drawn onto the performance\n * timeline. Overlays are DOM and are drawn above the network and main flame\n * chart.\n *\n * For more documentation, see `timeline/README.md` which has a section on overlays.\n */\nexport class Overlays extends EventTarget {\n  /**\n   * The list of active overlays. Overlays can't be marked as visible or\n   * hidden; every overlay in this list is rendered.\n   * We track each overlay against the HTML Element we have rendered. This is\n   * because on first render of a new overlay, we create it, but then on\n   * subsequent renders we do not destroy and recreate it, instead we update it\n   * based on the new position of the timeline.\n   */\n  #overlaysToElements = new Map<Trace.Types.Overlays.Overlay, HTMLElement|null>();\n\n  #singletonOverlays = new Map<SingletonOverlay['type'], Trace.Types.Overlays.Overlay>();\n\n  // When the Entries Link Annotation is created, the arrow needs to follow the mouse.\n  // Update the mouse coordinates while it is being created.\n  #lastMouseOffsetX: number|null = null;\n  #lastMouseOffsetY: number|null = null;\n  // `entriesLinkInProgress` is the entries link Overlay that has not yet been fully created\n  // and only has the entry that the link starts from set.\n  // We save it as a separate variable because when the second entry of the link is not chosen yet,\n  // the arrow follows the mouse. To achieve that, update the coordinates of `entriesLinkInProgress`\n  // on mousemove. There can only be one link in the process on being created so the mousemove\n  // only needs to update `entriesLinkInProgress` link overlay.\n  #entriesLinkInProgress: Trace.Types.Overlays.EntriesLink|null;\n\n  #dimensions: ActiveDimensions = {\n    trace: {\n      visibleWindow: null,\n    },\n    charts: {\n      main: null,\n      network: null,\n    },\n  };\n\n  /**\n   * To calculate the Y pixel value for an event we need access to the chart\n   * and data provider in order to find out what level the event is on, and from\n   * there calculate the pixel value for that level.\n   */\n  #charts: TimelineCharts;\n\n  /**\n   * The Overlays class will take each overlay, generate its HTML, and add it\n   * to the container. This container is provided for us when the class is\n   * created so we can manage its contents as overlays come and go.\n   */\n  #overlaysContainer: HTMLElement;\n\n  // Setting that specified if the annotations overlays need to be visible.\n  // It is switched on/off from the annotations tab in the sidebar.\n  readonly #annotationsHiddenSetting: Common.Settings.Setting<boolean>;\n\n  /**\n   * The OverlaysManager sometimes needs to find out if an entry is visible or\n   * not, and if not, why not - for example, if the user has collapsed its\n   * parent. We define these query functions that must be supplied in order to\n   * answer these questions.\n   */\n  #queries: OverlayEntryQueries;\n\n  constructor(init: {\n    container: HTMLElement,\n    flameChartsContainers: {\n      main: HTMLElement,\n      network: HTMLElement,\n    },\n    charts: TimelineCharts,\n    entryQueries: OverlayEntryQueries,\n  }) {\n    super();\n    this.#overlaysContainer = init.container;\n    this.#charts = init.charts;\n    this.#queries = init.entryQueries;\n    this.#entriesLinkInProgress = null;\n    this.#annotationsHiddenSetting = Common.Settings.Settings.instance().moduleSetting('annotations-hidden');\n    this.#annotationsHiddenSetting.addChangeListener(this.update.bind(this));\n\n    // HTMLElements of both Flamecharts. They are used to get the mouse position over the Flamecharts.\n    init.flameChartsContainers.main.addEventListener(\n        'mousemove', event => this.#updateMouseCoordinatesProgressEntriesLink.bind(this)(event, 'main'));\n    init.flameChartsContainers.network.addEventListener(\n        'mousemove', event => this.#updateMouseCoordinatesProgressEntriesLink.bind(this)(event, 'network'));\n  }\n\n  // Toggle display of the whole OverlaysContainer.\n  // This function is used to hide all overlays when the Flamechart is in the 'reorder tracks' state.\n  // If the tracks are being reordered, they are collapsed and we do not want to display\n  // anything except the tracks reordering interface.\n  //\n  // Do not change individual overlays visibility with 'setOverlayElementVisibility' since we do not\n  // want to overwrite the overlays visibility state that was set before entering the reordering state.\n  toggleAllOverlaysDisplayed(allOverlaysDisplayed: boolean): void {\n    this.#overlaysContainer.style.display = allOverlaysDisplayed ? 'block' : 'none';\n  }\n\n  // Mousemove event listener to get mouse coordinates and update them for the entries link that is being created.\n  //\n  // The 'mousemove' event is attached to `flameChartsContainers` instead of `overlaysContainer`\n  // because `overlaysContainer` doesn't have events to enable the interaction with the\n  // Flamecharts beneath it.\n  #updateMouseCoordinatesProgressEntriesLink(event: Event, chart: EntryChartLocation): void {\n    if (this.#entriesLinkInProgress?.state !== Trace.Types.File.EntriesLinkState.PENDING_TO_EVENT) {\n      return;\n    }\n    const mouseEvent = (event as MouseEvent);\n    this.#lastMouseOffsetX = mouseEvent.offsetX;\n    this.#lastMouseOffsetY = mouseEvent.offsetY;\n\n    // The Overlays layer coordinates cover both Network and Main Charts, while the mousemove\n    // coordinates are received from the charts individually and start from 0 for each chart.\n    //\n    // To make it work on the overlays, we need to know which chart the entry belongs to and,\n    // if it is on the main chart, add the height of the Network chart to get correct Entry\n    // coordinates on the Overlays layer.\n    const networkHeight = this.#dimensions.charts.network?.heightPixels ?? 0;\n    const linkInProgressElement = this.#overlaysToElements.get(this.#entriesLinkInProgress);\n\n    if (linkInProgressElement) {\n      const component = linkInProgressElement.querySelector('devtools-entries-link-overlay') as\n          Components.EntriesLinkOverlay.EntriesLinkOverlay;\n      const yCoordinate = mouseEvent.offsetY + ((chart === 'main') ? networkHeight : 0);\n      component.toEntryCoordinateAndDimensions = {x: mouseEvent.offsetX, y: yCoordinate};\n    }\n  }\n\n  /**\n   * Add a new overlay to the view.\n   */\n  add<T extends Trace.Types.Overlays.Overlay>(newOverlay: T): T {\n    if (this.#overlaysToElements.has(newOverlay)) {\n      return newOverlay;\n    }\n\n    /**\n     * If the overlay type is a singleton, and we already have one, we update\n     * the existing one, rather than create a new one. This ensures you can only\n     * ever have one instance of the overlay type.\n     */\n    if (overlayIsSingleton(newOverlay)) {\n      const existing = this.#singletonOverlays.get(newOverlay.type);\n      if (existing) {\n        this.updateExisting(existing, newOverlay);\n        return existing as T;  // The is a safe cast, thanks to `type` above.\n      }\n\n      this.#singletonOverlays.set(newOverlay.type, newOverlay);\n    }\n\n    // By setting the value to null, we ensure that on the next render that the\n    // overlay will have a new HTML element created for it.\n    this.#overlaysToElements.set(newOverlay, null);\n    return newOverlay;\n  }\n\n  /**\n   * Update an existing overlay without destroying and recreating its\n   * associated DOM.\n   *\n   * This is useful if you need to rapidly update an overlay's data - e.g.\n   * dragging to create time ranges - without the thrashing of destroying the\n   * old overlay and re-creating the new one.\n   */\n  updateExisting<T extends Trace.Types.Overlays.Overlay>(existingOverlay: T, newData: Partial<T>): void {\n    if (!this.#overlaysToElements.has(existingOverlay)) {\n      console.error('Trying to update an overlay that does not exist.');\n      return;\n    }\n\n    for (const [key, value] of Object.entries(newData)) {\n      // newData is of type Partial<T>, so each key must exist in T, but\n      // Object.entries doesn't carry that information.\n      const k = key as keyof T;\n      existingOverlay[k] = value;\n    }\n  }\n\n  enterLabelEditMode(overlay: Trace.Types.Overlays.EntryLabel): void {\n    // Entry edit state can be triggered from outside the label component by clicking on the\n    // Entry that already has a label. Instead of creating a new label, set the existing entry\n    // label into an editable state.\n    const element = this.#overlaysToElements.get(overlay);\n    const component = element?.querySelector('devtools-entry-label-overlay');\n    if (component) {\n      component.setLabelEditabilityAndRemoveEmptyLabel(true);\n    }\n  }\n\n  bringLabelForward(overlay: Trace.Types.Overlays.EntryLabel): void {\n    // Before bringing the element forward, remove the 'bring-forward' class from all the other elements\n    for (const element of this.#overlaysToElements.values()) {\n      element?.classList.remove('bring-forward');\n    }\n\n    const element = this.#overlaysToElements.get(overlay);\n    element?.classList.add('bring-forward');\n  }\n\n  /**\n   * @returns the list of overlays associated with a given entry.\n   */\n  overlaysForEntry(entry: Trace.Types.Overlays.OverlayEntry): Trace.Types.Overlays.Overlay[] {\n    const matches: Trace.Types.Overlays.Overlay[] = [];\n    for (const [overlay] of this.#overlaysToElements) {\n      if ('entry' in overlay && overlay.entry === entry) {\n        matches.push(overlay);\n      }\n    }\n    return matches;\n  }\n\n  /**\n   * Used for debugging and testing. Do not mutate the element directly using\n   * this method.\n   */\n  elementForOverlay(overlay: Trace.Types.Overlays.Overlay): HTMLElement|null {\n    return this.#overlaysToElements.get(overlay) ?? null;\n  }\n\n  /**\n   * Removes any active overlays that match the provided type.\n   * @returns the number of overlays that were removed.\n   */\n  removeOverlaysOfType(type: Trace.Types.Overlays.Overlay['type']): number {\n    if (overlayTypeIsSingleton(type)) {\n      const singleton = this.#singletonOverlays.get(type);\n      if (singleton) {\n        this.remove(singleton);\n        return 1;\n      }\n\n      return 0;\n    }\n\n    const overlaysToRemove = Array.from(this.#overlaysToElements.keys()).filter(overlay => {\n      return overlay.type === type;\n    });\n    for (const overlay of overlaysToRemove) {\n      this.remove(overlay);\n    }\n    return overlaysToRemove.length;\n  }\n\n  /**\n   * @returns all overlays that match the provided type.\n   */\n  overlaysOfType<T extends Trace.Types.Overlays.Overlay>(type: T['type']): Array<NoInfer<T>> {\n    if (overlayTypeIsSingleton(type)) {\n      const singleton = this.#singletonOverlays.get(type);\n      if (singleton) {\n        return [singleton as T];\n      }\n\n      return [];\n    }\n\n    const matches: T[] = [];\n\n    function overlayIsOfType(overlay: Trace.Types.Overlays.Overlay): overlay is T {\n      return overlay.type === type;\n    }\n\n    for (const [overlay] of this.#overlaysToElements) {\n      if (overlayIsOfType(overlay)) {\n        matches.push(overlay);\n      }\n    }\n    return matches;\n  }\n\n  /**\n   * @returns all overlays.\n   */\n  allOverlays(): Trace.Types.Overlays.Overlay[] {\n    return [...this.#overlaysToElements.keys()];\n  }\n\n  /**\n   * Removes the provided overlay from the list of overlays and destroys any\n   * DOM associated with it.\n   */\n  remove(overlay: Trace.Types.Overlays.Overlay): void {\n    const htmlElement = this.#overlaysToElements.get(overlay);\n    if (htmlElement && this.#overlaysContainer) {\n      this.#overlaysContainer.removeChild(htmlElement);\n    }\n    this.#overlaysToElements.delete(overlay);\n    if (overlayIsSingleton(overlay)) {\n      this.#singletonOverlays.delete(overlay.type);\n    }\n  }\n\n  /**\n   * Update the dimensions of a chart.\n   * IMPORTANT: this does not trigger a re-draw. You must call the render() method manually.\n   */\n  updateChartDimensions(chart: EntryChartLocation, dimensions: FlameChartDimensions): void {\n    this.#dimensions.charts[chart] = dimensions;\n  }\n\n  /**\n   * Update the visible window of the UI.\n   * IMPORTANT: this does not trigger a re-draw. You must call the render() method manually.\n   */\n  updateVisibleWindow(visibleWindow: Trace.Types.Timing.TraceWindowMicro): void {\n    this.#dimensions.trace.visibleWindow = visibleWindow;\n  }\n\n  /**\n   * Clears all overlays and all data. Call this when the trace is changing\n   * (e.g. the user has imported/recorded a new trace) and we need to start from\n   * scratch and remove all overlays relating to the previous trace.\n   */\n  reset(): void {\n    if (this.#overlaysContainer) {\n      this.#overlaysContainer.innerHTML = '';\n    }\n    this.#overlaysToElements.clear();\n    this.#singletonOverlays.clear();\n\n    // Clear out dimensions from the old Flame Charts.\n    this.#dimensions.trace.visibleWindow = null;\n    this.#dimensions.charts.main = null;\n    this.#dimensions.charts.network = null;\n  }\n\n  /**\n   * Updates the Overlays UI: new overlays will be rendered onto the view, and\n   * existing overlays will have their positions changed to ensure they are\n   * rendered in the right place.\n   */\n  async update(): Promise<void> {\n    const timeRangeOverlays: Trace.Types.Overlays.TimeRangeLabel[] = [];\n\n    for (const [overlay, existingElement] of this.#overlaysToElements) {\n      const element = existingElement || this.#createElementForNewOverlay(overlay);\n      if (!existingElement) {\n        // This is a new overlay, so we have to store the element and add it to the DOM.\n        this.#overlaysToElements.set(overlay, element);\n        this.#overlaysContainer.appendChild(element);\n      }\n\n      // A chance to update the overlay before we re-position it. If an\n      // overlay's data changed, this is where we can pass that data into the\n      // overlay's component so it has the latest data.\n      this.#updateOverlayBeforePositioning(overlay, element);\n\n      // Now we position the overlay on the timeline.\n      this.#positionOverlay(overlay, element);\n\n      // And now we give every overlay a chance to react to its new position,\n      // if it needs to\n      this.#updateOverlayAfterPositioning(overlay, element);\n\n      if (overlay.type === 'TIME_RANGE') {\n        timeRangeOverlays.push(overlay);\n      }\n    }\n\n    if (timeRangeOverlays.length > 1) {  // If there are 0 or 1 overlays, they can't overlap\n      this.#positionOverlappingTimeRangeLabels(timeRangeOverlays);\n    }\n  }\n\n  /**\n   * If any time-range overlays overlap, we try to adjust their horizontal\n   * position in order to make sure you can distinguish them and that the labels\n   * do not entirely overlap.\n   * This is very much minimal best effort, and does not guarantee that all\n   * labels will remain readable.\n   */\n  #positionOverlappingTimeRangeLabels(overlays: readonly Trace.Types.Overlays.TimeRangeLabel[]): void {\n    const overlaysSorted = overlays.toSorted((o1, o2) => {\n      return o1.bounds.min - o2.bounds.min;\n    });\n\n    // Track the overlays which overlap other overlays.\n    // This isn't bi-directional: if we find that O2 overlaps O1, we will\n    // store O1 => [O2]. We will not then also store O2 => [O1], because we\n    // only need to deal with the overlap once.\n    const overlapsByOverlay = new Map<Trace.Types.Overlays.TimeRangeLabel, Trace.Types.Overlays.TimeRangeLabel[]>();\n\n    for (let i = 0; i < overlaysSorted.length; i++) {\n      const current = overlaysSorted[i];\n      const overlaps: Trace.Types.Overlays.TimeRangeLabel[] = [];\n\n      // Walk through subsequent overlays and find stop when you find the next one that does not overlap.\n      for (let j = i + 1; j < overlaysSorted.length; j++) {\n        const next = overlaysSorted[j];\n        const currentAndNextOverlap = Trace.Helpers.Timing.boundsIncludeTimeRange({\n          bounds: current.bounds,\n          timeRange: next.bounds,\n        });\n        if (currentAndNextOverlap) {\n          overlaps.push(next);\n        } else {\n          // Overlays are sorted by time, if this one does not overlap, the next one will not, so we can break.\n          break;\n        }\n      }\n      overlapsByOverlay.set(current, overlaps);\n    }\n    for (const [firstOverlay, overlappingOverlays] of overlapsByOverlay) {\n      const element = this.#overlaysToElements.get(firstOverlay);\n      if (!element) {\n        continue;\n      }\n\n      // If the first overlay is adjusted, we can start back from 0 again\n      // rather than continually increment up.\n      let firstIndexForOverlapClass = 1;\n      if (element.getAttribute('class')?.includes('overlap-')) {\n        firstIndexForOverlapClass = 0;\n      }\n\n      overlappingOverlays.forEach(overlay => {\n        const element = this.#overlaysToElements.get(overlay);\n        element?.classList.add(`overlap-${firstIndexForOverlapClass++}`);\n      });\n    }\n  }\n\n  #positionOverlay(overlay: Trace.Types.Overlays.Overlay, element: HTMLElement): void {\n    const annotationsAreHidden = this.#annotationsHiddenSetting.get();\n    switch (overlay.type) {\n      case 'ENTRY_SELECTED': {\n        const isVisible = this.entryIsVisibleOnChart(overlay.entry);\n        this.#setOverlayElementVisibility(element, isVisible);\n        if (isVisible) {\n          this.#positionEntryBorderOutlineType(overlay.entry, element);\n        }\n        break;\n      }\n      case 'ENTRY_OUTLINE': {\n        if (this.entryIsVisibleOnChart(overlay.entry)) {\n          this.#setOverlayElementVisibility(element, true);\n          this.#positionEntryBorderOutlineType(overlay.entry, element);\n        } else {\n          this.#setOverlayElementVisibility(element, false);\n        }\n        break;\n      }\n\n      case 'TIME_RANGE': {\n        // The time range annotation can also be used to measure a selection in the timeline and is not saved if no label is added.\n        // Therefore, we only care about the annotation hidden setting if the time range has a label.\n        if (overlay.label.length) {\n          this.#setOverlayElementVisibility(element, !annotationsAreHidden);\n        }\n        this.#positionTimeRangeOverlay(overlay, element);\n        break;\n      }\n      case 'ENTRY_LABEL': {\n        const entryVisible = this.entryIsVisibleOnChart(overlay.entry);\n        this.#setOverlayElementVisibility(element, entryVisible && !annotationsAreHidden);\n        if (entryVisible) {\n          const entryLabelVisibleHeight = this.#positionEntryLabelOverlay(overlay, element);\n          const component = element.querySelector('devtools-entry-label-overlay');\n          if (component && entryLabelVisibleHeight) {\n            component.entryLabelVisibleHeight = entryLabelVisibleHeight;\n          }\n        }\n        break;\n      }\n      case 'ENTRIES_LINK': {\n        // The exact entries that are linked to could be collapsed in a flame\n        // chart, so we figure out the best visible entry pairs to draw\n        // between.\n        const entriesToConnect = this.#calculateFromAndToForEntriesLink(overlay);\n        const isVisible = entriesToConnect !== null && !annotationsAreHidden;\n        this.#setOverlayElementVisibility(element, isVisible);\n\n        if (isVisible) {\n          this.#positionEntriesLinkOverlay(overlay, element, entriesToConnect);\n        }\n        break;\n      }\n      case 'TIMESPAN_BREAKDOWN': {\n        this.#positionTimespanBreakdownOverlay(overlay, element);\n        // TODO: Have the timespan squeeze instead.\n        if (overlay.entry) {\n          const {visibleWindow} = this.#dimensions.trace;\n          const isVisible = Boolean(\n              visibleWindow && this.#entryIsVerticallyVisibleOnChart(overlay.entry) &&\n                  Trace.Helpers.Timing.boundsIncludeTimeRange({\n                    bounds: visibleWindow,\n                    timeRange: overlay.sections[0].bounds,\n                  }),\n          );\n          this.#setOverlayElementVisibility(element, isVisible);\n        }\n        break;\n      }\n\n      case 'TIMESTAMP_MARKER': {\n        const {visibleWindow} = this.#dimensions.trace;\n        // Only update the position if the timestamp of this marker is within\n        // the visible bounds.\n        const isVisible =\n            Boolean(visibleWindow && Trace.Helpers.Timing.timestampIsInBounds(visibleWindow, overlay.timestamp));\n        this.#setOverlayElementVisibility(element, isVisible);\n        if (isVisible) {\n          this.#positionTimingOverlay(overlay, element);\n        }\n        break;\n      }\n\n      case 'CANDY_STRIPED_TIME_RANGE': {\n        const {visibleWindow} = this.#dimensions.trace;\n        // If the bounds of this overlay are not within the visible bounds, we\n        // can skip updating its position and just hide it.\n\n        const isVisible = Boolean(\n            visibleWindow && this.#entryIsVerticallyVisibleOnChart(overlay.entry) &&\n            Trace.Helpers.Timing.boundsIncludeTimeRange({\n              bounds: visibleWindow,\n              timeRange: overlay.bounds,\n            }));\n        this.#setOverlayElementVisibility(element, isVisible);\n        if (isVisible) {\n          this.#positionCandyStripedTimeRange(overlay, element);\n        }\n        break;\n      }\n\n      case 'TIMINGS_MARKER': {\n        const {visibleWindow} = this.#dimensions.trace;\n        // All the entries have the same ts, so can use the first.\n        const isVisible = Boolean(visibleWindow && this.#entryIsHorizontallyVisibleOnChart(overlay.entries[0]));\n        this.#setOverlayElementVisibility(element, isVisible);\n        if (isVisible) {\n          this.#positionTimingOverlay(overlay, element);\n        }\n        break;\n      }\n\n      case 'BOTTOM_INFO_BAR': {\n        this.#positionInfoBarBanner(overlay, element);\n        break;\n      }\n\n      default: {\n        Platform.TypeScriptUtilities.assertNever(overlay, `Unknown overlay: ${JSON.stringify(overlay)}`);\n      }\n    }\n  }\n\n  #positionInfoBarBanner(\n      overlay: Trace.Types.Overlays.BottomInfoBar,\n      element: HTMLElement,\n      ): void {\n    const mainChart = this.#dimensions.charts.main;\n    if (!mainChart) {\n      this.#setOverlayElementVisibility(element, false);\n      return;\n    }\n\n    /*\n     * This calculation determines how many pixels of the bottom-positioned element\n     * (the banner) are visible within a scrollable container.\n\n     * The logic works by first calculating the number of pixels that are hidden\n     * below the current scroll position, and then subtracting that value from\n     * the total height of the banner.\n\n     * 1. totalHeight - (mainChart.scrollOffsetPixels + mainChart.heightPixels):\n     *    Calculates the number of pixels of content that are hidden below the\n     *    bottom of the viewport.\n\n     * 2. defaultBannerHeight - (hidden pixels):\n     *    Subtracts the hidden pixels from the banner's total height to find\n     *    the remaining, visible portion.\n     */\n\n    // By default an Infobar is 40px high. But when it comes to rendering it\n    // might be higher if the infobar is wrapped; so we adjust the actual\n    // number of visible pixels later on.\n    // We can't use the real value in the calculation because when its hidden\n    // it has a height of 0, which means we'd never calculate the right values.\n    const defaultBannerHeight = 40;\n    const totalHeight = this.#charts.mainChart.totalContentHeight();\n    const pixelsHiddenBelowViewport = totalHeight - (mainChart.scrollOffsetPixels + mainChart.heightPixels);\n    const visiblePixelsOfBanner = defaultBannerHeight - pixelsHiddenBelowViewport;\n\n    if (visiblePixelsOfBanner <= 0) {\n      this.#setOverlayElementVisibility(element, false);\n      return;\n    }\n\n    this.#setOverlayElementVisibility(element, true);\n\n    // Now we adjust our calculation based on the actual size of the infobar\n    // (it has height as now it's visible on the screen)\n    // We do this by removing the default banner height (to reset our\n    // calculation back to \"0\") and adding the actual height.\n    const actualBannerHeight = overlay.infobar.element.clientHeight;\n    const adjustedVisiblePixels = visiblePixelsOfBanner - defaultBannerHeight + actualBannerHeight;\n    // Use Math.min here to ensure the infobar never grows beyond the size it\n    // needs to be. Without this we make the infobar fill all available space\n    // in the canvas, but we want it to stay the right size and stuck to the\n    // bottom.\n    element.style.height = `${Math.min(adjustedVisiblePixels, actualBannerHeight)}px`;\n\n    // So it doesn't overlap the right scrollbar.\n    if (this.#charts.mainChart.verticalScrollBarVisible()) {\n      element.style.right = '11px';\n    } else {\n      element.style.right = '0';\n    }\n  }\n\n  #positionTimingOverlay(\n      overlay: Trace.Types.Overlays.TimestampMarker|Trace.Types.Overlays.TimingsMarker, element: HTMLElement): void {\n    let left;\n    switch (overlay.type) {\n      case 'TIMINGS_MARKER': {\n        // All the entries have the same ts, so can use the first.\n        const timings = Trace.Helpers.Timing.eventTimingsMicroSeconds(overlay.entries[0]);\n        left = this.#xPixelForMicroSeconds('main', timings.startTime);\n        break;\n      }\n      case 'TIMESTAMP_MARKER': {\n        // Because we are adjusting the x position, we can use either chart here.\n        left = this.#xPixelForMicroSeconds('main', overlay.timestamp);\n        break;\n      }\n    }\n    element.style.left = `${left}px`;\n  }\n\n  #positionTimespanBreakdownOverlay(overlay: Trace.Types.Overlays.TimespanBreakdown, element: HTMLElement): void {\n    if (overlay.sections.length === 0) {\n      return;\n    }\n\n    const component = element.querySelector('devtools-timespan-breakdown-overlay');\n    const elementSections = component?.renderedSections() ?? [];\n\n    // Handle horizontal positioning.\n    const leftEdgePixel = this.#xPixelForMicroSeconds('main', overlay.sections[0].bounds.min);\n    const rightEdgePixel =\n        this.#xPixelForMicroSeconds('main', overlay.sections[overlay.sections.length - 1].bounds.max);\n    if (leftEdgePixel === null || rightEdgePixel === null) {\n      return;\n    }\n\n    const rangeWidth = rightEdgePixel - leftEdgePixel;\n    element.style.left = `${leftEdgePixel}px`;\n    element.style.width = `${rangeWidth}px`;\n\n    if (elementSections.length === 0) {\n      return;\n    }\n\n    let count = 0;\n    for (const section of overlay.sections) {\n      const leftPixel = this.#xPixelForMicroSeconds('main', section.bounds.min);\n      const rightPixel = this.#xPixelForMicroSeconds('main', section.bounds.max);\n      if (leftPixel === null || rightPixel === null) {\n        return;\n      }\n      const rangeWidth = rightPixel - leftPixel;\n      const sectionElement = elementSections[count];\n\n      sectionElement.style.left = `${leftPixel}px`;\n      sectionElement.style.width = `${rangeWidth}px`;\n      count++;\n    }\n\n    // Handle vertical positioning based on the entry's vertical position.\n    if (overlay.entry && (overlay.renderLocation === 'BELOW_EVENT' || overlay.renderLocation === 'ABOVE_EVENT')) {\n      // Max height for the overlay box when attached to an entry.\n      const MAX_BOX_HEIGHT = 50;\n      element.style.maxHeight = `${MAX_BOX_HEIGHT}px`;\n\n      const y = this.yPixelForEventOnChart(overlay.entry);\n      if (y === null) {\n        return;\n      }\n      const eventHeight = this.pixelHeightForEventOnChart(overlay.entry);\n      if (eventHeight === null) {\n        return;\n      }\n\n      if (overlay.renderLocation === 'BELOW_EVENT') {\n        const top = y + eventHeight;\n        element.style.top = `${top}px`;\n      } else {\n        // Some padding so the box hovers just on top.\n        const PADDING = 7;\n\n        // Where the timespan breakdown should sit. Slightly on top of the entry.\n        const bottom = y - PADDING;\n\n        // Available space between the bottom of the overlay and top of the chart.\n        const minSpace = Math.max(bottom, 0);\n        // Constrain height to available space.\n        const height = Math.min(MAX_BOX_HEIGHT, minSpace);\n\n        const top = bottom - height;\n        element.style.top = `${top}px`;\n      }\n    }\n  }\n\n  /**\n   * Positions the arrow between two entries. Takes in the entriesToConnect\n   * because if one of the original entries is hidden in a collapsed main thread\n   * icicle, we use its parent to connect to.\n   */\n  #positionEntriesLinkOverlay(\n      overlay: Trace.Types.Overlays.EntriesLink, element: HTMLElement,\n      entriesToConnect: EntriesLinkVisibleEntries): void {\n    const component = element.querySelector('devtools-entries-link-overlay');\n\n    if (component) {\n      const fromEntryInCollapsedTrack = this.#entryIsInCollapsedTrack(entriesToConnect.entryFrom);\n      const toEntryInCollapsedTrack =\n          entriesToConnect.entryTo && this.#entryIsInCollapsedTrack(entriesToConnect.entryTo);\n\n      const bothEntriesInCollapsedTrack = Boolean(fromEntryInCollapsedTrack && toEntryInCollapsedTrack);\n      // If both entries are in collapsed tracks, we hide the overlay completely.\n      if (bothEntriesInCollapsedTrack) {\n        this.#setOverlayElementVisibility(element, false);\n        return;\n      }\n\n      // If either entry (but not both) is in a track that the user has collapsed, we do not\n      // show the connection at all, but we still show the borders around\n      // the entry. So in this case we mark the overlay as visible, but\n      // tell it to not draw the arrow.\n      const hideArrow = Boolean(fromEntryInCollapsedTrack || toEntryInCollapsedTrack);\n      component.hideArrow = hideArrow;\n\n      const {entryFrom, entryTo, entryFromIsSource, entryToIsSource} = entriesToConnect;\n      const entryFromWrapper = component.entryFromWrapper();\n\n      // Should not happen, the 'from' wrapper should always exist. Something went wrong, return in this case.\n      if (!entryFromWrapper) {\n        return;\n      }\n\n      const entryFromVisibility = this.entryIsVisibleOnChart(entryFrom) && !fromEntryInCollapsedTrack;\n      const entryToVisibility = entryTo ? this.entryIsVisibleOnChart(entryTo) && !toEntryInCollapsedTrack : false;\n\n      // If the entry is not currently visible, draw the arrow to the edge of the screen towards the entry on the Y-axis.\n      let fromEntryX = 0;\n      let fromEntryY = this.#yCoordinateForNotVisibleEntry(entryFrom);\n\n      // If the entry is visible, draw the arrow to the entry.\n      if (entryFromVisibility) {\n        const fromEntryParams = this.#positionEntryBorderOutlineType(entriesToConnect.entryFrom, entryFromWrapper);\n        if (fromEntryParams) {\n          const fromEntryHeight = fromEntryParams?.entryHeight;\n          const fromEntryWidth = fromEntryParams?.entryWidth;\n          const fromCutOffHeight = fromEntryParams?.cutOffHeight;\n          fromEntryX = fromEntryParams?.x;\n          fromEntryY = fromEntryParams?.y;\n\n          component.fromEntryCoordinateAndDimensions =\n              {x: fromEntryX, y: fromEntryY, length: fromEntryWidth, height: fromEntryHeight - fromCutOffHeight};\n        } else {\n          // Something went if the entry is visible and we cannot get its' parameters.\n          return;\n        }\n      }\n\n      // If `fromEntry` is not visible and the link creation is not started yet, meaning that\n      // only the button to create the link is displayed, delete the whole overlay.\n      if (!entryFromVisibility && overlay.state === Trace.Types.File.EntriesLinkState.CREATION_NOT_STARTED) {\n        this.dispatchEvent(new AnnotationOverlayActionEvent(overlay, 'Remove'));\n      }\n\n      // If entryTo exists, pass the coordinates and dimensions of the entry that the arrow snaps to.\n      // If it does not, the event tracking mouse coordinates updates 'to coordinates' so the arrow follows the mouse instead.\n      const entryToWrapper = component.entryToWrapper();\n\n      if (entryTo && entryToWrapper) {\n        let toEntryX = this.xPixelForEventStartOnChart(entryTo) ?? 0;\n        // If the 'to' entry is visible, set the entry Y as an arrow coordinate to point to. If not, get the canvas edge coordate to point the arrow to.\n        let toEntryY = this.#yCoordinateForNotVisibleEntry(entryTo);\n        const toEntryParams = this.#positionEntryBorderOutlineType(entryTo, entryToWrapper);\n\n        if (toEntryParams) {\n          const toEntryHeight = toEntryParams?.entryHeight;\n          const toEntryWidth = toEntryParams?.entryWidth;\n          const toCutOffHeight = toEntryParams?.cutOffHeight;\n          toEntryX = toEntryParams?.x;\n          toEntryY = toEntryParams?.y;\n\n          component.toEntryCoordinateAndDimensions = {\n            x: toEntryX,\n            y: toEntryY,\n            length: toEntryWidth,\n            height: toEntryHeight - toCutOffHeight,\n          };\n        } else {\n          // if the entry exists and we cannot get its' parameters, it is probably loaded and is off screen.\n          // In this case, assign the coordinates so we can draw the arrow in the right direction.\n          component.toEntryCoordinateAndDimensions = {\n            x: toEntryX,\n            y: toEntryY,\n          };\n          return;\n        }\n\n      } else {\n        // If the 'to' entry does not exist, the link is being created.\n        // The second coordinate for in progress link gets updated on mousemove\n        this.#entriesLinkInProgress = overlay;\n      }\n\n      component.fromEntryIsSource = entryFromIsSource;\n      component.toEntryIsSource = entryToIsSource;\n      component.entriesVisibility = {\n        fromEntryVisibility: entryFromVisibility,\n        toEntryVisibility: entryToVisibility,\n      };\n    }\n  }\n\n  /**\n   *  Return Y coordinate for an arrow connecting 2 entries to attach to if the entry is not visible.\n   *  For example, if the entry is scrolled up from the visible area , return the y index of the edge of the track:\n   *  --\n   * |  | - entry off the visible chart\n   *  --\n   *\n   * --Y---------------  -- Y is the returned coordinate that the arrow should point to\n   *\n   * flamechart data     -- visible flamechart data between the 2 lines\n   * ------------------\n   *\n   * On the contrary, if the entry is scrolled off the bottom, get the coordinate of the top of the visible canvas.\n   */\n  #yCoordinateForNotVisibleEntry(entry: Trace.Types.Overlays.OverlayEntry): number {\n    const chartName = chartForEntry(entry);\n\n    const y = this.yPixelForEventOnChart(entry);\n    if (y === null) {\n      return 0;\n    }\n\n    if (chartName === 'main') {\n      if (!this.#dimensions.charts.main?.heightPixels) {\n        // Shouldn't happen, but if the main chart has no height, nothing on it is visible.\n        return 0;\n      }\n\n      const yWithoutNetwork = y - this.networkChartOffsetHeight();\n      // Check if the y position is less than 0. If it, the entry is off the top of the track canvas.\n      // In that case, return the height of network track, which is also the top of main track.\n      if (yWithoutNetwork < 0) {\n        return this.networkChartOffsetHeight();\n      }\n    }\n\n    if (chartName === 'network') {\n      if (!this.#dimensions.charts.network) {\n        return 0;\n      }\n\n      // The event is off the bottom of the network chart. In this case return the bottom of the network chart.\n      if (y > this.#dimensions.charts.network.heightPixels) {\n        return this.#dimensions.charts.network.heightPixels;\n      }\n    }\n\n    // In other cases, return the y of the entry\n    return y;\n  }\n\n  #positionTimeRangeOverlay(overlay: Trace.Types.Overlays.TimeRangeLabel, element: HTMLElement): void {\n    // Time ranges span both charts, it doesn't matter which one we pass here.\n    // It's used to get the width of the container, and both charts have the\n    // same width.\n    const leftEdgePixel = this.#xPixelForMicroSeconds('main', overlay.bounds.min);\n    const rightEdgePixel = this.#xPixelForMicroSeconds('main', overlay.bounds.max);\n    if (leftEdgePixel === null || rightEdgePixel === null) {\n      return;\n    }\n\n    const rangeWidth = rightEdgePixel - leftEdgePixel;\n\n    element.style.left = `${leftEdgePixel}px`;\n    element.style.width = `${rangeWidth}px`;\n  }\n\n  /**\n   * @param overlay the EntrySelected overlay that we need to position.\n   * @param element the DOM element representing the overlay\n   */\n  #positionEntryLabelOverlay(overlay: Trace.Types.Overlays.EntryLabel, element: HTMLElement): number|null {\n    // Because the entry outline is a common Overlay pattern, get the wrapper of the entry\n    // that comes with the Trace.Types.Overlays.EntryLabel Overlay and pass it into the `positionEntryBorderOutlineType`\n    // to draw and position it. The other parts of Trace.Types.Overlays.EntryLabel are drawn by the `EntryLabelOverlay` class.\n    const component = element.querySelector('devtools-entry-label-overlay');\n    if (!component) {\n      return null;\n    }\n    const entryWrapper = component.entryHighlightWrapper();\n    const inputField = component.shadowRoot?.querySelector<HTMLElement>('.input-field');\n\n    if (!entryWrapper) {\n      return null;\n    }\n\n    const {entryHeight, entryWidth, cutOffHeight = 0, x, y} =\n        this.#positionEntryBorderOutlineType(overlay.entry, entryWrapper) || {};\n\n    if (!entryHeight || !entryWidth || x === null || !y) {\n      return null;\n    }\n\n    // Use the actual inputfield height to position the overlay, with a default value in case the element has not yet been rendered.\n    const inputFieldHeight = inputField?.offsetHeight ?? 25;\n    // Position the start of label overlay at the start of the entry + length of connector + length of the label element\n    element.style.top =\n        `${y - Components.EntryLabelOverlay.EntryLabelOverlay.LABEL_CONNECTOR_HEIGHT - inputFieldHeight}px`;\n    element.style.left = `${x}px`;\n    element.style.width = `${entryWidth}px`;\n\n    return entryHeight - cutOffHeight;\n  }\n\n  #positionCandyStripedTimeRange(overlay: Trace.Types.Overlays.CandyStripedTimeRange, element: HTMLElement): void {\n    const chartName = chartForEntry(overlay.entry);\n\n    const startX = this.#xPixelForMicroSeconds(chartName, overlay.bounds.min);\n    const endX = this.#xPixelForMicroSeconds(chartName, overlay.bounds.max);\n    if (startX === null || endX === null) {\n      return;\n    }\n\n    const widthPixels = endX - startX;\n    // The entry selected overlay is always at least 2px wide.\n    const finalWidth = Math.max(2, widthPixels);\n    element.style.width = `${finalWidth}px`;\n    element.style.left = `${startX}px`;\n\n    let y = this.yPixelForEventOnChart(overlay.entry);\n    if (y === null) {\n      return;\n    }\n\n    const totalHeight = this.pixelHeightForEventOnChart(overlay.entry) ?? 0;\n\n    // We might modify the height we use when drawing the overlay, hence copying the totalHeight.\n    let height = totalHeight;\n    if (height === null) {\n      return;\n    }\n\n    // If the event is on the main chart, we need to adjust its selected border\n    // if the event is cut off the top of the screen, because we need to ensure\n    // that it does not overlap the resize element. Unfortunately we cannot\n    // z-index our way out of this, so instead we calculate if the event is cut\n    // off, and if it is, we draw the partial selected outline and do not draw\n    // the top border, making it appear like it is going behind the resizer.\n    // We don't need to worry about it going off the bottom, because in that\n    // case we don't draw the overlay anyway.\n    if (chartName === 'main') {\n      const chartTopPadding = this.networkChartOffsetHeight();\n      // We now calculate the available height: if the entry is cut off we don't\n      // show the border for the part that is cut off.\n      const cutOffTop = y < chartTopPadding;\n\n      height = cutOffTop ? Math.abs(y + height - chartTopPadding) : height;\n      element.classList.toggle('cut-off-top', cutOffTop);\n      if (cutOffTop) {\n        // Adjust the y position: we need to move it down from the top Y\n        // position to the Y position of the first visible pixel. The\n        // adjustment is totalHeight - height because if the totalHeight is 17,\n        // and the visibleHeight is 5, we need to draw the overlay at 17-5=12px\n        // vertically from the top of the event.\n        y = y + totalHeight - height;\n      }\n    } else {\n      // If the event is on the network chart, we use the same logic as above\n      // for the main chart, but to check if the event is cut off the bottom of\n      // the network track and only part of the overlay is visible.\n      // We don't need to worry about the event going off the top of the panel\n      // as we can show the full overlay and it gets cut off by the minimap UI.\n      const networkHeight = this.#dimensions.charts.network?.heightPixels ?? 0;\n      const lastVisibleY = y + totalHeight;\n      const cutOffBottom = lastVisibleY > networkHeight;\n      const cutOffTop = y > networkHeight;\n      element.classList.toggle('cut-off-top', cutOffTop);\n      element.classList.toggle('cut-off-bottom', cutOffBottom);\n      if (cutOffBottom) {\n        // Adjust the height of the overlay to be the amount of visible pixels.\n        height = networkHeight - y;\n      }\n    }\n\n    element.style.height = `${height}px`;\n    element.style.top = `${y}px`;\n  }\n\n  /**\n   * Draw and position borders around an entry. Multiple overlays either fully consist\n   * of a border around an entry of have an entry border as a part of the overlay.\n   * Positions an EntrySelected or EntryOutline overlay and a part of the Trace.Types.Overlays.EntryLabel.\n   * @param overlay the EntrySelected/EntryOutline/Trace.Types.Overlays.EntryLabel overlay that we need to position.\n   * @param element the DOM element representing the overlay\n   */\n  #positionEntryBorderOutlineType(entry: Trace.Types.Overlays.OverlayEntry, element: HTMLElement):\n      {entryHeight: number, entryWidth: number, cutOffHeight: number, x: number, y: number}|null {\n    const chartName = chartForEntry(entry);\n    let x = this.xPixelForEventStartOnChart(entry);\n    let y = this.yPixelForEventOnChart(entry);\n    const chartWidth = (chartName === 'main') ? this.#dimensions.charts.main?.widthPixels :\n                                                this.#dimensions.charts.network?.widthPixels;\n\n    if (x === null || y === null || !chartWidth) {\n      return null;\n    }\n\n    const {endTime} = timingsForOverlayEntry(entry);\n    const endX = this.#xPixelForMicroSeconds(chartName, endTime);\n    if (endX === null) {\n      return null;\n    }\n\n    const totalHeight = this.pixelHeightForEventOnChart(entry) ?? 0;\n\n    // We might modify the height we use when drawing the overlay, hence copying the totalHeight.\n    let height = totalHeight;\n    if (height === null) {\n      return null;\n    }\n\n    // The width of the overlay is by default the width of the entry. However\n    // we modify that for instant events like LCP markers, and also ensure a\n    // minimum width.\n    let widthPixels = endX - x;\n\n    const provider = chartName === 'main' ? this.#charts.mainProvider : this.#charts.networkProvider;\n    const chart = chartName === 'main' ? this.#charts.mainChart : this.#charts.networkChart;\n    const index = provider.indexForEvent?.(entry);\n    const customPos = chart.getCustomDrawnPositionForEntryIndex(index ?? -1);\n    if (customPos) {\n      // Some events like markers and layout shifts define their exact coordinates explicitly.\n      // If this is one of those events we should change the overlay coordinates to match.\n      x = customPos.x;\n      widthPixels = customPos.width;\n    }\n\n    // Calculate the visible overlay width by subtracting the entry width that is outside of the flamechart width\n    const cutOffRight = (x + widthPixels > chartWidth) ? (x + widthPixels) - chartWidth : null;\n    const cutOffLeft = (x < 0) ? Math.abs(x) : null;\n    element.classList.toggle('cut-off-right', cutOffRight !== null);\n\n    if (cutOffRight) {\n      widthPixels = widthPixels - cutOffRight;\n    }\n\n    if (cutOffLeft) {\n      // If the entry is cut off from the left, move its beginning to the left most part of the flamechart\n      x = 0;\n      widthPixels = widthPixels - cutOffLeft;\n    }\n\n    // The entry selected overlay is always at least 2px wide.\n    const finalWidth = Math.max(2, widthPixels);\n    element.style.width = `${finalWidth}px`;\n\n    // If the event is on the main chart, we need to adjust its selected border\n    // if the event is cut off the top of the screen, because we need to ensure\n    // that it does not overlap the resize element. Unfortunately we cannot\n    // z-index our way out of this, so instead we calculate if the event is cut\n    // off, and if it is, we draw the partial selected outline and do not draw\n    // the top border, making it appear like it is going behind the resizer.\n    // We don't need to worry about it going off the bottom, because in that\n    // case we don't draw the overlay anyway.\n    if (chartName === 'main') {\n      const chartTopPadding = this.networkChartOffsetHeight();\n      // We now calculate the available height: if the entry is cut off we don't\n      // show the border for the part that is cut off.\n      const cutOffTop = y < chartTopPadding;\n\n      height = cutOffTop ? Math.abs(y + height - chartTopPadding) : height;\n      element.classList.toggle('cut-off-top', cutOffTop);\n      if (cutOffTop) {\n        // Adjust the y position: we need to move it down from the top Y\n        // position to the Y position of the first visible pixel. The\n        // adjustment is totalHeight - height because if the totalHeight is 17,\n        // and the visibleHeight is 5, we need to draw the overlay at 17-5=12px\n        // vertically from the top of the event.\n        y = y + totalHeight - height;\n      }\n    } else {\n      // If the event is on the network chart, we use the same logic as above\n      // for the main chart, but to check if the event is cut off the bottom of\n      // the network track and only part of the overlay is visible.\n      // We don't need to worry about the even going off the top of the panel\n      // as we can show the full overlay and it gets cut off by the minimap UI.\n      const networkHeight = this.#dimensions.charts.network?.heightPixels ?? 0;\n      const lastVisibleY = y + totalHeight;\n      const cutOffBottom = lastVisibleY > networkHeight;\n      element.classList.toggle('cut-off-bottom', cutOffBottom);\n      if (cutOffBottom) {\n        // Adjust the height of the overlay to be the amount of visible pixels.\n        height = networkHeight - y;\n      }\n    }\n\n    element.style.height = `${height}px`;\n    element.style.top = `${y}px`;\n    element.style.left = `${x}px`;\n\n    return {entryHeight: totalHeight, entryWidth: finalWidth, cutOffHeight: totalHeight - height, x, y};\n  }\n\n  /**\n   * We draw an arrow between connected entries but this can get complicated\n   * depending on if the entries are visible or not. For example, the user might\n   * draw a connection to an entry in the main thread but then collapse the\n   * parent of that entry. In this case the entry we want to draw to is the\n   * first visible parent of that entry rather than the (invisible) entry.\n   */\n  #calculateFromAndToForEntriesLink(overlay: Trace.Types.Overlays.EntriesLink): EntriesLinkVisibleEntries|null {\n    if (!overlay.entryTo) {\n      // This case is where the user has clicked on the first entry and needs\n      // to pick a second. In this case they can only pick from visible\n      // entries, so we don't need to do any checks and can just return.\n      return {\n        entryFrom: overlay.entryFrom,\n        entryTo: overlay.entryTo,\n        entryFromIsSource: true,\n        entryToIsSource: true,\n      };\n    }\n\n    let entryFrom: Trace.Types.Overlays.OverlayEntry|null = overlay.entryFrom;\n    let entryTo: Trace.Types.Overlays.OverlayEntry|null = overlay.entryTo ?? null;\n\n    if (this.#queries.isEntryCollapsedByUser(overlay.entryFrom)) {\n      entryFrom = this.#queries.firstVisibleParentForEntry(overlay.entryFrom);\n    }\n    if (overlay.entryTo && this.#queries.isEntryCollapsedByUser(overlay.entryTo)) {\n      entryTo = this.#queries.firstVisibleParentForEntry(overlay.entryTo);\n    }\n\n    if (entryFrom === null || entryTo === null) {\n      // We cannot draw this overlay; so return null;\n      // The only valid case of entryTo being null/undefined has been dealt\n      // with already at the start of this function.\n      return null;\n    }\n\n    return {\n      entryFrom,\n      entryFromIsSource: entryFrom === overlay.entryFrom,\n      entryTo,\n      entryToIsSource: entryTo === overlay.entryTo,\n    };\n  }\n\n  // Dimms all label annotations except the one that is hovered over in the timeline or sidebar.\n  // The highlighter annotation is brought forward.\n  highlightOverlay(overlay: Trace.Types.Overlays.EntryLabel): void {\n    const allLabelOverlays = this.overlaysOfType('ENTRY_LABEL');\n    for (const otherOverlay of allLabelOverlays) {\n      const element = this.elementForOverlay(otherOverlay);\n      const component = element?.querySelector('devtools-entry-label-overlay');\n      if (element && !component?.hasAttribute('data-user-editing-label')) {\n        if (otherOverlay === overlay) {\n          element.style.opacity = '1';\n          element.style.zIndex = '3';\n        } else {\n          element.style.opacity = '0.5';\n          element.style.zIndex = '2';\n        }\n      }\n    }\n  }\n\n  undimAllEntryLabels(): void {\n    const allLabelOverlays = this.overlaysOfType('ENTRY_LABEL');\n    for (const otherOverlay of allLabelOverlays) {\n      const element = this.elementForOverlay(otherOverlay);\n      if (element) {\n        element.style.opacity = '1';\n        element.style.zIndex = '2';\n      }\n    }\n  }\n\n  #createElementForNewOverlay(overlay: Trace.Types.Overlays.Overlay): HTMLElement {\n    const overlayElement = document.createElement('div');\n    overlayElement.classList.add('overlay-item', `overlay-type-${overlay.type}`);\n\n    const jslogContext = jsLogContext(overlay);\n    if (jslogContext) {\n      overlayElement.setAttribute('jslog', `${VisualLogging.item(jslogContext)}`);\n    }\n\n    switch (overlay.type) {\n      case 'ENTRY_LABEL': {\n        const shouldDrawLabelBelowEntry = Trace.Types.Events.isLegacyTimelineFrame(overlay.entry);\n        const component = new Components.EntryLabelOverlay.EntryLabelOverlay(overlay.label, shouldDrawLabelBelowEntry);\n        // Generate the AI Call Tree for the AI Auto-Annotation feature.\n        const parsedTrace = this.#queries.parsedTrace();\n        const callTree = parsedTrace ? AIAssistance.AICallTree.AICallTree.fromEvent(overlay.entry, parsedTrace) : null;\n        component.callTree = callTree;\n\n        component.addEventListener(\n            Components.EntryLabelOverlay.LabelAnnotationsConsentDialogVisibilityChange.eventName, e => {\n              const event = e as Components.EntryLabelOverlay.LabelAnnotationsConsentDialogVisibilityChange;\n              this.dispatchEvent(new ConsentDialogVisibilityChange(event.isVisible));\n            });\n        component.addEventListener(Components.EntryLabelOverlay.EntryLabelRemoveEvent.eventName, () => {\n          this.dispatchEvent(new AnnotationOverlayActionEvent(overlay, 'Remove'));\n        });\n        component.addEventListener(Components.EntryLabelOverlay.EntryLabelChangeEvent.eventName, event => {\n          const newLabel = (event as Components.EntryLabelOverlay.EntryLabelChangeEvent).newLabel;\n          overlay.label = newLabel;\n          this.dispatchEvent(new AnnotationOverlayActionEvent(overlay, 'Update'));\n        });\n        overlayElement.addEventListener('mouseover', () => {\n          this.highlightOverlay(overlay);\n        });\n        overlayElement.addEventListener('mouseout', () => {\n          this.undimAllEntryLabels();\n        });\n        overlayElement.appendChild(component);\n        overlayElement.addEventListener('click', event => {\n          event.preventDefault();\n          event.stopPropagation();\n          this.dispatchEvent(new EntryLabelMouseClick(overlay));\n        });\n        return overlayElement;\n      }\n      case 'ENTRIES_LINK': {\n        const entries = this.#calculateFromAndToForEntriesLink(overlay);\n        if (entries === null) {\n          // For some reason, we don't have two entries we can draw between\n          // (can happen if the user has collapsed an icicle in the flame\n          // chart, or a track), so just draw an empty div.\n          return overlayElement;\n        }\n        const entryEndX = this.xPixelForEventEndOnChart(entries.entryFrom) ?? 0;\n        const entryStartX = this.xPixelForEventEndOnChart(entries.entryFrom) ?? 0;\n        const entryStartY = (this.yPixelForEventOnChart(entries.entryFrom) ?? 0);\n        const entryWidth = entryEndX - entryStartX;\n        const entryHeight = this.pixelHeightForEventOnChart(entries.entryFrom) ?? 0;\n\n        const component = new Components.EntriesLinkOverlay.EntriesLinkOverlay(\n            {x: entryEndX, y: entryStartY, width: entryWidth, height: entryHeight}, overlay.state);\n\n        component.addEventListener(Components.EntriesLinkOverlay.EntryLinkStartCreating.eventName, () => {\n          overlay.state = Trace.Types.File.EntriesLinkState.PENDING_TO_EVENT;\n          this.dispatchEvent(new AnnotationOverlayActionEvent(overlay, 'Update'));\n        });\n        overlayElement.appendChild(component);\n        return overlayElement;\n      }\n      case 'ENTRY_OUTLINE': {\n        overlayElement.classList.add(`outline-reason-${overlay.outlineReason}`);\n        return overlayElement;\n      }\n      case 'TIME_RANGE': {\n        const component = new Components.TimeRangeOverlay.TimeRangeOverlay(overlay.label);\n        component.duration = overlay.showDuration ? overlay.bounds.range : null;\n        component.canvasRect = this.#charts.mainChart.canvasBoundingClientRect();\n        component.addEventListener(Components.TimeRangeOverlay.TimeRangeLabelChangeEvent.eventName, event => {\n          const newLabel = (event as Components.TimeRangeOverlay.TimeRangeLabelChangeEvent).newLabel;\n          overlay.label = newLabel;\n          this.dispatchEvent(new AnnotationOverlayActionEvent(overlay, 'Update'));\n        });\n        component.addEventListener(Components.TimeRangeOverlay.TimeRangeRemoveEvent.eventName, () => {\n          this.dispatchEvent(new AnnotationOverlayActionEvent(overlay, 'Remove'));\n        });\n        component.addEventListener('mouseover', () => {\n          this.dispatchEvent(new TimeRangeMouseOverEvent(overlay));\n        });\n        component.addEventListener('mouseout', () => {\n          this.dispatchEvent(new TimeRangeMouseOutEvent());\n        });\n        overlayElement.appendChild(component);\n        return overlayElement;\n      }\n      case 'TIMESPAN_BREAKDOWN': {\n        const component = new Components.TimespanBreakdownOverlay.TimespanBreakdownOverlay();\n        component.sections = overlay.sections;\n        component.canvasRect = this.#charts.mainChart.canvasBoundingClientRect();\n        component.isBelowEntry = overlay.renderLocation === 'BELOW_EVENT';\n        overlayElement.appendChild(component);\n        return overlayElement;\n      }\n      case 'TIMINGS_MARKER': {\n        const {color} = Trace.Styles.markerDetailsForEvent(overlay.entries[0]);\n        const markersComponent = this.#createTimingsMarkerElement(overlay);\n        overlayElement.appendChild(markersComponent);\n        overlayElement.style.backgroundColor = color;\n        return overlayElement;\n      }\n      default: {\n        return overlayElement;\n      }\n    }\n  }\n\n  #clickEvent(event: Trace.Types.Events.Event): void {\n    this.dispatchEvent(new EventReferenceClick(event));\n  }\n\n  #createOverlayPopover(\n      adjustedTimestamp: Trace.Types.Timing.Micro, name: string,\n      fieldResult: Trace.Types.Overlays.TimingsMarkerFieldResult|undefined): HTMLElement {\n    const popoverElement = document.createElement('div');\n    const popoverContents = popoverElement.createChild('div', 'overlay-popover');\n    popoverContents.createChild('span', 'overlay-popover-time').textContent =\n        i18n.TimeUtilities.formatMicroSecondsTime(adjustedTimestamp);\n    popoverContents.createChild('span', 'overlay-popover-title').textContent =\n        fieldResult ? i18nString(UIStrings.fieldMetricMarkerLocal, {PH1: name}) : name;\n\n    // If there's field data, make another row.\n    if (fieldResult) {\n      const popoverContents = popoverElement.createChild('div', 'overlay-popover');\n      popoverContents.createChild('span', 'overlay-popover-time').textContent =\n          i18n.TimeUtilities.formatMicroSecondsTime(fieldResult.value);\n      let scope: string = fieldResult.pageScope;\n      if (fieldResult.pageScope === 'url') {\n        scope = i18nString(UIStrings.urlOption);\n      } else if (fieldResult.pageScope === 'origin') {\n        scope = i18nString(UIStrings.originOption);\n      }\n      popoverContents.createChild('span', 'overlay-popover-title').textContent =\n          i18nString(UIStrings.fieldMetricMarkerField, {\n            PH1: name,\n            PH2: scope,\n          });\n    }\n\n    return popoverElement;\n  }\n\n  #mouseMoveOverlay(\n      e: MouseEvent, event: Trace.Types.Events.PageLoadEvent, name: string, overlay: Trace.Types.Overlays.TimingsMarker,\n      markers: HTMLElement, marker: HTMLElement): void {\n    const fieldResult = overlay.entryToFieldResult.get(event);\n    const popoverElement = this.#createOverlayPopover(overlay.adjustedTimestamp, name, fieldResult);\n    this.#lastMouseOffsetX = e.offsetX + (markers.offsetLeft || 0) + (marker.offsetLeft || 0);\n    this.#lastMouseOffsetY = e.offsetY + markers.offsetTop || 0;\n    this.#charts.mainChart.updateMouseOffset(this.#lastMouseOffsetX, this.#lastMouseOffsetY);\n    this.#charts.mainChart.updatePopoverContents(popoverElement);\n  }\n\n  #mouseOutOverlay(): void {\n    this.#lastMouseOffsetX = -1;\n    this.#lastMouseOffsetY = -1;\n    this.#charts.mainChart.updateMouseOffset(this.#lastMouseOffsetX, this.#lastMouseOffsetY);\n    this.#charts.mainChart.hideHighlight();\n  }\n\n  #createTimingsMarkerElement(overlay: Trace.Types.Overlays.TimingsMarker): HTMLElement {\n    const markers = document.createElement('div');\n    markers.classList.add('markers');\n    for (const entry of overlay.entries) {\n      const {color, title} = Trace.Styles.markerDetailsForEvent(entry);\n      const marker = document.createElement('div');\n      marker.classList.add('marker-title');\n      marker.textContent = title;\n      marker.style.backgroundColor = color;\n      markers.appendChild(marker);\n\n      marker.addEventListener('click', () => this.#clickEvent(entry));\n      // Popover.\n      marker.addEventListener('mousemove', e => this.#mouseMoveOverlay(e, entry, title, overlay, markers, marker));\n      marker.addEventListener('mouseout', () => this.#mouseOutOverlay());\n    }\n    return markers;\n  }\n\n  /**\n   * Some overlays store data in their components that needs to be updated\n   * before we position an overlay. Else, we might position an overlay based on\n   * stale data. This method is used to update an overlay BEFORE it is then\n   * positioned onto the canvas. It is the right place to ensure an overlay has\n   * the latest data it needs.\n   */\n  #updateOverlayBeforePositioning(overlay: Trace.Types.Overlays.Overlay, element: HTMLElement): void {\n    switch (overlay.type) {\n      case 'ENTRY_SELECTED':\n        break;\n      case 'TIME_RANGE': {\n        const component = element.querySelector('devtools-time-range-overlay');\n        if (component) {\n          component.duration = overlay.showDuration ? overlay.bounds.range : null;\n          component.canvasRect = this.#charts.mainChart.canvasBoundingClientRect();\n        }\n        break;\n      }\n      case 'ENTRY_LABEL':\n      case 'ENTRY_OUTLINE':\n      case 'ENTRIES_LINK': {\n        const component = element.querySelector('devtools-entries-link-overlay');\n        if (component) {\n          component.canvasRect = this.#charts.mainChart.canvasBoundingClientRect();\n        }\n        break;\n      }\n      case 'TIMESPAN_BREAKDOWN': {\n        const component = element.querySelector('devtools-timespan-breakdown-overlay');\n        if (component) {\n          component.sections = overlay.sections;\n          component.canvasRect = this.#charts.mainChart.canvasBoundingClientRect();\n        }\n        break;\n      }\n      case 'TIMESTAMP_MARKER':\n        break;\n      case 'CANDY_STRIPED_TIME_RANGE':\n        break;\n      case 'TIMINGS_MARKER':\n        break;\n      case 'BOTTOM_INFO_BAR': {\n        if (element.contains(overlay.infobar.element)) {\n          return;\n        }\n\n        // This overlay is a singleton; this means it could be updated with a\n        // different info bar. So we need to clear out the existing contents\n        // before appending the infobar, just in case.\n        element.innerHTML = '';\n        element.appendChild(overlay.infobar.element);\n      }\n\n      break;\n      default:\n        Platform.TypeScriptUtilities.assertNever(overlay, `Unexpected overlay ${overlay}`);\n    }\n  }\n  /**\n   * Some overlays have custom logic within them to manage visibility of\n   * labels/etc that can be impacted if the positioning or size of the overlay\n   * has changed. This method can be used to run code after an overlay has\n   * been updated + repositioned on the timeline.\n   */\n  #updateOverlayAfterPositioning(overlay: Trace.Types.Overlays.Overlay, element: HTMLElement): void {\n    switch (overlay.type) {\n      case 'ENTRY_SELECTED':\n        break;\n      case 'TIME_RANGE': {\n        const component = element.querySelector('devtools-time-range-overlay');\n        component?.updateLabelPositioning();\n        break;\n      }\n      case 'ENTRY_LABEL':\n        break;\n      case 'ENTRY_OUTLINE':\n        break;\n      case 'ENTRIES_LINK':\n        break;\n      case 'TIMESPAN_BREAKDOWN': {\n        const component = element.querySelector('devtools-timespan-breakdown-overlay');\n        component?.checkSectionLabelPositioning();\n        break;\n      }\n      case 'TIMESTAMP_MARKER':\n        break;\n      case 'CANDY_STRIPED_TIME_RANGE':\n        break;\n      case 'TIMINGS_MARKER':\n        break;\n      case 'BOTTOM_INFO_BAR':\n        break;\n      default:\n        Platform.TypeScriptUtilities.assertNever(overlay, `Unexpected overlay ${overlay}`);\n    }\n  }\n\n  /**\n   * @returns true if the entry is visible on chart, which means that both\n   * horizontally and vertically it is at least partially in view.\n   */\n  entryIsVisibleOnChart(entry: Trace.Types.Overlays.OverlayEntry): boolean {\n    const verticallyVisible = this.#entryIsVerticallyVisibleOnChart(entry);\n    const horiziontallyVisible = this.#entryIsHorizontallyVisibleOnChart(entry);\n    return verticallyVisible && horiziontallyVisible;\n  }\n\n  /**\n   * Calculates if an entry is visible horizontally. This is easy because we\n   * don't have to consider any pixels and can instead check that its start and\n   * end times intersect with the visible window.\n   */\n  #entryIsHorizontallyVisibleOnChart(entry: Trace.Types.Overlays.OverlayEntry): boolean {\n    if (this.#dimensions.trace.visibleWindow === null) {\n      return false;\n    }\n    const {startTime, endTime} = timingsForOverlayEntry(entry);\n\n    const entryTimeRange = Trace.Helpers.Timing.traceWindowFromMicroSeconds(startTime, endTime);\n\n    return Trace.Helpers.Timing.boundsIncludeTimeRange({\n      bounds: this.#dimensions.trace.visibleWindow,\n      timeRange: entryTimeRange,\n    });\n  }\n\n  #entryIsInCollapsedTrack(entry: Trace.Types.Overlays.OverlayEntry): boolean {\n    const chartName = chartForEntry(entry);\n    const provider = chartName === 'main' ? this.#charts.mainProvider : this.#charts.networkProvider;\n\n    const entryIndex = provider.indexForEvent?.(entry) ?? null;\n    if (entryIndex === null) {\n      return false;\n    }\n\n    const group = provider.groupForEvent?.(entryIndex) ?? null;\n    if (!group) {\n      return false;\n    }\n\n    return Boolean(group.expanded) === false;\n  }\n\n  /**\n   * Calculate if an entry is visible vertically on the chart. A bit fiddly as\n   * we have to figure out its pixel offset and go on that. Unlike horizontal\n   * visibility, we can't work solely from its microsecond values.\n   */\n  #entryIsVerticallyVisibleOnChart(entry: Trace.Types.Overlays.OverlayEntry): boolean {\n    const chartName = chartForEntry(entry);\n\n    const y = this.yPixelForEventOnChart(entry);\n    if (y === null) {\n      return false;\n    }\n\n    const eventHeight = this.pixelHeightForEventOnChart(entry);\n    if (!eventHeight) {\n      return false;\n    }\n\n    if (chartName === 'main') {\n      if (!this.#dimensions.charts.main?.heightPixels) {\n        // Shouldn't happen, but if the main chart has no height, nothing on it is visible.\n        return false;\n      }\n\n      // The yPixelForEventOnChart method returns the y pixel including an adjustment for the network track.\n      // To see if an entry on the main flame chart is visible, we can check\n      // its y value without the network track adjustment. If it is < 0, then\n      // it's off the top of the screen.\n      //\n      const yWithoutNetwork = y - this.networkChartOffsetHeight();\n      // Check if the y position + the height is less than 0. We add height so\n      // that we correctly consider an event only partially scrolled off to be\n      // visible.\n      if (yWithoutNetwork + eventHeight < 0) {\n        return false;\n      }\n\n      if (yWithoutNetwork > this.#dimensions.charts.main.heightPixels) {\n        // The event is off the bottom of the screen.\n        return false;\n      }\n    }\n\n    if (chartName === 'network') {\n      if (!this.#dimensions.charts.network) {\n        // The network chart can be hidden if there are no requests in the trace.\n        return false;\n      }\n      if (y <= -14) {\n        // Weird value, but the network chart has the header row with\n        // timestamps on it: events stay visible behind those timestamps, so we\n        // want any overlays to treat themselves as visible too.\n        return false;\n      }\n\n      if (y > this.#dimensions.charts.network.heightPixels) {\n        // The event is off the bottom of the network chart.\n        return false;\n      }\n    }\n    // If we got here, none of the conditions to mark an event as invisible got\n    // triggered, so the event must be visible.\n    return true;\n  }\n\n  /**\n   * Calculate the X pixel position for an event start on the timeline.\n   * @param chartName the chart that the event is on. It is expected that both\n   * charts have the same width so this doesn't make a difference - but it might\n   * in the future if the UI changes, hence asking for it.\n   * @param event the trace event you want to get the pixel position of\n   */\n  xPixelForEventStartOnChart(event: Trace.Types.Overlays.OverlayEntry): number|null {\n    const chartName = chartForEntry(event);\n    const {startTime} = timingsForOverlayEntry(event);\n    return this.#xPixelForMicroSeconds(chartName, startTime);\n  }\n\n  /**\n   * Calculate the X pixel position for an event end on the timeline.\n   * @param chartName the chart that the event is on. It is expected that both\n   * charts have the same width so this doesn't make a difference - but it might\n   * in the future if the UI changes, hence asking for it.\n   * @param event the trace event you want to get the pixel position of\n   */\n  xPixelForEventEndOnChart(event: Trace.Types.Overlays.OverlayEntry): number|null {\n    const chartName = chartForEntry(event);\n    const {endTime} = timingsForOverlayEntry(event);\n    return this.#xPixelForMicroSeconds(chartName, endTime);\n  }\n\n  /**\n   * Calculate the xPixel for a given timestamp. To do this we calculate how\n   * far in microseconds from the left of the visible window an event is, and\n   * divide that by the total time span. This gives us a fraction representing\n   * how far along the timeline the event is. We can then multiply that by the\n   * width of the canvas to get its pixel position.\n   */\n  #xPixelForMicroSeconds(chart: EntryChartLocation, timestamp: Trace.Types.Timing.Micro): number|null {\n    if (this.#dimensions.trace.visibleWindow === null) {\n      console.error('Cannot calculate xPixel without visible trace window.');\n      return null;\n    }\n    const canvasWidthPixels = this.#dimensions.charts[chart]?.widthPixels ?? null;\n    if (canvasWidthPixels === null) {\n      console.error(`Cannot calculate xPixel without ${chart} dimensions.`);\n      return null;\n    }\n\n    const timeFromLeft = timestamp - this.#dimensions.trace.visibleWindow.min;\n    const totalTimeSpan = this.#dimensions.trace.visibleWindow.range;\n    return Math.floor(\n        timeFromLeft / totalTimeSpan * canvasWidthPixels,\n    );\n  }\n\n  /**\n   * Calculate the Y pixel position for the event on the timeline relative to\n   * the entire window.\n   * This means if the event is in the main flame chart and below the network,\n   * we add the height of the network chart to the Y value to position it\n   * correctly.\n   * This can return null if any data was missing, or if the event is not\n   * visible (if the level it's on is hidden because the track is collapsed,\n   * for example)\n   */\n  yPixelForEventOnChart(event: Trace.Types.Overlays.OverlayEntry): number|null {\n    const chartName = chartForEntry(event);\n    const chart = chartName === 'main' ? this.#charts.mainChart : this.#charts.networkChart;\n    const provider = chartName === 'main' ? this.#charts.mainProvider : this.#charts.networkProvider;\n\n    const indexForEntry = provider.indexForEvent?.(event);\n    if (typeof indexForEntry !== 'number') {\n      return null;\n    }\n    const timelineData = provider.timelineData();\n    if (timelineData === null) {\n      return null;\n    }\n    const level = timelineData.entryLevels.at(indexForEntry);\n    if (typeof level === 'undefined') {\n      return null;\n    }\n\n    if (!chart.levelIsVisible(level)) {\n      return null;\n    }\n\n    const pixelOffsetForLevel = chart.levelToOffset(level);\n    // Now we have the offset for the level, we need to adjust it by the user's scroll offset.\n    let pixelAdjustedForScroll = pixelOffsetForLevel - (this.#dimensions.charts[chartName]?.scrollOffsetPixels ?? 0);\n\n    // Now if the event is in the main chart, we need to pad its Y position\n    // down by the height of the network chart + the network resize element.\n    if (chartName === 'main') {\n      pixelAdjustedForScroll += this.networkChartOffsetHeight();\n    }\n\n    return pixelAdjustedForScroll;\n  }\n\n  /**\n   * Calculate the height of the event on the timeline.\n   */\n  pixelHeightForEventOnChart(event: Trace.Types.Overlays.OverlayEntry): number|null {\n    const chartName = chartForEntry(event);\n    const chart = chartName === 'main' ? this.#charts.mainChart : this.#charts.networkChart;\n    const provider = chartName === 'main' ? this.#charts.mainProvider : this.#charts.networkProvider;\n\n    const indexForEntry = provider.indexForEvent?.(event);\n    if (typeof indexForEntry !== 'number') {\n      return null;\n    }\n    const timelineData = provider.timelineData();\n    if (timelineData === null) {\n      return null;\n    }\n    const level = timelineData.entryLevels.at(indexForEntry);\n    if (typeof level === 'undefined') {\n      return null;\n    }\n    return chart.levelHeight(level);\n  }\n\n  /**\n   * Calculate the height of the network chart. If the network chart has\n   * height, we also allow for the size of the resize handle shown between the\n   * two charts.\n   *\n   * Note that it is possible for the chart to have 0 height if the user is\n   * looking at a trace with no network requests.\n   */\n  networkChartOffsetHeight(): number {\n    if (this.#dimensions.charts.network === null) {\n      return 0;\n    }\n\n    if (this.#dimensions.charts.network.heightPixels === 0) {\n      return 0;\n    }\n\n    // At this point we know the network track exists and has height. But we\n    // need to check if it is collapsed, because if it is collapsed there is no\n    // resizer shown.\n    if (this.#dimensions.charts.network.allGroupsCollapsed) {\n      return this.#dimensions.charts.network.heightPixels;\n    }\n\n    return this.#dimensions.charts.network.heightPixels + NETWORK_RESIZE_ELEM_HEIGHT_PX;\n  }\n\n  /**\n   * Hides or shows an element. We used to use visibility rather than display,\n   * but a child of an element with visibility: hidden may still be visible if\n   * its own `display` property is set.\n   */\n  #setOverlayElementVisibility(element: HTMLElement, isVisible: boolean): void {\n    element.style.display = isVisible ? 'block' : 'none';\n  }\n}\n\n/**\n * Because entries can be a TimelineFrame, which is not a trace event, this\n * helper exists to return a consistent set of timings regardless of the type\n * of entry.\n */\nexport function timingsForOverlayEntry(entry: Trace.Types.Overlays.OverlayEntry):\n    Trace.Helpers.Timing.EventTimingsData<Trace.Types.Timing.Micro> {\n  if (Trace.Types.Events.isLegacyTimelineFrame(entry)) {\n    return {\n      startTime: entry.startTime,\n      endTime: entry.endTime,\n      duration: entry.duration,\n    };\n  }\n  return Trace.Helpers.Timing.eventTimingsMicroSeconds(entry);\n}\n\n/**\n * Defines if the overlay container `div` should have a jslog context attached.\n * Note that despite some of the overlays being used currently exclusively\n * for annotations, we log here with `overlays` to be generic as overlays can\n * be used for insights, annotations or in the future, who knows...\n */\nexport function jsLogContext(overlay: Trace.Types.Overlays.Overlay): string|null {\n  switch (overlay.type) {\n    case 'ENTRY_SELECTED': {\n      // No jslog for this; it would be very noisy and not very useful.\n      return null;\n    }\n    case 'ENTRY_OUTLINE': {\n      return `timeline.overlays.entry-outline-${Platform.StringUtilities.toKebabCase(overlay.outlineReason)}`;\n    }\n    case 'ENTRY_LABEL': {\n      return 'timeline.overlays.entry-label';\n    }\n    case 'ENTRIES_LINK': {\n      // do not log impressions for incomplete entry links\n      if (overlay.state !== Trace.Types.File.EntriesLinkState.CONNECTED) {\n        return null;\n      }\n      return 'timeline.overlays.entries-link';\n    }\n    case 'TIME_RANGE': {\n      return 'timeline.overlays.time-range';\n    }\n    case 'TIMESPAN_BREAKDOWN': {\n      return 'timeline.overlays.timespan-breakdown';\n    }\n    case 'TIMESTAMP_MARKER': {\n      return 'timeline.overlays.cursor-timestamp-marker';\n    }\n    case 'CANDY_STRIPED_TIME_RANGE': {\n      return 'timeline.overlays.candy-striped-time-range';\n    }\n    case 'TIMINGS_MARKER': {\n      return 'timeline.overlays.timings-marker';\n    }\n    case 'BOTTOM_INFO_BAR':\n      return 'timeline.overlays.info-bar';\n    default:\n      Platform.assertNever(overlay, 'Unknown overlay type');\n  }\n}\n"]}