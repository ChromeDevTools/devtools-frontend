{"version":3,"file":"TimespanBreakdownOverlay.js","sourceRoot":"","sources":["../../../../../../../../front_end/panels/timeline/overlays/components/TimespanBreakdownOverlay.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as i18n from '../../../../core/i18n/i18n.js';\nimport type * as Trace from '../../../../models/trace/trace.js';\nimport * as UI from '../../../../ui/legacy/legacy.js';\nimport {Directives, html, nothing, render, type TemplateResult} from '../../../../ui/lit/lit.js';\n\nimport timespanBreakdownOverlayStyles from './timespanBreakdownOverlay.css.js';\n\nexport interface Input {\n  sections: Trace.Types.Overlays.TimespanBreakdownEntryBreakdown[]|null;\n  positions: SectionPosition[];\n  left: number|null;\n  width: number|null;\n  maxHeight: number|null;\n  top: number|null;\n  className: string;\n}\nexport interface SectionPosition {\n  left: number|null;\n  width: number|null;\n}\n\ntype View = (input: Input, _output: undefined, target: HTMLElement) => void;\n\nconst renderSection =\n    (section: Trace.Types.Overlays.TimespanBreakdownEntryBreakdown, position: SectionPosition): TemplateResult => {\n      const style = Directives.styleMap(\n          {left: position ? `${position.left}px` : undefined, width: position ? `${position.width}px` : undefined});\n\n      // clang-format off\n    return html`\n      <div class=\"timespan-breakdown-overlay-section\" style=${style}>\n        <div class=\"timespan-breakdown-overlay-label\">\n          ${\n            section.showDuration ?\n                html`<span class=\"duration-text\">${i18n.TimeUtilities.formatMicroSecondsAsMillisFixed(section.bounds.range)}</span> ` :\n                nothing\n          }\n          <span class=\"section-label-text\">${section.label}</span>\n        </div>\n      </div>`;\n      // clang-format on\n    };\n\nexport const DEFAULT_VIEW = (input: Input, _output: undefined, target: HTMLElement): void => {\n  const style = Directives.styleMap({\n    left: input.left ? `${input.left}px` : undefined,\n    width: input.width ? `${input.width}px` : undefined,\n    top: input.top ? `${input.top}px` : undefined,\n    maxHeight: input.maxHeight ? `${input.maxHeight}px` : undefined,\n    position: 'relative'\n  });\n  // clang-format off\n  render(\n      html`\n        <style>${timespanBreakdownOverlayStyles}</style>\n        <div style=${style} class=${input.className}>\n          ${input.sections?.map((curr, index) => {\n            return renderSection(curr, input.positions[index]);\n          })}\n        </div>`,\n      target);\n  // clang-format off\n};\n\nexport class TimespanBreakdownOverlay extends UI.Widget.Widget {\n  #canvasRect: DOMRect|null = null;\n  #sections: Trace.Types.Overlays.TimespanBreakdownEntryBreakdown[]|null = null;\n  #sectionsPositions: SectionPosition[] = [];\n  #left: number|null = null;\n  #width: number|null = null;\n  #maxHeight: number|null = null;\n  #top: number|null = null;\n\n  #view: View;\n\n  constructor(element?: HTMLElement, view: View = DEFAULT_VIEW) {\n    super(element, {classes: ['devtools-timespan-breakdown-overlay']});\n    this.#view = view;\n    this.requestUpdate();\n  }\n\n  set top(top: number) {\n    this.#top = top;\n    this.requestUpdate();\n  }\n\n  set maxHeight(maxHeight: number) {\n    this.#maxHeight = maxHeight;\n    this.requestUpdate();\n  }\n\n  set width(width: number) {\n    this.#width = width;\n    this.requestUpdate();\n  }\n\n  set left(left: number) {\n    this.#left = left;\n    this.requestUpdate();\n  }\n\n  set isBelowEntry(isBelow: boolean) {\n    this.element.classList.toggle('is-below', isBelow);\n  }\n\n  set canvasRect(rect: DOMRect|null) {\n    if (this.#canvasRect && rect && this.#canvasRect.width === rect.width && this.#canvasRect.height === rect.height) {\n      return;\n    }\n    this.#canvasRect = rect;\n    this.requestUpdate();\n  }\n\n  set widths(widths: SectionPosition[]) {\n    if (widths === this.#sectionsPositions) {\n      return;\n    }\n\n    this.#sectionsPositions = widths;\n    this.requestUpdate();\n  }\n\n  set sections(sections: Trace.Types.Overlays.TimespanBreakdownEntryBreakdown[]|null) {\n    if (sections === this.#sections) {\n      return;\n    }\n    this.#sections = sections;\n    this.requestUpdate();\n  }\n\n  /**\n   * We use this method after the overlay has been positioned in order to move\n   * the section label as required to keep it on screen.\n   * If the label is off to the left or right, we fix it to that corner and\n   * align the text so the label is visible as long as possible.\n   */\n  checkSectionLabelPositioning(): void {\n    const sections = this.element.querySelectorAll<HTMLElement>('.timespan-breakdown-overlay-section');\n    if (!sections) {\n      return;\n    }\n\n    if (!this.#canvasRect) {\n      return;\n    }\n\n    // On the RHS of the panel a scrollbar can be shown which means the canvas\n    // has a 9px gap on the right hand edge. We use this value when calculating\n    // values and label positioning from the left hand side in order to be\n    // consistent on both edges of the UI.\n    const paddingForScrollbar = 9;\n\n    // Fetch the rects for each section and label now, rather than in the loop,\n    // to avoid causing a bunch of recalcStyles\n    const sectionLayoutData = new Map<HTMLElement, {sectionRect: DOMRect, labelRect: DOMRect, label: HTMLElement}>();\n    for (const section of sections) {\n      const label = section.querySelector<HTMLElement>('.timespan-breakdown-overlay-label');\n      if (!label) {\n        continue;\n      }\n      const sectionRect = section.getBoundingClientRect();\n      const labelRect = label.getBoundingClientRect();\n      sectionLayoutData.set(section, {sectionRect, labelRect, label});\n    }\n\n    const minSectionWidthToShowAnyLabel = 30;\n\n    // Align the labels for all the breakdown sections.\n    for (const section of sections) {\n      const layoutData = sectionLayoutData.get(section);\n      if (!layoutData) {\n        break;\n      }\n      const {labelRect, sectionRect, label} = layoutData;\n\n      const labelHidden = sectionRect.width < minSectionWidthToShowAnyLabel;\n      // Subtract 5 from the section width to allow a tiny bit of padding.\n      const labelTruncated = sectionRect.width - 5 <= labelRect.width;\n      // We differentiate between hidden + truncated; if it is truncated we\n      // will show the text with ellipsis for overflow, but if the section is\n      // really small we just hide the label entirely.\n      label.classList.toggle('labelHidden', labelHidden);\n      label.classList.toggle('labelTruncated', labelTruncated);\n\n      if (labelHidden || labelTruncated) {\n        // Label is hidden or doesn't fully fit, so we don't need to do the\n        // logic to left/right align if it needs it.\n        continue;\n      }\n\n      // Check if label is off the LHS of the screen.\n      const labelLeftMarginToCenter = (sectionRect.width - labelRect.width) / 2;\n      const newLabelX = sectionRect.x + labelLeftMarginToCenter;\n\n      const labelOffLeftOfScreen = newLabelX < this.#canvasRect.x;\n      label.classList.toggle('offScreenLeft', labelOffLeftOfScreen);\n\n      // Check if label is off the RHS of the screen\n      const rightBound = this.#canvasRect.x + this.#canvasRect.width;\n      // The label's right hand edge is the gap from the left of the range to the\n      // label, and then the width of the label.\n      const labelRightEdge = sectionRect.x + labelLeftMarginToCenter + labelRect.width;\n      const labelOffRightOfScreen = labelRightEdge > rightBound;\n      label.classList.toggle('offScreenRight', labelOffRightOfScreen);\n\n      if (labelOffLeftOfScreen) {\n        // If the label is off the left of the screen, we adjust by the\n        // difference between the X that represents the start of the cavnas, and\n        // the X that represents the start of the overlay.\n        // We then take the absolute value of this - because if the canvas starts\n        // at 0, and the overlay is -200px, we have to adjust the label by +200.\n        // Add on 9 pixels to pad from the left; this is the width of the sidebar\n        // on the RHS so we match it so the label is equally padded on either\n        // side.\n        label.style.marginLeft = `${Math.abs(this.#canvasRect.x - sectionRect.x) + paddingForScrollbar}px`;\n\n      } else if (labelOffRightOfScreen) {\n        // To calculate how far left to push the label, we take the right hand\n        // bound (the canvas width and subtract the label's width).\n        // Finally, we subtract the X position of the overlay (if the overlay is\n        // 200px within the view, we don't need to push the label that 200px too\n        // otherwise it will be off-screen)\n        const leftMargin = rightBound - labelRect.width - sectionRect.x;\n\n        label.style.marginLeft = `${leftMargin}px`;\n\n      } else {\n        // Keep the label central.\n        label.style.marginLeft = `${labelLeftMarginToCenter}px`;\n      }\n    }\n  }\n\n  override performUpdate(): void {\n    let className = 'timeline-segment-container';\n\n    if (this.#sections) {\n      if(this.#sections.length % 2 === 0) {\n        className += ' even-number-of-sections';\n      } else {\n        className += ' odd-number-of-sections';\n      }\n    }\n\n    this.#view({sections: this.#sections,\n      positions: this.#sectionsPositions,\n      left: this.#left,\n      width: this.#width,\n      top: this.#top,\n      maxHeight: this.#maxHeight,\n      className\n    }, undefined, this.contentElement);\n\n    this.checkSectionLabelPositioning();\n  }\n}\n"]}