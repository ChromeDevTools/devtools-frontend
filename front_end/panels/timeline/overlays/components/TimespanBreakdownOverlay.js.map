{"version":3,"file":"TimespanBreakdownOverlay.js","sourceRoot":"","sources":["../../../../../../../../front_end/panels/timeline/overlays/components/TimespanBreakdownOverlay.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n/* eslint-disable @devtools/no-lit-render-outside-of-view */\n\nimport * as i18n from '../../../../core/i18n/i18n.js';\nimport type * as Trace from '../../../../models/trace/trace.js';\nimport * as Lit from '../../../../ui/lit/lit.js';\n\nimport timespanBreakdownOverlayStyles from './timespanBreakdownOverlay.css.js';\n\nconst {html} = Lit;\n\nexport class TimespanBreakdownOverlay extends HTMLElement {\n  readonly #shadow = this.attachShadow({mode: 'open'});\n  #canvasRect: DOMRect|null = null;\n  #sections: Trace.Types.Overlays.TimespanBreakdownEntryBreakdown[]|null = null;\n\n  set isBelowEntry(isBelow: boolean) {\n    this.classList.toggle('is-below', isBelow);\n  }\n\n  set canvasRect(rect: DOMRect|null) {\n    if (this.#canvasRect && rect && this.#canvasRect.width === rect.width && this.#canvasRect.height === rect.height) {\n      return;\n    }\n    this.#canvasRect = rect;\n    this.#render();\n  }\n\n  set sections(sections: Trace.Types.Overlays.TimespanBreakdownEntryBreakdown[]|null) {\n    if (sections === this.#sections) {\n      return;\n    }\n    this.#sections = sections;\n    this.#render();\n  }\n\n  /**\n   * We use this method after the overlay has been positioned in order to move\n   * the section label as required to keep it on screen.\n   * If the label is off to the left or right, we fix it to that corner and\n   * align the text so the label is visible as long as possible.\n   */\n  checkSectionLabelPositioning(): void {\n    const sections = this.#shadow.querySelectorAll<HTMLElement>('.timespan-breakdown-overlay-section');\n    if (!sections) {\n      return;\n    }\n\n    if (!this.#canvasRect) {\n      return;\n    }\n\n    // On the RHS of the panel a scrollbar can be shown which means the canvas\n    // has a 9px gap on the right hand edge. We use this value when calculating\n    // values and label positioning from the left hand side in order to be\n    // consistent on both edges of the UI.\n    const paddingForScrollbar = 9;\n\n    // Fetch the rects for each section and label now, rather than in the loop,\n    // to avoid causing a bunch of recalcStyles\n    const sectionLayoutData = new Map<HTMLElement, {sectionRect: DOMRect, labelRect: DOMRect, label: HTMLElement}>();\n    for (const section of sections) {\n      const label = section.querySelector<HTMLElement>('.timespan-breakdown-overlay-label');\n      if (!label) {\n        continue;\n      }\n      const sectionRect = section.getBoundingClientRect();\n      const labelRect = label.getBoundingClientRect();\n      sectionLayoutData.set(section, {sectionRect, labelRect, label});\n    }\n\n    const minSectionWidthToShowAnyLabel = 30;\n\n    // Align the labels for all the breakdown sections.\n    for (const section of sections) {\n      const layoutData = sectionLayoutData.get(section);\n      if (!layoutData) {\n        break;\n      }\n      const {labelRect, sectionRect, label} = layoutData;\n\n      const labelHidden = sectionRect.width < minSectionWidthToShowAnyLabel;\n      // Subtract 5 from the section width to allow a tiny bit of padding.\n      const labelTruncated = sectionRect.width - 5 <= labelRect.width;\n      // We differentiate between hidden + truncated; if it is truncated we\n      // will show the text with ellipsis for overflow, but if the section is\n      // really small we just hide the label entirely.\n      label.classList.toggle('labelHidden', labelHidden);\n      label.classList.toggle('labelTruncated', labelTruncated);\n\n      if (labelHidden || labelTruncated) {\n        // Label is hidden or doesn't fully fit, so we don't need to do the\n        // logic to left/right align if it needs it.\n        continue;\n      }\n\n      // Check if label is off the LHS of the screen.\n      const labelLeftMarginToCenter = (sectionRect.width - labelRect.width) / 2;\n      const newLabelX = sectionRect.x + labelLeftMarginToCenter;\n\n      const labelOffLeftOfScreen = newLabelX < this.#canvasRect.x;\n      label.classList.toggle('offScreenLeft', labelOffLeftOfScreen);\n\n      // Check if label is off the RHS of the screen\n      const rightBound = this.#canvasRect.x + this.#canvasRect.width;\n      // The label's right hand edge is the gap from the left of the range to the\n      // label, and then the width of the label.\n      const labelRightEdge = sectionRect.x + labelLeftMarginToCenter + labelRect.width;\n      const labelOffRightOfScreen = labelRightEdge > rightBound;\n      label.classList.toggle('offScreenRight', labelOffRightOfScreen);\n\n      if (labelOffLeftOfScreen) {\n        // If the label is off the left of the screen, we adjust by the\n        // difference between the X that represents the start of the cavnas, and\n        // the X that represents the start of the overlay.\n        // We then take the absolute value of this - because if the canvas starts\n        // at 0, and the overlay is -200px, we have to adjust the label by +200.\n        // Add on 9 pixels to pad from the left; this is the width of the sidebar\n        // on the RHS so we match it so the label is equally padded on either\n        // side.\n        label.style.marginLeft = `${Math.abs(this.#canvasRect.x - sectionRect.x) + paddingForScrollbar}px`;\n\n      } else if (labelOffRightOfScreen) {\n        // To calculate how far left to push the label, we take the right hand\n        // bound (the canvas width and subtract the label's width).\n        // Finally, we subtract the X position of the overlay (if the overlay is\n        // 200px within the view, we don't need to push the label that 200px too\n        // otherwise it will be off-screen)\n        const leftMargin = rightBound - labelRect.width - sectionRect.x;\n\n        label.style.marginLeft = `${leftMargin}px`;\n\n      } else {\n        // Keep the label central.\n        label.style.marginLeft = `${labelLeftMarginToCenter}px`;\n      }\n    }\n  }\n\n  renderedSections(): HTMLElement[] {\n    return Array.from(this.#shadow.querySelectorAll('.timespan-breakdown-overlay-section'));\n  }\n\n  #renderSection(section: Trace.Types.Overlays.TimespanBreakdownEntryBreakdown): Lit.TemplateResult {\n    // clang-format off\n    return html`\n      <div class=\"timespan-breakdown-overlay-section\">\n        <div class=\"timespan-breakdown-overlay-label\">\n        ${section.showDuration ?\n          html`<span class=\"duration-text\">${i18n.TimeUtilities.formatMicroSecondsAsMillisFixed(section.bounds.range)}</span> ` : Lit.nothing}\n          <span class=\"section-label-text\">${section.label}</span>\n        </div>\n      </div>`;\n    // clang-format on\n  }\n\n  #render(): void {\n    if (this.#sections) {\n      this.classList.toggle('odd-number-of-sections', this.#sections.length % 2 === 1);\n      this.classList.toggle('even-number-of-sections', this.#sections.length % 2 === 0);\n    }\n    Lit.render(\n        html`<style>${timespanBreakdownOverlayStyles}</style>\n             ${this.#sections?.map(this.#renderSection)}`,\n        this.#shadow, {host: this});\n    this.checkSectionLabelPositioning();\n  }\n}\n\ncustomElements.define('devtools-timespan-breakdown-overlay', TimespanBreakdownOverlay);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'devtools-timespan-breakdown-overlay': TimespanBreakdownOverlay;\n  }\n}\n"]}