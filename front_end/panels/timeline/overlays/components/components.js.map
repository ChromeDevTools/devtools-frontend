{
  "version": 3,
  "sources": ["../../../../../../../../front_end/panels/timeline/overlays/components/EntriesLinkOverlay.ts", "entriesLinkOverlay.css.js", "../../../../../../../../front_end/panels/timeline/overlays/components/EntryLabelOverlay.ts", "entryLabelOverlay.css.js", "../../../../../../../../front_end/panels/timeline/overlays/components/TimeRangeOverlay.ts", "timeRangeOverlay.css.js", "../../../../../../../../front_end/panels/timeline/overlays/components/TimespanBreakdownOverlay.ts", "timespanBreakdownOverlay.css.js"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport '../../../../ui/components/icon_button/icon_button.js';\n\n/* eslint-disable @devtools/no-lit-render-outside-of-view */\n\nimport * as i18n from '../../../../core/i18n/i18n.js';\nimport * as Trace from '../../../../models/trace/trace.js';\nimport * as ThemeSupport from '../../../../ui/legacy/theme_support/theme_support.js';\nimport {html, render} from '../../../../ui/lit/lit.js';\nimport * as VisualLogging from '../../../../ui/visual_logging/visual_logging.js';\n\nimport entriesLinkOverlayStyles from './entriesLinkOverlay.css.js';\n\nconst UIStrings = {\n  /**\n   * @description Accessible label used to explain to a user that they are viewing an arrow representing a link between two entries.\n   */\n  diagram: 'Links between entries',\n} as const;\nconst str_ = i18n.i18n.registerUIStrings('panels/timeline/overlays/components/EntriesLinkOverlay.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\nexport class EntryLinkStartCreating extends Event {\n  static readonly eventName = 'entrylinkstartcreating';\n\n  constructor() {\n    super(EntryLinkStartCreating.eventName, {bubbles: true, composed: true});\n  }\n}\n\nexport class EntriesLinkOverlay extends HTMLElement {\n  readonly #shadow = this.attachShadow({mode: 'open'});\n  #coordinateFrom: {x: number, y: number};\n  #fromEntryDimensions: {width: number, height: number};\n  #coordinateTo: {x: number, y: number};\n  #toEntryDimensions: {width: number, height: number}|null = null;\n  #connectorLineContainer: SVGAElement|null = null;\n  #connector: SVGLineElement|null = null;\n  #entryFromWrapper: HTMLElement|null = null;\n  #entryToWrapper: HTMLElement|null = null;\n  #entryFromCirleConnector: SVGCircleElement|null = null;\n  #entryToCircleConnector: SVGCircleElement|null = null;\n  #entryFromVisible = true;\n  #entryToVisible = true;\n  #canvasRect: DOMRect|null = null;\n\n  // These flags let us know if the entry we are drawing from/to are the\n  // originals, or if they are the parent, which can happen if an entry is\n  // collapsed. We care about this because if the entry is not the source, we\n  // draw the border as dashed, not solid.\n  #fromEntryIsSource = true;\n  #toEntryIsSource = true;\n  #arrowHidden = false;\n  #linkState: Trace.Types.File.EntriesLinkState;\n\n  constructor(\n      initialFromEntryCoordinateAndDimensions: {x: number, y: number, width: number, height: number},\n      linkCreationNotStartedState: Trace.Types.File.EntriesLinkState) {\n    super();\n    this.#render();\n    this.#coordinateFrom = {x: initialFromEntryCoordinateAndDimensions.x, y: initialFromEntryCoordinateAndDimensions.y};\n    this.#fromEntryDimensions = {\n      width: initialFromEntryCoordinateAndDimensions.width,\n      height: initialFromEntryCoordinateAndDimensions.height,\n    };\n    this.#coordinateTo = {x: initialFromEntryCoordinateAndDimensions.x, y: initialFromEntryCoordinateAndDimensions.y};\n    this.#connectorLineContainer = this.#shadow.querySelector<SVGAElement>('.connectorContainer') ?? null;\n    this.#connector = this.#connectorLineContainer?.querySelector('line') ?? null;\n    this.#entryFromWrapper = this.#shadow.querySelector('.from-highlight-wrapper') ?? null;\n    this.#entryToWrapper = this.#shadow.querySelector('.to-highlight-wrapper') ?? null;\n    this.#entryFromCirleConnector = this.#connectorLineContainer?.querySelector('.entryFromConnector') ?? null;\n    this.#entryToCircleConnector = this.#connectorLineContainer?.querySelector('.entryToConnector') ?? null;\n    this.#linkState = linkCreationNotStartedState;\n    this.#render();\n  }\n\n  set canvasRect(rect: DOMRect|null) {\n    if (rect === null) {\n      return;\n    }\n    if (this.#canvasRect && this.#canvasRect.width === rect.width && this.#canvasRect.height === rect.height) {\n      return;\n    }\n    this.#canvasRect = rect;\n    this.#render();\n  }\n\n  entryFromWrapper(): HTMLElement|null {\n    return this.#entryFromWrapper;\n  }\n\n  entryToWrapper(): HTMLElement|null {\n    return this.#entryToWrapper;\n  }\n\n  /**\n   * If one entry that is linked is in a collapsed track, we show the outlines\n   * but hide only the arrow.\n   */\n  set hideArrow(shouldHide: boolean) {\n    this.#arrowHidden = shouldHide;\n    if (this.#connector) {\n      this.#connector.style.display = shouldHide ? 'none' : 'block';\n    }\n  }\n\n  set fromEntryCoordinateAndDimensions(fromEntryParams: {x: number, y: number, length: number, height: number}) {\n    this.#coordinateFrom = {x: fromEntryParams.x, y: fromEntryParams.y};\n    this.#fromEntryDimensions = {width: fromEntryParams.length, height: fromEntryParams.height};\n    this.#updateCreateLinkBox();\n    this.#redrawAllEntriesLinkParts();\n  }\n\n  set entriesVisibility(entriesVisibility: {fromEntryVisibility: boolean, toEntryVisibility: boolean}) {\n    this.#entryFromVisible = entriesVisibility.fromEntryVisibility;\n    this.#entryToVisible = entriesVisibility.toEntryVisibility;\n    this.#redrawAllEntriesLinkParts();\n  }\n\n  // The arrow might be pointing either to an entry or an empty space.\n  // If the dimensions are not passed, it is pointing at an empty space.\n  set toEntryCoordinateAndDimensions(toEntryParams: {x: number, y: number, length?: number, height?: number}) {\n    this.#coordinateTo = {x: toEntryParams.x, y: toEntryParams.y};\n    if (toEntryParams.length && toEntryParams.height) {\n      this.#toEntryDimensions = {width: toEntryParams.length, height: toEntryParams.height};\n    } else {\n      this.#toEntryDimensions = null;\n    }\n\n    this.#updateCreateLinkBox();\n    this.#redrawAllEntriesLinkParts();\n  }\n\n  set fromEntryIsSource(x: boolean) {\n    if (x === this.#fromEntryIsSource) {\n      return;\n    }\n    this.#fromEntryIsSource = x;\n    this.#render();\n  }\n\n  set toEntryIsSource(x: boolean) {\n    if (x === this.#toEntryIsSource) {\n      return;\n    }\n    this.#toEntryIsSource = x;\n    this.#render();\n  }\n\n  /*\n    Redraw all parts of the EntriesLink overlay\n     _________\n    |__entry__|o\\      <-- 'from 'entry wrapper and the circle connector next to it\n                 \\\n                  \\    <-- Arrow Connector\n                   \\   ________________\n                    ➘ o|_____entry______|  <-- 'to' entry wrapper and the circle connector next to it\n  */\n  #redrawAllEntriesLinkParts(): void {\n    if (!this.#connector || !this.#entryFromWrapper || !this.#entryToWrapper || !this.#entryFromCirleConnector ||\n        !this.#entryToCircleConnector) {\n      console.error('one of the required Entries Link elements is missing.');\n      return;\n    }\n\n    if (this.#linkState === Trace.Types.File.EntriesLinkState.CREATION_NOT_STARTED) {\n      this.#entryFromCirleConnector.setAttribute('visibility', 'hidden');\n      this.#entryToCircleConnector.setAttribute('visibility', 'hidden');\n      this.#connector.style.display = 'none';\n      return;\n    }\n\n    this.#setEntriesWrappersVisibility();\n    this.#setConnectorCirclesVisibility();\n    this.#setArrowConnectorStyle();\n    this.#positionConnectorLineAndCircles();\n\n    this.#render();\n  }\n\n  // Only draw the entry wrapper if that entry is visible\n  #setEntriesWrappersVisibility(): void {\n    if (!this.#entryFromWrapper || !this.#entryToWrapper) {\n      return;\n    }\n    this.#entryFromWrapper.style.visibility = this.#entryFromVisible ? 'visible' : 'hidden';\n    this.#entryToWrapper.style.visibility = this.#entryToVisible ? 'visible' : 'hidden';\n  }\n\n  // Draw the entry connector circles:\n  //  - The entry the arrow is connecting to is the connection source\n  //  - That entry currently is visible\n  //  - There is enough space for the connector circle\n  #setConnectorCirclesVisibility(): void {\n    if (!this.#toEntryDimensions || !this.#entryFromCirleConnector || !this.#entryToCircleConnector) {\n      return;\n    }\n    // If the user is zoomed out, the connector circles can be as large as the\n    // event itself. So if the rectangle for this entry is too small, we\n    // don't draw the circles.\n    const minWidthToDrawConnectorCircles = 8;\n    const drawFromEntryConnectorCircle = this.#entryFromVisible && !this.#arrowHidden && this.#fromEntryIsSource &&\n        this.#fromEntryDimensions.width >= minWidthToDrawConnectorCircles;\n    const drawToEntryConnectorCircle = !this.#arrowHidden && this.#entryToVisible && this.#toEntryIsSource &&\n        this.#toEntryDimensions?.width >= minWidthToDrawConnectorCircles && !this.#arrowHidden;\n\n    this.#entryFromCirleConnector.setAttribute('visibility', drawFromEntryConnectorCircle ? 'visible' : 'hidden');\n    this.#entryToCircleConnector.setAttribute('visibility', drawToEntryConnectorCircle ? 'visible' : 'hidden');\n  }\n\n  #setArrowConnectorStyle(): void {\n    if (!this.#connector) {\n      return;\n    }\n\n    // If neither entry is visible, do not display the connector\n    this.#connector.style.display = (this.#entryFromVisible || this.#entryToVisible) ? 'block' : 'none';\n    this.#connector.setAttribute('stroke-width', '2');\n\n    const arrowColor = ThemeSupport.ThemeSupport.instance().getComputedValue('--color-text-primary');\n\n    // Use a solid stroke if the 'to' entry's dimensions are unknown (during link creation) or if both entries are visible.\n    if (!this.#toEntryDimensions || (this.#entryFromVisible && this.#entryToVisible)) {\n      this.#connector.setAttribute('stroke', arrowColor);\n      return;\n    }\n\n    // If one entry is not visible and one is, fade the arrow.\n    if (this.#entryFromVisible && !this.#entryToVisible) {\n      this.#connector.setAttribute('stroke', 'url(#fromVisibleLineGradient)');\n    } else if (this.#entryToVisible && !this.#entryFromVisible) {\n      this.#connector.setAttribute('stroke', 'url(#toVisibleLineGradient)');\n    }\n  }\n\n  #positionConnectorLineAndCircles(): void {\n    if (!this.#connector || !this.#entryFromCirleConnector || !this.#entryToCircleConnector) {\n      return;\n    }\n\n    // If the entry is visible, the entry arrow starts from the middle of the right edge of the entry (end on the X axis and middle of the Y axis).\n    // If not, draw it to the y coordinate of the entry and the edge of the timeline so it is pointing in the direction of the entry.\n    const halfFromEntryHeight = this.#fromEntryDimensions.height / 2;\n    const fromX = this.#coordinateFrom.x + this.#fromEntryDimensions.width;\n    const fromY = this.#coordinateFrom.y + halfFromEntryHeight;\n\n    this.#connector.setAttribute('x1', fromX.toString());\n    this.#connector.setAttribute('y1', fromY.toString());\n\n    this.#entryFromCirleConnector.setAttribute('cx', fromX.toString());\n    this.#entryFromCirleConnector.setAttribute('cy', fromY.toString());\n\n    // If the arrow is pointing to the entry and that entry is visible, point it to the middle of the entry.\n    // If the entry is not visible, point the arrow to the edge of the screen towards the entry.\n    // Otherwise, the arrow is following the mouse so we assign it to the provided coordinates.\n    const toX = this.#coordinateTo.x;\n    const toY = this.#toEntryDimensions ? this.#coordinateTo.y + (this.#toEntryDimensions?.height ?? 0) / 2 :\n                                          this.#coordinateTo.y;\n\n    this.#connector.setAttribute('x2', toX.toString());\n    this.#connector.setAttribute('y2', toY.toString());\n\n    this.#entryToCircleConnector.setAttribute('cx', toX.toString());\n    this.#entryToCircleConnector.setAttribute('cy', toY.toString());\n  }\n\n  /*\n   * Calculates the gradient stop percentage when only one entry is visible.\n   * This percentage represents the portion of the line visible within the canvas,\n   * used to create a fade effect towards the off-screen entry.\n   * When one entry is off-screen, it is impossible to tell where exactly the line\n   * is going to. Therefore, to not needlessly take space, the faded line is very short.\n   *\n   * To achieve this, we need to calculate what percentage of the\n   * shole connection the short line is currently occupying and apply\n   * that gradient to the visible connection part.\n   */\n  #partlyVisibleConnectionLinePercentage(): number {\n    if (!this.#canvasRect) {\n      return 100;\n    }\n    const fadedLineLength = 25;\n\n    const lineLength = this.#coordinateTo.x - (this.#coordinateFrom.x + this.#fromEntryDimensions.width);\n    const visibleLineFromTotalPercentage = (fadedLineLength * 100) / lineLength;\n\n    return (visibleLineFromTotalPercentage < 100) ? visibleLineFromTotalPercentage : 100;\n  }\n\n  #updateCreateLinkBox(): void {\n    const createLinkBox = this.#shadow.querySelector<HTMLElement>('.create-link-box');\n    const createLinkIcon = createLinkBox?.querySelector<HTMLElement>('.create-link-icon') ?? null;\n\n    if (!createLinkBox || !createLinkIcon) {\n      console.error('creating element is missing.');\n      return;\n    }\n\n    if (this.#linkState !== Trace.Types.File.EntriesLinkState.CREATION_NOT_STARTED) {\n      createLinkIcon.style.display = 'none';\n      return;\n    }\n\n    createLinkIcon.style.left = `${this.#coordinateFrom.x + this.#fromEntryDimensions.width}px`;\n    createLinkIcon.style.top = `${this.#coordinateFrom.y}px`;\n  }\n\n  #startCreatingConnection(): void {\n    this.#linkState = Trace.Types.File.EntriesLinkState.PENDING_TO_EVENT;\n    this.dispatchEvent(new EntryLinkStartCreating());\n  }\n\n  /*\n  The entries link overlay is an arrow connecting 2 entries.\n  The Entries are drawn by Flamechart and this Overlay is only drawing the arrow between them.\n   _________\n  |__entry__|\\\n              \\\n               \\          <-- arrow connecting the sides of entries drawn by this overlay\n                \\   ________________\n                 ➘ |_____entry______|\n  */\n  #render(): void {\n    const arrowColor = ThemeSupport.ThemeSupport.instance().getComputedValue('--color-text-primary');\n    // clang-format off\n    render(\n        html`\n          <style>${entriesLinkOverlayStyles}</style>\n          <svg class=\"connectorContainer\" width=\"100%\" height=\"100%\" role=\"region\" aria-label=${i18nString(UIStrings.diagram)}>\n            <defs>\n              <linearGradient\n                id=\"fromVisibleLineGradient\"\n                x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"0%\">\n                <stop\n                  offset=\"0%\"\n                  stop-color=${arrowColor}\n                  stop-opacity=\"1\" />\n                <stop\n                  offset=\"${this.#partlyVisibleConnectionLinePercentage()}%\"\n                  stop-color=${arrowColor}\n                  stop-opacity=\"0\" />\n              </linearGradient>\n\n              <linearGradient\n                id=\"toVisibleLineGradient\"\n                x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"0%\">\n                <stop\n                  offset=\"${100 - this.#partlyVisibleConnectionLinePercentage()}%\"\n                  stop-color=${arrowColor}\n                  stop-opacity=\"0\" />\n                <stop\n                  offset=\"100%\"\n                  stop-color=${arrowColor}\n                  stop-opacity=\"1\" />\n              </linearGradient>\n              <marker\n                id=\"arrow\"\n                orient=\"auto\"\n                markerWidth=\"3\"\n                markerHeight=\"4\"\n                fill-opacity=\"1\"\n                refX=\"4\"\n                refY=\"2\"\n                visibility=${this.#entryToVisible || !this.#toEntryDimensions ? 'visible' : 'hidden'}>\n                <path d=\"M0,0 V4 L4,2 Z\" fill=${arrowColor} />\n              </marker>\n            </defs>\n            <line\n              marker-end=\"url(#arrow)\"\n              stroke-dasharray=${!this.#fromEntryIsSource || !this.#toEntryIsSource ? DASHED_STROKE_AMOUNT : 'none'}\n              visibility=${!this.#entryFromVisible && !this.#entryToVisible ? 'hidden' : 'visible'}\n              />\n            <circle class=\"entryFromConnector\" fill=\"none\" stroke=${arrowColor} stroke-width=${CONNECTOR_CIRCLE_STROKE_WIDTH} r=${CONNECTOR_CIRCLE_RADIUS} />\n            <circle class=\"entryToConnector\" fill=\"none\" stroke=${arrowColor} stroke-width=${CONNECTOR_CIRCLE_STROKE_WIDTH} r=${CONNECTOR_CIRCLE_RADIUS} />\n          </svg>\n          <div class=\"entry-wrapper from-highlight-wrapper ${this.#fromEntryIsSource ? '' : 'entry-is-not-source'}\"></div>\n          <div class=\"entry-wrapper to-highlight-wrapper ${this.#toEntryIsSource ? '' : 'entry-is-not-source'}\"></div>\n          <div class=\"create-link-box ${this.#linkState ? 'visible' : 'hidden'}\">\n            <devtools-icon\n              class='create-link-icon'\n              jslog=${VisualLogging.action('timeline.annotations.create-entry-link').track({click: true})}\n              @click=${this.#startCreatingConnection}\n              name='arrow-right-circle'>\n            </devtools-icon>\n          </div>\n        `,\n        this.#shadow, {host: this});\n    // clang-format on\n  }\n}\n\nconst CONNECTOR_CIRCLE_RADIUS = 2;\nconst CONNECTOR_CIRCLE_STROKE_WIDTH = 1;\n\n// Defines the gap in the border when we are drawing a dashed outline.\n// https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray\nconst DASHED_STROKE_AMOUNT = 4;\n\ncustomElements.define('devtools-entries-link-overlay', EntriesLinkOverlay);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'devtools-entries-link-overlay': EntriesLinkOverlay;\n  }\n}\n", "// Copyright 2025 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n// IMPORTANT: this file is auto generated. Please do not edit this file.\n/* istanbul ignore file */\nexport default `/*\n * Copyright 2024 The Chromium Authors\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.connectorContainer {\n  display: flex;\n  width: 100%;\n  height: 100%;\n}\n\n.entry-wrapper {\n  pointer-events: none;\n  position: absolute;\n  display: block;\n  border: 2px solid var(--color-text-primary);\n  box-sizing: border-box;\n\n  &.cut-off-top {\n    border-top: none;\n  }\n\n  &.cut-off-bottom {\n    border-bottom: none;\n  }\n\n  &.cut-off-right {\n    border-right: none;\n  }\n\n  &.cut-off-left {\n    border-left: none;\n  }\n}\n\n.entry-is-not-source {\n  border: 2px dashed var(--color-text-primary);\n}\n\n.create-link-icon {\n  pointer-events: auto;\n  cursor: pointer;\n  color: var(--sys-color-on-surface);\n  width: 16px;\n  height: 16px;\n  position: absolute;\n}\n\n/*# sourceURL=${import.meta.resolve('./entriesLinkOverlay.css')} */`;", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n/* eslint-disable @devtools/no-lit-render-outside-of-view */\n\nimport '../../../../ui/components/icon_button/icon_button.js';\nimport '../../../../ui/components/tooltips/tooltips.js';\nimport '../../../../ui/components/spinners/spinners.js';\n\nimport * as Common from '../../../../core/common/common.js';\nimport * as Host from '../../../../core/host/host.js';\nimport * as i18n from '../../../../core/i18n/i18n.js';\nimport * as Platform from '../../../../core/platform/platform.js';\nimport * as Root from '../../../../core/root/root.js';\nimport * as AiAssistanceModels from '../../../../models/ai_assistance/ai_assistance.js';\nimport * as Buttons from '../../../../ui/components/buttons/buttons.js';\nimport * as ComponentHelpers from '../../../../ui/components/helpers/helpers.js';\nimport * as UIHelpers from '../../../../ui/helpers/helpers.js';\nimport * as UI from '../../../../ui/legacy/legacy.js';\nimport * as ThemeSupport from '../../../../ui/legacy/theme_support/theme_support.js';\nimport * as Lit from '../../../../ui/lit/lit.js';\nimport * as VisualLogging from '../../../../ui/visual_logging/visual_logging.js';\nimport * as PanelCommon from '../../../common/common.js';\n\nimport entryLabelOverlayStyles from './entryLabelOverlay.css.js';\n\nconst {html, Directives} = Lit;\n\nconst UIStrings = {\n  /**\n   * @description Accessible label used to explain to a user that they are viewing an entry label.\n   */\n  entryLabel: 'Entry label',\n  /**\n   * @description Accessible label used to prompt the user to input text into the field.\n   */\n  inputTextPrompt: 'Enter an annotation label',\n  /**\n   * @description Text displayed on a button that generates an AI label.\n   */\n  generateLabelButton: 'Generate label',\n  /**\n   * @description Label used for screenreaders on the FRE dialog\n   */\n  freDialog: 'Get AI-powered annotation suggestions dialog',\n  /**\n   * @description Screen-reader text for a tooltip link for navigating to \"AI innovations\" settings where the user can learn more about auto-annotations.\n   */\n  learnMoreAriaLabel: 'Learn more about auto annotations in settings',\n  /**\n   * @description Screen-reader text for a tooltip icon.\n   */\n  moreInfoAriaLabel: 'More information about this feature',\n} as const;\n\n/*\n* Strings that don't need to be translated at this time.\n*/\nconst UIStringsNotTranslate = {\n  /**\n   * @description Tooltip link for the navigating to \"AI innovations\" page in settings.\n   */\n  learnMore: 'Learn more in settings',\n  /**\n   * @description Security disclaimer text displayed when the information icon on a button that generates an AI label is hovered.\n   */\n  generateLabelSecurityDisclaimer:\n      'The selected call stack is sent to Google. The content you submit and that is generated by this feature will be used to improve Google’s AI models. This is an experimental AI feature and won’t always get it right.',\n  /**\n   * @description Enterprise users with logging off - Security disclaimer text displayed when the information icon on a button that generates an AI label is hovered.\n   */\n  generateLabelSecurityDisclaimerLogginOff:\n      'The selected call stack is sent to Google. The content you submit and that is generated by this feature will not be used to improve Google’s AI models. This is an experimental AI feature and won’t always get it right.',\n  /**\n   * @description The `Generate AI label button` tooltip disclaimer for when the feature is not available and the reason can be checked in settings.\n   */\n  autoAnnotationNotAvailableDisclaimer: 'Auto annotations are not available.',\n  /**\n   * @description The `Generate AI label button` tooltip disclaimer for when the feature is not available because the user is offline.\n   */\n  autoAnnotationNotAvailableOfflineDisclaimer: 'Auto annotations are not available because you are offline.',\n  /**\n   * @description Header text for the AI-powered annotations suggestions disclaimer dialog.\n   */\n  freDisclaimerHeader: 'Get AI-powered annotation suggestions',\n  /**\n   * @description Text shown when the AI-powered annotation is being generated.\n   */\n  generatingLabel: 'Generating label',\n  /**\n   * @description Text shown when the generation of the AI-powered annotation failed.\n   */\n  generationFailed: 'Generation failed',\n  /**\n   * @description First disclaimer item text for the fre dialog - AI won't always get it right.\n   */\n  freDisclaimerAiWontAlwaysGetItRight: 'This feature uses AI and won’t always get it right',\n  /**\n   * @description Second disclaimer item text for the fre dialog - trace data is sent to Google.\n   */\n  freDisclaimerPrivacyDataSentToGoogle:\n      'To generate annotation suggestions, your performance trace is sent to Google. This data may be seen by human reviewers to improve this feature.',\n  /**\n   * @description Second disclaimer item text for the fre dialog - trace data is sent to Google.\n   */\n  freDisclaimerPrivacyDataSentToGoogleNoLogging:\n      'To generate annotation suggestions, your performance trace is sent to Google. This data will not be used to improve Google’s AI models. Your organization may change these settings at any time.',\n  /**\n   * @description Text for the 'learn more' button displayed in fre.\n   */\n  learnMoreButton: 'Learn more',\n} as const;\n\nconst enum AIButtonState {\n  ENABLED = 'enabled',\n  DISABLED = 'disabled',\n  HIDDEN = 'hidden',\n  GENERATION_FAILED = 'generation_failed',\n  GENERATING_LABEL = 'generating_label',\n}\n\nconst str_ = i18n.i18n.registerUIStrings('panels/timeline/overlays/components/EntryLabelOverlay.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\nconst lockedString = i18n.i18n.lockedString;\n\nfunction isAiAssistanceServerSideLoggingEnabled(): boolean {\n  return !Root.Runtime.hostConfig.aidaAvailability?.disallowLogging;\n}\n\nexport class EntryLabelRemoveEvent extends Event {\n  static readonly eventName = 'entrylabelremoveevent';\n\n  constructor() {\n    super(EntryLabelRemoveEvent.eventName);\n  }\n}\n\nexport class EntryLabelChangeEvent extends Event {\n  static readonly eventName = 'entrylabelchangeevent';\n\n  constructor(public newLabel: string) {\n    super(EntryLabelChangeEvent.eventName);\n  }\n}\n\nexport class LabelAnnotationsConsentDialogVisibilityChange extends Event {\n  static readonly eventName = 'labelannotationsconsentdialogvisiblitychange';\n  constructor(public isVisible: boolean) {\n    super(LabelAnnotationsConsentDialogVisibilityChange.eventName, {bubbles: true, composed: true});\n  }\n}\n\nexport class EntryLabelOverlay extends HTMLElement {\n  // The label is angled on the left from the centre of the entry it belongs to.\n  // `LABEL_AND_CONNECTOR_SHIFT_LENGTH` specifies how many pixels to the left it is shifted.\n  static readonly LABEL_AND_CONNECTOR_SHIFT_LENGTH = 8;\n  // Length of the line that connects the label to the entry.\n  static readonly LABEL_CONNECTOR_HEIGHT = 7;\n  // Set the max label length to avoid labels that could signicantly increase the file size.\n  static readonly MAX_LABEL_LENGTH = 100;\n\n  readonly #shadow = this.attachShadow({mode: 'open'});\n\n  // Once a label is bound for deletion, we remove it from the DOM via events\n  // that are dispatched. But in the meantime the blur event of the input box\n  // can fire, and that triggers a second removal. So we set this flag after\n  // the first removal to avoid a duplicate event firing which is a no-op but\n  // causes errors when we try to delete an already deleted annotation.\n  #isPendingRemoval = false;\n\n  // The label is set to editable when it is double clicked. If the user clicks away from the label box\n  // element, the label is set to not editable until it double clicked.s\n  #isLabelEditable = true;\n  #entryLabelVisibleHeight: number|null = null;\n\n  #labelPartsWrapper: HTMLElement|null = null;\n  #entryHighlightWrapper: HTMLElement|null = null;\n  #inputField: HTMLElement|null = null;\n  #connectorLineContainer: SVGAElement|null = null;\n  #label: string;\n  #shouldDrawBelowEntry: boolean;\n  #richTooltip: Lit.Directives.Ref<HTMLElement> = Directives.createRef();\n  #noLogging: boolean;\n  /**\n   * Required to generate a label with AI.\n   */\n  #callTree: AiAssistanceModels.AICallTree.AICallTree|null = null;\n  // Creates or gets the setting if it exists.\n  #aiAnnotationsEnabledSetting = Common.Settings.Settings.instance().createSetting('ai-annotations-enabled', false);\n  #agent = new AiAssistanceModels.PerformanceAnnotationsAgent.PerformanceAnnotationsAgent({\n    aidaClient: new Host.AidaClient.AidaClient(),\n    serverSideLoggingEnabled: isAiAssistanceServerSideLoggingEnabled(),\n  });\n  /**\n   * We track this because when the user is in this flow we don't want the\n   * empty annotation label to be removed on blur, as we take them to the flow &\n   * want to keep the label there for when they come back from the flow having\n   * consented, hopefully!\n   */\n  #inAIConsentDialogFlow = false;\n  #currAIButtonState: AIButtonState = AIButtonState.HIDDEN;\n\n  /**\n   * The entry label overlay consists of 3 parts - the label part with the label string inside,\n   * the line connecting the label to the entry, and a black box around an entry to highlight the entry with a label.\n   * ________\n   * |_label__|                <-- label part with the label string inside\n   *     \\\n   *      \\                   <-- line connecting the label to the entry with a circle at the end\n   *       \\\n   * _______◯_________\n   * |_____entry______|         <--- box around an entry\n   *\n   * `drawLabel` method below draws the first part.\n   * `drawConnector` method below draws the second part - the connector line with a circle and the svg container for them.\n   * `drawEntryHighlightWrapper` draws the third part.\n   * We only rerender the first part if the label changes and the third part if the size of the entry changes.\n   * The connector and circle shapes never change so we only draw the second part when the component is created.\n   *\n   * Otherwise, the entry label overlay object only gets repositioned.\n   */\n\n  constructor(label: string, shouldDrawBelowEntry = false) {\n    super();\n    this.#render();\n    this.#shouldDrawBelowEntry = shouldDrawBelowEntry;\n    this.#labelPartsWrapper = this.#shadow.querySelector<HTMLElement>('.label-parts-wrapper');\n    this.#inputField = this.#labelPartsWrapper?.querySelector<HTMLElement>('.input-field') ?? null;\n    this.#connectorLineContainer = this.#labelPartsWrapper?.querySelector<SVGAElement>('.connectorContainer') ?? null;\n    this.#entryHighlightWrapper =\n        this.#labelPartsWrapper?.querySelector<HTMLElement>('.entry-highlight-wrapper') ?? null;\n    this.#label = label;\n    this.#noLogging = Root.Runtime.hostConfig.aidaAvailability?.enterprisePolicyValue ===\n        Root.Runtime.GenAiEnterprisePolicyValue.ALLOW_WITHOUT_LOGGING;\n    this.#drawLabel(label);\n    // If the label is not empty, it was loaded from the trace file.\n    // In that case, do not auto-focus it as if the user were creating it for the first time\n    if (label !== '') {\n      this.setLabelEditabilityAndRemoveEmptyLabel(false);\n    }\n    const ariaLabel = label === '' ? i18nString(UIStrings.inputTextPrompt) : label;\n    this.#inputField?.setAttribute('aria-label', ariaLabel);\n\n    this.#drawConnector();\n  }\n\n  /**\n   * So we can provide a mocked agent in tests. Do not call this method outside of a test!\n   */\n  overrideAIAgentForTest(agent: AiAssistanceModels.PerformanceAnnotationsAgent.PerformanceAnnotationsAgent): void {\n    this.#agent = agent;\n  }\n\n  entryHighlightWrapper(): HTMLElement|null {\n    return this.#entryHighlightWrapper;\n  }\n\n  #handleLabelInputKeyUp(): void {\n    // If the label changed on key up, dispatch label changed event.\n    const labelBoxTextContent = this.#inputField?.textContent?.trim() ?? '';\n    if (labelBoxTextContent !== this.#label) {\n      this.#label = labelBoxTextContent;\n      this.dispatchEvent(new EntryLabelChangeEvent(this.#label));\n      // Dispatch a fake change event; because we use contenteditable rather than an input, this event does not fire.\n      // But we want to listen to the change event in the VE logs, so we dispatch it here.\n      this.#inputField?.dispatchEvent(new Event('change', {bubbles: true, composed: true}));\n    }\n    this.#setAIButtonRenderState();\n    // Rerender the label component when the label text changes because we need to\n    // make sure the 'auto annotation' button is only shown when the label is empty.\n    this.#render();\n    this.#inputField?.setAttribute('aria-label', labelBoxTextContent);\n  }\n\n  #handleLabelInputKeyDown(event: KeyboardEvent): boolean {\n    if (!this.#inputField) {\n      return false;\n    }\n\n    const allowedKeysAfterReachingLenLimit = [\n      'Backspace',\n      'Delete',\n      'ArrowLeft',\n      'ArrowRight',\n    ];\n\n    // We do not want to create multi-line labels.\n    // Therefore, if the new key is `Enter` key, treat it\n    // as the end of the label input and blur the input field.\n    if ((event.key === Platform.KeyboardUtilities.ENTER_KEY || event.key === Platform.KeyboardUtilities.ESCAPE_KEY) &&\n        this.#isLabelEditable) {\n      // Note that we do not stop the event propagating here; this is on\n      // purpose because we need it to bubble up into TimelineFlameChartView's\n      // handler. That updates the state and deals with the keydown.\n      // In theory blur() should call the blur event listener, which in turn\n      // calls the setLabelEditabilityAndRemoveEmptyLabel method. However, we\n      // have seen this not work as part of the AI FRE flow where the privacy\n      // consent dialog is shown, which takes focus away from the input and\n      // causes the blur() to be a no-op. It's not entirely clear why this\n      // happens as visually it renders as focused, but as a back-up we call\n      // the setLabelEditabilityAndRemoveEmptyLabel method manually. It won't\n      // do anything if the editable state matches what is passed in, so it's\n      // safe to call this just in case the blur() didn't actually trigger.\n      this.#inputField.blur();\n      this.setLabelEditabilityAndRemoveEmptyLabel(false);\n      return false;\n    }\n\n    // If the max limit is not reached, return true\n    if (this.#inputField.textContent !== null &&\n        this.#inputField.textContent.length <= EntryLabelOverlay.MAX_LABEL_LENGTH) {\n      return true;\n    }\n\n    if (allowedKeysAfterReachingLenLimit.includes(event.key)) {\n      return true;\n    }\n\n    if (event.key.length === 1 && event.ctrlKey /* Ctrl + A for selecting all */) {\n      return true;\n    }\n\n    event.preventDefault();\n    return false;\n  }\n\n  #handleLabelInputPaste(event: ClipboardEvent): void {\n    event.preventDefault();\n\n    const clipboardData = event.clipboardData;\n    if (!clipboardData || !this.#inputField) {\n      return;\n    }\n\n    // Remove newline characters to ensure single-line paste.\n    const pastedText = clipboardData.getData('text').replace(/(\\r\\n|\\n|\\r)/gm, '');\n    const newText = this.#inputField.textContent + pastedText;\n    const trimmedText = newText.slice(0, EntryLabelOverlay.MAX_LABEL_LENGTH + 1);\n    this.#inputField.textContent = trimmedText;\n    this.#placeCursorAtInputEnd();\n  }\n\n  set entryLabelVisibleHeight(entryLabelVisibleHeight: number) {\n    this.#entryLabelVisibleHeight = entryLabelVisibleHeight;\n    void ComponentHelpers.ScheduledRender.scheduleRender(this, this.#render);\n    // If the label is editable, focus cursor on it.\n    // This method needs to be called after rendering the wrapper because it is the last label overlay element to render.\n    // By doing this, the cursor focuses when the label is created.\n    if (this.#isLabelEditable) {\n      this.#focusInputBox();\n    }\n    // The label and connector can move depending on the height of the entry\n    this.#drawLabel();\n    this.#drawConnector();\n  }\n\n  #drawConnector(): void {\n    if (!this.#connectorLineContainer) {\n      console.error('`connectorLineContainer` element is missing.');\n      return;\n    }\n\n    if (this.#shouldDrawBelowEntry && this.#entryLabelVisibleHeight) {\n      const translation = this.#entryLabelVisibleHeight + EntryLabelOverlay.LABEL_CONNECTOR_HEIGHT;\n\n      this.#connectorLineContainer.style.transform = `translateY(${translation}px) rotate(180deg)`;\n    }\n\n    const connector = this.#connectorLineContainer.querySelector('line');\n    const circle = this.#connectorLineContainer.querySelector('circle');\n    if (!connector || !circle) {\n      console.error('Some entry label elements are missing.');\n      return;\n    }\n    // PART 2: draw the connector from label to the entry\n    // Set the width of the canvas that draws the connector to be equal to the length of the shift multiplied by two.\n    // That way, we can draw the connector from its corner to its middle. Since all elements are aligned in the middle, the connector\n    // will end in the middle of the entry.\n    this.#connectorLineContainer.setAttribute(\n        'width', (EntryLabelOverlay.LABEL_AND_CONNECTOR_SHIFT_LENGTH * 2).toString());\n    this.#connectorLineContainer.setAttribute('height', EntryLabelOverlay.LABEL_CONNECTOR_HEIGHT.toString());\n    // Start drawing the top right corner.\n    connector.setAttribute('x1', '0');\n    connector.setAttribute('y1', '0');\n    // Finish drawing in middle of the connector container.\n    connector.setAttribute('x2', EntryLabelOverlay.LABEL_AND_CONNECTOR_SHIFT_LENGTH.toString());\n    connector.setAttribute('y2', EntryLabelOverlay.LABEL_CONNECTOR_HEIGHT.toString());\n    const connectorColor = ThemeSupport.ThemeSupport.instance().getComputedValue('--color-text-primary');\n    connector.setAttribute('stroke', connectorColor);\n    connector.setAttribute('stroke-width', '2');\n\n    // Draw the circle at the bottom of the connector\n    circle.setAttribute('cx', EntryLabelOverlay.LABEL_AND_CONNECTOR_SHIFT_LENGTH.toString());\n    // Add one to the offset of the circle which positions it perfectly centered on the border of the overlay.\n    circle.setAttribute('cy', (EntryLabelOverlay.LABEL_CONNECTOR_HEIGHT + 1).toString());\n    circle.setAttribute('r', '3');\n    circle.setAttribute('fill', connectorColor);\n  }\n\n  #drawLabel(initialLabel?: string): void {\n    if (!this.#inputField) {\n      console.error('`labelBox`element is missing.');\n      return;\n    }\n\n    if (typeof initialLabel === 'string') {\n      this.#inputField.innerText = initialLabel;\n    }\n\n    let xTranslation: number|null = null;\n    let yTranslation: number|null = null;\n    // PART 1: draw the label box\n    if (this.#shouldDrawBelowEntry) {\n      // Label is drawn below and slightly to the right.\n      xTranslation = EntryLabelOverlay.LABEL_AND_CONNECTOR_SHIFT_LENGTH;\n    } else {\n      // If the label is drawn above, the connector goes up and to the left, so\n      // we pull the label back slightly to align it nicely.\n      xTranslation = EntryLabelOverlay.LABEL_AND_CONNECTOR_SHIFT_LENGTH * -1;\n    }\n\n    if (this.#shouldDrawBelowEntry && this.#entryLabelVisibleHeight) {\n      // Move the label down from above the entry to below it. The label is positioned by default quite far above the entry, hence why we add:\n      // 1. the height of the entry + of the label (inc its padding)\n      // 2. the height of the connector (*2), so we have room to draw it\n      const verticalTransform = this.#entryLabelVisibleHeight + (EntryLabelOverlay.LABEL_CONNECTOR_HEIGHT * 2) +\n          this.#inputField?.offsetHeight;\n\n      yTranslation = verticalTransform;\n    }\n\n    let transformString = '';\n    if (xTranslation) {\n      transformString += `translateX(${xTranslation}px) `;\n    }\n    if (yTranslation) {\n      transformString += `translateY(${yTranslation}px)`;\n    }\n\n    if (transformString.length) {\n      this.#inputField.style.transform = transformString;\n    }\n  }\n\n  #focusInputBox(): void {\n    if (!this.#inputField) {\n      console.error('`labelBox` element is missing.');\n      return;\n    }\n    this.#inputField.focus();\n  }\n\n  setLabelEditabilityAndRemoveEmptyLabel(editable: boolean): void {\n    // We skip this if we have taken the user to the AI FRE flow, because we want the label still there when they come back.\n    if (this.#inAIConsentDialogFlow && editable === false) {\n      return;\n    }\n\n    // Set an attribute on the host; this is used in the overlays CSS to bring\n    // the focused, editable label to the top above any others.\n    if (editable) {\n      this.setAttribute('data-user-editing-label', 'true');\n    } else {\n      this.removeAttribute('data-user-editing-label');\n    }\n\n    this.#isLabelEditable = editable;\n    this.#render();\n    // If the label is editable, focus cursor on it & put the cursor at the end\n    if (editable && this.#inputField) {\n      this.#placeCursorAtInputEnd();\n      this.#focusInputBox();\n    }\n    // On MacOS when clearing the input box it is left with a new line, so we\n    // trim the string to remove any accidental trailing whitespace.\n    const newLabelText = this.#inputField?.textContent?.trim() ?? '';\n    // If the label is empty when it is being navigated away from, dispatch an event to remove this entry overlay\n    if (!editable && newLabelText.length === 0 && !this.#isPendingRemoval) {\n      this.#isPendingRemoval = true;\n      this.dispatchEvent(new EntryLabelRemoveEvent());\n    }\n  }\n\n  /**\n   * Places the user's cursor at the end of the input. We do this when the user\n   * focuses the input with either the keyboard or mouse, and when they paste in\n   * text, so that the cursor is placed in a useful position to edit.\n   */\n  #placeCursorAtInputEnd(): void {\n    if (!this.#inputField) {\n      return;\n    }\n    const selection = window.getSelection();\n    const range = document.createRange();\n    range.selectNodeContents(this.#inputField);\n    range.collapse(false);\n    selection?.removeAllRanges();\n    selection?.addRange(range);\n  }\n\n  set callTree(callTree: AiAssistanceModels.AICallTree.AICallTree|null) {\n    this.#callTree = callTree;\n    // If the entry has a calltree, we need to check if we need to show the 'generate label' button.\n    this.#setAIButtonRenderState();\n  }\n\n  // Generate the AI label suggestion if:\n  // 1. the user has already already seen the fre dialog and confirmed the feature usage\n  // or\n  // 2. turned on the `generate AI labels` setting through the AI settings panel\n  //\n  // Otherwise, show the fre dialog with a 'Got it' button that turns the setting on.\n  async #handleAiButtonClick(): Promise<void> {\n    if (this.#aiAnnotationsEnabledSetting.get()) {\n      if (!this.#callTree || !this.#inputField) {\n        // Shouldn't happen as we only show the Generate UI when we have this, but this satisfies TS.\n        return;\n      }\n      try {\n        // Trigger a re-render to display the loading component in the place of the button when the label is being generated.\n        this.#currAIButtonState = AIButtonState.GENERATING_LABEL;\n        UI.ARIAUtils.LiveAnnouncer.alert(UIStringsNotTranslate.generatingLabel);\n        // Trigger a re-render to put focus back on the input box, otherwise\n        // when the button changes to a loading spinner, it loses focus and the\n        // editing state is reset because the component loses focus.\n        this.#render();\n        this.#focusInputBox();\n        void ComponentHelpers.ScheduledRender.scheduleRender(this, this.#render);\n\n        this.#label = await this.#agent.generateAIEntryLabel(this.#callTree);\n        this.dispatchEvent(new EntryLabelChangeEvent(this.#label));\n        this.#inputField.innerText = this.#label;\n        this.#placeCursorAtInputEnd();\n        // Reset the button state because we want to hide it if the label is not empty.\n        this.#setAIButtonRenderState();\n        // Trigger a re-render to hide the AI Button and display the generated label.\n        this.#render();\n      } catch {\n        this.#currAIButtonState = AIButtonState.GENERATION_FAILED;\n        void ComponentHelpers.ScheduledRender.scheduleRender(this, this.#render);\n      }\n    } else {\n      this.#inAIConsentDialogFlow = true;\n      this.#render();\n      const hasConsented = await this.#showUserAiFirstRunDialog();\n      this.#inAIConsentDialogFlow = false;\n      // This makes sure we put the user back in the editable state.\n      this.setLabelEditabilityAndRemoveEmptyLabel(true);\n      // If the user has consented, we now want to call this function again so\n      // the label generation happens without them having to click the button\n      // again.\n      if (hasConsented) {\n        await this.#handleAiButtonClick();\n      }\n    }\n  }\n\n  /**\n   * @returns `true` if the user has now consented, and `false` otherwise.\n   */\n  async #showUserAiFirstRunDialog(): Promise<boolean> {\n    this.dispatchEvent(new LabelAnnotationsConsentDialogVisibilityChange(true));\n    const userConsented = await PanelCommon.FreDialog.show({\n      ariaLabel: i18nString(UIStrings.freDialog),\n      header: {iconName: 'pen-spark', text: lockedString(UIStringsNotTranslate.freDisclaimerHeader)},\n      reminderItems: [\n        {\n          iconName: 'psychiatry',\n          content: lockedString(UIStringsNotTranslate.freDisclaimerAiWontAlwaysGetItRight),\n        },\n        {\n          iconName: 'google',\n          content: this.#noLogging ? lockedString(UIStringsNotTranslate.freDisclaimerPrivacyDataSentToGoogleNoLogging) :\n                                     lockedString(UIStringsNotTranslate.freDisclaimerPrivacyDataSentToGoogle),\n        },\n      ],\n      onLearnMoreClick: () => {\n        UIHelpers.openInNewTab('https://developer.chrome.com/docs/devtools/performance/annotations#auto-annotations');\n      },\n      learnMoreButtonText: UIStringsNotTranslate.learnMoreButton,\n    });\n    this.dispatchEvent(new LabelAnnotationsConsentDialogVisibilityChange(false));\n\n    if (userConsented) {\n      this.#aiAnnotationsEnabledSetting.set(true);\n    }\n    return this.#aiAnnotationsEnabledSetting.get();\n  }\n\n  #setAIButtonRenderState(): void {\n    const hasAiExperiment = Boolean(Root.Runtime.hostConfig.devToolsAiGeneratedTimelineLabels?.enabled);\n    const aiDisabledByEnterprisePolicy = Root.Runtime.hostConfig.aidaAvailability?.enterprisePolicyValue ===\n        Root.Runtime.GenAiEnterprisePolicyValue.DISABLE;\n    // If the call tree is not available, the entry is in a track other than the main track.\n    // Therefore, hide the button because, at the moment, the label can only be generated for main tracks\n    const dataToGenerateLabelAvailable = this.#callTree !== null;\n    /**\n     * Right now if the user \"retries\" the AI label generation the result will\n     * be almost identical because we don't change the input data or prompt. So\n     * we only show the generate button if the label is empty.\n     */\n    const labelIsEmpty = this.#label?.length <= 0;\n\n    if (!hasAiExperiment || aiDisabledByEnterprisePolicy || !dataToGenerateLabelAvailable || !labelIsEmpty) {\n      this.#currAIButtonState = AIButtonState.HIDDEN;\n    } else {\n      // To verify whether AI can be used, check if aida is available, the user is logged in, over 18, in a supported\n      // location and offline.\n      const aiAvailable = Root.Runtime.hostConfig.aidaAvailability?.enabled &&\n          !Root.Runtime.hostConfig.aidaAvailability?.blockedByAge &&\n          !Root.Runtime.hostConfig.aidaAvailability?.blockedByGeo && navigator.onLine;\n      if (aiAvailable) {\n        this.#currAIButtonState = AIButtonState.ENABLED;\n      } else {\n        // If AI features are not available, we show a disabled button.\n        this.#currAIButtonState = AIButtonState.DISABLED;\n      }\n    }\n  }\n\n  #renderAITooltip(opts: {textContent: string, includeSettingsButton: boolean}): Lit.TemplateResult {\n    // clang-format off\n    return html`<devtools-tooltip\n    variant=\"rich\"\n    id=\"info-tooltip\"\n    ${Directives.ref(this.#richTooltip)}>\n      <div class=\"info-tooltip-container\">\n        ${opts.textContent} ${opts.includeSettingsButton ? html`\n          <button\n            class=\"link tooltip-link\"\n            role=\"link\"\n            jslog=${VisualLogging.link('open-ai-settings').track({\n              click: true,\n            })}\n            @click=${this.#onTooltipLearnMoreClick}\n            aria-label=${i18nString(UIStrings.learnMoreAriaLabel)}\n          >${lockedString(UIStringsNotTranslate.learnMore)}</button>\n        ` : Lit.nothing}\n      </div>\n    </devtools-tooltip>`;\n    // clang-format on\n  }\n  #renderGeneratingLabelAiButton(): Lit.LitTemplate {\n    // clang-format off\n      return html`\n      <span\n        class=\"ai-label-loading\">\n        <devtools-spinner></devtools-spinner>\n        <span class=\"generate-label-text\">${lockedString(UIStringsNotTranslate.generatingLabel)}</span>\n      </span>\n    `;\n    // clang-format on\n  }\n\n  #renderAiButton(): Lit.LitTemplate {\n    if (this.#currAIButtonState === AIButtonState.GENERATION_FAILED) {\n      // Only show the error message on the first component render render after the failure.\n      // clang-format off\n      return html`\n        <span\n          class=\"ai-label-error\">\n          <devtools-icon\n            class=\"warning extra-large\"\n            name=\"warning\"\n            style=\"color: var(--ref-palette-error50)\">\n          </devtools-icon>\n          <span class=\"generate-label-text\">${lockedString(UIStringsNotTranslate.generationFailed)}</span>\n        </span>\n      `;\n      // clang-format on\n    }\n    // clang-format off\n    return html`\n      <!-- 'preventDefault' on the AI label button to prevent the label removal on blur  -->\n      <span\n        class=\"ai-label-button-wrapper only-pen-wrapper\"\n        @mousedown=${(e: Event) => e.preventDefault()}>\n        <button\n          class=\"ai-label-button enabled\"\n          @click=${this.#handleAiButtonClick}\n          jslog=${VisualLogging.link('timeline.annotations.ai-generate-label').track({\n            click: true,\n          })}>\n          <devtools-icon\n            class=\"pen-icon extra-large\"\n            name=\"pen-spark\"\n            style=\"color: var(--icon-primary);\">\n          </devtools-icon>\n          <span class=\"generate-label-text\">${i18nString(UIStrings.generateLabelButton)}</span>\n        </button>\n        <devtools-button\n          aria-details=\"info-tooltip\"\n          class=\"pen-icon\"\n          .title=${i18nString(UIStrings.moreInfoAriaLabel)}\n          .iconName=${'info'}\n          .variant=${Buttons.Button.Variant.ICON}\n          ></devtools-button>\n        ${this.#renderAITooltip({\n         textContent: this.#noLogging ? lockedString(UIStringsNotTranslate.generateLabelSecurityDisclaimerLogginOff) : lockedString(UIStringsNotTranslate.generateLabelSecurityDisclaimer),\n         includeSettingsButton: true,\n        })}\n      </span>\n    `;\n    // clang-format on\n  }\n\n  #onTooltipLearnMoreClick(): void {\n    this.#richTooltip?.value?.hidePopover();\n    void UI.ViewManager.ViewManager.instance().showView('chrome-ai');\n  }\n\n  // The disabled button rendered when the `generate AI label` feature is not available\n  // because of the geolocation, age or if they are not logged in into the google account.\n  //\n  // If the user is offline, display the same button with a different tooltip.\n  #renderDisabledAiButton(): Lit.TemplateResult {\n    const noConnection = navigator.onLine === false;\n    // clang-format off\n    return html`\n      <!-- 'preventDefault' on the AI label button to prevent the label removal on blur  -->\n      <span\n        class=\"ai-label-disabled-button-wrapper only-pen-wrapper\"\n        @mousedown=${(e: Event) => e.preventDefault()}>\n        <button\n          class=\"ai-label-button disabled\"\n          ?disabled=${true}\n          @click=${this.#handleAiButtonClick}>\n          <devtools-icon\n            aria-details=\"info-tooltip\"\n            class=\"pen-icon extra-large\"\n            name=\"pen-spark\"\n            style=\"color: var(--sys-color-state-disabled);\">\n          </devtools-icon>\n        </button>\n        ${this.#renderAITooltip({\n          textContent: noConnection ? lockedString(UIStringsNotTranslate.autoAnnotationNotAvailableOfflineDisclaimer) : lockedString(UIStringsNotTranslate.autoAnnotationNotAvailableDisclaimer),\n          includeSettingsButton: !noConnection,\n        })}\n      </span>\n    `;\n    // clang-format on\n  }\n\n  #handleFocusOutEvent(event: FocusEvent): void {\n    /**\n     * Usually when the text box loses focus, we want to stop the edit mode and\n     * just display the annotation. However, if the user tabs from the text box\n     * to focus the GenerateAI button, we need to ensure that we do not exit\n     * edit mode. The only reliable method is to listen to the focusout event\n     * (which bubbles, unlike `blur`) on the parent.\n     */\n    const relatedTarget = event.relatedTarget as Node | null;\n    // If the related target is null, it means the focus has left the browser\n    // window. If it's not null, we check if the new focused element is a\n    // descendant of this component's shadow root. If it is, we don't do anything.\n    if (relatedTarget && this.#shadow.contains(relatedTarget)) {\n      return;\n    }\n    this.setLabelEditabilityAndRemoveEmptyLabel(false);\n  }\n\n  #render(): void {\n    const inputFieldClasses = Lit.Directives.classMap({\n      'input-field': true,\n      // When the consent modal pops up, we want the input to look like it has focus so it visually doesn't change.\n      // Once the consent flow is closed, we restore focus and maintain the appearance.\n      'fake-focus-state': this.#inAIConsentDialogFlow,\n    });\n    // clang-format off\n    Lit.render(\n        html`\n        <style>${entryLabelOverlayStyles}</style>\n        <span class=\"label-parts-wrapper\" role=\"region\" aria-label=${i18nString(UIStrings.entryLabel)}\n          @focusout=${this.#handleFocusOutEvent}\n        >\n          <span\n            class=\"label-button-input-wrapper\">\n            <span\n              class=${inputFieldClasses}\n              role=\"textbox\"\n              @focus=${() => {\n                this.setLabelEditabilityAndRemoveEmptyLabel(true);\n              }}\n              @dblclick=${() => {\n                this.setLabelEditabilityAndRemoveEmptyLabel(true);\n              }}\n              @keydown=${this.#handleLabelInputKeyDown}\n              @paste=${this.#handleLabelInputPaste}\n              @input=${this.#handleLabelInputKeyUp}\n              contenteditable=${this.#isLabelEditable ? 'plaintext-only' : false}\n              jslog=${VisualLogging.textField('timeline.annotations.entry-label-input').track({keydown: true, click: true, change: true})}\n              tabindex=\"0\"\n            ></span>\n            ${this.#isLabelEditable && this.#inputField?.innerText !== '' ? html`\n              <button\n                class=\"delete-button\"\n                @click=${() => this.dispatchEvent(new EntryLabelRemoveEvent())}\n                jslog=${VisualLogging.action('timeline.annotations.delete-entry-label').track({click: true})}>\n              <devtools-icon name=\"cross\" class=\"small\" style=\"color: var(--color-background);\"\n              ></devtools-icon>\n              </button>\n            ` : Lit.nothing}\n            ${(() => {\n              switch (this.#currAIButtonState) {\n                case AIButtonState.HIDDEN:\n                  return Lit.nothing;\n                case AIButtonState.ENABLED:\n                  return this.#renderAiButton();\n                case AIButtonState.GENERATING_LABEL:\n                  return this.#renderGeneratingLabelAiButton();\n                case AIButtonState.GENERATION_FAILED:\n                  return this.#renderAiButton();\n                case AIButtonState.DISABLED:\n                  return this.#renderDisabledAiButton();\n              }\n            })()}\n          </span>\n          <svg class=\"connectorContainer\">\n            <line/>\n            <circle/>\n          </svg>\n          <div class=\"entry-highlight-wrapper\"></div>\n        </span>`,\n        this.#shadow, {host: this});\n    // clang-format on\n  }\n}\n\ncustomElements.define('devtools-entry-label-overlay', EntryLabelOverlay);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'devtools-entry-label-overlay': EntryLabelOverlay;\n  }\n}\n", "// Copyright 2025 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n// IMPORTANT: this file is auto generated. Please do not edit this file.\n/* istanbul ignore file */\nexport default `/*\n * Copyright 2024 The Chromium Authors\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.label-parts-wrapper {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n\n.label-button-input-wrapper {\n  display: flex;\n  position: relative;\n  overflow: visible;\n}\n\n.ai-label-button-wrapper,\n.ai-label-disabled-button-wrapper,\n.ai-label-loading,\n.ai-label-error {\n  /* position the button wrapper on the very right of the label */\n  position: absolute;\n  left: 100%;\n  display: flex;\n  /* Since the ai-button is a bit bigger than the label, lift it up for it to appear more centered */\n  transform: translateY(-3px);\n  flex-flow: row nowrap;\n  border: none;\n  border-radius: var(--sys-shape-corner-large);\n  background: var(--sys-color-surface3);\n  box-shadow: var(--drop-shadow);\n  align-items: center;\n  gap: var(--sys-size-4);\n  pointer-events: auto;\n  transition:\n    all var(--sys-motion-duration-medium2) var(--sys-motion-easing-emphasized);\n\n  &.only-pen-wrapper {\n    /* when the button wrapper is not hovered, set the max width to only fit the pen icon */\n    overflow: hidden;\n    width: var(--sys-size-12);\n    height: var(--sys-size-12);\n  }\n\n  * {\n    /* When unhovered, shift the contents left you don't see the border of the .ai-label-button  */\n    transform: translateX(-2px);\n  }\n}\n\n.delete-button {\n  display: flex;\n  pointer-events: auto;\n  position: absolute;\n  right: 0;\n  top: -5px;\n  border-radius: 50%;\n  padding: 0;\n  border: none;\n  background: var(--color-background-inverted);\n}\n\n.ai-label-loading,\n.ai-label-error {\n  gap: var(--sys-size-6);\n  padding: var(--sys-size-5) var(--sys-size-8);\n}\n\n.ai-label-button-wrapper:focus,\n.ai-label-button-wrapper:focus-within,\n.ai-label-button-wrapper:hover {\n  width: auto;\n  height: var(--sys-size-13);\n  padding: var(--sys-size-3) var(--sys-size-5);\n  transform: translateY(-9px); /* -9px is the original -3px minus 6px (coming from the padding adjustment) */\n\n  * {\n    transform: translateX(0);\n  }\n}\n\n.ai-label-button {\n  display: flex;\n  align-items: center;\n  gap: var(--sys-size-4);\n  padding: var(--sys-size-3) var(--sys-size-5);\n  border: 1px solid var(--color-primary);\n  border-radius: var(--sys-shape-corner-large);\n\n  &.enabled {\n    background: var(--sys-color-surface3);\n  }\n\n  &.disabled {\n    background: var(--sys-color-surface5);\n  }\n\n  &:hover {\n    background: var(--sys-color-state-hover-on-subtle);\n  }\n}\n\n.generate-label-text {\n  white-space: nowrap;\n  color: var(--color-primary);\n}\n\n.input-field {\n  background-color: var(--color-background-inverted);\n  color: var(--color-background);\n  pointer-events: auto;\n  border-radius: var(--sys-shape-corner-extra-small);\n  white-space: nowrap;\n  padding: var(--sys-size-3) var(--sys-size-4);\n  font-family: var(--default-font-family);\n  font-size: var(--sys-typescale-body2-size);\n  font-weight: var(--ref-typeface-weight-medium);\n  outline: 2px solid var(--color-background);\n}\n\n\n/* When the input field is focused we want to style it as a light background so\n * it's clear that the user is in it and can edit the text.\n* However we also do this styling when the user's focus is on the GenerateAI\n* button (using the :focus-within on the parent). This is so if you open an\n* empty annotation, and then tab to the GenerateAI button, the text field\n* styling doesn't change. */\n.input-field:focus,\n.label-parts-wrapper:focus-within .input-field,\n.input-field.fake-focus-state {\n  background-color: var(--color-background);\n  color: var(--color-background-inverted);\n  outline: 2px solid var(--color-background-inverted);\n}\n\n.connectorContainer {\n  overflow: visible;\n}\n\n.entry-highlight-wrapper {\n  box-sizing: border-box;\n  border: 2px solid var(--sys-color-on-surface);\n\n  &.cut-off-top {\n    border-top: none;\n  }\n\n  &.cut-off-bottom {\n    border-bottom: none;\n  }\n\n  &.cut-off-right {\n    border-right: none;\n  }\n\n  &.cut-off-left {\n    border-left: none;\n  }\n}\n\n/* The tooltip for the AI label generation info */\n.info-tooltip-container {\n  max-width: var(--sys-size-28);\n\n  button.link {\n    cursor: pointer;\n    text-decoration: underline;\n    border: none;\n    padding: 0;\n    background: none;\n    font: inherit;\n    font-weight: var(--ref-typeface-weight-medium);\n    display: block;\n    margin-top: var(--sys-size-4);\n    color: var(--sys-color-primary);\n  }\n}\n\n/*# sourceURL=${import.meta.resolve('./entryLabelOverlay.css')} */`;", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n/* eslint-disable @devtools/no-lit-render-outside-of-view */\n\nimport * as i18n from '../../../../core/i18n/i18n.js';\nimport * as Platform from '../../../../core/platform/platform.js';\nimport type * as Trace from '../../../../models/trace/trace.js';\nimport {html, render} from '../../../../ui/lit/lit.js';\nimport * as VisualLogging from '../../../../ui/visual_logging/visual_logging.js';\n\nimport timeRangeOverlayStyles from './timeRangeOverlay.css.js';\n\nconst UIStrings = {\n  /**\n   * @description Accessible label used to explain to a user that they are viewing an entry label.\n   */\n  timeRange: 'Time range',\n} as const;\nconst str_ = i18n.i18n.registerUIStrings('panels/timeline/overlays/components/TimeRangeOverlay.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\nexport class TimeRangeLabelChangeEvent extends Event {\n  static readonly eventName = 'timerangelabelchange';\n\n  constructor(public newLabel: string) {\n    super(TimeRangeLabelChangeEvent.eventName);\n  }\n}\n\nexport class TimeRangeRemoveEvent extends Event {\n  static readonly eventName = 'timerangeremoveevent';\n\n  constructor() {\n    super(TimeRangeRemoveEvent.eventName);\n  }\n}\n\nexport class TimeRangeOverlay extends HTMLElement {\n  readonly #shadow = this.attachShadow({mode: 'open'});\n  #duration: Trace.Types.Timing.Micro|null = null;\n  #canvasRect: DOMRect|null = null;\n  #label: string;\n\n  // The label is set to editable and in focus anytime the label is empty and when the label it is double clicked.\n  // If the user clicks away from the selected range element and the label is not empty, the label is set to not editable until it is double clicked.\n  #isLabelEditable = true;\n\n  #rangeContainer: HTMLElement|null = null;\n  #labelBox: HTMLElement|null = null;\n\n  constructor(initialLabel: string) {\n    super();\n    this.#render();\n    this.#rangeContainer = this.#shadow.querySelector<HTMLElement>('.range-container');\n    this.#labelBox = this.#rangeContainer?.querySelector<HTMLElement>('.label-text') ?? null;\n    this.#label = initialLabel;\n    if (!this.#labelBox) {\n      console.error('`labelBox` element is missing.');\n      return;\n    }\n    this.#labelBox.innerText = initialLabel;\n    if (initialLabel) {\n      this.#labelBox?.setAttribute('aria-label', initialLabel);\n      // To construct a time range with a predefined label, it must have been\n      // loaded from the trace file. In this case we do not want it to default\n      // to editable.\n      this.#setLabelEditability(false);\n    }\n  }\n\n  set canvasRect(rect: DOMRect|null) {\n    if (rect === null) {\n      return;\n    }\n    if (this.#canvasRect && this.#canvasRect.width === rect.width && this.#canvasRect.height === rect.height) {\n      return;\n    }\n    this.#canvasRect = rect;\n    this.#render();\n  }\n\n  set duration(duration: Trace.Types.Timing.Micro|null) {\n    if (duration === this.#duration) {\n      return;\n    }\n    this.#duration = duration;\n    this.#render();\n  }\n\n  /**\n   * This calculates how much of the time range is in the user's view. This is\n   * used to determine how much of the label can fit into the view, and if we\n   * should even show the label.\n   */\n  #visibleOverlayWidth(overlayRect: DOMRect): number {\n    if (!this.#canvasRect) {\n      return 0;\n    }\n\n    const {x: overlayStartX, width} = overlayRect;\n    const overlayEndX = overlayStartX + width;\n\n    const canvasStartX = this.#canvasRect.x;\n    const canvasEndX = this.#canvasRect.x + this.#canvasRect.width;\n\n    const leftVisible = Math.max(canvasStartX, overlayStartX);\n    const rightVisible = Math.min(canvasEndX, overlayEndX);\n    return rightVisible - leftVisible;\n  }\n\n  /**\n   * We use this method after the overlay has been positioned in order to move\n   * the label as required to keep it on screen.\n   * If the label is off to the left or right, we fix it to that corner and\n   * align the text so the label is visible as long as possible.\n   */\n  updateLabelPositioning(): void {\n    if (!this.#rangeContainer) {\n      return;\n    }\n\n    if (!this.#canvasRect || !this.#labelBox) {\n      return;\n    }\n\n    // On the RHS of the panel a scrollbar can be shown which means the canvas\n    // has a 9px gap on the right hand edge. We use this value when calculating\n    // values and label positioning from the left hand side in order to be\n    // consistent on both edges of the UI.\n    const paddingForScrollbar = 9;\n    const overlayRect = this.getBoundingClientRect();\n    const labelFocused = this.#shadow.activeElement === this.#labelBox;\n\n    const labelRect = this.#rangeContainer.getBoundingClientRect();\n    const visibleOverlayWidth = this.#visibleOverlayWidth(overlayRect) - paddingForScrollbar;\n\n    const durationBox = this.#rangeContainer.querySelector<HTMLElement>('.duration') ?? null;\n    const durationBoxLength = durationBox?.getBoundingClientRect().width;\n    if (!durationBoxLength) {\n      return;\n    }\n    const overlayTooNarrow = visibleOverlayWidth <= durationBoxLength;\n    // We do not hide the label if:\n    // 1. it is focused (user is typing into it)\n    // 2. it is empty - this means it's a new label and we need to let the user type into it!\n    // 3. it is too narrow - narrower than the duration length\n    const hideLabel = overlayTooNarrow && !labelFocused && this.#label.length > 0;\n    this.#rangeContainer.classList.toggle('labelHidden', hideLabel);\n\n    if (hideLabel) {\n      // Label is invisible, no need to do all the layout.\n      return;\n    }\n\n    // Check if label is off the LHS of the screen.\n    const labelLeftMarginToCenter = (overlayRect.width - labelRect.width) / 2;\n    const newLabelX = overlayRect.x + labelLeftMarginToCenter;\n\n    const labelOffLeftOfScreen = newLabelX < this.#canvasRect.x;\n    this.#rangeContainer.classList.toggle('offScreenLeft', labelOffLeftOfScreen);\n\n    // Check if label is off the RHS of the screen\n    const rightBound = this.#canvasRect.x + this.#canvasRect.width;\n    // The label's right hand edge is the gap from the left of the range to the\n    // label, and then the width of the label.\n    const labelRightEdge = overlayRect.x + labelLeftMarginToCenter + labelRect.width;\n    const labelOffRightOfScreen = labelRightEdge > rightBound;\n    this.#rangeContainer.classList.toggle('offScreenRight', labelOffRightOfScreen);\n\n    if (labelOffLeftOfScreen) {\n      // If the label is off the left of the screen, we adjust by the\n      // difference between the X that represents the start of the cavnas, and\n      // the X that represents the start of the overlay.\n      // We then take the absolute value of this - because if the canvas starts\n      // at 0, and the overlay is -200px, we have to adjust the label by +200.\n      // Add on 9 pixels to pad from the left; this is the width of the sidebar\n      // on the RHS so we match it so the label is equally padded on either\n      // side.\n      this.#rangeContainer.style.marginLeft = `${Math.abs(this.#canvasRect.x - overlayRect.x) + paddingForScrollbar}px`;\n    } else if (labelOffRightOfScreen) {\n      // If the label is off the right of the screen, we adjust by adding the\n      // right margin equal to the difference between the right edge of the\n      // overlay and the right edge of the canvas.\n      this.#rangeContainer.style.marginRight = `${overlayRect.right - this.#canvasRect.right + paddingForScrollbar}px`;\n    } else {\n      // Keep the label central.\n      this.#rangeContainer.style.margin = '0px';\n    }\n\n    // If the text is empty, set the label editibility to true.\n    // Only allow to remove the focus and save the range as annotation if the label is not empty.\n    if (this.#labelBox?.innerText === '') {\n      this.#setLabelEditability(true);\n    }\n  }\n\n  #focusInputBox(): void {\n    if (!this.#labelBox) {\n      console.error('`labelBox` element is missing.');\n      return;\n    }\n    this.#labelBox.focus();\n  }\n\n  #setLabelEditability(editable: boolean): void {\n    // Always keep focus on the label input field if the label is empty.\n    // TODO: Do not remove a range that is being navigated away from if the label is not empty\n    if (this.#labelBox?.innerText === '') {\n      this.#focusInputBox();\n      return;\n    }\n    this.#isLabelEditable = editable;\n    this.#render();\n    // If the label is editable, focus cursor on it\n    if (editable) {\n      this.#focusInputBox();\n    }\n  }\n\n  #handleLabelInputKeyUp(): void {\n    // If the label changed on key up, dispatch label changed event\n    const labelBoxTextContent = this.#labelBox?.textContent ?? '';\n    if (labelBoxTextContent !== this.#label) {\n      this.#label = labelBoxTextContent;\n      this.dispatchEvent(new TimeRangeLabelChangeEvent(this.#label));\n      this.#labelBox?.setAttribute('aria-label', labelBoxTextContent);\n    }\n  }\n\n  #handleLabelInputKeyDown(event: KeyboardEvent): boolean {\n    // If the new key is `Enter` or `Escape` key, treat it\n    // as the end of the label input and blur the input field.\n    // If the text field is empty when `Enter` or `Escape` are pressed,\n    // dispatch an event to remove the time range.\n    if (event.key === Platform.KeyboardUtilities.ENTER_KEY || event.key === Platform.KeyboardUtilities.ESCAPE_KEY) {\n      // In DevTools, the `Escape` button will by default toggle the console\n      // drawer, which we don't want here, so we need to call\n      // `stopPropagation()`.\n      event.stopPropagation();\n      if (this.#label === '') {\n        this.dispatchEvent(new TimeRangeRemoveEvent());\n      }\n      this.#labelBox?.blur();\n      return false;\n    }\n\n    return true;\n  }\n\n  #render(): void {\n    const durationText = this.#duration ? i18n.TimeUtilities.formatMicroSecondsTime(this.#duration) : '';\n    // clang-format off\n    render(\n        html`\n          <style>${timeRangeOverlayStyles}</style>\n          <span class=\"range-container\" role=\"region\" aria-label=${i18nString(UIStrings.timeRange)}>\n            <span\n             class=\"label-text\"\n             role=\"textbox\"\n             @focusout=${() => this.#setLabelEditability(false)}\n             @dblclick=${() => this.#setLabelEditability(true)}\n             @keydown=${this.#handleLabelInputKeyDown}\n             @keyup=${this.#handleLabelInputKeyUp}\n             contenteditable=${this.#isLabelEditable ? 'plaintext-only' : false}\n             jslog=${VisualLogging.textField('timeline.annotations.time-range-label-input').track({keydown: true, click: true})}\n            ></span>\n            <span class=\"duration\">${durationText}</span>\n          </span>\n          `,\n        this.#shadow, {host: this});\n    // clang-format on\n\n    // Now we have rendered, we need to re-run the code to tweak the margin &\n    // positioning of the label.\n    this.updateLabelPositioning();\n  }\n}\n\ncustomElements.define('devtools-time-range-overlay', TimeRangeOverlay);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'devtools-time-range-overlay': TimeRangeOverlay;\n  }\n}\n", "// Copyright 2025 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n// IMPORTANT: this file is auto generated. Please do not edit this file.\n/* istanbul ignore file */\nexport default `/*\n * Copyright 2024 The Chromium Authors\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n:host {\n  display: flex;\n  overflow: hidden;\n  flex-direction: column;\n  justify-content: flex-end;\n  width: 100%;\n  height: 100%;\n  box-sizing: border-box;\n  padding-bottom: 5px;\n  /* stylelint-disable-next-line plugin/use_theme_colors */\n  background: linear-gradient(\n    180deg,\n    rgb(255 125 210 / 0%) 0%,\n    rgb(255 125 210 / 15%) 85%\n  );\n  border-color: var(--ref-palette-pink55);\n  border-width: 0 1px 5px;\n  border-style: solid;\n  pointer-events: none;\n}\n\n.range-container {\n  display: flex;\n  align-items: center;\n  flex-direction: column;\n  text-align: center;\n  box-sizing: border-box;\n  pointer-events: all;\n  user-select: none;\n  color: var(--sys-color-pink);\n\n  &.labelHidden {\n    /* Have to use this not display: none so it maintains its width */\n    user-select: none;\n    pointer-events: none;\n    visibility: hidden;\n  }\n\n  &.offScreenLeft {\n    align-items: flex-start;\n    text-align: left;\n  }\n\n  &.offScreenRight {\n    align-items: flex-end;\n    text-align: right;\n  }\n}\n\n.label-text {\n  /*\n  * The width priority is min-width > max-width > width\n  * When the range itself is smaller that 70px, expand 100% to fill the whole width.\n  * When the range is wider, only expand the textfield to over 70px\n  * if it's needed to fit the label text.\n  */\n  width: 100%;\n  max-width: 70px;\n  min-width: fit-content;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  word-break: normal;\n  overflow-wrap: anywhere;\n  margin-bottom: 3px;\n  display: -webkit-box;\n  white-space: break-spaces;\n  background: var(--sys-color-cdt-base-container);\n  line-clamp: 2;\n  -webkit-line-clamp: 2;\n  -webkit-box-orient: vertical;\n}\n\n.duration {\n  background: var(--sys-color-cdt-base-container);\n}\n\n.label-text[contenteditable='true'] {\n  outline: none;\n  box-shadow: 0 0 0 1px var(--ref-palette-pink55);\n}\n\n.label-text[contenteditable='false'] {\n  width: auto;\n}\n\n/*# sourceURL=${import.meta.resolve('./timeRangeOverlay.css')} */`;", "// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n/* eslint-disable @devtools/no-lit-render-outside-of-view */\n\nimport * as i18n from '../../../../core/i18n/i18n.js';\nimport type * as Trace from '../../../../models/trace/trace.js';\nimport * as Lit from '../../../../ui/lit/lit.js';\n\nimport timespanBreakdownOverlayStyles from './timespanBreakdownOverlay.css.js';\n\nconst {html} = Lit;\n\nexport class TimespanBreakdownOverlay extends HTMLElement {\n  readonly #shadow = this.attachShadow({mode: 'open'});\n  #canvasRect: DOMRect|null = null;\n  #sections: Trace.Types.Overlays.TimespanBreakdownEntryBreakdown[]|null = null;\n\n  set isBelowEntry(isBelow: boolean) {\n    this.classList.toggle('is-below', isBelow);\n  }\n\n  set canvasRect(rect: DOMRect|null) {\n    if (this.#canvasRect && rect && this.#canvasRect.width === rect.width && this.#canvasRect.height === rect.height) {\n      return;\n    }\n    this.#canvasRect = rect;\n    this.#render();\n  }\n\n  set sections(sections: Trace.Types.Overlays.TimespanBreakdownEntryBreakdown[]|null) {\n    if (sections === this.#sections) {\n      return;\n    }\n    this.#sections = sections;\n    this.#render();\n  }\n\n  /**\n   * We use this method after the overlay has been positioned in order to move\n   * the section label as required to keep it on screen.\n   * If the label is off to the left or right, we fix it to that corner and\n   * align the text so the label is visible as long as possible.\n   */\n  checkSectionLabelPositioning(): void {\n    const sections = this.#shadow.querySelectorAll<HTMLElement>('.timespan-breakdown-overlay-section');\n    if (!sections) {\n      return;\n    }\n\n    if (!this.#canvasRect) {\n      return;\n    }\n\n    // On the RHS of the panel a scrollbar can be shown which means the canvas\n    // has a 9px gap on the right hand edge. We use this value when calculating\n    // values and label positioning from the left hand side in order to be\n    // consistent on both edges of the UI.\n    const paddingForScrollbar = 9;\n\n    // Fetch the rects for each section and label now, rather than in the loop,\n    // to avoid causing a bunch of recalcStyles\n    const sectionLayoutData = new Map<HTMLElement, {sectionRect: DOMRect, labelRect: DOMRect, label: HTMLElement}>();\n    for (const section of sections) {\n      const label = section.querySelector<HTMLElement>('.timespan-breakdown-overlay-label');\n      if (!label) {\n        continue;\n      }\n      const sectionRect = section.getBoundingClientRect();\n      const labelRect = label.getBoundingClientRect();\n      sectionLayoutData.set(section, {sectionRect, labelRect, label});\n    }\n\n    const minSectionWidthToShowAnyLabel = 30;\n\n    // Align the labels for all the breakdown sections.\n    for (const section of sections) {\n      const layoutData = sectionLayoutData.get(section);\n      if (!layoutData) {\n        break;\n      }\n      const {labelRect, sectionRect, label} = layoutData;\n\n      const labelHidden = sectionRect.width < minSectionWidthToShowAnyLabel;\n      // Subtract 5 from the section width to allow a tiny bit of padding.\n      const labelTruncated = sectionRect.width - 5 <= labelRect.width;\n      // We differentiate between hidden + truncated; if it is truncated we\n      // will show the text with ellipsis for overflow, but if the section is\n      // really small we just hide the label entirely.\n      label.classList.toggle('labelHidden', labelHidden);\n      label.classList.toggle('labelTruncated', labelTruncated);\n\n      if (labelHidden || labelTruncated) {\n        // Label is hidden or doesn't fully fit, so we don't need to do the\n        // logic to left/right align if it needs it.\n        continue;\n      }\n\n      // Check if label is off the LHS of the screen.\n      const labelLeftMarginToCenter = (sectionRect.width - labelRect.width) / 2;\n      const newLabelX = sectionRect.x + labelLeftMarginToCenter;\n\n      const labelOffLeftOfScreen = newLabelX < this.#canvasRect.x;\n      label.classList.toggle('offScreenLeft', labelOffLeftOfScreen);\n\n      // Check if label is off the RHS of the screen\n      const rightBound = this.#canvasRect.x + this.#canvasRect.width;\n      // The label's right hand edge is the gap from the left of the range to the\n      // label, and then the width of the label.\n      const labelRightEdge = sectionRect.x + labelLeftMarginToCenter + labelRect.width;\n      const labelOffRightOfScreen = labelRightEdge > rightBound;\n      label.classList.toggle('offScreenRight', labelOffRightOfScreen);\n\n      if (labelOffLeftOfScreen) {\n        // If the label is off the left of the screen, we adjust by the\n        // difference between the X that represents the start of the cavnas, and\n        // the X that represents the start of the overlay.\n        // We then take the absolute value of this - because if the canvas starts\n        // at 0, and the overlay is -200px, we have to adjust the label by +200.\n        // Add on 9 pixels to pad from the left; this is the width of the sidebar\n        // on the RHS so we match it so the label is equally padded on either\n        // side.\n        label.style.marginLeft = `${Math.abs(this.#canvasRect.x - sectionRect.x) + paddingForScrollbar}px`;\n\n      } else if (labelOffRightOfScreen) {\n        // To calculate how far left to push the label, we take the right hand\n        // bound (the canvas width and subtract the label's width).\n        // Finally, we subtract the X position of the overlay (if the overlay is\n        // 200px within the view, we don't need to push the label that 200px too\n        // otherwise it will be off-screen)\n        const leftMargin = rightBound - labelRect.width - sectionRect.x;\n\n        label.style.marginLeft = `${leftMargin}px`;\n\n      } else {\n        // Keep the label central.\n        label.style.marginLeft = `${labelLeftMarginToCenter}px`;\n      }\n    }\n  }\n\n  renderedSections(): HTMLElement[] {\n    return Array.from(this.#shadow.querySelectorAll('.timespan-breakdown-overlay-section'));\n  }\n\n  #renderSection(section: Trace.Types.Overlays.TimespanBreakdownEntryBreakdown): Lit.TemplateResult {\n    // clang-format off\n    return html`\n      <div class=\"timespan-breakdown-overlay-section\">\n        <div class=\"timespan-breakdown-overlay-label\">\n        ${section.showDuration ?\n          html`<span class=\"duration-text\">${i18n.TimeUtilities.formatMicroSecondsAsMillisFixed(section.bounds.range)}</span> ` : Lit.nothing}\n          <span class=\"section-label-text\">${section.label}</span>\n        </div>\n      </div>`;\n    // clang-format on\n  }\n\n  #render(): void {\n    if (this.#sections) {\n      this.classList.toggle('odd-number-of-sections', this.#sections.length % 2 === 1);\n      this.classList.toggle('even-number-of-sections', this.#sections.length % 2 === 0);\n    }\n    Lit.render(\n        html`<style>${timespanBreakdownOverlayStyles}</style>\n             ${this.#sections?.map(this.#renderSection)}`,\n        this.#shadow, {host: this});\n    this.checkSectionLabelPositioning();\n  }\n}\n\ncustomElements.define('devtools-timespan-breakdown-overlay', TimespanBreakdownOverlay);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'devtools-timespan-breakdown-overlay': TimespanBreakdownOverlay;\n  }\n}\n", "// Copyright 2025 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n// IMPORTANT: this file is auto generated. Please do not edit this file.\n/* istanbul ignore file */\nexport default `/*\n * Copyright 2024 The Chromium Authors\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.timespan-breakdown-overlay-section {\n  border: solid;\n  border-color: var(--sys-color-on-surface);\n  border-width: 4px 1px 0;\n  align-content: flex-start;\n  text-align: center;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  background-image: linear-gradient(180deg, var(--sys-color-on-primary), transparent);\n  height: 90%;\n  box-sizing: border-box;\n  padding-top: var(--sys-size-2);\n\n  :host(.is-below) & {\n    border-top-width: 0;\n    border-bottom-width: 4px;\n    align-content: flex-end; /* anchor the text at the bottom */\n    padding-bottom: var(--sys-size-2);\n    padding-top: 0;\n\n    /* re-order so the timestamp is below label */\n    .timespan-breakdown-overlay-label {\n      display: flex;\n      flex-direction: column-reverse;\n    }\n  }\n}\n\n:host {\n  display: flex;\n  overflow: hidden;\n  flex-direction: row;\n  justify-content: flex-end;\n  align-items: flex-end;\n  width: 100%;\n  box-sizing: border-box;\n  height: 100%;\n  max-height: 100px;\n\n  /* Ensure that the first & last sections always have the left/right border */\n  /* (disable stylelint because we need the !important to override border\n   * styles below + keeping them here is clearer to read) */\n  .timespan-breakdown-overlay-section:first-child {\n    border-left-width: 1px !important; /* stylelint-disable-line declaration-no-important */\n  }\n\n  .timespan-breakdown-overlay-section:last-child {\n    border-right-width: 1px !important; /* stylelint-disable-line declaration-no-important */\n  }\n}\n\n:host(.is-below) {\n  align-items: flex-start;\n}\n\n/* Depending on if the number of sections is odd or even, we alternate the\n * heights of the even/odd sections. We do this to ensure that the first item\n * is never a \"high\" item, because that looks a bit clunky. */\n:host(.odd-number-of-sections) {\n  .timespan-breakdown-overlay-section:nth-child(even) {\n    height: 100%;\n  }\n\n  .timespan-breakdown-overlay-section:nth-child(odd) {\n    border-left-width: 0;\n    border-right-width: 0;\n  }\n}\n\n:host(.even-number-of-sections) {\n  .timespan-breakdown-overlay-section:nth-child(odd) {\n    height: 100%;\n  }\n\n  .timespan-breakdown-overlay-section:nth-child(even) {\n    border-left-width: 0;\n    border-right-width: 0;\n  }\n}\n\n.timespan-breakdown-overlay-label {\n  font-family: var(--default-font-family);\n  font-size: var(--sys-typescale-body2-size);\n  line-height: var(--sys-typescale-body4-line-height);\n  font-weight: var(--ref-typeface-weight-medium);\n  color: var(--sys-color-on-surface);\n  text-align: center;\n  box-sizing: border-box;\n  width: max-content;\n  padding: 0 3px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  text-wrap: nowrap;\n\n  .duration-text {\n    font-size: var(--sys-typescale-body4-size);\n    text-overflow: ellipsis;\n    overflow: hidden;\n    text-wrap: nowrap;\n    display: block;\n  }\n\n  .discovery-time-ms {\n    font-weight: var(--ref-typeface-weight-bold);\n  }\n\n  &.labelHidden {\n    /* Have to use this not display: none so it maintains its width */\n    user-select: none;\n    pointer-events: none;\n    visibility: hidden;\n  }\n\n  &.labelTruncated {\n    /* This means the label will show the text that fits with an ellipsis for\n     * the overflow */\n    max-width: 100%;\n  }\n\n  &.offScreenLeft {\n    text-align: left;\n  }\n\n  &.offScreenRight {\n    text-align: right;\n  }\n}\n\n/*# sourceURL=${import.meta.resolve('./timespanBreakdownOverlay.css')} */`;"],
  "mappings": "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",
  "names": ["i18n", "ThemeSupport", "VisualLogging", "html", "Directives", "UIStrings", "str_", "i18nString", "i18n", "Platform", "html", "render", "VisualLogging", "UIStrings", "str_", "i18nString", "render", "html", "i18n", "Lit", "html", "Lit"]
}
