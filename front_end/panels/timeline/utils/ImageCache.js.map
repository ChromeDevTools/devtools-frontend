{"version":3,"file":"ImageCache.js","sourceRoot":"","sources":["../../../../../../../front_end/panels/timeline/utils/ImageCache.ts"],"names":[],"mappings":"AAAA,sCAAsC;AACtC,yEAAyE;AACzE,6BAA6B;AAE7B,OAAO,KAAK,KAAK,MAAM,gCAAgC,CAAC;AAExD,MAAM,UAAU,GACZ,IAAI,OAAO,EAAqG,CAAC;AACrH,MAAM,CAAC,MAAM,OAAO,GAAG,IAAI,WAAW,EAAE,CAAC;AAEzC;;;GAGG;AACH,MAAM,UAAU,UAAU,CAAC,UAC6B;IACtD,IAAI,UAAU,CAAC,GAAG,CAAC,UAAU,CAAC,EAAE,CAAC;QAC/B,OAAO,UAAU,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,IAAI,CAAC;IAC5C,CAAC;IAED,MAAM,GAAG,GAAG,KAAK,CAAC,QAAQ,CAAC,aAAa,CAAC,WAAW,CAAC,sBAAsB,CAAC,UAAU,CAAC,CAAC;IAExF,SAAS,CAAC,GAAG,CAAC;SACT,IAAI,CAAC,WAAW,CAAC,EAAE;QAClB,UAAU,CAAC,GAAG,CAAC,UAAU,EAAE,WAAW,CAAC,CAAC;QACxC,OAAO,CAAC,aAAa,CAAC,IAAI,WAAW,CAAC,mBAAmB,EAAE,EAAC,MAAM,EAAE,EAAC,UAAU,EAAE,KAAK,EAAE,WAAW,EAAC,EAAC,CAAC,CAAC,CAAC;IAC1G,CAAC,CAAC;SACD,KAAK,CAAC,GAAG,EAAE,GAAE,CAAC,CAAC,CAAC;IACrB,OAAO,IAAI,CAAC;AACd,CAAC;AAED,yEAAyE;AACzE,SAAS,SAAS,CAAC,GAAW;IAC5B,OAAO,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE;QAC3B,MAAM,KAAK,GAAG,IAAI,KAAK,EAAE,CAAC;QAC1B,KAAK,CAAC,gBAAgB,CAAC,MAAM,EAAE,GAAG,EAAE,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;QACrD,KAAK,CAAC,gBAAgB,CAAC,OAAO,EAAE,GAAG,EAAE,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC;QACrD,KAAK,CAAC,GAAG,GAAG,GAAG,CAAC;IAClB,CAAC,CAAC,CAAC;AACL,CAAC;AAED,+FAA+F;AAC/F,MAAM,UAAU,OAAO,CAAC,WAA8F;IAEpH,MAAM,QAAQ,GAAG,WAAW,CAAC,GAAG,CAAC,UAAU,CAAC,EAAE;QAC5C,IAAI,UAAU,CAAC,GAAG,CAAC,UAAU,CAAC,EAAE,CAAC;YAC/B,OAAO;QACT,CAAC;QACD,MAAM,GAAG,GAAG,KAAK,CAAC,QAAQ,CAAC,aAAa,CAAC,WAAW,CAAC,sBAAsB,CAAC,UAAU,CAAC,CAAC;QACxF,OAAO,SAAS,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE;YACjC,UAAU,CAAC,GAAG,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;YAClC,OAAO;QACT,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IACH,OAAO,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;AAC/B,CAAC;AAED,MAAM,CAAC,MAAM,eAAe,GAAG,UAAU,CAAC;AAC1C,MAAM,CAAC,MAAM,mBAAmB,GAAG,SAAS,CAAC","sourcesContent":["// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Trace from '../../../models/trace/trace.js';\n\nconst imageCache =\n    new WeakMap<Trace.Types.Events.LegacySyntheticScreenshot|Trace.Types.Events.Screenshot, HTMLImageElement|null>();\nexport const emitter = new EventTarget();\n\n/**\n * Synchronously returns an image, or return `null` while queuing up an async load of that image.\n * If the image load fails, we cache a null to avoid reattempts.\n */\nexport function getOrQueue(screenshot: Trace.Types.Events.LegacySyntheticScreenshot|\n                           Trace.Types.Events.Screenshot): HTMLImageElement|null {\n  if (imageCache.has(screenshot)) {\n    return imageCache.get(screenshot) ?? null;\n  }\n\n  const uri = Trace.Handlers.ModelHandlers.Screenshots.screenshotImageDataUri(screenshot);\n\n  loadImage(uri)\n      .then(imageOrNull => {\n        imageCache.set(screenshot, imageOrNull);\n        emitter.dispatchEvent(new CustomEvent('screenshot-loaded', {detail: {screenshot, image: imageOrNull}}));\n      })\n      .catch(() => {});\n  return null;\n}\n\n/** Load an image (probably data URI). If it fails, resolve with null. */\nfunction loadImage(url: string): Promise<HTMLImageElement|null> {\n  return new Promise(resolve => {\n    const image = new Image();\n    image.addEventListener('load', () => resolve(image));\n    image.addEventListener('error', () => resolve(null));\n    image.src = url;\n  });\n}\n\n/** Populate the cache ahead of use, to allow for getOrQueue to synchronously return images. */\nexport function preload(screenshots: Array<Trace.Types.Events.LegacySyntheticScreenshot|Trace.Types.Events.Screenshot>):\n    Promise<void[]> {\n  const promises = screenshots.map(screenshot => {\n    if (imageCache.has(screenshot)) {\n      return;\n    }\n    const uri = Trace.Handlers.ModelHandlers.Screenshots.screenshotImageDataUri(screenshot);\n    return loadImage(uri).then(image => {\n      imageCache.set(screenshot, image);\n      return;\n    });\n  });\n  return Promise.all(promises);\n}\n\nexport const cacheForTesting = imageCache;\nexport const loadImageForTesting = loadImage;\n"]}