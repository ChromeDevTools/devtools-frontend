{"version":3,"file":"TraceBounds.js","sourceRoot":"","sources":["../../../../../../front_end/services/trace_bounds/TraceBounds.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Trace from '../../models/trace/trace.js';\n\nlet instance: BoundsManager|null = null;\n\nexport class StateChangedEvent extends Event {\n  static readonly eventName = 'traceboundsstatechanged';\n  constructor(\n      public state: Readonly<State>,\n      public updateType: 'RESET'|'MINIMAP_BOUNDS'|'VISIBLE_WINDOW',\n      public options: {\n        shouldAnimate?: boolean,\n      } = {shouldAnimate: false},\n  ) {\n    super(StateChangedEvent.eventName, {composed: true, bubbles: true});\n  }\n}\n\n/**\n * Exposed as a shortcut to BoundsManager.instance().addEventListener, which\n * also takes care of type-casting the event to StateChangedEvent.\n **/\nexport function onChange(cb: (event: StateChangedEvent) => void): void {\n  BoundsManager.instance().addEventListener(\n      StateChangedEvent.eventName,\n      // Cast the callback as TS doesn't know that these events will emit\n      // StateChangedEvent types.\n      cb as (event: Event) => void);\n}\n\nexport function removeListener(cb: (event: StateChangedEvent) => void): void {\n  BoundsManager.instance().removeEventListener(StateChangedEvent.eventName, cb as (event: Event) => void);\n}\n\nexport interface State {\n  readonly micro: Readonly<TraceWindows<Trace.Types.Timing.Micro>>;\n  readonly milli: Readonly<TraceWindows<Trace.Types.Timing.Milli>>;\n}\n\nexport interface TraceWindows<TimeFormat extends Trace.Types.Timing.Micro|Trace.Types.Timing.Milli> {\n  /**\n   * This is the bounds of the entire trace. Once a trace is imported/recorded\n   * and this is set, it cannot be changed.\n   */\n  readonly entireTraceBounds: Trace.Types.Timing.TraceWindow<TimeFormat>;\n  /**\n   * This is the bounds of the minimap and represents the left and right bound\n   * being shown by the minimap. It can be changed by a user action: for\n   * example, when a user creates a breadcrumb, that breadcrumb becomes the\n   * minimap trace bounds. By default, and when a trace is first loaded, the\n   * minimapTraceBounds are equivalent to the entireTraceBounds.\n   * Note that this is NOT the active time window that the user has dragged\n   * the minimap handles to; this is the min/max being shown by the minimap.\n   */\n  minimapTraceBounds: Trace.Types.Timing.TraceWindow<TimeFormat>;\n  /**\n   * This represents the trace window that is being shown on the main timeline.\n   * The reason this is called a \"Window\" rather than \"Bounds\" is because the\n   * user is not bound by this value - they can use their mouse to pan/zoom\n   * in/out beyond the limits of this window (the limit is the\n   * minimapTraceBounds). Another way to think of this value is that the\n   * min/max of this value is what is represented by the two drag handles on\n   * the TimelineMiniMap that the user can drag to change their current window.\n   */\n  timelineTraceWindow: Trace.Types.Timing.TraceWindow<TimeFormat>;\n}\n\nexport class BoundsManager extends EventTarget {\n  static instance(opts: {\n    forceNew: boolean|null,\n  } = {forceNew: null}): BoundsManager {\n    const forceNew = Boolean(opts.forceNew);\n    if (!instance || forceNew) {\n      instance = new BoundsManager();\n    }\n    return instance;\n  }\n\n  static removeInstance(): void {\n    instance = null;\n  }\n\n  #currentState: TraceWindows<Trace.Types.Timing.Micro>|null = null;\n\n  private constructor() {\n    // Defined to enable us to mark it as Private.\n    super();\n  }\n\n  resetWithNewBounds(initialBounds: Trace.Types.Timing.TraceWindowMicro): this {\n    this.#currentState = {\n      entireTraceBounds: initialBounds,\n      minimapTraceBounds: initialBounds,\n      timelineTraceWindow: initialBounds,\n    };\n    this.dispatchEvent(new StateChangedEvent(this.state() as State, 'RESET'));\n    return this;\n  }\n\n  state(): Readonly<State>|null {\n    if (this.#currentState === null) {\n      return null;\n    }\n    const entireBoundsMilli = Trace.Helpers.Timing.traceWindowMilliSeconds(this.#currentState.entireTraceBounds);\n    const minimapBoundsMilli = Trace.Helpers.Timing.traceWindowMilliSeconds(this.#currentState.minimapTraceBounds);\n    const timelineTraceWindowMilli =\n        Trace.Helpers.Timing.traceWindowMilliSeconds(this.#currentState.timelineTraceWindow);\n\n    return {\n      micro: this.#currentState,\n      milli: {\n        entireTraceBounds: entireBoundsMilli,\n        minimapTraceBounds: minimapBoundsMilli,\n        timelineTraceWindow: timelineTraceWindowMilli,\n      },\n    };\n  }\n\n  setMiniMapBounds(newBounds: Trace.Types.Timing.TraceWindowMicro): void {\n    if (!this.#currentState) {\n      // If we don't have the existing state and know the trace bounds, we\n      // cannot set the minimap bounds.\n      console.error('TraceBounds.setMiniMapBounds could not set bounds because there is no existing trace window set.');\n      return;\n    }\n    const existingBounds = this.#currentState.minimapTraceBounds;\n    if (newBounds.min === existingBounds.min && newBounds.max === existingBounds.max) {\n      // New bounds are identical to the old ones so no action required.\n      return;\n    }\n\n    if (newBounds.range < 1_000) {\n      // Minimum minimap bounds range is 1 millisecond.\n      return;\n    }\n\n    this.#currentState.minimapTraceBounds = newBounds;\n    // this.state() cannot be null here.\n    this.dispatchEvent(new StateChangedEvent(this.state() as State, 'MINIMAP_BOUNDS'));\n  }\n\n  /**\n   * Updates the visible part of the trace that the user can see.\n   * @param options.ignoreMiniMapBounds by default the visible window will be\n   * bound by the minimap bounds. If you set this to `true` then the timeline\n   * visible window will not be constrained by the minimap bounds. Be careful\n   * with this! Unless you deal with this situation, the UI of the performance\n   * panel will break.\n   */\n  setTimelineVisibleWindow(newWindow: Trace.Types.Timing.TraceWindowMicro, options: {\n    shouldAnimate?: boolean,\n    ignoreMiniMapBounds?: boolean,\n  } = {\n    shouldAnimate: false,\n    ignoreMiniMapBounds: false,\n  }): void {\n    if (!this.#currentState) {\n      // This is a weird state to be in: we can't change the visible timeline\n      // window if we don't already have an existing state with the trace\n      // bounds set.\n      console.error(\n          'TraceBounds.setTimelineVisibleWindow could not set bounds because there is no existing trace window set.');\n      return;\n    }\n    const existingWindow = this.#currentState.timelineTraceWindow;\n    if (newWindow.range < 1_000) {\n      // Minimum timeline visible window range is 1 millisecond.\n      return;\n    }\n\n    if (newWindow.min === existingWindow.min && newWindow.max === existingWindow.max) {\n      // New bounds are identical to the old ones so no action required.\n      return;\n    }\n\n    if (!options.ignoreMiniMapBounds) {\n      // Ensure that the setTimelineVisibleWindow can never go outside the bounds of the minimap bounds.\n      newWindow.min = Trace.Types.Timing.Micro(Math.max(this.#currentState.minimapTraceBounds.min, newWindow.min));\n      newWindow.max = Trace.Types.Timing.Micro(Math.min(this.#currentState.minimapTraceBounds.max, newWindow.max));\n    }\n\n    if (newWindow.min === existingWindow.min && newWindow.max === existingWindow.max) {\n      // If, after we adjust for the minimap bounds, the new window matches the\n      // old one, we can exit as no action is required.\n      return;\n    }\n\n    this.#currentState.timelineTraceWindow = newWindow;\n    this.dispatchEvent(\n        new StateChangedEvent(this.state() as State, 'VISIBLE_WINDOW', {shouldAnimate: options.shouldAnimate}));\n  }\n}\n"]}