{
  "version": 3,
  "sources": ["../../../../../../front_end/services/trace_bounds/TraceBounds.ts"],
  "sourcesContent": ["// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Trace from '../../models/trace/trace.js';\n\nlet instance: BoundsManager|null = null;\n\nexport class StateChangedEvent extends Event {\n  static readonly eventName = 'traceboundsstatechanged';\n  constructor(\n      public state: Readonly<State>,\n      public updateType: 'RESET'|'MINIMAP_BOUNDS'|'VISIBLE_WINDOW',\n      public options: {\n        shouldAnimate?: boolean,\n      } = {shouldAnimate: false},\n  ) {\n    super(StateChangedEvent.eventName, {composed: true, bubbles: true});\n  }\n}\n\n/**\n * Exposed as a shortcut to BoundsManager.instance().addEventListener, which\n * also takes care of type-casting the event to StateChangedEvent.\n **/\nexport function onChange(cb: (event: StateChangedEvent) => void): void {\n  BoundsManager.instance().addEventListener(\n      StateChangedEvent.eventName,\n      // Cast the callback as TS doesn't know that these events will emit\n      // StateChangedEvent types.\n      cb as (event: Event) => void);\n}\n\nexport function removeListener(cb: (event: StateChangedEvent) => void): void {\n  BoundsManager.instance().removeEventListener(StateChangedEvent.eventName, cb as (event: Event) => void);\n}\n\nexport interface State {\n  readonly micro: Readonly<TraceWindows<Trace.Types.Timing.Micro>>;\n  readonly milli: Readonly<TraceWindows<Trace.Types.Timing.Milli>>;\n}\n\nexport interface TraceWindows<TimeFormat extends Trace.Types.Timing.Micro|Trace.Types.Timing.Milli> {\n  /**\n   * This is the bounds of the entire trace. Once a trace is imported/recorded\n   * and this is set, it cannot be changed.\n   */\n  readonly entireTraceBounds: Trace.Types.Timing.TraceWindow<TimeFormat>;\n  /**\n   * This is the bounds of the minimap and represents the left and right bound\n   * being shown by the minimap. It can be changed by a user action: for\n   * example, when a user creates a breadcrumb, that breadcrumb becomes the\n   * minimap trace bounds. By default, and when a trace is first loaded, the\n   * minimapTraceBounds are equivalent to the entireTraceBounds.\n   * Note that this is NOT the active time window that the user has dragged\n   * the minimap handles to; this is the min/max being shown by the minimap.\n   */\n  minimapTraceBounds: Trace.Types.Timing.TraceWindow<TimeFormat>;\n  /**\n   * This represents the trace window that is being shown on the main timeline.\n   * The reason this is called a \"Window\" rather than \"Bounds\" is because the\n   * user is not bound by this value - they can use their mouse to pan/zoom\n   * in/out beyond the limits of this window (the limit is the\n   * minimapTraceBounds). Another way to think of this value is that the\n   * min/max of this value is what is represented by the two drag handles on\n   * the TimelineMiniMap that the user can drag to change their current window.\n   */\n  timelineTraceWindow: Trace.Types.Timing.TraceWindow<TimeFormat>;\n}\n\nexport class BoundsManager extends EventTarget {\n  static instance(opts: {\n    forceNew: boolean|null,\n  } = {forceNew: null}): BoundsManager {\n    const forceNew = Boolean(opts.forceNew);\n    if (!instance || forceNew) {\n      instance = new BoundsManager();\n    }\n    return instance;\n  }\n\n  static removeInstance(): void {\n    instance = null;\n  }\n\n  #currentState: TraceWindows<Trace.Types.Timing.Micro>|null = null;\n\n  private constructor() {\n    // Defined to enable us to mark it as Private.\n    super();\n  }\n\n  resetWithNewBounds(initialBounds: Trace.Types.Timing.TraceWindowMicro): this {\n    this.#currentState = {\n      entireTraceBounds: initialBounds,\n      minimapTraceBounds: initialBounds,\n      timelineTraceWindow: initialBounds,\n    };\n    this.dispatchEvent(new StateChangedEvent(this.state() as State, 'RESET'));\n    return this;\n  }\n\n  state(): Readonly<State>|null {\n    if (this.#currentState === null) {\n      return null;\n    }\n    const entireBoundsMilli = Trace.Helpers.Timing.traceWindowMilliSeconds(this.#currentState.entireTraceBounds);\n    const minimapBoundsMilli = Trace.Helpers.Timing.traceWindowMilliSeconds(this.#currentState.minimapTraceBounds);\n    const timelineTraceWindowMilli =\n        Trace.Helpers.Timing.traceWindowMilliSeconds(this.#currentState.timelineTraceWindow);\n\n    return {\n      micro: this.#currentState,\n      milli: {\n        entireTraceBounds: entireBoundsMilli,\n        minimapTraceBounds: minimapBoundsMilli,\n        timelineTraceWindow: timelineTraceWindowMilli,\n      },\n    };\n  }\n\n  setMiniMapBounds(newBounds: Trace.Types.Timing.TraceWindowMicro): void {\n    if (!this.#currentState) {\n      // If we don't have the existing state and know the trace bounds, we\n      // cannot set the minimap bounds.\n      console.error('TraceBounds.setMiniMapBounds could not set bounds because there is no existing trace window set.');\n      return;\n    }\n    const existingBounds = this.#currentState.minimapTraceBounds;\n    if (newBounds.min === existingBounds.min && newBounds.max === existingBounds.max) {\n      // New bounds are identical to the old ones so no action required.\n      return;\n    }\n\n    if (newBounds.range < 1_000) {\n      // Minimum minimap bounds range is 1 millisecond.\n      return;\n    }\n\n    this.#currentState.minimapTraceBounds = newBounds;\n    // this.state() cannot be null here.\n    this.dispatchEvent(new StateChangedEvent(this.state() as State, 'MINIMAP_BOUNDS'));\n  }\n\n  /**\n   * Updates the visible part of the trace that the user can see.\n   * @param options.ignoreMiniMapBounds by default the visible window will be\n   * bound by the minimap bounds. If you set this to `true` then the timeline\n   * visible window will not be constrained by the minimap bounds. Be careful\n   * with this! Unless you deal with this situation, the UI of the performance\n   * panel will break.\n   */\n  setTimelineVisibleWindow(newWindow: Trace.Types.Timing.TraceWindowMicro, options: {\n    shouldAnimate?: boolean,\n    ignoreMiniMapBounds?: boolean,\n  } = {\n    shouldAnimate: false,\n    ignoreMiniMapBounds: false,\n  }): void {\n    if (!this.#currentState) {\n      // This is a weird state to be in: we can't change the visible timeline\n      // window if we don't already have an existing state with the trace\n      // bounds set.\n      console.error(\n          'TraceBounds.setTimelineVisibleWindow could not set bounds because there is no existing trace window set.');\n      return;\n    }\n    const existingWindow = this.#currentState.timelineTraceWindow;\n    if (newWindow.range < 1_000) {\n      // Minimum timeline visible window range is 1 millisecond.\n      return;\n    }\n\n    if (newWindow.min === existingWindow.min && newWindow.max === existingWindow.max) {\n      // New bounds are identical to the old ones so no action required.\n      return;\n    }\n\n    if (!options.ignoreMiniMapBounds) {\n      // Ensure that the setTimelineVisibleWindow can never go outside the bounds of the minimap bounds.\n      newWindow.min = Trace.Types.Timing.Micro(Math.max(this.#currentState.minimapTraceBounds.min, newWindow.min));\n      newWindow.max = Trace.Types.Timing.Micro(Math.min(this.#currentState.minimapTraceBounds.max, newWindow.max));\n    }\n\n    if (newWindow.min === existingWindow.min && newWindow.max === existingWindow.max) {\n      // If, after we adjust for the minimap bounds, the new window matches the\n      // old one, we can exit as no action is required.\n      return;\n    }\n\n    this.#currentState.timelineTraceWindow = newWindow;\n    this.dispatchEvent(\n        new StateChangedEvent(this.state() as State, 'VISIBLE_WINDOW', {shouldAnimate: options.shouldAnimate}));\n  }\n}\n"],
  "mappings": ";;;;;;;AAAA;;;;;;;AAIA,YAAY,WAAW;AAEvB,IAAI,WAA+B;AAE7B,IAAO,oBAAP,MAAO,2BAA0B,MAAK;EAG/B;EACA;EACA;EAJX,OAAgB,YAAY;EAC5B,YACW,OACA,YACA,UAEH,EAAC,eAAe,MAAK,GAAC;AAE5B,UAAM,mBAAkB,WAAW,EAAC,UAAU,MAAM,SAAS,KAAI,CAAC;AANzD,SAAA,QAAA;AACA,SAAA,aAAA;AACA,SAAA,UAAA;EAKX;;AAOI,SAAU,SAAS,IAAsC;AAC7D,gBAAc,SAAQ,EAAG;IACrB,kBAAkB;;;IAGlB;EAA4B;AAClC;AAEM,SAAU,eAAe,IAAsC;AACnE,gBAAc,SAAQ,EAAG,oBAAoB,kBAAkB,WAAW,EAA4B;AACxG;AAmCM,IAAO,gBAAP,MAAO,uBAAsB,YAAW;EAC5C,OAAO,SAAS,OAEZ,EAAC,UAAU,KAAI,GAAC;AAClB,UAAM,WAAW,QAAQ,KAAK,QAAQ;AACtC,QAAI,CAAC,YAAY,UAAU;AACzB,iBAAW,IAAI,eAAa;IAC9B;AACA,WAAO;EACT;EAEA,OAAO,iBAAc;AACnB,eAAW;EACb;EAEA,gBAA6D;EAE7D,cAAA;AAEE,UAAK;EACP;EAEA,mBAAmB,eAAkD;AACnE,SAAK,gBAAgB;MACnB,mBAAmB;MACnB,oBAAoB;MACpB,qBAAqB;;AAEvB,SAAK,cAAc,IAAI,kBAAkB,KAAK,MAAK,GAAa,OAAO,CAAC;AACxE,WAAO;EACT;EAEA,QAAK;AACH,QAAI,KAAK,kBAAkB,MAAM;AAC/B,aAAO;IACT;AACA,UAAM,oBAA0B,cAAQ,OAAO,wBAAwB,KAAK,cAAc,iBAAiB;AAC3G,UAAM,qBAA2B,cAAQ,OAAO,wBAAwB,KAAK,cAAc,kBAAkB;AAC7G,UAAM,2BACI,cAAQ,OAAO,wBAAwB,KAAK,cAAc,mBAAmB;AAEvF,WAAO;MACL,OAAO,KAAK;MACZ,OAAO;QACL,mBAAmB;QACnB,oBAAoB;QACpB,qBAAqB;;;EAG3B;EAEA,iBAAiB,WAA8C;AAC7D,QAAI,CAAC,KAAK,eAAe;AAGvB,cAAQ,MAAM,kGAAkG;AAChH;IACF;AACA,UAAM,iBAAiB,KAAK,cAAc;AAC1C,QAAI,UAAU,QAAQ,eAAe,OAAO,UAAU,QAAQ,eAAe,KAAK;AAEhF;IACF;AAEA,QAAI,UAAU,QAAQ,KAAO;AAE3B;IACF;AAEA,SAAK,cAAc,qBAAqB;AAExC,SAAK,cAAc,IAAI,kBAAkB,KAAK,MAAK,GAAa,gBAAgB,CAAC;EACnF;;;;;;;;;EAUA,yBAAyB,WAAgD,UAGrE;IACF,eAAe;IACf,qBAAqB;KACtB;AACC,QAAI,CAAC,KAAK,eAAe;AAIvB,cAAQ,MACJ,0GAA0G;AAC9G;IACF;AACA,UAAM,iBAAiB,KAAK,cAAc;AAC1C,QAAI,UAAU,QAAQ,KAAO;AAE3B;IACF;AAEA,QAAI,UAAU,QAAQ,eAAe,OAAO,UAAU,QAAQ,eAAe,KAAK;AAEhF;IACF;AAEA,QAAI,CAAC,QAAQ,qBAAqB;AAEhC,gBAAU,MAAY,YAAM,OAAO,MAAM,KAAK,IAAI,KAAK,cAAc,mBAAmB,KAAK,UAAU,GAAG,CAAC;AAC3G,gBAAU,MAAY,YAAM,OAAO,MAAM,KAAK,IAAI,KAAK,cAAc,mBAAmB,KAAK,UAAU,GAAG,CAAC;IAC7G;AAEA,QAAI,UAAU,QAAQ,eAAe,OAAO,UAAU,QAAQ,eAAe,KAAK;AAGhF;IACF;AAEA,SAAK,cAAc,sBAAsB;AACzC,SAAK,cACD,IAAI,kBAAkB,KAAK,MAAK,GAAa,kBAAkB,EAAC,eAAe,QAAQ,cAAa,CAAC,CAAC;EAC5G;;",
  "names": []
}
