{"version":3,"file":"TracingManager.js","sourceRoot":"","sources":["../../../../../../front_end/services/tracing/TracingManager.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2014 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as SDK from '../../core/sdk/sdk.js';\nimport type * as ProtocolProxyApi from '../../generated/protocol-proxy-api.js';\nimport * as Protocol from '../../generated/protocol.js';\nimport type * as Trace from '../../models/trace/trace.js';\n\nexport class TracingManager extends SDK.SDKModel.SDKModel<void> {\n  readonly #tracingAgent: ProtocolProxyApi.TracingApi;\n  #activeClient: TracingManagerClient|null;\n  #eventsRetrieved: number;\n  #finishing?: boolean;\n  constructor(target: SDK.Target.Target) {\n    super(target);\n    this.#tracingAgent = target.tracingAgent();\n    target.registerTracingDispatcher(new TracingDispatcher(this));\n\n    this.#activeClient = null;\n    this.#eventsRetrieved = 0;\n  }\n\n  bufferUsage(usage?: number, percentFull?: number): void {\n    if (this.#activeClient) {\n      this.#activeClient.tracingBufferUsage(usage || percentFull || 0);\n    }\n  }\n\n  eventsCollected(events: Trace.Types.Events.Event[]): void {\n    if (!this.#activeClient) {\n      return;\n    }\n    this.#activeClient.traceEventsCollected(events);\n    this.#eventsRetrieved += events.length;\n\n    // CDP no longer provides an approximate_event_count AKA eventCount. It's always 0.\n    // To give some idea of progress we'll compare to a large (900k event) trace.\n    // And we'll clamp both sides so the user sees some progress, and never maxed at 99%\n    const progress = Math.min((this.#eventsRetrieved / 900_000) + 0.15, 0.90);\n    this.#activeClient.eventsRetrievalProgress(progress);\n  }\n\n  tracingComplete(): void {\n    this.#eventsRetrieved = 0;\n    if (this.#activeClient) {\n      this.#activeClient.tracingComplete();\n      this.#activeClient = null;\n    }\n    this.#finishing = false;\n  }\n\n  async reset(): Promise<void> {\n    // If we have an active client, we should try to stop\n    // it before resetting it, else we will leave the\n    // backend in a broken state where it thinks we are in\n    // the middle of tracing, but we think we are not.\n    // Then, any subsequent attempts to record will fail\n    // because the backend will not let us start a second\n    // tracing session.\n    if (this.#activeClient) {\n      await this.#tracingAgent.invoke_end();\n    }\n    this.#eventsRetrieved = 0;\n    this.#activeClient = null;\n    this.#finishing = false;\n  }\n\n  async start(client: TracingManagerClient, categoryFilter: string): Promise<Protocol.ProtocolResponseWithError> {\n    if (this.#activeClient) {\n      throw new Error('Tracing is already started');\n    }\n    const bufferUsageReportingIntervalMs = 500;\n    this.#activeClient = client;\n    const args = {\n      bufferUsageReportingInterval: bufferUsageReportingIntervalMs,\n      transferMode: Protocol.Tracing.StartRequestTransferMode.ReportEvents,\n      traceConfig: {\n        recordMode: Protocol.Tracing.TraceConfigRecordMode.RecordUntilFull,\n        traceBufferSizeInKb: 1200 * 1000,\n        includedCategories: categoryFilter.split(','),\n      },\n    };\n    const response = await this.#tracingAgent.invoke_start(args);\n    if (response.getError()) {\n      this.#activeClient = null;\n    }\n    return response;\n  }\n\n  stop(): void {\n    if (!this.#activeClient) {\n      throw new Error('Tracing is not started');\n    }\n    if (this.#finishing) {\n      throw new Error('Tracing is already being stopped');\n    }\n    this.#finishing = true;\n    void this.#tracingAgent.invoke_end();\n  }\n}\n\nexport interface TracingManagerClient {\n  traceEventsCollected(events: Trace.Types.Events.Event[]): void;\n\n  tracingComplete(): void;\n  tracingBufferUsage(usage: number): void;\n  eventsRetrievalProgress(progress: number): void;\n}\n\nclass TracingDispatcher implements ProtocolProxyApi.TracingDispatcher {\n  readonly #tracingManager: TracingManager;\n  constructor(tracingManager: TracingManager) {\n    this.#tracingManager = tracingManager;\n  }\n\n  // `eventCount` will always be 0 as perfetto no longer calculates `approximate_event_count`\n  bufferUsage({value, percentFull}: Protocol.Tracing.BufferUsageEvent): void {\n    this.#tracingManager.bufferUsage(value, percentFull);\n  }\n\n  dataCollected({value}: Protocol.Tracing.DataCollectedEvent): void {\n    this.#tracingManager.eventsCollected(value);\n  }\n\n  tracingComplete(): void {\n    this.#tracingManager.tracingComplete();\n  }\n}\n\nSDK.SDKModel.SDKModel.register(TracingManager, {capabilities: SDK.Target.Capability.TRACING, autostart: false});\n"]}