{
  "version": 3,
  "sources": ["../../../../../../front_end/services/tracing/FreshRecording.ts", "../../../../../../front_end/services/tracing/PerformanceTracing.ts", "../../../../../../front_end/services/tracing/TracingManager.ts"],
  "sourcesContent": ["// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport type * as Trace from '../../models/trace/trace.js';\n\nlet instance: Tracker|null = null;\n\n/**\n * In multiple places we need to know if the trace we are working on is fresh\n * or not. We cannot store that data in the trace file's metadata (otherwise a\n * loaded trace file could claim to be fresh), so we store it here. When a new trace\n * is loaded, we set this flag accordingly.\n **/\nexport class Tracker {\n  #freshRecordings = new WeakSet<Trace.TraceModel.ParsedTrace>();\n\n  static instance(opts: {forceNew: boolean} = {forceNew: false}): Tracker {\n    if (!instance || opts.forceNew) {\n      instance = new Tracker();\n    }\n    return instance;\n  }\n\n  registerFreshRecording(data: Trace.TraceModel.ParsedTrace): void {\n    this.#freshRecordings.add(data);\n  }\n\n  recordingIsFresh(data: Trace.TraceModel.ParsedTrace): boolean {\n    return this.#freshRecordings.has(data);\n  }\n\n  recordingIsFreshOrEnhanced(data: Trace.TraceModel.ParsedTrace): boolean {\n    return this.#freshRecordings.has(data) || data.metadata.enhancedTraceVersion !== undefined;\n  }\n}\n", "// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as SDK from '../../core/sdk/sdk.js';\n\nimport {TracingManager, type TracingManagerClient} from './TracingManager.js';\n\nexport class PerformanceTracing implements TracingManagerClient {\n  readonly #traceEvents: Object[] = [];\n  #tracingManager: TracingManager|null = null;\n  #delegate: Delegate;\n\n  constructor(target: SDK.Target.Target, delegate: Delegate) {\n    this.#tracingManager = target.model(TracingManager);\n    this.#delegate = delegate;\n  }\n\n  async start(): Promise<void> {\n    this.#traceEvents.length = 0;\n\n    if (!this.#tracingManager) {\n      throw new Error('No tracing manager');\n    }\n\n    // This panel may be opened with trace data recorded in other tools.\n    // Keep in sync with the categories arrays in:\n    // https://source.chromium.org/chromium/chromium/src/+/main:third_party/devtools-frontend/src/front_end/panels/timeline/TimelineController.ts\n    // https://github.com/GoogleChrome/lighthouse/blob/master/lighthouse-core/gather/gatherers/trace.js\n    const categories = [\n      '-*',\n      'blink.console',\n      'blink.user_timing',\n      'devtools.timeline',\n      'disabled-by-default-devtools.screenshot',\n      'disabled-by-default-devtools.timeline',\n      'disabled-by-default-devtools.timeline.invalidationTracking',\n      'disabled-by-default-devtools.timeline.frame',\n      'disabled-by-default-devtools.timeline.stack',\n      'disabled-by-default-v8.cpu_profiler',\n      'disabled-by-default-v8.cpu_profiler.hires',\n      'latencyInfo',\n      'loading',\n      'disabled-by-default-lighthouse',\n      'v8.execute',\n      'v8',\n    ].join(',');\n\n    const started = await this.#tracingManager.start(this, categories);\n\n    if (!started) {\n      throw new Error('Unable to start tracing.');\n    }\n  }\n\n  async stop(): Promise<void> {\n    return this.#tracingManager?.stop();\n  }\n\n  // Start of implementation of SDK.TracingManager.TracingManagerClient\n  traceEventsCollected(events: Object[]): void {\n    this.#traceEvents.push(...events);\n  }\n\n  tracingBufferUsage(usage: number): void {\n    this.#delegate.tracingBufferUsage(usage);\n  }\n\n  eventsRetrievalProgress(progress: number): void {\n    this.#delegate.eventsRetrievalProgress(progress);\n  }\n\n  tracingComplete(): void {\n    this.#delegate.tracingComplete(this.#traceEvents);\n  }\n  // End of implementation of SDK.TracingManager.TracingManagerClient\n}\n\ninterface Delegate {\n  tracingBufferUsage(usage: number): void;\n  eventsRetrievalProgress(progress: number): void;\n  tracingComplete(events: Object[]): void;\n}\n\n/** Used by an implementation of Common.Revealer to transfer data from the recorder to the performance panel. **/\nexport class RawTraceEvents {\n  constructor(private events: Object[]) {\n  }\n\n  getEvents(): Object[] {\n    return this.events;\n  }\n}\n", "// Copyright 2014 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as SDK from '../../core/sdk/sdk.js';\nimport type * as ProtocolProxyApi from '../../generated/protocol-proxy-api.js';\nimport * as Protocol from '../../generated/protocol.js';\nimport type * as Trace from '../../models/trace/trace.js';\n\nexport class TracingManager extends SDK.SDKModel.SDKModel<void> {\n  readonly #tracingAgent: ProtocolProxyApi.TracingApi;\n  #activeClient: TracingManagerClient|null;\n  #eventsRetrieved: number;\n  #finishing?: boolean;\n  constructor(target: SDK.Target.Target) {\n    super(target);\n    this.#tracingAgent = target.tracingAgent();\n    target.registerTracingDispatcher(new TracingDispatcher(this));\n\n    this.#activeClient = null;\n    this.#eventsRetrieved = 0;\n  }\n\n  bufferUsage(usage?: number, percentFull?: number): void {\n    if (this.#activeClient) {\n      this.#activeClient.tracingBufferUsage(usage || percentFull || 0);\n    }\n  }\n\n  eventsCollected(events: Trace.Types.Events.Event[]): void {\n    if (!this.#activeClient) {\n      return;\n    }\n    this.#activeClient.traceEventsCollected(events);\n    this.#eventsRetrieved += events.length;\n\n    // CDP no longer provides an approximate_event_count AKA eventCount. It's always 0.\n    // To give some idea of progress we'll compare to a large (900k event) trace.\n    // And we'll clamp both sides so the user sees some progress, and never maxed at 99%\n    const progress = Math.min((this.#eventsRetrieved / 900_000) + 0.15, 0.90);\n    this.#activeClient.eventsRetrievalProgress(progress);\n  }\n\n  tracingComplete(): void {\n    this.#eventsRetrieved = 0;\n    if (this.#activeClient) {\n      this.#activeClient.tracingComplete();\n      this.#activeClient = null;\n    }\n    this.#finishing = false;\n  }\n\n  async reset(): Promise<void> {\n    // If we have an active client, we should try to stop\n    // it before resetting it, else we will leave the\n    // backend in a broken state where it thinks we are in\n    // the middle of tracing, but we think we are not.\n    // Then, any subsequent attempts to record will fail\n    // because the backend will not let us start a second\n    // tracing session.\n    if (this.#activeClient) {\n      await this.#tracingAgent.invoke_end();\n    }\n    this.#eventsRetrieved = 0;\n    this.#activeClient = null;\n    this.#finishing = false;\n  }\n\n  async start(client: TracingManagerClient, categoryFilter: string): Promise<Protocol.ProtocolResponseWithError> {\n    if (this.#activeClient) {\n      throw new Error('Tracing is already started');\n    }\n    const bufferUsageReportingIntervalMs = 500;\n    this.#activeClient = client;\n    const args = {\n      bufferUsageReportingInterval: bufferUsageReportingIntervalMs,\n      transferMode: Protocol.Tracing.StartRequestTransferMode.ReportEvents,\n      traceConfig: {\n        recordMode: Protocol.Tracing.TraceConfigRecordMode.RecordUntilFull,\n        traceBufferSizeInKb: 1200 * 1000,\n        includedCategories: categoryFilter.split(','),\n      },\n    };\n    const response = await this.#tracingAgent.invoke_start(args);\n    if (response.getError()) {\n      this.#activeClient = null;\n    }\n    return response;\n  }\n\n  stop(): void {\n    if (!this.#activeClient) {\n      throw new Error('Tracing is not started');\n    }\n    if (this.#finishing) {\n      throw new Error('Tracing is already being stopped');\n    }\n    this.#finishing = true;\n    void this.#tracingAgent.invoke_end();\n  }\n}\n\nexport interface TracingManagerClient {\n  traceEventsCollected(events: Trace.Types.Events.Event[]): void;\n\n  tracingComplete(): void;\n  tracingBufferUsage(usage: number): void;\n  eventsRetrievalProgress(progress: number): void;\n}\n\nclass TracingDispatcher implements ProtocolProxyApi.TracingDispatcher {\n  readonly #tracingManager: TracingManager;\n  constructor(tracingManager: TracingManager) {\n    this.#tracingManager = tracingManager;\n  }\n\n  // `eventCount` will always be 0 as perfetto no longer calculates `approximate_event_count`\n  bufferUsage({value, percentFull}: Protocol.Tracing.BufferUsageEvent): void {\n    this.#tracingManager.bufferUsage(value, percentFull);\n  }\n\n  dataCollected({value}: Protocol.Tracing.DataCollectedEvent): void {\n    this.#tracingManager.eventsCollected(value);\n  }\n\n  tracingComplete(): void {\n    this.#tracingManager.tracingComplete();\n  }\n}\n\nSDK.SDKModel.SDKModel.register(TracingManager, {capabilities: SDK.Target.Capability.TRACING, autostart: false});\n"],
  "mappings": "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",
  "names": []
}
