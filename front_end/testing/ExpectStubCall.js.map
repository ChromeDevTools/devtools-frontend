{"version":3,"file":"ExpectStubCall.js","sourceRoot":"","sources":["../../../../../front_end/testing/ExpectStubCall.ts"],"names":[],"mappings":"AAAA,sCAAsC;AACtC,yEAAyE;AACzE,6BAA6B;AAE7B,8DAA8D;AAC9D,MAAM,UAAU,UAAU,CACtB,IAA0C,EAC1C,UAA2E,EAAE;IAC/E,OAAO,IAAI,OAAO,CAAQ,OAAO,CAAC,EAAE;QAClC,8DAA8D;QAC9D,IAAI,CAAC,SAAS,CAAC,UAAoB,GAAG,IAAW;YAC/C,IAAI,IAAI,CAAC,SAAS,IAAI,CAAC,OAAO,CAAC,SAAS,IAAI,CAAC,CAAC,EAAE,CAAC;gBAC/C,OAAO,CAAC,IAAI,CAAC,CAAC;YAChB,CAAC;YACD,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,SAAS,CAAiB,CAAC;QACzF,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;AACL,CAAC;AAED,8DAA8D;AAC9D,MAAM,UAAU,YAAY,CACxB,IAA0C,EAC1C,UAA2E,EAAE;IAC/E,MAAM,cAAc,GAAG,CAAC,OAAO,CAAC,SAAS,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC;IACjE,IAAI,cAAc,IAAI,CAAC,EAAE,CAAC;QACxB,OAAO,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;IAC7C,CAAC;IACD,OAAO,UAAU,CAAC,IAAI,EAAE,EAAC,GAAG,OAAO,EAAE,SAAS,EAAE,cAAc,EAAC,CAAC,CAAC;AACnE,CAAC;AAKD,MAAM,UAAU,OAAO,CAAwB,GAAM,EAAE,MAAU;IAC/D,MAAM,EAAC,OAAO,EAAE,OAAO,EAAC,GAAG,OAAO,CAAC,aAAa,EAA2C,CAAC;IAE5F,MAAM,QAAQ,GAAG,GAAG,CAAC,MAAM,CAAyC,CAAC;IACrE,8DAA8D;IAC9D,MAAM,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC,SAAS,CAAC,UAAoB,GAAG,IAAS;QAC7E,MAAM,MAAM,GAAG,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QAC1C,OAAO,CAAC,EAAC,IAAI,EAAE,MAAM,EAAC,CAAC,CAAC;QACxB,IAAI,CAAC,OAAO,EAAE,CAAC;IACjB,CAAC,CAAC,CAAC;IAEH,OAAO,OAAO,CAAC;AACjB,CAAC","sourcesContent":["// Copyright 2024 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function expectCall<TArgs extends any[] = any[], TReturnValue = any>(\n    stub: sinon.SinonStub<TArgs, TReturnValue>,\n    options: {fakeFn?: (...args: TArgs) => TReturnValue, callCount?: number} = {}): Promise<TArgs> {\n  return new Promise<TArgs>(resolve => {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    stub.callsFake(function(this: any, ...args: TArgs) {\n      if (stub.callCount >= (options.callCount ?? 1)) {\n        resolve(args);\n      }\n      return (options.fakeFn ? options.fakeFn.apply(this, args) : undefined) as TReturnValue;\n    });\n  });\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function expectCalled<TArgs extends any[] = any[], TReturnValue = any>(\n    stub: sinon.SinonStub<TArgs, TReturnValue>,\n    options: {fakeFn?: (...args: TArgs) => TReturnValue, callCount?: number} = {}): Promise<TArgs> {\n  const remainingCalls = (options.callCount ?? 1) - stub.callCount;\n  if (remainingCalls <= 0) {\n    return Promise.resolve(stub.lastCall.args);\n  }\n  return expectCall(stub, {...options, callCount: remainingCalls});\n}\n\ntype Args<T> = T extends(...args: infer TArgs) => unknown ? TArgs : never;\ntype Ret<T> = T extends(...args: any[]) => infer TRet ? TRet : never;\n\nexport function spyCall<T, Fn extends keyof T>(obj: T, method: Fn): Promise<{args: Args<T[Fn]>, result: Ret<T[Fn]>}> {\n  const {promise, resolve} = Promise.withResolvers<{args: Args<T[Fn]>, result: Ret<T[Fn]>}>();\n\n  const original = obj[method] as (...args: Args<T[Fn]>) => Ret<T[Fn]>;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const stub = sinon.stub(obj, method).callsFake(function(this: any, ...args: any) {\n    const result = original.apply(this, args);\n    resolve({args, result});\n    stub.restore();\n  });\n\n  return promise;\n}\n"]}