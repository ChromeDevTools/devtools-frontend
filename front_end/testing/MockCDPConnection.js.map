{"version":3,"file":"MockCDPConnection.js","sourceRoot":"","sources":["../../../../../front_end/testing/MockCDPConnection.ts"],"names":[],"mappings":"AAAA,sCAAsC;AACtC,yEAAyE;AACzE,6BAA6B;AAE7B,OAAO,KAAK,cAAc,MAAM,4CAA4C,CAAC;AAS7E;;;;;;;;;GASG;AACH,MAAM,OAAO,iBAAiB;IACnB,UAAU,GAAG,IAAI,GAAG,EAAsD,CAAC;IACpF,8DAA8D;IACrD,SAAS,CAAiE;IAEnF,YAAY,WAA2E,EAAE;QACvF,IAAI,CAAC,SAAS,GAAG,IAAI,GAAG,CAAC,QAAQ,CAAC,CAAC;IACrC,CAAC;IAED;;;;OAIG;IACH,UAAU,CAAiD,MAAS,EAAE,OAA+B;QACnG,IAAI,OAAO,IAAI,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC;YAC1C,MAAM,IAAI,KAAK,CAAC,+CAA+C,MAAM,EAAE,CAAC,CAAC;QAC3E,CAAC;QAED,IAAI,OAAO,EAAE,CAAC;YACZ,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;QACtC,CAAC;aAAM,CAAC;YACN,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;QAChC,CAAC;IACH,CAAC;IAED,IAAI,CACA,MAAS,EAAE,MAAqD,EAChE,SAA2B;QAG7B,MAAM,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QAC3C,IAAI,CAAC,OAAO,EAAE,CAAC;YACb,OAAO,OAAO,CAAC,OAAO,CAAC;gBACrB,KAAK,EAAE;oBACL,OAAO,EAAE,UAAU,MAAM,sCAAsC;oBAC/D,IAAI,EAAE,cAAc,CAAC,aAAa,CAAC,cAAc,CAAC,mBAAmB;iBACtE;aACF,CAAC,CAAC;QACL,CAAC;QAED,OAAO,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,EAAE,SAAS,CAAC,CAAC,CAAC;IACrD,CAAC;IAED,aAAa,CACT,KAAQ,EAAE,MAAmD,EAAE,SAA2B;QAC5F,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE,CAAC,QAAQ,CAAC,OAAO,CAAC;YACnD,SAAS;YACT,MAAM,EAAE,KAAK;YACb,MAAM;SACP,CAAC,CAAC,CAAC;IACN,CAAC;IAED,OAAO,CAAC,QAA4D;QAClE,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;IAChC,CAAC;IAED,SAAS,CAAC,QAA4D;QACpE,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;IACnC,CAAC;CACF","sourcesContent":["// Copyright 2025 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as ProtocolClient from '../core/protocol_client/protocol_client.js';\n\nexport type CommandHandler<C extends ProtocolClient.CDPConnection.Command> =\n    (params: ProtocolClient.CDPConnection.CommandParams<C>, sessionId: string|undefined) =>\n        Promise<{result: ProtocolClient.CDPConnection.CommandResult<C>}|{error: ProtocolClient.CDPConnection.CDPError}>|\n    {result: ProtocolClient.CDPConnection.CommandResult<C>}|{error: ProtocolClient.CDPConnection.CDPError};\n\nexport type CommandAndHandler<C extends ProtocolClient.CDPConnection.Command> = [C, CommandHandler<C>];\n\n/**\n * This class fulfills a similar role as `describeWithMockConnection` with the main difference\n * being that it doesn't operate global.\n *\n * The right usage is to create a `MockCDPConnection` instance with your handlers, and then pass\n * it along to {@link createTarget}.\n *\n * This means a `MockCDPConnection` only affects the targets explicitly created with it and doesn't\n * leak anywhere else.\n */\nexport class MockCDPConnection implements ProtocolClient.CDPConnection.CDPConnection {\n  readonly #observers = new Set<ProtocolClient.CDPConnection.CDPConnectionObserver>();\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  readonly #handlers: Map<ProtocolClient.CDPConnection.Command, CommandHandler<any>>;\n\n  constructor(handlers: Array<CommandAndHandler<ProtocolClient.CDPConnection.Command>> = []) {\n    this.#handlers = new Map(handlers);\n  }\n\n  /**\n   * Sets the provided handler or clears an existing handler when passing `null`.\n   *\n   * Throws if a set would overwrite an existing handler.\n   */\n  setHandler<T extends ProtocolClient.CDPConnection.Command>(method: T, handler: CommandHandler<T>|null): void {\n    if (handler && this.#handlers.has(method)) {\n      throw new Error(`MockCDPConnection already has a handler for ${method}`);\n    }\n\n    if (handler) {\n      this.#handlers.set(method, handler);\n    } else {\n      this.#handlers.delete(method);\n    }\n  }\n\n  send<T extends ProtocolClient.CDPConnection.Command>(\n      method: T, params: ProtocolClient.CDPConnection.CommandParams<T>,\n      sessionId: string|undefined): Promise<{result: ProtocolClient.CDPConnection.CommandResult<T>}|{\n    error: ProtocolClient.CDPConnection.CDPError,\n  }> {\n    const handler = this.#handlers.get(method);\n    if (!handler) {\n      return Promise.resolve({\n        error: {\n          message: `Method ${method} is not stubbed in MockCDPConnection`,\n          code: ProtocolClient.CDPConnection.CDPErrorStatus.DEVTOOLS_STUB_ERROR,\n        }\n      });\n    }\n\n    return Promise.resolve(handler(params, sessionId));\n  }\n\n  dispatchEvent<T extends ProtocolClient.CDPConnection.Event>(\n      event: T, params: ProtocolClient.CDPConnection.EventParams<T>, sessionId: string|undefined): void {\n    this.#observers.forEach(observer => observer.onEvent({\n      sessionId,\n      method: event,\n      params,\n    }));\n  }\n\n  observe(observer: ProtocolClient.CDPConnection.CDPConnectionObserver): void {\n    this.#observers.add(observer);\n  }\n\n  unobserve(observer: ProtocolClient.CDPConnection.CDPConnectionObserver): void {\n    this.#observers.delete(observer);\n  }\n}\n"]}