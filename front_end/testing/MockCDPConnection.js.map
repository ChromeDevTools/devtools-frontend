{"version":3,"file":"MockCDPConnection.js","sourceRoot":"","sources":["../../../../../front_end/testing/MockCDPConnection.ts"],"names":[],"mappings":"AAAA,sCAAsC;AACtC,yEAAyE;AACzE,6BAA6B;AAE7B,OAAO,KAAK,cAAc,MAAM,4CAA4C,CAAC;AAS7E;;;;;;;;;GASG;AACH,MAAM,OAAO,iBAAiB;IACnB,UAAU,GAAG,IAAI,GAAG,EAAsD,CAAC;IAC3E,SAAS,CAAkG;IAEpH,YAAY,QAAwE;QAClF,IAAI,CAAC,SAAS,GAAG,IAAI,GAAG,CAAC,QAAQ,CAAC,CAAC;IACrC,CAAC;IAED,IAAI,CACA,MAAS,EAAE,MAAqD,EAChE,SAA2B;QAG7B,MAAM,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QAC3C,IAAI,CAAC,OAAO,EAAE,CAAC;YACb,OAAO,OAAO,CAAC,OAAO,CAAC;gBACrB,KAAK,EAAE;oBACL,OAAO,EAAE,UAAU,MAAM,sCAAsC;oBAC/D,IAAI,EAAE,cAAc,CAAC,aAAa,CAAC,cAAc,CAAC,mBAAmB;iBACtE;aACF,CAAC,CAAC;QACL,CAAC;QAED,OAAO,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,EAAE,SAAS,CAAC,CAAC,CAAC;IACrD,CAAC;IAED,OAAO,CAAC,QAA4D;QAClE,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;IAChC,CAAC;IAED,SAAS,CAAC,QAA4D;QACpE,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;IACnC,CAAC;CACF","sourcesContent":["// Copyright 2025 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as ProtocolClient from '../core/protocol_client/protocol_client.js';\n\nexport type CommandHandler<C extends ProtocolClient.CDPConnection.Command> =\n    (params: ProtocolClient.CDPConnection.CommandParams<C>, sessionId: string|undefined) =>\n        Promise<{result: ProtocolClient.CDPConnection.CommandResult<C>}|{error: ProtocolClient.CDPConnection.CDPError}>|\n    {result: ProtocolClient.CDPConnection.CommandResult<C>}|{error: ProtocolClient.CDPConnection.CDPError};\n\nexport type CommandAndHandler<C extends ProtocolClient.CDPConnection.Command> = [C, CommandHandler<C>];\n\n/**\n * This class fulfills a similar role as `describeWithMockConnection` with the main difference\n * being that it doesn't operate global.\n *\n * The right usage is to create a `MockCDPConnection` instance with your handlers, and then pass\n * it along to {@link createTarget}.\n *\n * This means a `MockCDPConnection` only affects the targets explicitly created with it and doesn't\n * leak anywhere else.\n */\nexport class MockCDPConnection implements ProtocolClient.CDPConnection.CDPConnection {\n  readonly #observers = new Set<ProtocolClient.CDPConnection.CDPConnectionObserver>();\n  readonly #handlers: Map<ProtocolClient.CDPConnection.Command, CommandHandler<ProtocolClient.CDPConnection.Command>>;\n\n  constructor(handlers: Array<CommandAndHandler<ProtocolClient.CDPConnection.Command>>) {\n    this.#handlers = new Map(handlers);\n  }\n\n  send<T extends ProtocolClient.CDPConnection.Command>(\n      method: T, params: ProtocolClient.CDPConnection.CommandParams<T>,\n      sessionId: string|undefined): Promise<{result: ProtocolClient.CDPConnection.CommandResult<T>}|{\n    error: ProtocolClient.CDPConnection.CDPError,\n  }> {\n    const handler = this.#handlers.get(method);\n    if (!handler) {\n      return Promise.resolve({\n        error: {\n          message: `Method ${method} is not stubbed in MockCDPConnection`,\n          code: ProtocolClient.CDPConnection.CDPErrorStatus.DEVTOOLS_STUB_ERROR,\n        }\n      });\n    }\n\n    return Promise.resolve(handler(params, sessionId));\n  }\n\n  observe(observer: ProtocolClient.CDPConnection.CDPConnectionObserver): void {\n    this.#observers.add(observer);\n  }\n\n  unobserve(observer: ProtocolClient.CDPConnection.CDPConnectionObserver): void {\n    this.#observers.delete(observer);\n  }\n}\n"]}