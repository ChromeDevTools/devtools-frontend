{"version":3,"file":"decode.js","sourceRoot":"","sources":["../../../../../../../../../front_end/third_party/source-map-scopes-codec/package/src/decode/decode.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2025 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport {\n  GeneratedRangeFlags,\n  type GeneratedRangeStartItem,\n  OriginalScopeFlags,\n  type OriginalScopeStartItem,\n  Tag,\n} from \"../codec.js\";\nimport type {\n  GeneratedRange,\n  IndexSourceMapJson,\n  OriginalScope,\n  Position,\n  ScopeInfo,\n  SourceMap,\n  SourceMapJson,\n  SubRangeBinding,\n} from \"../scopes.d.ts\";\nimport { TokenIterator } from \"../vlq.js\";\n\n/**\n * The mode decides how well-formed the encoded scopes have to be, to be accepted by the decoder.\n *\n * LAX is the default and is much more lenient. It's still best effort though and the decoder doesn't\n * implement any error recovery: e.g. superfluous \"start\" items can lead to whole trees being omitted.\n *\n * STRICT mode will throw in the following situations:\n *\n *   - Encountering ORIGINAL_SCOPE_END, or GENERATED_RANGE_END items that don't have matching *_START items.\n *   - Encountering ORIGINAL_SCOPE_VARIABLES items outside a surrounding scope START/END.\n *   - Encountering GENERATED_RANGE_BINDINGS items outside a surrounding range START/END.\n *   - Miss-matches between the number of variables in a scope vs the number of value expressions in the ranges.\n *   - Out-of-bound indices into the \"names\" array.\n */\nexport const enum DecodeMode {\n  STRICT = 1,\n  LAX = 2,\n}\n\nexport interface DecodeOptions {\n  mode: DecodeMode;\n\n  /**\n   * Offsets `start` and `end` of all generated ranges by the specified amount.\n   * Intended to be used when decoding sections of index source maps one-by-one.\n   *\n   * Has no effect when passing a {@link IndexSourceMapJson} directly to {@link decode}.\n   */\n  generatedOffset: Position;\n}\n\nexport const DEFAULT_DECODE_OPTIONS: DecodeOptions = {\n  mode: DecodeMode.LAX,\n  generatedOffset: { line: 0, column: 0 },\n};\n\nexport function decode(\n  sourceMap: SourceMap,\n  options: Partial<DecodeOptions> = DEFAULT_DECODE_OPTIONS,\n): ScopeInfo {\n  const opts = { ...DEFAULT_DECODE_OPTIONS, ...options };\n  if (\"sections\" in sourceMap) {\n    return decodeIndexMap(sourceMap, {\n      ...opts,\n      generatedOffset: { line: 0, column: 0 },\n    });\n  }\n  return decodeMap(sourceMap, opts);\n}\n\nfunction decodeMap(\n  sourceMap: SourceMapJson,\n  options: DecodeOptions,\n): ScopeInfo {\n  if (!sourceMap.scopes || !sourceMap.names) return { scopes: [], ranges: [] };\n\n  return new Decoder(sourceMap.scopes, sourceMap.names, options).decode();\n}\n\nfunction decodeIndexMap(\n  sourceMap: IndexSourceMapJson,\n  options: DecodeOptions,\n): ScopeInfo {\n  const scopeInfo: ScopeInfo = { scopes: [], ranges: [] };\n\n  for (const section of sourceMap.sections) {\n    const { scopes, ranges } = decode(section.map, {\n      ...options,\n      generatedOffset: section.offset,\n    });\n    for (const scope of scopes) scopeInfo.scopes.push(scope);\n    for (const range of ranges) scopeInfo.ranges.push(range);\n  }\n\n  return scopeInfo;\n}\n\nconst DEFAULT_SCOPE_STATE = {\n  line: 0,\n  column: 0,\n  name: 0,\n  kind: 0,\n  variable: 0,\n};\n\nconst DEFAULT_RANGE_STATE = {\n  line: 0,\n  column: 0,\n  defScopeIdx: 0,\n};\n\nclass Decoder {\n  readonly #encodedScopes: string;\n  readonly #names: string[];\n  readonly #mode: DecodeMode;\n\n  #scopes: (OriginalScope | null)[] = [];\n  #ranges: GeneratedRange[] = [];\n\n  readonly #scopeState = { ...DEFAULT_SCOPE_STATE };\n  readonly #rangeState = { ...DEFAULT_RANGE_STATE };\n\n  readonly #scopeStack: OriginalScope[] = [];\n  readonly #rangeStack: GeneratedRange[] = [];\n\n  #flatOriginalScopes: OriginalScope[] = [];\n  #subRangeBindingsForRange = new Map<number, [number, number, number][]>();\n\n  constructor(scopes: string, names: string[], options: DecodeOptions) {\n    this.#encodedScopes = scopes;\n    this.#names = names;\n    this.#mode = options.mode;\n    this.#rangeState.line = options.generatedOffset.line;\n    this.#rangeState.column = options.generatedOffset.column;\n  }\n\n  decode(): ScopeInfo {\n    const iter = new TokenIterator(this.#encodedScopes);\n\n    while (iter.hasNext()) {\n      if (iter.peek() === \",\") {\n        iter.nextChar(); // Consume \",\".\n        this.#scopes.push(null); // Add an EmptyItem;\n        continue;\n      }\n\n      const tag = iter.nextUnsignedVLQ();\n      switch (tag) {\n        case Tag.ORIGINAL_SCOPE_START: {\n          const item: OriginalScopeStartItem = {\n            flags: iter.nextUnsignedVLQ(),\n            line: iter.nextUnsignedVLQ(),\n            column: iter.nextUnsignedVLQ(),\n          };\n\n          if (item.flags & OriginalScopeFlags.HAS_NAME) {\n            item.nameIdx = iter.nextSignedVLQ();\n          }\n          if (item.flags & OriginalScopeFlags.HAS_KIND) {\n            item.kindIdx = iter.nextSignedVLQ();\n          }\n\n          this.#handleOriginalScopeStartItem(item);\n          break;\n        }\n        case Tag.ORIGINAL_SCOPE_VARIABLES: {\n          const variableIdxs: number[] = [];\n\n          while (iter.hasNext() && iter.peek() !== \",\") {\n            variableIdxs.push(iter.nextSignedVLQ());\n          }\n\n          this.#handleOriginalScopeVariablesItem(variableIdxs);\n          break;\n        }\n        case Tag.ORIGINAL_SCOPE_END: {\n          this.#handleOriginalScopeEndItem(\n            iter.nextUnsignedVLQ(),\n            iter.nextUnsignedVLQ(),\n          );\n          break;\n        }\n        case Tag.GENERATED_RANGE_START: {\n          const flags = iter.nextUnsignedVLQ();\n          const line = flags & GeneratedRangeFlags.HAS_LINE\n            ? iter.nextUnsignedVLQ()\n            : undefined;\n          const column = iter.nextUnsignedVLQ();\n\n          const definitionIdx = flags & GeneratedRangeFlags.HAS_DEFINITION\n            ? iter.nextSignedVLQ()\n            : undefined;\n\n          this.#handleGeneratedRangeStartItem({\n            flags,\n            line,\n            column,\n            definitionIdx,\n          });\n          break;\n        }\n        case Tag.GENERATED_RANGE_END: {\n          const lineOrColumn = iter.nextUnsignedVLQ();\n          const maybeColumn = iter.hasNext() && iter.peek() !== \",\"\n            ? iter.nextUnsignedVLQ()\n            : undefined;\n\n          if (maybeColumn !== undefined) {\n            this.#handleGeneratedRangeEndItem(lineOrColumn, maybeColumn);\n          } else {\n            this.#handleGeneratedRangeEndItem(0, lineOrColumn);\n          }\n          break;\n        }\n        case Tag.GENERATED_RANGE_BINDINGS: {\n          const valueIdxs: number[] = [];\n\n          while (iter.hasNext() && iter.peek() !== \",\") {\n            valueIdxs.push(iter.nextUnsignedVLQ());\n          }\n\n          this.#handleGeneratedRangeBindingsItem(valueIdxs);\n          break;\n        }\n        case Tag.GENERATED_RANGE_SUBRANGE_BINDING: {\n          const variableIndex = iter.nextUnsignedVLQ();\n          const bindings: [number, number, number][] = [];\n\n          while (iter.hasNext() && iter.peek() !== \",\") {\n            bindings.push([\n              iter.nextUnsignedVLQ(),\n              iter.nextUnsignedVLQ(),\n              iter.nextUnsignedVLQ(),\n            ]);\n          }\n\n          this.#recordGeneratedSubRangeBindingItem(variableIndex, bindings);\n          break;\n        }\n        case Tag.GENERATED_RANGE_CALL_SITE: {\n          this.#handleGeneratedRangeCallSite(\n            iter.nextUnsignedVLQ(),\n            iter.nextUnsignedVLQ(),\n            iter.nextUnsignedVLQ(),\n          );\n          break;\n        }\n      }\n\n      // Consume any trailing VLQ and the the \",\"\n      while (iter.hasNext() && iter.peek() !== \",\") iter.nextUnsignedVLQ();\n      if (iter.hasNext()) iter.nextChar();\n    }\n\n    if (iter.currentChar() === \",\") {\n      // Handle trailing EmptyItem.\n      this.#scopes.push(null);\n    }\n\n    if (this.#scopeStack.length > 0) {\n      this.#throwInStrictMode(\n        \"Encountered ORIGINAL_SCOPE_START without matching END!\",\n      );\n    }\n    if (this.#rangeStack.length > 0) {\n      this.#throwInStrictMode(\n        \"Encountered GENERATED_RANGE_START without matching END!\",\n      );\n    }\n\n    const info = { scopes: this.#scopes, ranges: this.#ranges };\n\n    this.#scopes = [];\n    this.#ranges = [];\n    this.#flatOriginalScopes = [];\n\n    return info;\n  }\n\n  #throwInStrictMode(message: string) {\n    if (this.#mode === DecodeMode.STRICT) throw new Error(message);\n  }\n\n  #handleOriginalScopeStartItem(item: OriginalScopeStartItem) {\n    this.#scopeState.line += item.line;\n    if (item.line === 0) {\n      this.#scopeState.column += item.column;\n    } else {\n      this.#scopeState.column = item.column;\n    }\n    const scope: OriginalScope = {\n      start: { line: this.#scopeState.line, column: this.#scopeState.column },\n      end: { line: this.#scopeState.line, column: this.#scopeState.column },\n      isStackFrame: false,\n      variables: [],\n      children: [],\n    };\n\n    if (item.nameIdx !== undefined) {\n      this.#scopeState.name += item.nameIdx;\n      scope.name = this.#resolveName(this.#scopeState.name);\n    }\n    if (item.kindIdx !== undefined) {\n      this.#scopeState.kind += item.kindIdx;\n      scope.kind = this.#resolveName(this.#scopeState.kind);\n    }\n\n    scope.isStackFrame = Boolean(\n      item.flags & OriginalScopeFlags.IS_STACK_FRAME,\n    );\n\n    this.#scopeStack.push(scope);\n    this.#flatOriginalScopes.push(scope);\n  }\n\n  #handleOriginalScopeVariablesItem(variableIdxs: number[]) {\n    const scope = this.#scopeStack.at(-1);\n    if (!scope) {\n      this.#throwInStrictMode(\n        \"Encountered ORIGINAL_SCOPE_VARIABLES without surrounding ORIGINAL_SCOPE_START\",\n      );\n      return;\n    }\n\n    for (const variableIdx of variableIdxs) {\n      this.#scopeState.variable += variableIdx;\n      scope.variables.push(this.#resolveName(this.#scopeState.variable));\n    }\n  }\n\n  #handleOriginalScopeEndItem(line: number, column: number) {\n    this.#scopeState.line += line;\n    if (line === 0) {\n      this.#scopeState.column += column;\n    } else {\n      this.#scopeState.column = column;\n    }\n\n    const scope = this.#scopeStack.pop();\n    if (!scope) {\n      this.#throwInStrictMode(\n        \"Encountered ORIGINAL_SCOPE_END without matching ORIGINAL_SCOPE_START!\",\n      );\n      return;\n    }\n\n    scope.end = {\n      line: this.#scopeState.line,\n      column: this.#scopeState.column,\n    };\n\n    if (this.#scopeStack.length > 0) {\n      const parent = this.#scopeStack.at(-1)!;\n      scope.parent = parent;\n      parent.children.push(scope);\n    } else {\n      this.#scopes.push(scope);\n      this.#scopeState.line = 0;\n      this.#scopeState.column = 0;\n    }\n  }\n\n  #handleGeneratedRangeStartItem(item: GeneratedRangeStartItem) {\n    if (item.line !== undefined) {\n      this.#rangeState.line += item.line;\n      this.#rangeState.column = item.column;\n    } else {\n      this.#rangeState.column += item.column;\n    }\n\n    const range: GeneratedRange = {\n      start: {\n        line: this.#rangeState.line,\n        column: this.#rangeState.column,\n      },\n      end: {\n        line: this.#rangeState.line,\n        column: this.#rangeState.column,\n      },\n      isStackFrame: Boolean(\n        item.flags & GeneratedRangeFlags.IS_STACK_FRAME,\n      ),\n      isHidden: Boolean(item.flags & GeneratedRangeFlags.IS_HIDDEN),\n      values: [],\n      children: [],\n    };\n\n    if (item.definitionIdx !== undefined) {\n      this.#rangeState.defScopeIdx += item.definitionIdx;\n      if (\n        this.#rangeState.defScopeIdx < 0 ||\n        this.#rangeState.defScopeIdx >= this.#flatOriginalScopes.length\n      ) {\n        this.#throwInStrictMode(\"Invalid definition scope index\");\n      } else {\n        range.originalScope =\n          this.#flatOriginalScopes[this.#rangeState.defScopeIdx];\n      }\n    }\n\n    this.#rangeStack.push(range);\n    this.#subRangeBindingsForRange.clear();\n  }\n\n  #handleGeneratedRangeBindingsItem(valueIdxs: number[]) {\n    const range = this.#rangeStack.at(-1);\n    if (!range) {\n      this.#throwInStrictMode(\n        \"Encountered GENERATED_RANGE_BINDINGS without surrounding GENERATED_RANGE_START\",\n      );\n      return;\n    }\n\n    for (const valueIdx of valueIdxs) {\n      if (valueIdx === 0) {\n        range.values.push(null);\n      } else {\n        range.values.push(this.#resolveName(valueIdx - 1));\n      }\n    }\n  }\n\n  #recordGeneratedSubRangeBindingItem(\n    variableIndex: number,\n    bindings: [number, number, number][],\n  ) {\n    if (this.#subRangeBindingsForRange.has(variableIndex)) {\n      this.#throwInStrictMode(\n        \"Encountered multiple GENERATED_RANGE_SUBRANGE_BINDING items for the same variable\",\n      );\n      return;\n    }\n    this.#subRangeBindingsForRange.set(variableIndex, bindings);\n  }\n\n  #handleGeneratedRangeCallSite(\n    sourceIndex: number,\n    line: number,\n    column: number,\n  ) {\n    const range = this.#rangeStack.at(-1);\n    if (!range) {\n      this.#throwInStrictMode(\n        \"Encountered GENERATED_RANGE_CALL_SITE without surrounding GENERATED_RANGE_START\",\n      );\n      return;\n    }\n\n    range.callSite = {\n      sourceIndex,\n      line,\n      column,\n    };\n  }\n\n  #handleGeneratedRangeEndItem(line: number, column: number) {\n    if (line !== 0) {\n      this.#rangeState.line += line;\n      this.#rangeState.column = column;\n    } else {\n      this.#rangeState.column += column;\n    }\n\n    const range = this.#rangeStack.pop();\n    if (!range) {\n      this.#throwInStrictMode(\n        \"Encountered GENERATED_RANGE_END without matching GENERATED_RANGE_START!\",\n      );\n      return;\n    }\n\n    range.end = {\n      line: this.#rangeState.line,\n      column: this.#rangeState.column,\n    };\n\n    this.#handleGeneratedRangeSubRangeBindings(range);\n\n    if (this.#rangeStack.length > 0) {\n      const parent = this.#rangeStack.at(-1)!;\n      range.parent = parent;\n      parent.children.push(range);\n    } else {\n      this.#ranges.push(range);\n    }\n  }\n\n  #handleGeneratedRangeSubRangeBindings(range: GeneratedRange) {\n    for (const [variableIndex, bindings] of this.#subRangeBindingsForRange) {\n      const value = range.values[variableIndex];\n      const subRanges: SubRangeBinding[] = [];\n      range.values[variableIndex] = subRanges;\n\n      let lastLine = range.start.line;\n      let lastColumn = range.start.column;\n\n      subRanges.push({\n        from: { line: lastLine, column: lastColumn },\n        to: { line: 0, column: 0 },\n        value: value as string | undefined,\n      });\n\n      for (const [binding, line, column] of bindings) {\n        lastLine += line;\n        if (line === 0) {\n          lastColumn += column;\n        } else {\n          lastColumn = column;\n        }\n\n        subRanges.push({\n          from: { line: lastLine, column: lastColumn },\n          to: { line: 0, column: 0 }, // This will be fixed in the post-processing step.\n          value: binding === 0 ? undefined : this.#resolveName(binding - 1),\n        });\n      }\n    }\n\n    for (const value of range.values) {\n      if (Array.isArray(value)) {\n        const subRanges = value;\n        for (let i = 0; i < subRanges.length - 1; ++i) {\n          subRanges[i].to = subRanges[i + 1].from;\n        }\n        subRanges[subRanges.length - 1].to = range.end;\n      }\n    }\n  }\n\n  #resolveName(index: number): string {\n    if (index < 0 || index >= this.#names.length) {\n      this.#throwInStrictMode(\"Illegal index into the 'names' array\");\n    }\n    return this.#names[index] ?? \"\";\n  }\n}\n"]}