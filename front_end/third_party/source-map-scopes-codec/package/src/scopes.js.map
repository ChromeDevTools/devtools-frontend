{"version":3,"file":"scopes.js","sourceRoot":"","sources":["../../../../../../../../front_end/third_party/source-map-scopes-codec/package/src/scopes.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B","sourcesContent":["// Copyright 2025 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/**\n * The decoded scopes information found in a source map.\n */\nexport interface ScopeInfo {\n  /**\n   * The length of {@linkcode scopes} must match the length of \"sources\" in the source map JSON. Each entry describes the scope tree of the corresponding source file.\n   */\n  scopes: (OriginalScope | null)[];\n\n  /**\n   * The range tree of the generated bundle. Multiple top-level ranges are allowed but must not overlap source position wise.\n   */\n  ranges: GeneratedRange[];\n}\n\n/**\n * A scope in the authored source.\n */\nexport interface OriginalScope {\n  /** The beginning of this scope (inclusive). */\n  start: Position;\n\n  /** The end of this scope (exclusive) */\n  end: Position;\n\n  /**\n   * The name of this scope. For function scopes this is the function name.\n   *\n   * Constructors may put the class name here.\n   */\n  name?: string;\n\n  /**\n   * JavaScript-like languages are encouraged to use 'Global', 'Class', 'Function' and 'Block'.\n   *\n   * The \"kind\" is only used in debuggers as a label for scope UI views, but does not have any\n   * semantic significance.\n   */\n  kind?: string;\n\n  /**\n   * Whether this scope is something that can be called and results in stack frame (e.g. functions, methods, etc.).\n   */\n  isStackFrame: boolean;\n\n  /**\n   * All variable names that this scope declares.\n   */\n  variables: string[];\n\n  /**\n   * The child scopes. When manually building scopes, {@linkcode children} must be sorted, not\n   * overlap each other and be contained within [start, end).\n   */\n  children: OriginalScope[];\n\n  /** The parent scope or `undefined` for top-level scopes. */\n  parent?: OriginalScope;\n}\n\n/**\n * A range (can be a scope) in the generated JavaScript/WASM.\n *\n * The name \"range\" was chosen deliberately as a GeneratedRange does not necessarily\n * correspond to a lexical JavaScript scope. E.g. inlining, or concatenating multiple\n * bundles can result in generated ranges that are not lexical scopes.\n */\nexport interface GeneratedRange {\n  /** The beginning of this range (inclusive) */\n  start: Position;\n\n  /** The end of this range (exclusive) */\n  end: Position;\n\n  /**\n   * The corresponding scope in the authored source.\n   */\n  originalScope?: OriginalScope;\n\n  /**\n   * Whether this generated range is an actual JavaScript/WASM function in the generated code.\n   */\n  isStackFrame: boolean;\n\n  /**\n   * Whether calls to this generated range should be hidden from stack traces even if\n   * this range has an `originalScope`.\n   */\n  isHidden: boolean;\n\n  /**\n   * If this `GeneratedRange` is the result of inlining `originalScope`, then `callSite`\n   * refers to where `originalScope` was called in the original (\"authored\") code.\n   *\n   * If this field is present than `originalScope` is present as well and `isStackFrame` is `false`.\n   */\n  callSite?: OriginalPosition;\n\n  /**\n   * Expressions that compute the values of the variables of this OriginalScope. The length\n   * of `values` matches the length of `originalScope.variables`.\n   */\n  values: Binding[];\n\n  /**\n   * The child ranges. When manually building ranges, {@linkcode children} must be sorted,\n   * not overlap each other and be contained within [start, end).\n   */\n  children: GeneratedRange[];\n\n  /** The parent range or `undefined` for top-level ranges. */\n  parent?: GeneratedRange;\n}\n\n/**\n * For each variable, this can either be:\n *\n *   1) A single expression (valid for a full `GeneratedRange`).\n *\n *   2) `null` if this variable is unavailable in the whole range. This can\n *      happen e.g. when the variable was optimized out and can't be recomputed.\n *\n *   3) A list of `SubRangeBinding`s. Used when computing the value requires different\n *      expressions throughout the `GeneratedRange` or if the variable is unavailable in\n *      parts of the `GeneratedRange`.\n *\n *      Note: The decoder produces `SubRangeBindings` where the \"from\" of the first `SubRangeBinding`\n *      and the \"to\" of the last `SubRangeBinding` are equal to the `GeneratedRange`s \"start\" and \"end\"\n *      position respectively.\n */\nexport type Binding = string | null | SubRangeBinding[];\n\nexport interface SubRangeBinding {\n  value?: string;\n  from: Position;\n  to: Position;\n}\n\n/**\n * A position with 0-based line and column numbers.\n *\n * A {@linkcode Position} object by itself does not imply a position in original source\n * or generated code. It is used in both and normally it is clear from context.\n */\nexport interface Position {\n  line: number;\n  column: number;\n}\n\n/**\n * A position with 0-based line and column numbers in a specific original source file.\n */\nexport interface OriginalPosition extends Position {\n  /** The 0-based index into \"sources\" in the source map. Or into {@linkcode ScopeInfo.scopes}. */\n  sourceIndex: number;\n}\n\n/**\n * A standard source map, or index source map as per https://tc39.es/ecma426.\n */\nexport type SourceMap = SourceMapJson | IndexSourceMapJson;\n\n/**\n * A standard index source map json object as per https://tc39.es/ecma426.\n */\nexport interface IndexSourceMapJson {\n  version: 3;\n  sections: Array<{ offset: Position; map: SourceMapJson }>;\n}\n\n/**\n * A standard source map json object as per https://tc39.es/ecma426.\n */\nexport interface SourceMapJson {\n  version: 3;\n  sources: (string | null)[];\n  mappings: string;\n  names?: string[];\n  scopes?: string;\n}\n"]}