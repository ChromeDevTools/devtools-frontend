{
  "version": 3,
  "sources": ["../../../../../../front_end/third_party/source-map-scopes-codec/package/src/vlq.ts", "../../../../../../front_end/third_party/source-map-scopes-codec/package/src/util.ts", "../../../../../../front_end/third_party/source-map-scopes-codec/package/src/encode/encoder.ts", "../../../../../../front_end/third_party/source-map-scopes-codec/package/src/encode/encode.ts", "../../../../../../front_end/third_party/source-map-scopes-codec/package/src/decode/decode.ts", "../../../../../../front_end/third_party/source-map-scopes-codec/package/src/builder/builder.ts", "../../../../../../front_end/third_party/source-map-scopes-codec/package/src/builder/safe_builder.ts"],
  "sourcesContent": ["// Copyright 2025 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/**\n * @fileoverview\n *\n * VLQ implementation taken mostly verbatim from Chrome DevTools itself.\n */\n\nconst BASE64_CHARS =\n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nconst BASE64_CODES = new Uint8Array(123);\nfor (let index = 0; index < BASE64_CHARS.length; ++index) {\n  BASE64_CODES[BASE64_CHARS.charCodeAt(index)] = index;\n}\n\nconst VLQ_BASE_SHIFT = 5;\nconst VLQ_BASE_MASK = (1 << 5) - 1;\nconst VLQ_CONTINUATION_MASK = 1 << 5;\n\nexport function encodeSigned(n: number): string {\n  // Set the sign bit as the least significant bit.\n  n = n >= 0 ? 2 * n : 1 - 2 * n;\n  return encodeUnsigned(n);\n}\n\nexport function encodeUnsigned(n: number): string {\n  // Encode into a base64 run.\n  let result = \"\";\n  while (true) {\n    // Extract the lowest 5 bits and remove them from the number.\n    const digit = n & 0x1f;\n    n >>>= 5;\n    // Is there anything more left to encode?\n    if (n === 0) {\n      // We are done encoding, finish the run.\n      result += BASE64_CHARS[digit];\n      break;\n    } else {\n      // There is still more encode, so add the digit and the continuation bit.\n      result += BASE64_CHARS[0x20 + digit];\n    }\n  }\n  return result;\n}\n\nexport class TokenIterator {\n  readonly #string: string;\n  #position: number;\n\n  constructor(string: string) {\n    this.#string = string;\n    this.#position = 0;\n  }\n\n  nextChar(): string {\n    return this.#string.charAt(this.#position++);\n  }\n\n  /** Returns the unicode value of the next character and advances the iterator  */\n  nextCharCode(): number {\n    return this.#string.charCodeAt(this.#position++);\n  }\n\n  peek(): string {\n    return this.#string.charAt(this.#position);\n  }\n\n  hasNext(): boolean {\n    return this.#position < this.#string.length;\n  }\n\n  nextSignedVLQ(): number {\n    let result = this.nextUnsignedVLQ();\n\n    // Fix the sign.\n    const negative = result & 1;\n    result >>>= 1;\n    return negative ? -result : result;\n  }\n\n  nextUnsignedVLQ(): number {\n    let result = 0;\n    let shift = 0;\n    let digit = 0;\n    do {\n      const charCode = this.nextCharCode();\n      digit = BASE64_CODES[charCode];\n      result += (digit & VLQ_BASE_MASK) << shift;\n      shift += VLQ_BASE_SHIFT;\n    } while (digit & VLQ_CONTINUATION_MASK);\n    return result;\n  }\n\n  currentChar(): string {\n    return this.#string.charAt(this.#position - 1);\n  }\n}\n", "// Copyright 2025 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type { Position } from \"./scopes.d.ts\";\n\n/**\n * @returns A negative number iff `a` precedes `b`, 0 iff `a` and `b` are equal and a positive number iff `b` precedes `a`.\n */\nexport function comparePositions(a: Position, b: Position): number {\n  return a.line - b.line || a.column - b.column;\n}\n", "// Copyright 2025 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport {\n  EncodedTag,\n  GeneratedRangeFlags,\n  OriginalScopeFlags,\n} from \"../codec.js\";\nimport type { GeneratedRange, OriginalScope, ScopeInfo } from \"../scopes.d.ts\";\nimport { encodeSigned, encodeUnsigned } from \"../vlq.js\";\nimport { comparePositions } from \"../util.js\";\n\nconst DEFAULT_SCOPE_STATE = {\n  line: 0,\n  column: 0,\n  name: 0,\n  kind: 0,\n  variable: 0,\n};\n\nconst DEFAULT_RANGE_STATE = {\n  line: 0,\n  column: 0,\n  defScopeIdx: 0,\n};\n\nexport class Encoder {\n  readonly #info: ScopeInfo;\n  readonly #names: string[];\n\n  // Hash map to resolve indices of strings in the \"names\" array. Otherwise we'd have\n  // to use 'indexOf' for every name we want to encode.\n  readonly #namesToIndex = new Map<string, number>();\n\n  readonly #scopeState = { ...DEFAULT_SCOPE_STATE };\n  readonly #rangeState = { ...DEFAULT_RANGE_STATE };\n  #encodedItems: string[] = [];\n  #currentItem: string = \"\";\n\n  #scopeToCount = new Map<OriginalScope, number>();\n  #scopeCounter = 0;\n\n  constructor(info: ScopeInfo, names: string[]) {\n    this.#info = info;\n    this.#names = names;\n\n    for (let i = 0; i < names.length; ++i) {\n      this.#namesToIndex.set(names[i], i);\n    }\n  }\n\n  encode(): string {\n    this.#encodedItems = [];\n    this.#info.scopes.forEach((scope) => {\n      this.#scopeState.line = 0;\n      this.#scopeState.column = 0;\n      this.#encodeOriginalScope(scope);\n    });\n    this.#info.ranges.forEach((range) => {\n      this.#encodeGeneratedRange(range);\n    });\n\n    return this.#encodedItems.join(\",\");\n  }\n\n  #encodeOriginalScope(scope: OriginalScope | null): void {\n    if (scope === null) {\n      this.#encodedItems.push(\"\");\n      return;\n    }\n\n    this.#encodeOriginalScopeStart(scope);\n    this.#encodeOriginalScopeVariables(scope);\n    scope.children.forEach((child) => this.#encodeOriginalScope(child));\n    this.#encodeOriginalScopeEnd(scope);\n  }\n\n  #encodeOriginalScopeStart(scope: OriginalScope) {\n    const { line, column } = scope.start;\n    this.#verifyPositionWithScopeState(line, column);\n\n    let flags = 0;\n    const encodedLine = line - this.#scopeState.line;\n    const encodedColumn = encodedLine === 0\n      ? column - this.#scopeState.column\n      : column;\n    this.#scopeState.line = line;\n    this.#scopeState.column = column;\n\n    let encodedName: number | undefined;\n    if (scope.name !== undefined) {\n      flags |= OriginalScopeFlags.HAS_NAME;\n      const nameIdx = this.#resolveNamesIdx(scope.name);\n      encodedName = nameIdx - this.#scopeState.name;\n      this.#scopeState.name = nameIdx;\n    }\n\n    let encodedKind: number | undefined;\n    if (scope.kind !== undefined) {\n      flags |= OriginalScopeFlags.HAS_KIND;\n      const kindIdx = this.#resolveNamesIdx(scope.kind);\n      encodedKind = kindIdx - this.#scopeState.kind;\n      this.#scopeState.kind = kindIdx;\n    }\n\n    if (scope.isStackFrame) flags |= OriginalScopeFlags.IS_STACK_FRAME;\n\n    this.#encodeTag(EncodedTag.ORIGINAL_SCOPE_START).#encodeUnsigned(flags)\n      .#encodeUnsigned(encodedLine).#encodeUnsigned(encodedColumn);\n    if (encodedName !== undefined) this.#encodeSigned(encodedName);\n    if (encodedKind !== undefined) this.#encodeSigned(encodedKind);\n    this.#finishItem();\n\n    this.#scopeToCount.set(scope, this.#scopeCounter++);\n  }\n\n  #encodeOriginalScopeVariables(scope: OriginalScope) {\n    if (scope.variables.length === 0) return;\n\n    this.#encodeTag(EncodedTag.ORIGINAL_SCOPE_VARIABLES);\n\n    for (const variable of scope.variables) {\n      const idx = this.#resolveNamesIdx(variable);\n      this.#encodeSigned(idx - this.#scopeState.variable);\n      this.#scopeState.variable = idx;\n    }\n\n    this.#finishItem();\n  }\n\n  #encodeOriginalScopeEnd(scope: OriginalScope) {\n    const { line, column } = scope.end;\n    this.#verifyPositionWithScopeState(line, column);\n\n    const encodedLine = line - this.#scopeState.line;\n    const encodedColumn = encodedLine === 0\n      ? column - this.#scopeState.column\n      : column;\n\n    this.#scopeState.line = line;\n    this.#scopeState.column = column;\n\n    this.#encodeTag(EncodedTag.ORIGINAL_SCOPE_END).#encodeUnsigned(encodedLine)\n      .#encodeUnsigned(encodedColumn).#finishItem();\n  }\n\n  #encodeGeneratedRange(range: GeneratedRange): void {\n    this.#encodeGeneratedRangeStart(range);\n    this.#encodeGeneratedRangeBindings(range);\n    this.#encodeGeneratedRangeSubRangeBindings(range);\n    this.#encodeGeneratedRangeCallSite(range);\n    range.children.forEach((child) => this.#encodeGeneratedRange(child));\n    this.#encodeGeneratedRangeEnd(range);\n  }\n\n  #encodeGeneratedRangeStart(range: GeneratedRange) {\n    const { line, column } = range.start;\n    this.#verifyPositionWithRangeState(line, column);\n\n    let flags = 0;\n    const encodedLine = line - this.#rangeState.line;\n    let encodedColumn = column - this.#rangeState.column;\n    if (encodedLine > 0) {\n      flags |= GeneratedRangeFlags.HAS_LINE;\n      encodedColumn = column;\n    }\n\n    this.#rangeState.line = line;\n    this.#rangeState.column = column;\n\n    let encodedDefinition;\n    if (range.originalScope) {\n      const definitionIdx = this.#scopeToCount.get(range.originalScope);\n      if (definitionIdx === undefined) {\n        throw new Error(\"Unknown OriginalScope for definition!\");\n      }\n\n      flags |= GeneratedRangeFlags.HAS_DEFINITION;\n\n      encodedDefinition = definitionIdx - this.#rangeState.defScopeIdx;\n      this.#rangeState.defScopeIdx = definitionIdx;\n    }\n\n    if (range.isStackFrame) flags |= GeneratedRangeFlags.IS_STACK_FRAME;\n    if (range.isHidden) flags |= GeneratedRangeFlags.IS_HIDDEN;\n\n    this.#encodeTag(EncodedTag.GENERATED_RANGE_START).#encodeUnsigned(flags);\n    if (encodedLine > 0) this.#encodeUnsigned(encodedLine);\n    this.#encodeUnsigned(encodedColumn);\n    if (encodedDefinition !== undefined) this.#encodeSigned(encodedDefinition);\n    this.#finishItem();\n  }\n\n  #encodeGeneratedRangeSubRangeBindings(range: GeneratedRange) {\n    if (range.values.length === 0) return;\n\n    for (let i = 0; i < range.values.length; ++i) {\n      const value = range.values[i];\n      if (!Array.isArray(value) || value.length <= 1) {\n        continue;\n      }\n\n      this.#encodeTag(EncodedTag.GENERATED_RANGE_SUBRANGE_BINDING)\n        .#encodeUnsigned(i);\n\n      let lastLine = range.start.line;\n      let lastColumn = range.start.column;\n      for (let j = 1; j < value.length; ++j) {\n        const subRange = value[j];\n        const prevSubRange = value[j - 1];\n\n        if (comparePositions(prevSubRange.to, subRange.from) !== 0) {\n          throw new Error(\"Sub-range bindings must not have gaps\");\n        }\n\n        const encodedLine = subRange.from.line - lastLine;\n        const encodedColumn = encodedLine === 0\n          ? subRange.from.column - lastColumn\n          : subRange.from.column;\n        if (encodedLine < 0 || encodedColumn < 0) {\n          throw new Error(\"Sub-range bindings must be sorted\");\n        }\n\n        lastLine = subRange.from.line;\n        lastColumn = subRange.from.column;\n\n        const binding = subRange.value === undefined\n          ? 0\n          : this.#resolveNamesIdx(subRange.value) + 1;\n        this.#encodeUnsigned(binding).#encodeUnsigned(encodedLine)\n          .#encodeUnsigned(encodedColumn);\n      }\n      this.#finishItem();\n    }\n  }\n\n  #encodeGeneratedRangeBindings(range: GeneratedRange) {\n    if (range.values.length === 0) return;\n\n    if (!range.originalScope) {\n      throw new Error(\"Range has binding expressions but no OriginalScope\");\n    } else if (range.originalScope.variables.length !== range.values.length) {\n      throw new Error(\n        \"Range's binding expressions don't match OriginalScopes' variables\",\n      );\n    }\n\n    this.#encodeTag(EncodedTag.GENERATED_RANGE_BINDINGS);\n    for (const val of range.values) {\n      if (val === null || val === undefined) {\n        this.#encodeUnsigned(0);\n      } else if (typeof val === \"string\") {\n        this.#encodeUnsigned(this.#resolveNamesIdx(val) + 1);\n      } else {\n        const initialValue = val[0];\n        const binding = initialValue.value === undefined\n          ? 0\n          : this.#resolveNamesIdx(initialValue.value) + 1;\n        this.#encodeUnsigned(binding);\n      }\n    }\n    this.#finishItem();\n  }\n\n  #encodeGeneratedRangeCallSite(range: GeneratedRange) {\n    if (!range.callSite) return;\n    const { sourceIndex, line, column } = range.callSite;\n\n    // TODO: Throw if stackFrame flag is set or OriginalScope index is invalid or no generated range is here.\n\n    this.#encodeTag(EncodedTag.GENERATED_RANGE_CALL_SITE).#encodeUnsigned(\n      sourceIndex,\n    ).#encodeUnsigned(line).#encodeUnsigned(column).#finishItem();\n  }\n\n  #encodeGeneratedRangeEnd(range: GeneratedRange) {\n    const { line, column } = range.end;\n    this.#verifyPositionWithRangeState(line, column);\n\n    let flags = 0;\n    const encodedLine = line - this.#rangeState.line;\n    let encodedColumn = column - this.#rangeState.column;\n    if (encodedLine > 0) {\n      flags |= GeneratedRangeFlags.HAS_LINE;\n      encodedColumn = column;\n    }\n\n    this.#rangeState.line = line;\n    this.#rangeState.column = column;\n\n    this.#encodeTag(EncodedTag.GENERATED_RANGE_END);\n    if (encodedLine > 0) this.#encodeUnsigned(encodedLine);\n    this.#encodeUnsigned(encodedColumn).#finishItem();\n  }\n\n  #resolveNamesIdx(name: string): number {\n    const index = this.#namesToIndex.get(name);\n    if (index !== undefined) return index;\n\n    const addedIndex = this.#names.length;\n    this.#names.push(name);\n    this.#namesToIndex.set(name, addedIndex);\n    return addedIndex;\n  }\n\n  #verifyPositionWithScopeState(line: number, column: number) {\n    if (\n      this.#scopeState.line > line ||\n      (this.#scopeState.line === line && this.#scopeState.column > column)\n    ) {\n      throw new Error(\n        `Attempting to encode scope item (${line}, ${column}) that precedes the last encoded scope item (${this.#scopeState.line}, ${this.#scopeState.column})`,\n      );\n    }\n  }\n\n  #verifyPositionWithRangeState(line: number, column: number) {\n    if (\n      this.#rangeState.line > line ||\n      (this.#rangeState.line === line && this.#rangeState.column > column)\n    ) {\n      throw new Error(\n        `Attempting to encode range item that precedes the last encoded range item (${line}, ${column})`,\n      );\n    }\n  }\n\n  #encodeTag(tag: EncodedTag): this {\n    this.#currentItem += tag;\n    return this;\n  }\n\n  #encodeSigned(n: number): this {\n    this.#currentItem += encodeSigned(n);\n    return this;\n  }\n\n  #encodeUnsigned(n: number): this {\n    this.#currentItem += encodeUnsigned(n);\n    return this;\n  }\n\n  #finishItem(): void {\n    this.#encodedItems.push(this.#currentItem);\n    this.#currentItem = \"\";\n  }\n}\n", "// Copyright 2025 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type { ScopeInfo, SourceMapJson } from \"../scopes.d.ts\";\nimport { Encoder } from \"./encoder.js\";\n\n/**\n * Encodes the `ScopeInfo` into a source map JSON object.\n *\n * If `inputSourceMap` is provided, `encode` will augment the \"names\" array and\n * overwrite the \"scopes\" field, before returning the provided `inputSourceMap` again.\n */\nexport function encode(\n  scopesInfo: ScopeInfo,\n  inputSourceMap?: SourceMapJson,\n): SourceMapJson {\n  inputSourceMap ||= {\n    version: 3,\n    mappings: \"\",\n    sources: new Array(scopesInfo.scopes.length).fill(null),\n  };\n  inputSourceMap.names ||= [];\n\n  if (inputSourceMap.sources.length !== scopesInfo.scopes.length) {\n    throw new Error(\n      `SourceMapJson.sources.length must match ScopesInfo.scopes! ${inputSourceMap.sources.length} vs ${scopesInfo.scopes.length}`,\n    );\n  }\n\n  inputSourceMap.scopes = new Encoder(scopesInfo, inputSourceMap.names)\n    .encode();\n\n  return inputSourceMap;\n}\n", "// Copyright 2025 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport {\n  GeneratedRangeFlags,\n  type GeneratedRangeStartItem,\n  OriginalScopeFlags,\n  type OriginalScopeStartItem,\n  Tag,\n} from \"../codec.js\";\nimport type {\n  GeneratedRange,\n  IndexSourceMapJson,\n  OriginalScope,\n  Position,\n  ScopeInfo,\n  SourceMap,\n  SourceMapJson,\n  SubRangeBinding,\n} from \"../scopes.d.ts\";\nimport { TokenIterator } from \"../vlq.js\";\n\n/**\n * The mode decides how well-formed the encoded scopes have to be, to be accepted by the decoder.\n *\n * LAX is the default and is much more lenient. It's still best effort though and the decoder doesn't\n * implement any error recovery: e.g. superfluous \"start\" items can lead to whole trees being omitted.\n *\n * STRICT mode will throw in the following situations:\n *\n *   - Encountering ORIGINAL_SCOPE_END, or GENERATED_RANGE_END items that don't have matching *_START items.\n *   - Encountering ORIGINAL_SCOPE_VARIABLES items outside a surrounding scope START/END.\n *   - Encountering GENERATED_RANGE_BINDINGS items outside a surrounding range START/END.\n *   - Miss-matches between the number of variables in a scope vs the number of value expressions in the ranges.\n *   - Out-of-bound indices into the \"names\" array.\n */\nexport const enum DecodeMode {\n  STRICT = 1,\n  LAX = 2,\n}\n\nexport interface DecodeOptions {\n  mode: DecodeMode;\n\n  /**\n   * Offsets `start` and `end` of all generated ranges by the specified amount.\n   * Intended to be used when decoding sections of index source maps one-by-one.\n   *\n   * Has no effect when passing a {@link IndexSourceMapJson} directly to {@link decode}.\n   */\n  generatedOffset: Position;\n}\n\nexport const DEFAULT_DECODE_OPTIONS: DecodeOptions = {\n  mode: DecodeMode.LAX,\n  generatedOffset: { line: 0, column: 0 },\n};\n\nexport function decode(\n  sourceMap: SourceMap,\n  options: Partial<DecodeOptions> = DEFAULT_DECODE_OPTIONS,\n): ScopeInfo {\n  const opts = { ...DEFAULT_DECODE_OPTIONS, ...options };\n  if (\"sections\" in sourceMap) {\n    return decodeIndexMap(sourceMap, {\n      ...opts,\n      generatedOffset: { line: 0, column: 0 },\n    });\n  }\n  return decodeMap(sourceMap, opts);\n}\n\nfunction decodeMap(\n  sourceMap: SourceMapJson,\n  options: DecodeOptions,\n): ScopeInfo {\n  if (!sourceMap.scopes || !sourceMap.names) return { scopes: [], ranges: [] };\n\n  return new Decoder(sourceMap.scopes, sourceMap.names, options).decode();\n}\n\nfunction decodeIndexMap(\n  sourceMap: IndexSourceMapJson,\n  options: DecodeOptions,\n): ScopeInfo {\n  const scopeInfo: ScopeInfo = { scopes: [], ranges: [] };\n\n  for (const section of sourceMap.sections) {\n    const { scopes, ranges } = decode(section.map, {\n      ...options,\n      generatedOffset: section.offset,\n    });\n    for (const scope of scopes) scopeInfo.scopes.push(scope);\n    for (const range of ranges) scopeInfo.ranges.push(range);\n  }\n\n  return scopeInfo;\n}\n\nconst DEFAULT_SCOPE_STATE = {\n  line: 0,\n  column: 0,\n  name: 0,\n  kind: 0,\n  variable: 0,\n};\n\nconst DEFAULT_RANGE_STATE = {\n  line: 0,\n  column: 0,\n  defScopeIdx: 0,\n};\n\nclass Decoder {\n  readonly #encodedScopes: string;\n  readonly #names: string[];\n  readonly #mode: DecodeMode;\n\n  #scopes: (OriginalScope | null)[] = [];\n  #ranges: GeneratedRange[] = [];\n\n  readonly #scopeState = { ...DEFAULT_SCOPE_STATE };\n  readonly #rangeState = { ...DEFAULT_RANGE_STATE };\n\n  readonly #scopeStack: OriginalScope[] = [];\n  readonly #rangeStack: GeneratedRange[] = [];\n\n  #flatOriginalScopes: OriginalScope[] = [];\n  #subRangeBindingsForRange = new Map<number, [number, number, number][]>();\n\n  constructor(scopes: string, names: string[], options: DecodeOptions) {\n    this.#encodedScopes = scopes;\n    this.#names = names;\n    this.#mode = options.mode;\n    this.#rangeState.line = options.generatedOffset.line;\n    this.#rangeState.column = options.generatedOffset.column;\n  }\n\n  decode(): ScopeInfo {\n    const iter = new TokenIterator(this.#encodedScopes);\n\n    while (iter.hasNext()) {\n      if (iter.peek() === \",\") {\n        iter.nextChar(); // Consume \",\".\n        this.#scopes.push(null); // Add an EmptyItem;\n        continue;\n      }\n\n      const tag = iter.nextUnsignedVLQ();\n      switch (tag) {\n        case Tag.ORIGINAL_SCOPE_START: {\n          const item: OriginalScopeStartItem = {\n            flags: iter.nextUnsignedVLQ(),\n            line: iter.nextUnsignedVLQ(),\n            column: iter.nextUnsignedVLQ(),\n          };\n\n          if (item.flags & OriginalScopeFlags.HAS_NAME) {\n            item.nameIdx = iter.nextSignedVLQ();\n          }\n          if (item.flags & OriginalScopeFlags.HAS_KIND) {\n            item.kindIdx = iter.nextSignedVLQ();\n          }\n\n          this.#handleOriginalScopeStartItem(item);\n          break;\n        }\n        case Tag.ORIGINAL_SCOPE_VARIABLES: {\n          const variableIdxs: number[] = [];\n\n          while (iter.hasNext() && iter.peek() !== \",\") {\n            variableIdxs.push(iter.nextSignedVLQ());\n          }\n\n          this.#handleOriginalScopeVariablesItem(variableIdxs);\n          break;\n        }\n        case Tag.ORIGINAL_SCOPE_END: {\n          this.#handleOriginalScopeEndItem(\n            iter.nextUnsignedVLQ(),\n            iter.nextUnsignedVLQ(),\n          );\n          break;\n        }\n        case Tag.GENERATED_RANGE_START: {\n          const flags = iter.nextUnsignedVLQ();\n          const line = flags & GeneratedRangeFlags.HAS_LINE\n            ? iter.nextUnsignedVLQ()\n            : undefined;\n          const column = iter.nextUnsignedVLQ();\n\n          const definitionIdx = flags & GeneratedRangeFlags.HAS_DEFINITION\n            ? iter.nextSignedVLQ()\n            : undefined;\n\n          this.#handleGeneratedRangeStartItem({\n            flags,\n            line,\n            column,\n            definitionIdx,\n          });\n          break;\n        }\n        case Tag.GENERATED_RANGE_END: {\n          const lineOrColumn = iter.nextUnsignedVLQ();\n          const maybeColumn = iter.hasNext() && iter.peek() !== \",\"\n            ? iter.nextUnsignedVLQ()\n            : undefined;\n\n          if (maybeColumn !== undefined) {\n            this.#handleGeneratedRangeEndItem(lineOrColumn, maybeColumn);\n          } else {\n            this.#handleGeneratedRangeEndItem(0, lineOrColumn);\n          }\n          break;\n        }\n        case Tag.GENERATED_RANGE_BINDINGS: {\n          const valueIdxs: number[] = [];\n\n          while (iter.hasNext() && iter.peek() !== \",\") {\n            valueIdxs.push(iter.nextUnsignedVLQ());\n          }\n\n          this.#handleGeneratedRangeBindingsItem(valueIdxs);\n          break;\n        }\n        case Tag.GENERATED_RANGE_SUBRANGE_BINDING: {\n          const variableIndex = iter.nextUnsignedVLQ();\n          const bindings: [number, number, number][] = [];\n\n          while (iter.hasNext() && iter.peek() !== \",\") {\n            bindings.push([\n              iter.nextUnsignedVLQ(),\n              iter.nextUnsignedVLQ(),\n              iter.nextUnsignedVLQ(),\n            ]);\n          }\n\n          this.#recordGeneratedSubRangeBindingItem(variableIndex, bindings);\n          break;\n        }\n        case Tag.GENERATED_RANGE_CALL_SITE: {\n          this.#handleGeneratedRangeCallSite(\n            iter.nextUnsignedVLQ(),\n            iter.nextUnsignedVLQ(),\n            iter.nextUnsignedVLQ(),\n          );\n          break;\n        }\n      }\n\n      // Consume any trailing VLQ and the the \",\"\n      while (iter.hasNext() && iter.peek() !== \",\") iter.nextUnsignedVLQ();\n      if (iter.hasNext()) iter.nextChar();\n    }\n\n    if (iter.currentChar() === \",\") {\n      // Handle trailing EmptyItem.\n      this.#scopes.push(null);\n    }\n\n    if (this.#scopeStack.length > 0) {\n      this.#throwInStrictMode(\n        \"Encountered ORIGINAL_SCOPE_START without matching END!\",\n      );\n    }\n    if (this.#rangeStack.length > 0) {\n      this.#throwInStrictMode(\n        \"Encountered GENERATED_RANGE_START without matching END!\",\n      );\n    }\n\n    const info = { scopes: this.#scopes, ranges: this.#ranges };\n\n    this.#scopes = [];\n    this.#ranges = [];\n    this.#flatOriginalScopes = [];\n\n    return info;\n  }\n\n  #throwInStrictMode(message: string) {\n    if (this.#mode === DecodeMode.STRICT) throw new Error(message);\n  }\n\n  #handleOriginalScopeStartItem(item: OriginalScopeStartItem) {\n    this.#scopeState.line += item.line;\n    if (item.line === 0) {\n      this.#scopeState.column += item.column;\n    } else {\n      this.#scopeState.column = item.column;\n    }\n    const scope: OriginalScope = {\n      start: { line: this.#scopeState.line, column: this.#scopeState.column },\n      end: { line: this.#scopeState.line, column: this.#scopeState.column },\n      isStackFrame: false,\n      variables: [],\n      children: [],\n    };\n\n    if (item.nameIdx !== undefined) {\n      this.#scopeState.name += item.nameIdx;\n      scope.name = this.#resolveName(this.#scopeState.name);\n    }\n    if (item.kindIdx !== undefined) {\n      this.#scopeState.kind += item.kindIdx;\n      scope.kind = this.#resolveName(this.#scopeState.kind);\n    }\n\n    scope.isStackFrame = Boolean(\n      item.flags & OriginalScopeFlags.IS_STACK_FRAME,\n    );\n\n    this.#scopeStack.push(scope);\n    this.#flatOriginalScopes.push(scope);\n  }\n\n  #handleOriginalScopeVariablesItem(variableIdxs: number[]) {\n    const scope = this.#scopeStack.at(-1);\n    if (!scope) {\n      this.#throwInStrictMode(\n        \"Encountered ORIGINAL_SCOPE_VARIABLES without surrounding ORIGINAL_SCOPE_START\",\n      );\n      return;\n    }\n\n    for (const variableIdx of variableIdxs) {\n      this.#scopeState.variable += variableIdx;\n      scope.variables.push(this.#resolveName(this.#scopeState.variable));\n    }\n  }\n\n  #handleOriginalScopeEndItem(line: number, column: number) {\n    this.#scopeState.line += line;\n    if (line === 0) {\n      this.#scopeState.column += column;\n    } else {\n      this.#scopeState.column = column;\n    }\n\n    const scope = this.#scopeStack.pop();\n    if (!scope) {\n      this.#throwInStrictMode(\n        \"Encountered ORIGINAL_SCOPE_END without matching ORIGINAL_SCOPE_START!\",\n      );\n      return;\n    }\n\n    scope.end = {\n      line: this.#scopeState.line,\n      column: this.#scopeState.column,\n    };\n\n    if (this.#scopeStack.length > 0) {\n      const parent = this.#scopeStack.at(-1)!;\n      scope.parent = parent;\n      parent.children.push(scope);\n    } else {\n      this.#scopes.push(scope);\n      this.#scopeState.line = 0;\n      this.#scopeState.column = 0;\n    }\n  }\n\n  #handleGeneratedRangeStartItem(item: GeneratedRangeStartItem) {\n    if (item.line !== undefined) {\n      this.#rangeState.line += item.line;\n      this.#rangeState.column = item.column;\n    } else {\n      this.#rangeState.column += item.column;\n    }\n\n    const range: GeneratedRange = {\n      start: {\n        line: this.#rangeState.line,\n        column: this.#rangeState.column,\n      },\n      end: {\n        line: this.#rangeState.line,\n        column: this.#rangeState.column,\n      },\n      isStackFrame: Boolean(\n        item.flags & GeneratedRangeFlags.IS_STACK_FRAME,\n      ),\n      isHidden: Boolean(item.flags & GeneratedRangeFlags.IS_HIDDEN),\n      values: [],\n      children: [],\n    };\n\n    if (item.definitionIdx !== undefined) {\n      this.#rangeState.defScopeIdx += item.definitionIdx;\n      if (\n        this.#rangeState.defScopeIdx < 0 ||\n        this.#rangeState.defScopeIdx >= this.#flatOriginalScopes.length\n      ) {\n        this.#throwInStrictMode(\"Invalid definition scope index\");\n      } else {\n        range.originalScope =\n          this.#flatOriginalScopes[this.#rangeState.defScopeIdx];\n      }\n    }\n\n    this.#rangeStack.push(range);\n    this.#subRangeBindingsForRange.clear();\n  }\n\n  #handleGeneratedRangeBindingsItem(valueIdxs: number[]) {\n    const range = this.#rangeStack.at(-1);\n    if (!range) {\n      this.#throwInStrictMode(\n        \"Encountered GENERATED_RANGE_BINDINGS without surrounding GENERATED_RANGE_START\",\n      );\n      return;\n    }\n\n    for (const valueIdx of valueIdxs) {\n      if (valueIdx === 0) {\n        range.values.push(null);\n      } else {\n        range.values.push(this.#resolveName(valueIdx - 1));\n      }\n    }\n  }\n\n  #recordGeneratedSubRangeBindingItem(\n    variableIndex: number,\n    bindings: [number, number, number][],\n  ) {\n    if (this.#subRangeBindingsForRange.has(variableIndex)) {\n      this.#throwInStrictMode(\n        \"Encountered multiple GENERATED_RANGE_SUBRANGE_BINDING items for the same variable\",\n      );\n      return;\n    }\n    this.#subRangeBindingsForRange.set(variableIndex, bindings);\n  }\n\n  #handleGeneratedRangeCallSite(\n    sourceIndex: number,\n    line: number,\n    column: number,\n  ) {\n    const range = this.#rangeStack.at(-1);\n    if (!range) {\n      this.#throwInStrictMode(\n        \"Encountered GENERATED_RANGE_CALL_SITE without surrounding GENERATED_RANGE_START\",\n      );\n      return;\n    }\n\n    range.callSite = {\n      sourceIndex,\n      line,\n      column,\n    };\n  }\n\n  #handleGeneratedRangeEndItem(line: number, column: number) {\n    if (line !== 0) {\n      this.#rangeState.line += line;\n      this.#rangeState.column = column;\n    } else {\n      this.#rangeState.column += column;\n    }\n\n    const range = this.#rangeStack.pop();\n    if (!range) {\n      this.#throwInStrictMode(\n        \"Encountered GENERATED_RANGE_END without matching GENERATED_RANGE_START!\",\n      );\n      return;\n    }\n\n    range.end = {\n      line: this.#rangeState.line,\n      column: this.#rangeState.column,\n    };\n\n    this.#handleGeneratedRangeSubRangeBindings(range);\n\n    if (this.#rangeStack.length > 0) {\n      const parent = this.#rangeStack.at(-1)!;\n      range.parent = parent;\n      parent.children.push(range);\n    } else {\n      this.#ranges.push(range);\n    }\n  }\n\n  #handleGeneratedRangeSubRangeBindings(range: GeneratedRange) {\n    for (const [variableIndex, bindings] of this.#subRangeBindingsForRange) {\n      const value = range.values[variableIndex];\n      const subRanges: SubRangeBinding[] = [];\n      range.values[variableIndex] = subRanges;\n\n      let lastLine = range.start.line;\n      let lastColumn = range.start.column;\n\n      subRanges.push({\n        from: { line: lastLine, column: lastColumn },\n        to: { line: 0, column: 0 },\n        value: value as string | undefined,\n      });\n\n      for (const [binding, line, column] of bindings) {\n        lastLine += line;\n        if (line === 0) {\n          lastColumn += column;\n        } else {\n          lastColumn = column;\n        }\n\n        subRanges.push({\n          from: { line: lastLine, column: lastColumn },\n          to: { line: 0, column: 0 }, // This will be fixed in the post-processing step.\n          value: binding === 0 ? undefined : this.#resolveName(binding - 1),\n        });\n      }\n    }\n\n    for (const value of range.values) {\n      if (Array.isArray(value)) {\n        const subRanges = value;\n        for (let i = 0; i < subRanges.length - 1; ++i) {\n          subRanges[i].to = subRanges[i + 1].from;\n        }\n        subRanges[subRanges.length - 1].to = range.end;\n      }\n    }\n  }\n\n  #resolveName(index: number): string {\n    if (index < 0 || index >= this.#names.length) {\n      this.#throwInStrictMode(\"Illegal index into the 'names' array\");\n    }\n    return this.#names[index] ?? \"\";\n  }\n}\n", "// Copyright 2025 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type {\n  Binding,\n  GeneratedRange,\n  OriginalPosition,\n  OriginalScope,\n  ScopeInfo,\n} from \"../scopes.d.ts\";\n\n/**\n * Small utility class to build scope and range trees.\n *\n * This class allows construction of scope/range trees that will be rejected by the encoder.\n * Use this class if you guarantee proper nesting yourself and don't want to pay for the\n * checks, otherwise use the `SafeScopeInfoBuilder`.\n *\n * This class will also silently ignore calls that would fail otherwise. E.g. calling\n * `end*` without a matching `start*`.\n */\nexport class ScopeInfoBuilder {\n  #scopes: (OriginalScope | null)[] = [];\n  #ranges: GeneratedRange[] = [];\n\n  #scopeStack: OriginalScope[] = [];\n  #rangeStack: GeneratedRange[] = [];\n\n  #knownScopes = new Set<OriginalScope>();\n  #keyToScope = new Map<ScopeKey, OriginalScope>();\n  #lastScope: OriginalScope | null = null;\n\n  addNullScope(): this {\n    this.#scopes.push(null);\n    return this;\n  }\n\n  startScope(\n    line: number,\n    column: number,\n    options?: {\n      name?: string;\n      kind?: string;\n      isStackFrame?: boolean;\n      variables?: string[];\n      key?: ScopeKey;\n    },\n  ): this {\n    const scope: OriginalScope = {\n      start: { line, column },\n      end: { line, column },\n      variables: options?.variables?.slice(0) ?? [],\n      children: [],\n      isStackFrame: Boolean(options?.isStackFrame),\n    };\n\n    if (options?.name !== undefined) scope.name = options.name;\n    if (options?.kind !== undefined) scope.kind = options.kind;\n\n    if (this.#scopeStack.length > 0) {\n      scope.parent = this.#scopeStack.at(-1);\n    }\n    this.#scopeStack.push(scope);\n    this.#knownScopes.add(scope);\n    if (options?.key !== undefined) this.#keyToScope.set(options.key, scope);\n\n    return this;\n  }\n\n  setScopeName(name: string): this {\n    const scope = this.#scopeStack.at(-1);\n    if (scope) scope.name = name;\n    return this;\n  }\n\n  setScopeKind(kind: string): this {\n    const scope = this.#scopeStack.at(-1);\n    if (scope) scope.kind = kind;\n    return this;\n  }\n\n  setScopeStackFrame(isStackFrame: boolean): this {\n    const scope = this.#scopeStack.at(-1);\n    if (scope) scope.isStackFrame = isStackFrame;\n    return this;\n  }\n\n  setScopeVariables(variables: string[]): this {\n    const scope = this.#scopeStack.at(-1);\n    if (scope) scope.variables = variables.slice(0);\n\n    return this;\n  }\n\n  endScope(line: number, column: number): this {\n    const scope = this.#scopeStack.pop();\n    if (!scope) return this;\n\n    scope.end = { line, column };\n\n    if (this.#scopeStack.length === 0) {\n      this.#scopes.push(scope);\n    } else {\n      this.#scopeStack.at(-1)!.children.push(scope);\n    }\n    this.#lastScope = scope;\n\n    return this;\n  }\n\n  /**\n   * @returns The OriginalScope opened with the most recent `startScope` call, but not yet closed.\n   */\n  currentScope(): OriginalScope | null {\n    return this.#scopeStack.at(-1) ?? null;\n  }\n\n  /**\n   * @returns The most recent OriginalScope closed with `endScope`.\n   */\n  lastScope(): OriginalScope | null {\n    return this.#lastScope;\n  }\n\n  /**\n   * @param option The definition 'scope' of this range can either be the \"OriginalScope\" directly\n   * (produced by this builder) or the scope's key set while building the scope.\n   */\n  startRange(\n    line: number,\n    column: number,\n    options?: {\n      scope?: OriginalScope;\n      scopeKey?: ScopeKey;\n      isStackFrame?: boolean;\n      isHidden?: boolean;\n      values?: Binding[];\n      callSite?: OriginalPosition;\n    },\n  ): this {\n    const range: GeneratedRange = {\n      start: { line, column },\n      end: { line, column },\n      isStackFrame: Boolean(options?.isStackFrame),\n      isHidden: Boolean(options?.isHidden),\n      values: options?.values ?? [],\n      children: [],\n    };\n\n    if (this.#rangeStack.length > 0) {\n      range.parent = this.#rangeStack.at(-1);\n    }\n\n    if (options?.scope !== undefined) {\n      range.originalScope = options.scope;\n    } else if (options?.scopeKey !== undefined) {\n      range.originalScope = this.#keyToScope.get(options.scopeKey);\n    }\n\n    if (options?.callSite) {\n      range.callSite = options.callSite;\n    }\n\n    this.#rangeStack.push(range);\n\n    return this;\n  }\n\n  setRangeDefinitionScope(scope: OriginalScope): this {\n    const range = this.#rangeStack.at(-1);\n    if (range) range.originalScope = scope;\n    return this;\n  }\n\n  setRangeDefinitionScopeKey(scopeKey: ScopeKey): this {\n    const range = this.#rangeStack.at(-1);\n    if (range) range.originalScope = this.#keyToScope.get(scopeKey);\n    return this;\n  }\n\n  setRangeStackFrame(isStackFrame: boolean): this {\n    const range = this.#rangeStack.at(-1);\n    if (range) range.isStackFrame = isStackFrame;\n\n    return this;\n  }\n\n  setRangeHidden(isHidden: boolean): this {\n    const range = this.#rangeStack.at(-1);\n    if (range) range.isHidden = isHidden;\n\n    return this;\n  }\n\n  setRangeValues(values: Binding[]): this {\n    const range = this.#rangeStack.at(-1);\n    if (range) range.values = values;\n\n    return this;\n  }\n\n  setRangeCallSite(callSite: OriginalPosition): this {\n    const range = this.#rangeStack.at(-1);\n    if (range) range.callSite = callSite;\n\n    return this;\n  }\n\n  endRange(line: number, column: number): this {\n    const range = this.#rangeStack.pop();\n    if (!range) return this;\n\n    range.end = { line, column };\n\n    if (this.#rangeStack.length === 0) {\n      this.#ranges.push(range);\n    } else {\n      this.#rangeStack.at(-1)!.children.push(range);\n    }\n\n    return this;\n  }\n\n  build(): ScopeInfo {\n    const info: ScopeInfo = { scopes: this.#scopes, ranges: this.#ranges };\n\n    this.#scopes = [];\n    this.#ranges = [];\n    this.#knownScopes.clear();\n\n    return info;\n  }\n\n  protected get scopeStack(): ReadonlyArray<OriginalScope> {\n    return this.#scopeStack;\n  }\n\n  protected get rangeStack(): ReadonlyArray<GeneratedRange> {\n    return this.#rangeStack;\n  }\n\n  protected isKnownScope(scope: OriginalScope): boolean {\n    return this.#knownScopes.has(scope);\n  }\n\n  protected isValidScopeKey(key: ScopeKey): boolean {\n    return this.#keyToScope.has(key);\n  }\n\n  protected getScopeByValidKey(key: ScopeKey): OriginalScope {\n    return this.#keyToScope.get(key)!;\n  }\n}\n\n/**\n * Users of the {@link ScopeInfoBuilder} can provide their own keys to uniquely identify a scope,\n * and use the key later when building the corresponding range to connect them.\n *\n * The only requirement for ScopeKey is that it can be used as a key in a `Map`.\n */\nexport type ScopeKey = unknown;\n", "// Copyright 2025 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type {\n  Binding,\n  OriginalPosition,\n  OriginalScope,\n  Position,\n  ScopeInfo,\n} from \"../scopes.d.ts\";\nimport { comparePositions } from \"../util.js\";\nimport { ScopeInfoBuilder, type ScopeKey } from \"./builder.js\";\n\n/**\n * Similar to `ScopeInfoBuilder`, but with checks that scopes/ranges are well\n * nested and don't partially overlap.\n */\nexport class SafeScopeInfoBuilder extends ScopeInfoBuilder {\n  override addNullScope(): this {\n    this.#verifyEmptyScopeStack(\"add null scope\");\n    this.#verifyEmptyRangeStack(\"add null scope\");\n\n    super.addNullScope();\n    return this;\n  }\n\n  override startScope(\n    line: number,\n    column: number,\n    options?: {\n      name?: string;\n      kind?: string;\n      isStackFrame?: boolean;\n      variables?: string[];\n      key?: ScopeKey;\n    },\n  ): this {\n    this.#verifyEmptyRangeStack(\"start scope\");\n\n    const parent = this.scopeStack.at(-1);\n\n    if (parent && comparePositions(parent.start, { line, column }) > 0) {\n      throw new Error(\n        `Scope start (${line}, ${column}) must not precede parent start (${parent.start.line}, ${parent.start.column})`,\n      );\n    }\n\n    const precedingSibling = parent?.children.at(-1);\n    if (\n      precedingSibling &&\n      comparePositions(precedingSibling.end, { line, column }) > 0\n    ) {\n      throw new Error(\n        `Scope start (${line}, ${column}) must not precede preceding siblings' end (${precedingSibling\n          .end.line,\n          precedingSibling.end.column})`,\n      );\n    }\n\n    super.startScope(line, column, options);\n    return this;\n  }\n\n  override setScopeName(name: string): this {\n    this.#verifyScopePresent(\"setScopeName\");\n    this.#verifyEmptyRangeStack(\"setScopeName\");\n\n    super.setScopeName(name);\n    return this;\n  }\n\n  override setScopeKind(kind: string): this {\n    this.#verifyScopePresent(\"setScopeKind\");\n    this.#verifyEmptyRangeStack(\"setScopeKind\");\n\n    super.setScopeKind(kind);\n    return this;\n  }\n\n  override setScopeStackFrame(isStackFrame: boolean): this {\n    this.#verifyScopePresent(\"setScopeStackFrame\");\n    this.#verifyEmptyRangeStack(\"setScopeStackFrame\");\n\n    super.setScopeStackFrame(isStackFrame);\n    return this;\n  }\n\n  override setScopeVariables(variables: string[]): this {\n    this.#verifyScopePresent(\"setScopeVariables\");\n    this.#verifyEmptyRangeStack(\"setScopeVariables\");\n\n    super.setScopeVariables(variables);\n    return this;\n  }\n\n  override endScope(line: number, column: number): this {\n    this.#verifyEmptyRangeStack(\"end scope\");\n\n    if (this.scopeStack.length === 0) {\n      throw new Error(\"No scope to end\");\n    }\n\n    const scope = this.scopeStack.at(-1) as OriginalScope;\n    if (comparePositions(scope.start, { line, column }) > 0) {\n      throw new Error(\n        `Scope end (${line}, ${column}) must not precede scope start (${scope.start.line}, ${scope.start.column})`,\n      );\n    }\n\n    super.endScope(line, column);\n    return this;\n  }\n\n  override startRange(\n    line: number,\n    column: number,\n    options?: {\n      scope?: OriginalScope;\n      scopeKey?: ScopeKey;\n      isStackFrame?: boolean;\n      isHidden?: boolean;\n      values?: Binding[];\n      callSite?: OriginalPosition;\n    },\n  ): this {\n    this.#verifyEmptyScopeStack(\"starRange\");\n\n    const parent = this.rangeStack.at(-1);\n    if (parent && comparePositions(parent.start, { line, column }) > 0) {\n      throw new Error(\n        `Range start (${line}, ${column}) must not precede parent start (${parent.start.line}, ${parent.start.column})`,\n      );\n    }\n\n    const precedingSibling = parent?.children.at(-1);\n    if (\n      precedingSibling &&\n      comparePositions(precedingSibling.end, { line, column }) > 0\n    ) {\n      throw new Error(\n        `Range start (${line}, ${column}) must not precede preceding siblings' end (${precedingSibling\n          .end.line,\n          precedingSibling.end.column})`,\n      );\n    }\n\n    if (\n      options?.scopeKey !== undefined &&\n      !this.isValidScopeKey(options.scopeKey)\n    ) {\n      throw new Error(\n        `${options.scopeKey} does not reference a valid OriginalScope`,\n      );\n    }\n    if (options?.scope && !this.isKnownScope(options.scope)) {\n      throw new Error(\n        \"The provided definition scope was not produced by this builder!\",\n      );\n    }\n\n    if (\n      options?.values?.length && options?.scope === undefined &&\n      options?.scopeKey === undefined\n    ) {\n      throw new Error(\"Provided bindings without providing an OriginalScope\");\n    } else if (\n      options?.values?.length && options?.scope &&\n      options.values.length !== options.scope.variables.length\n    ) {\n      throw new Error(\n        \"Provided bindings don't match up with OriginalScope.variables\",\n      );\n    } else if (options?.values?.length && options?.scopeKey !== undefined) {\n      const scope = this.getScopeByValidKey(options.scopeKey);\n      if (options.values.length !== scope.variables.length) {\n        throw new Error(\n          \"Provided bindings don't match up with OriginalScope.variables\",\n        );\n      }\n    }\n\n    super.startRange(line, column, options);\n    return this;\n  }\n\n  override setRangeDefinitionScope(scope: OriginalScope): this {\n    this.#verifyEmptyScopeStack(\"setRangeDefinitionScope\");\n    this.#verifyRangePresent(\"setRangeDefinitionScope\");\n\n    if (!this.isKnownScope(scope)) {\n      throw new Error(\n        \"The provided definition scope was not produced by this builder!\",\n      );\n    }\n\n    super.setRangeDefinitionScope(scope);\n    return this;\n  }\n\n  override setRangeDefinitionScopeKey(scopeKey: ScopeKey): this {\n    this.#verifyEmptyScopeStack(\"setRangeDefinitionScope\");\n    this.#verifyRangePresent(\"setRangeDefinitionScope\");\n\n    if (!this.isValidScopeKey(scopeKey)) {\n      throw new Error(\n        `The provided scope key ${scopeKey} is not know nto the builder!`,\n      );\n    }\n\n    super.setRangeDefinitionScopeKey(scopeKey);\n    return this;\n  }\n\n  override setRangeStackFrame(isStackFrame: boolean): this {\n    this.#verifyEmptyScopeStack(\"setRangeStackFrame\");\n    this.#verifyRangePresent(\"setRangeStackFrame\");\n\n    super.setRangeStackFrame(isStackFrame);\n    return this;\n  }\n\n  override setRangeHidden(isHidden: boolean): this {\n    this.#verifyEmptyScopeStack(\"setRangeHidden\");\n    this.#verifyRangePresent(\"setRangeHidden\");\n\n    super.setRangeHidden(isHidden);\n    return this;\n  }\n\n  override setRangeValues(values: Binding[]): this {\n    this.#verifyEmptyScopeStack(\"setRangeValues\");\n    this.#verifyRangePresent(\"setRangeValues\");\n\n    const range = this.rangeStack.at(-1)!;\n    if (!range.originalScope) {\n      throw new Error(\n        \"Setting an OriginalScope for a range is required before value bindings can be provided!\",\n      );\n    } else if (range.originalScope.variables.length !== values.length) {\n      throw new Error(\n        \"Provided bindings don't match up with OriginalScope.variables\",\n      );\n    }\n\n    super.setRangeValues(values);\n    return this;\n  }\n\n  override setRangeCallSite(callSite: OriginalPosition): this {\n    this.#verifyEmptyScopeStack(\"setRangeCallSite\");\n    this.#verifyRangePresent(\"setRangeCallSite\");\n\n    super.setRangeCallSite(callSite);\n    return this;\n  }\n\n  override endRange(line: number, column: number): this {\n    this.#verifyEmptyScopeStack(\"endRange\");\n\n    if (this.rangeStack.length === 0) {\n      throw new Error(\"No range to end\");\n    }\n\n    const range = this.rangeStack.at(-1)!;\n    if (comparePositions(range.start, { line, column }) > 0) {\n      throw new Error(\n        `Range end (${line}, ${column}) must not precede range start (${range.start.line}, ${range.start.column})`,\n      );\n    }\n\n    this.#verifyRangeValues(range, { line, column });\n    super.endRange(line, column);\n    return this;\n  }\n\n  override build(): ScopeInfo {\n    if (this.scopeStack.length > 0) {\n      throw new Error(\n        \"Can't build ScopeInfo while an OriginalScope is unclosed.\",\n      );\n    }\n    this.#verifyEmptyRangeStack(\"build ScopeInfo\");\n\n    return super.build();\n  }\n\n  #verifyEmptyScopeStack(op: string): void {\n    if (this.scopeStack.length > 0) {\n      throw new Error(`Can't ${op} while a OriginalScope is unclosed.`);\n    }\n  }\n\n  #verifyEmptyRangeStack(op: string): void {\n    if (this.rangeStack.length > 0) {\n      throw new Error(`Can't ${op} while a GeneratedRange is unclosed.`);\n    }\n  }\n\n  #verifyScopePresent(op: string): void {\n    if (this.scopeStack.length === 0) {\n      throw new Error(`Can't ${op} while no OriginalScope is on the stack.`);\n    }\n  }\n\n  #verifyRangePresent(op: string): void {\n    if (this.rangeStack.length === 0) {\n      throw new Error(`Can't ${op} while no GeneratedRange is on the stack.`);\n    }\n  }\n\n  #verifyRangeValues(\n    range: { start: Position; values: Binding[] },\n    end: Position,\n  ): void {\n    for (const value of range.values) {\n      if (!Array.isArray(value)) {\n        continue;\n      }\n\n      const subRanges = value;\n      if (subRanges.length === 0) {\n        continue;\n      }\n\n      const first = subRanges.at(0)!;\n      if (comparePositions(first.from, range.start) !== 0) {\n        throw new Error(\n          `Sub-range bindings must start at the generated range's start. Expected ${range.start.line}:${range.start.column}, but got ${first.from.line}:${first.from.column}`,\n        );\n      }\n\n      const last = subRanges.at(-1)!;\n      if (comparePositions(last.to, end) !== 0) {\n        throw new Error(\n          `Sub-range bindings must end at the generated range's end. Expected ${end.line}:${end.column}, but got ${last.to.line}:${last.to.column}`,\n        );\n      }\n\n      for (let i = 0; i < subRanges.length; ++i) {\n        const current = subRanges[i];\n        if (comparePositions(current.from, current.to) >= 0) {\n          throw new Error(\n            `Sub-range binding 'from' (${current.from.line}:${current.from.column}) must precede 'to' (${current.to.line}:${current.to.column})`,\n          );\n        }\n\n        if (i > 0) {\n          const prev = subRanges[i - 1];\n          if (comparePositions(prev.to, current.from) !== 0) {\n            throw new Error(\n              `Sub-range bindings must be sorted and not overlap. Found gap between ${prev.to.line}:${prev.to.column} and ${current.from.line}:${current.from.column}`,\n            );\n          }\n        }\n      }\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["DEFAULT_SCOPE_STATE", "DEFAULT_RANGE_STATE"]
}
