{
  "version": 3,
  "sources": ["package/dist/modules/lib/bfcache.js", "package/dist/modules/lib/bindReporter.js", "package/dist/modules/lib/doubleRAF.js", "package/dist/modules/lib/generateUniqueID.js", "package/dist/modules/lib/getNavigationEntry.js", "package/dist/modules/lib/getActivationStart.js", "package/dist/modules/lib/initMetric.js", "package/dist/modules/lib/initUnique.js", "package/dist/modules/lib/LayoutShiftManager.js", "package/dist/modules/lib/observe.js", "package/dist/modules/lib/runOnce.js", "package/dist/modules/lib/getVisibilityWatcher.js", "package/dist/modules/lib/whenActivated.js", "package/dist/modules/onFCP.js", "package/dist/modules/onCLS.js", "package/dist/modules/lib/polyfills/interactionCountPolyfill.js", "package/dist/modules/lib/InteractionManager.js", "package/dist/modules/lib/whenIdleOrHidden.js", "package/dist/modules/onINP.js", "package/dist/modules/lib/LCPEntryManager.js", "package/dist/modules/onLCP.js", "package/dist/modules/onTTFB.js", "package/dist/modules/attribution/index.js", "package/dist/modules/lib/getLoadState.js", "package/dist/modules/lib/getSelector.js", "package/dist/modules/attribution/onCLS.js", "package/dist/modules/attribution/onFCP.js", "package/dist/modules/attribution/onINP.js", "package/dist/modules/attribution/onLCP.js", "package/dist/modules/attribution/onTTFB.js"],
  "sourcesContent": ["/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nlet bfcacheRestoreTime = -1;\nexport const getBFCacheRestoreTime = () => bfcacheRestoreTime;\nexport const onBFCacheRestore = (cb) => {\n    addEventListener('pageshow', (event) => {\n        if (event.persisted) {\n            bfcacheRestoreTime = event.timeStamp;\n            cb(event);\n        }\n    }, true);\n};\n", "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst getRating = (value, thresholds) => {\n    if (value > thresholds[1]) {\n        return 'poor';\n    }\n    if (value > thresholds[0]) {\n        return 'needs-improvement';\n    }\n    return 'good';\n};\nexport const bindReporter = (callback, metric, thresholds, reportAllChanges) => {\n    let prevValue;\n    let delta;\n    return (forceReport) => {\n        if (metric.value >= 0) {\n            if (forceReport || reportAllChanges) {\n                delta = metric.value - (prevValue ?? 0);\n                // Report the metric if there's a non-zero delta or if no previous\n                // value exists (which can happen in the case of the document becoming\n                // hidden when the metric value is 0).\n                // See: https://github.com/GoogleChrome/web-vitals/issues/14\n                if (delta || prevValue === undefined) {\n                    prevValue = metric.value;\n                    metric.delta = delta;\n                    metric.rating = getRating(metric.value, thresholds);\n                    callback(metric);\n                }\n            }\n        }\n    };\n};\n", "/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport const doubleRAF = (cb) => {\n    requestAnimationFrame(() => requestAnimationFrame(() => cb()));\n};\n", "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Performantly generate a unique, 30-char string by combining a version\n * number, the current timestamp with a 13-digit number integer.\n * @return {string}\n */\nexport const generateUniqueID = () => {\n    return `v5-${Date.now()}-${Math.floor(Math.random() * (9e12 - 1)) + 1e12}`;\n};\n", "/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport const getNavigationEntry = () => {\n    const navigationEntry = performance.getEntriesByType('navigation')[0];\n    // Check to ensure the `responseStart` property is present and valid.\n    // In some cases a zero value is reported by the browser (for\n    // privacy/security reasons), and in other cases (bugs) the value is\n    // negative or is larger than the current page time. Ignore these cases:\n    // - https://github.com/GoogleChrome/web-vitals/issues/137\n    // - https://github.com/GoogleChrome/web-vitals/issues/162\n    // - https://github.com/GoogleChrome/web-vitals/issues/275\n    if (navigationEntry &&\n        navigationEntry.responseStart > 0 &&\n        navigationEntry.responseStart < performance.now()) {\n        return navigationEntry;\n    }\n};\n", "/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getNavigationEntry } from './getNavigationEntry.js';\nexport const getActivationStart = () => {\n    const navEntry = getNavigationEntry();\n    return navEntry?.activationStart ?? 0;\n};\n", "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getBFCacheRestoreTime } from './bfcache.js';\nimport { generateUniqueID } from './generateUniqueID.js';\nimport { getActivationStart } from './getActivationStart.js';\nimport { getNavigationEntry } from './getNavigationEntry.js';\nexport const initMetric = (name, value = -1) => {\n    const navEntry = getNavigationEntry();\n    let navigationType = 'navigate';\n    if (getBFCacheRestoreTime() >= 0) {\n        navigationType = 'back-forward-cache';\n    }\n    else if (navEntry) {\n        if (document.prerendering || getActivationStart() > 0) {\n            navigationType = 'prerender';\n        }\n        else if (document.wasDiscarded) {\n            navigationType = 'restore';\n        }\n        else if (navEntry.type) {\n            navigationType = navEntry.type.replace(/_/g, '-');\n        }\n    }\n    // Use `entries` type specific for the metric.\n    const entries = [];\n    return {\n        name,\n        value,\n        rating: 'good', // If needed, will be updated when reported. `const` to keep the type from widening to `string`.\n        delta: 0,\n        entries,\n        id: generateUniqueID(),\n        navigationType,\n    };\n};\n", "/*\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst instanceMap = new WeakMap();\n/**\n * A function that accepts and identity object and a class object and returns\n * either a new instance of that class or an existing instance, if the\n * identity object was previously used.\n */\nexport function initUnique(identityObj, ClassObj) {\n    if (!instanceMap.get(identityObj)) {\n        instanceMap.set(identityObj, new ClassObj());\n    }\n    return instanceMap.get(identityObj);\n}\n", "/*\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport class LayoutShiftManager {\n    _onAfterProcessingUnexpectedShift;\n    _sessionValue = 0;\n    _sessionEntries = [];\n    _processEntry(entry) {\n        // Only count layout shifts without recent user input.\n        if (entry.hadRecentInput)\n            return;\n        const firstSessionEntry = this._sessionEntries[0];\n        const lastSessionEntry = this._sessionEntries.at(-1);\n        // If the entry occurred less than 1 second after the previous entry\n        // and less than 5 seconds after the first entry in the session,\n        // include the entry in the current session. Otherwise, start a new\n        // session.\n        if (this._sessionValue &&\n            firstSessionEntry &&\n            lastSessionEntry &&\n            entry.startTime - lastSessionEntry.startTime < 1000 &&\n            entry.startTime - firstSessionEntry.startTime < 5000) {\n            this._sessionValue += entry.value;\n            this._sessionEntries.push(entry);\n        }\n        else {\n            this._sessionValue = entry.value;\n            this._sessionEntries = [entry];\n        }\n        this._onAfterProcessingUnexpectedShift?.(entry);\n    }\n}\n", "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Takes a performance entry type and a callback function, and creates a\n * `PerformanceObserver` instance that will observe the specified entry type\n * with buffering enabled and call the callback _for each entry_.\n *\n * This function also feature-detects entry support and wraps the logic in a\n * try/catch to avoid errors in unsupporting browsers.\n */\nexport const observe = (type, callback, opts = {}) => {\n    try {\n        if (PerformanceObserver.supportedEntryTypes.includes(type)) {\n            const po = new PerformanceObserver((list) => {\n                // Delay by a microtask to workaround a bug in Safari where the\n                // callback is invoked immediately, rather than in a separate task.\n                // See: https://github.com/GoogleChrome/web-vitals/issues/277\n                Promise.resolve().then(() => {\n                    callback(list.getEntries());\n                });\n            });\n            po.observe({ type, buffered: true, ...opts });\n            return po;\n        }\n    }\n    catch {\n        // Do nothing.\n    }\n    return;\n};\n", "/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport const runOnce = (cb) => {\n    let called = false;\n    return () => {\n        if (!called) {\n            cb();\n            called = true;\n        }\n    };\n};\n", "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { onBFCacheRestore } from './bfcache.js';\nimport { getActivationStart } from './getActivationStart.js';\nlet firstHiddenTime = -1;\nconst onHiddenFunctions = new Set();\nconst initHiddenTime = () => {\n    // If the document is hidden when this code runs, assume it was always\n    // hidden and the page was loaded in the background, with the one exception\n    // that visibility state is always 'hidden' during prerendering, so we have\n    // to ignore that case until prerendering finishes (see: `prerenderingchange`\n    // event logic below).\n    return document.visibilityState === 'hidden' && !document.prerendering\n        ? 0\n        : Infinity;\n};\nconst onVisibilityUpdate = (event) => {\n    // Handle changes to hidden state\n    if (document.visibilityState === 'hidden') {\n        if (event.type === 'visibilitychange') {\n            for (const onHiddenFunction of onHiddenFunctions) {\n                onHiddenFunction();\n            }\n        }\n        // If the document is 'hidden' and no previous hidden timestamp has been\n        // set (so is infinity), update it based on the current event data.\n        if (!isFinite(firstHiddenTime)) {\n            // If the event is a 'visibilitychange' event, it means the page was\n            // visible prior to this change, so the event timestamp is the first\n            // hidden time.\n            // However, if the event is not a 'visibilitychange' event, then it must\n            // be a 'prerenderingchange' event, and the fact that the document is\n            // still 'hidden' from the above check means the tab was activated\n            // in a background state and so has always been hidden.\n            firstHiddenTime = event.type === 'visibilitychange' ? event.timeStamp : 0;\n            // We no longer need the `prerenderingchange` event listener now we've\n            // set an initial init time so remove that\n            // (we'll keep the visibilitychange one for onHiddenFunction above)\n            removeEventListener('prerenderingchange', onVisibilityUpdate, true);\n        }\n    }\n};\nexport const getVisibilityWatcher = () => {\n    if (firstHiddenTime < 0) {\n        // Check if we have a previous hidden `visibility-state` performance entry.\n        const activationStart = getActivationStart();\n        /* eslint-disable indent */\n        const firstVisibilityStateHiddenTime = !document.prerendering\n            ? globalThis.performance\n                .getEntriesByType('visibility-state')\n                .filter((e) => e.name === 'hidden' && e.startTime > activationStart)[0]?.startTime\n            : undefined;\n        /* eslint-enable indent */\n        // Prefer that, but if it's not available and the document is hidden when\n        // this code runs, assume it was hidden since navigation start. This isn't\n        // a perfect heuristic, but it's the best we can do until the\n        // `visibility-state` performance entry becomes available in all browsers.\n        firstHiddenTime = firstVisibilityStateHiddenTime ?? initHiddenTime();\n        // Listen for visibility changes so we can handle things like bfcache\n        // restores and/or prerender without having to examine individual\n        // timestamps in detail and also for onHidden function calls.\n        addEventListener('visibilitychange', onVisibilityUpdate, true);\n        // IMPORTANT: when a page is prerendering, its `visibilityState` is\n        // 'hidden', so in order to account for cases where this module checks for\n        // visibility during prerendering, an additional check after prerendering\n        // completes is also required.\n        addEventListener('prerenderingchange', onVisibilityUpdate, true);\n        // Reset the time on bfcache restores.\n        onBFCacheRestore(() => {\n            // Schedule a task in order to track the `visibilityState` once it's\n            // had an opportunity to change to visible in all browsers.\n            // https://bugs.chromium.org/p/chromium/issues/detail?id=1133363\n            setTimeout(() => {\n                firstHiddenTime = initHiddenTime();\n            });\n        });\n    }\n    return {\n        get firstHiddenTime() {\n            return firstHiddenTime;\n        },\n        onHidden(cb) {\n            onHiddenFunctions.add(cb);\n        },\n    };\n};\n", "/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport const whenActivated = (callback) => {\n    if (document.prerendering) {\n        addEventListener('prerenderingchange', () => callback(), true);\n    }\n    else {\n        callback();\n    }\n};\n", "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { onBFCacheRestore } from './lib/bfcache.js';\nimport { bindReporter } from './lib/bindReporter.js';\nimport { doubleRAF } from './lib/doubleRAF.js';\nimport { getActivationStart } from './lib/getActivationStart.js';\nimport { getVisibilityWatcher } from './lib/getVisibilityWatcher.js';\nimport { initMetric } from './lib/initMetric.js';\nimport { observe } from './lib/observe.js';\nimport { whenActivated } from './lib/whenActivated.js';\n/** Thresholds for FCP. See https://web.dev/articles/fcp#what_is_a_good_fcp_score */\nexport const FCPThresholds = [1800, 3000];\n/**\n * Calculates the [FCP](https://web.dev/articles/fcp) value for the current page and\n * calls the `callback` function once the value is ready, along with the\n * relevant `paint` performance entry used to determine the value. The reported\n * value is a `DOMHighResTimeStamp`.\n */\nexport const onFCP = (onReport, opts = {}) => {\n    whenActivated(() => {\n        const visibilityWatcher = getVisibilityWatcher();\n        let metric = initMetric('FCP');\n        let report;\n        const handleEntries = (entries) => {\n            for (const entry of entries) {\n                if (entry.name === 'first-contentful-paint') {\n                    po.disconnect();\n                    // Only report if the page wasn't hidden prior to the first paint.\n                    if (entry.startTime < visibilityWatcher.firstHiddenTime) {\n                        // The activationStart reference is used because FCP should be\n                        // relative to page activation rather than navigation start if the\n                        // page was prerendered. But in cases where `activationStart` occurs\n                        // after the FCP, this time should be clamped at 0.\n                        metric.value = Math.max(entry.startTime - getActivationStart(), 0);\n                        metric.entries.push(entry);\n                        report(true);\n                    }\n                }\n            }\n        };\n        const po = observe('paint', handleEntries);\n        if (po) {\n            report = bindReporter(onReport, metric, FCPThresholds, opts.reportAllChanges);\n            // Only report after a bfcache restore if the `PerformanceObserver`\n            // successfully registered or the `paint` entry exists.\n            onBFCacheRestore((event) => {\n                metric = initMetric('FCP');\n                report = bindReporter(onReport, metric, FCPThresholds, opts.reportAllChanges);\n                doubleRAF(() => {\n                    metric.value = performance.now() - event.timeStamp;\n                    report(true);\n                });\n            });\n        }\n    });\n};\n", "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { onBFCacheRestore } from './lib/bfcache.js';\nimport { bindReporter } from './lib/bindReporter.js';\nimport { doubleRAF } from './lib/doubleRAF.js';\nimport { initMetric } from './lib/initMetric.js';\nimport { initUnique } from './lib/initUnique.js';\nimport { LayoutShiftManager } from './lib/LayoutShiftManager.js';\nimport { observe } from './lib/observe.js';\nimport { runOnce } from './lib/runOnce.js';\nimport { onFCP } from './onFCP.js';\nimport { getVisibilityWatcher } from './lib/getVisibilityWatcher.js';\n/** Thresholds for CLS. See https://web.dev/articles/cls#what_is_a_good_cls_score */\nexport const CLSThresholds = [0.1, 0.25];\n/**\n * Calculates the [CLS](https://web.dev/articles/cls) value for the current page and\n * calls the `callback` function once the value is ready to be reported, along\n * with all `layout-shift` performance entries that were used in the metric\n * value calculation. The reported value is a `double` (corresponding to a\n * [layout shift score](https://web.dev/articles/cls#layout_shift_score)).\n *\n * If the `reportAllChanges` configuration option is set to `true`, the\n * `callback` function will be called as soon as the value is initially\n * determined as well as any time the value changes throughout the page\n * lifespan.\n *\n * _**Important:** CLS should be continually monitored for changes throughout\n * the entire lifespan of a page\u2014including if the user returns to the page after\n * it's been hidden/backgrounded. However, since browsers often [will not fire\n * additional callbacks once the user has backgrounded a\n * page](https://developer.chrome.com/blog/page-lifecycle-api/#advice-hidden),\n * `callback` is always called when the page's visibility state changes to\n * hidden. As a result, the `callback` function might be called multiple times\n * during the same page load._\n */\nexport const onCLS = (onReport, opts = {}) => {\n    const visibilityWatcher = getVisibilityWatcher();\n    // Start monitoring FCP so we can only report CLS if FCP is also reported.\n    // Note: this is done to match the current behavior of CrUX.\n    onFCP(runOnce(() => {\n        let metric = initMetric('CLS', 0);\n        let report;\n        const layoutShiftManager = initUnique(opts, LayoutShiftManager);\n        const handleEntries = (entries) => {\n            for (const entry of entries) {\n                layoutShiftManager._processEntry(entry);\n            }\n            // If the current session value is larger than the current CLS value,\n            // update CLS and the entries contributing to it.\n            if (layoutShiftManager._sessionValue > metric.value) {\n                metric.value = layoutShiftManager._sessionValue;\n                metric.entries = layoutShiftManager._sessionEntries;\n                report();\n            }\n        };\n        const po = observe('layout-shift', handleEntries);\n        if (po) {\n            report = bindReporter(onReport, metric, CLSThresholds, opts.reportAllChanges);\n            visibilityWatcher.onHidden(() => {\n                handleEntries(po.takeRecords());\n                report(true);\n            });\n            // Only report after a bfcache restore if the `PerformanceObserver`\n            // successfully registered.\n            onBFCacheRestore(() => {\n                layoutShiftManager._sessionValue = 0;\n                metric = initMetric('CLS', 0);\n                report = bindReporter(onReport, metric, CLSThresholds, opts.reportAllChanges);\n                doubleRAF(() => report());\n            });\n            // Queue a task to report (if nothing else triggers a report first).\n            // This allows CLS to be reported as soon as FCP fires when\n            // `reportAllChanges` is true.\n            setTimeout(report);\n        }\n    }));\n};\n", "/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { observe } from '../observe.js';\nlet interactionCountEstimate = 0;\nlet minKnownInteractionId = Infinity;\nlet maxKnownInteractionId = 0;\nconst updateEstimate = (entries) => {\n    for (const entry of entries) {\n        if (entry.interactionId) {\n            minKnownInteractionId = Math.min(minKnownInteractionId, entry.interactionId);\n            maxKnownInteractionId = Math.max(maxKnownInteractionId, entry.interactionId);\n            interactionCountEstimate = maxKnownInteractionId\n                ? (maxKnownInteractionId - minKnownInteractionId) / 7 + 1\n                : 0;\n        }\n    }\n};\nlet po;\n/**\n * Returns the `interactionCount` value using the native API (if available)\n * or the polyfill estimate in this module.\n */\nexport const getInteractionCount = () => {\n    return po ? interactionCountEstimate : performance.interactionCount ?? 0;\n};\n/**\n * Feature detects native support or initializes the polyfill if needed.\n */\nexport const initInteractionCountPolyfill = () => {\n    if ('interactionCount' in performance || po)\n        return;\n    po = observe('event', updateEstimate, {\n        type: 'event',\n        buffered: true,\n        durationThreshold: 0,\n    });\n};\n", "/*\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getInteractionCount } from './polyfills/interactionCountPolyfill.js';\n// To prevent unnecessary memory usage on pages with lots of interactions,\n// store at most 10 of the longest interactions to consider as INP candidates.\nconst MAX_INTERACTIONS_TO_CONSIDER = 10;\n// Used to store the interaction count after a bfcache restore, since p98\n// interaction latencies should only consider the current navigation.\nlet prevInteractionCount = 0;\n/**\n * Returns the interaction count since the last bfcache restore (or for the\n * full page lifecycle if there were no bfcache restores).\n */\nconst getInteractionCountForNavigation = () => {\n    return getInteractionCount() - prevInteractionCount;\n};\nexport class InteractionManager {\n    /**\n     * A list of longest interactions on the page (by latency) sorted so the\n     * longest one is first. The list is at most MAX_INTERACTIONS_TO_CONSIDER\n     * long.\n     */\n    _longestInteractionList = [];\n    /**\n     * A mapping of longest interactions by their interaction ID.\n     * This is used for faster lookup.\n     */\n    _longestInteractionMap = new Map();\n    _onBeforeProcessingEntry;\n    _onAfterProcessingINPCandidate;\n    _resetInteractions() {\n        prevInteractionCount = getInteractionCount();\n        this._longestInteractionList.length = 0;\n        this._longestInteractionMap.clear();\n    }\n    /**\n     * Returns the estimated p98 longest interaction based on the stored\n     * interaction candidates and the interaction count for the current page.\n     */\n    _estimateP98LongestInteraction() {\n        const candidateInteractionIndex = Math.min(this._longestInteractionList.length - 1, Math.floor(getInteractionCountForNavigation() / 50));\n        return this._longestInteractionList[candidateInteractionIndex];\n    }\n    /**\n     * Takes a performance entry and adds it to the list of worst interactions\n     * if its duration is long enough to make it among the worst. If the\n     * entry is part of an existing interaction, it is merged and the latency\n     * and entries list is updated as needed.\n     */\n    _processEntry(entry) {\n        this._onBeforeProcessingEntry?.(entry);\n        // Skip further processing for entries that cannot be INP candidates.\n        if (!(entry.interactionId || entry.entryType === 'first-input'))\n            return;\n        // The least-long of the 10 longest interactions.\n        const minLongestInteraction = this._longestInteractionList.at(-1);\n        let interaction = this._longestInteractionMap.get(entry.interactionId);\n        // Only process the entry if it's possibly one of the ten longest,\n        // or if it's part of an existing interaction.\n        if (interaction ||\n            this._longestInteractionList.length < MAX_INTERACTIONS_TO_CONSIDER ||\n            // If the above conditions are false, `minLongestInteraction` will be set.\n            entry.duration > minLongestInteraction._latency) {\n            // If the interaction already exists, update it. Otherwise create one.\n            if (interaction) {\n                // If the new entry has a longer duration, replace the old entries,\n                // otherwise add to the array.\n                if (entry.duration > interaction._latency) {\n                    interaction.entries = [entry];\n                    interaction._latency = entry.duration;\n                }\n                else if (entry.duration === interaction._latency &&\n                    entry.startTime === interaction.entries[0].startTime) {\n                    interaction.entries.push(entry);\n                }\n            }\n            else {\n                interaction = {\n                    id: entry.interactionId,\n                    entries: [entry],\n                    _latency: entry.duration,\n                };\n                this._longestInteractionMap.set(interaction.id, interaction);\n                this._longestInteractionList.push(interaction);\n            }\n            // Sort the entries by latency (descending) and keep only the top ten.\n            this._longestInteractionList.sort((a, b) => b._latency - a._latency);\n            if (this._longestInteractionList.length > MAX_INTERACTIONS_TO_CONSIDER) {\n                const removedInteractions = this._longestInteractionList.splice(MAX_INTERACTIONS_TO_CONSIDER);\n                for (const interaction of removedInteractions) {\n                    this._longestInteractionMap.delete(interaction.id);\n                }\n            }\n            // Call any post-processing on the interaction\n            this._onAfterProcessingINPCandidate?.(interaction);\n        }\n    }\n}\n", "/*\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { runOnce } from './runOnce.js';\n/**\n * Runs the passed callback during the next idle period, or immediately\n * if the browser's visibility state is (or becomes) hidden.\n */\nexport const whenIdleOrHidden = (cb) => {\n    const rIC = globalThis.requestIdleCallback || setTimeout;\n    // If the document is hidden, run the callback immediately, otherwise\n    // race an idle callback with the next `visibilitychange` event.\n    if (document.visibilityState === 'hidden') {\n        cb();\n    }\n    else {\n        cb = runOnce(cb);\n        addEventListener('visibilitychange', cb, { once: true, capture: true });\n        rIC(() => {\n            cb();\n            // Remove the above event listener since no longer required.\n            // See: https://github.com/GoogleChrome/web-vitals/issues/622\n            removeEventListener('visibilitychange', cb, { capture: true });\n        });\n    }\n};\n", "/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { onBFCacheRestore } from './lib/bfcache.js';\nimport { bindReporter } from './lib/bindReporter.js';\nimport { initMetric } from './lib/initMetric.js';\nimport { initUnique } from './lib/initUnique.js';\nimport { InteractionManager } from './lib/InteractionManager.js';\nimport { observe } from './lib/observe.js';\nimport { initInteractionCountPolyfill } from './lib/polyfills/interactionCountPolyfill.js';\nimport { whenActivated } from './lib/whenActivated.js';\nimport { getVisibilityWatcher } from './lib/getVisibilityWatcher.js';\nimport { whenIdleOrHidden } from './lib/whenIdleOrHidden.js';\n/** Thresholds for INP. See https://web.dev/articles/inp#what_is_a_good_inp_score */\nexport const INPThresholds = [200, 500];\n// The default `durationThreshold` used across this library for observing\n// `event` entries via PerformanceObserver.\nconst DEFAULT_DURATION_THRESHOLD = 40;\n/**\n * Calculates the [INP](https://web.dev/articles/inp) value for the current\n * page and calls the `callback` function once the value is ready, along with\n * the `event` performance entries reported for that interaction. The reported\n * value is a `DOMHighResTimeStamp`.\n *\n * A custom `durationThreshold` configuration option can optionally be passed\n * to control what `event-timing` entries are considered for INP reporting. The\n * default threshold is `40`, which means INP scores of less than 40 will not\n * be reported. To avoid reporting no interactions in these cases, the library\n * will fall back to the input delay of the first interaction. Note that this\n * will not affect your 75th percentile INP value unless that value is also\n * less than 40 (well below the recommended\n * [good](https://web.dev/articles/inp#what_is_a_good_inp_score) threshold).\n *\n * If the `reportAllChanges` configuration option is set to `true`, the\n * `callback` function will be called as soon as the value is initially\n * determined as well as any time the value changes throughout the page\n * lifespan.\n *\n * _**Important:** INP should be continually monitored for changes throughout\n * the entire lifespan of a page\u2014including if the user returns to the page after\n * it's been hidden/backgrounded. However, since browsers often [will not fire\n * additional callbacks once the user has backgrounded a\n * page](https://developer.chrome.com/blog/page-lifecycle-api/#advice-hidden),\n * `callback` is always called when the page's visibility state changes to\n * hidden. As a result, the `callback` function might be called multiple times\n * during the same page load._\n */\nexport const onINP = (onReport, opts = {}) => {\n    // Return if the browser doesn't support all APIs needed to measure INP.\n    if (!(globalThis.PerformanceEventTiming &&\n        'interactionId' in PerformanceEventTiming.prototype)) {\n        return;\n    }\n    const visibilityWatcher = getVisibilityWatcher();\n    whenActivated(() => {\n        // TODO(philipwalton): remove once the polyfill is no longer needed.\n        initInteractionCountPolyfill();\n        let metric = initMetric('INP');\n        let report;\n        const interactionManager = initUnique(opts, InteractionManager);\n        const handleEntries = (entries) => {\n            // Queue the `handleEntries()` callback in the next idle task.\n            // This is needed to increase the chances that all event entries that\n            // occurred between the user interaction and the next paint\n            // have been dispatched. Note: there is currently an experiment\n            // running in Chrome (EventTimingKeypressAndCompositionInteractionId)\n            // 123+ that if rolled out fully may make this no longer necessary.\n            whenIdleOrHidden(() => {\n                for (const entry of entries) {\n                    interactionManager._processEntry(entry);\n                }\n                const inp = interactionManager._estimateP98LongestInteraction();\n                if (inp && inp._latency !== metric.value) {\n                    metric.value = inp._latency;\n                    metric.entries = inp.entries;\n                    report();\n                }\n            });\n        };\n        const po = observe('event', handleEntries, {\n            // Event Timing entries have their durations rounded to the nearest 8ms,\n            // so a duration of 40ms would be any event that spans 2.5 or more frames\n            // at 60Hz. This threshold is chosen to strike a balance between usefulness\n            // and performance. Running this callback for any interaction that spans\n            // just one or two frames is likely not worth the insight that could be\n            // gained.\n            durationThreshold: opts.durationThreshold ?? DEFAULT_DURATION_THRESHOLD,\n        });\n        report = bindReporter(onReport, metric, INPThresholds, opts.reportAllChanges);\n        if (po) {\n            // Also observe entries of type `first-input`. This is useful in cases\n            // where the first interaction is less than the `durationThreshold`.\n            po.observe({ type: 'first-input', buffered: true });\n            visibilityWatcher.onHidden(() => {\n                handleEntries(po.takeRecords());\n                report(true);\n            });\n            // Only report after a bfcache restore if the `PerformanceObserver`\n            // successfully registered.\n            onBFCacheRestore(() => {\n                interactionManager._resetInteractions();\n                metric = initMetric('INP');\n                report = bindReporter(onReport, metric, INPThresholds, opts.reportAllChanges);\n            });\n        }\n    });\n};\n", "/*\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport class LCPEntryManager {\n    _onBeforeProcessingEntry;\n    _processEntry(entry) {\n        this._onBeforeProcessingEntry?.(entry);\n    }\n}\n", "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { LCPEntryManager } from './lib/LCPEntryManager.js';\nimport { onBFCacheRestore } from './lib/bfcache.js';\nimport { bindReporter } from './lib/bindReporter.js';\nimport { doubleRAF } from './lib/doubleRAF.js';\nimport { getActivationStart } from './lib/getActivationStart.js';\nimport { getVisibilityWatcher } from './lib/getVisibilityWatcher.js';\nimport { initMetric } from './lib/initMetric.js';\nimport { initUnique } from './lib/initUnique.js';\nimport { observe } from './lib/observe.js';\nimport { runOnce } from './lib/runOnce.js';\nimport { whenActivated } from './lib/whenActivated.js';\nimport { whenIdleOrHidden } from './lib/whenIdleOrHidden.js';\n/** Thresholds for LCP. See https://web.dev/articles/lcp#what_is_a_good_lcp_score */\nexport const LCPThresholds = [2500, 4000];\n/**\n * Calculates the [LCP](https://web.dev/articles/lcp) value for the current page and\n * calls the `callback` function once the value is ready (along with the\n * relevant `largest-contentful-paint` performance entry used to determine the\n * value). The reported value is a `DOMHighResTimeStamp`.\n *\n * If the `reportAllChanges` configuration option is set to `true`, the\n * `callback` function will be called any time a new `largest-contentful-paint`\n * performance entry is dispatched, or once the final value of the metric has\n * been determined.\n */\nexport const onLCP = (onReport, opts = {}) => {\n    whenActivated(() => {\n        const visibilityWatcher = getVisibilityWatcher();\n        let metric = initMetric('LCP');\n        let report;\n        const lcpEntryManager = initUnique(opts, LCPEntryManager);\n        const handleEntries = (entries) => {\n            // If reportAllChanges is set then call this function for each entry,\n            // otherwise only consider the last one.\n            if (!opts.reportAllChanges) {\n                entries = entries.slice(-1);\n            }\n            for (const entry of entries) {\n                lcpEntryManager._processEntry(entry);\n                // Only report if the page wasn't hidden prior to LCP.\n                if (entry.startTime < visibilityWatcher.firstHiddenTime) {\n                    // The startTime attribute returns the value of the renderTime if it is\n                    // not 0, and the value of the loadTime otherwise. The activationStart\n                    // reference is used because LCP should be relative to page activation\n                    // rather than navigation start if the page was prerendered. But in cases\n                    // where `activationStart` occurs after the LCP, this time should be\n                    // clamped at 0.\n                    metric.value = Math.max(entry.startTime - getActivationStart(), 0);\n                    metric.entries = [entry];\n                    report();\n                }\n            }\n        };\n        const po = observe('largest-contentful-paint', handleEntries);\n        if (po) {\n            report = bindReporter(onReport, metric, LCPThresholds, opts.reportAllChanges);\n            // Ensure this logic only runs once, since it can be triggered from\n            // any of three different event listeners below.\n            const stopListening = runOnce(() => {\n                handleEntries(po.takeRecords());\n                po.disconnect();\n                report(true);\n            });\n            // Need a separate wrapper to ensure the `runOnce` function above is\n            // common for all three functions\n            const stopListeningWrapper = (event) => {\n                if (event.isTrusted) {\n                    // Wrap the listener in an idle callback so it's run in a separate\n                    // task to reduce potential INP impact.\n                    // https://github.com/GoogleChrome/web-vitals/issues/383\n                    whenIdleOrHidden(stopListening);\n                    removeEventListener(event.type, stopListeningWrapper, {\n                        capture: true,\n                    });\n                }\n            };\n            // Stop listening after input or visibilitychange.\n            // Note: while scrolling is an input that stops LCP observation, it's\n            // unreliable since it can be programmatically generated.\n            // See: https://github.com/GoogleChrome/web-vitals/issues/75\n            for (const type of ['keydown', 'click', 'visibilitychange']) {\n                addEventListener(type, stopListeningWrapper, {\n                    capture: true,\n                });\n            }\n            // Only report after a bfcache restore if the `PerformanceObserver`\n            // successfully registered.\n            onBFCacheRestore((event) => {\n                metric = initMetric('LCP');\n                report = bindReporter(onReport, metric, LCPThresholds, opts.reportAllChanges);\n                doubleRAF(() => {\n                    metric.value = performance.now() - event.timeStamp;\n                    report(true);\n                });\n            });\n        }\n    });\n};\n", "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { bindReporter } from './lib/bindReporter.js';\nimport { initMetric } from './lib/initMetric.js';\nimport { onBFCacheRestore } from './lib/bfcache.js';\nimport { getNavigationEntry } from './lib/getNavigationEntry.js';\nimport { getActivationStart } from './lib/getActivationStart.js';\nimport { whenActivated } from './lib/whenActivated.js';\n/** Thresholds for TTFB. See https://web.dev/articles/ttfb#what_is_a_good_ttfb_score */\nexport const TTFBThresholds = [800, 1800];\n/**\n * Runs in the next task after the page is done loading and/or prerendering.\n * @param callback\n */\nconst whenReady = (callback) => {\n    if (document.prerendering) {\n        whenActivated(() => whenReady(callback));\n    }\n    else if (document.readyState !== 'complete') {\n        addEventListener('load', () => whenReady(callback), true);\n    }\n    else {\n        // Queue a task so the callback runs after `loadEventEnd`.\n        setTimeout(callback);\n    }\n};\n/**\n * Calculates the [TTFB](https://web.dev/articles/ttfb) value for the\n * current page and calls the `callback` function once the page has loaded,\n * along with the relevant `navigation` performance entry used to determine the\n * value. The reported value is a `DOMHighResTimeStamp`.\n *\n * Note, this function waits until after the page is loaded to call `callback`\n * in order to ensure all properties of the `navigation` entry are populated.\n * This is useful if you want to report on other metrics exposed by the\n * [Navigation Timing API](https://w3c.github.io/navigation-timing/). For\n * example, the TTFB metric starts from the page's [time\n * origin](https://www.w3.org/TR/hr-time-2/#sec-time-origin), which means it\n * includes time spent on DNS lookup, connection negotiation, network latency,\n * and server processing time.\n */\nexport const onTTFB = (onReport, opts = {}) => {\n    let metric = initMetric('TTFB');\n    let report = bindReporter(onReport, metric, TTFBThresholds, opts.reportAllChanges);\n    whenReady(() => {\n        const navigationEntry = getNavigationEntry();\n        if (navigationEntry) {\n            // The activationStart reference is used because TTFB should be\n            // relative to page activation rather than navigation start if the\n            // page was prerendered. But in cases where `activationStart` occurs\n            // after the first byte is received, this time should be clamped at 0.\n            metric.value = Math.max(navigationEntry.responseStart - getActivationStart(), 0);\n            metric.entries = [navigationEntry];\n            report(true);\n            // Only report TTFB after bfcache restores if a `navigation` entry\n            // was reported for the initial load.\n            onBFCacheRestore(() => {\n                metric = initMetric('TTFB', 0);\n                report = bindReporter(onReport, metric, TTFBThresholds, opts.reportAllChanges);\n                report(true);\n            });\n        }\n    });\n};\n", "/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport { onCLS } from './onCLS.js';\nexport { onFCP } from './onFCP.js';\nexport { onINP } from './onINP.js';\nexport { onLCP } from './onLCP.js';\nexport { onTTFB } from './onTTFB.js';\nexport { CLSThresholds } from '../onCLS.js';\nexport { FCPThresholds } from '../onFCP.js';\nexport { INPThresholds } from '../onINP.js';\nexport { LCPThresholds } from '../onLCP.js';\nexport { TTFBThresholds } from '../onTTFB.js';\nexport * from '../types.js';\n", "/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getNavigationEntry } from './getNavigationEntry.js';\nexport const getLoadState = (timestamp) => {\n    if (document.readyState === 'loading') {\n        // If the `readyState` is 'loading' there's no need to look at timestamps\n        // since the timestamp has to be the current time or earlier.\n        return 'loading';\n    }\n    else {\n        const navigationEntry = getNavigationEntry();\n        if (navigationEntry) {\n            if (timestamp < navigationEntry.domInteractive) {\n                return 'loading';\n            }\n            else if (navigationEntry.domContentLoadedEventStart === 0 ||\n                timestamp < navigationEntry.domContentLoadedEventStart) {\n                // If the `domContentLoadedEventStart` timestamp has not yet been\n                // set, or if the given timestamp is less than that value.\n                return 'dom-interactive';\n            }\n            else if (navigationEntry.domComplete === 0 ||\n                timestamp < navigationEntry.domComplete) {\n                // If the `domComplete` timestamp has not yet been\n                // set, or if the given timestamp is less than that value.\n                return 'dom-content-loaded';\n            }\n        }\n    }\n    // If any of the above fail, default to loaded. This could really only\n    // happy if the browser doesn't support the performance timeline, which\n    // most likely means this code would never run anyway.\n    return 'complete';\n};\n", "/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst getName = (node) => {\n    const name = node.nodeName;\n    return node.nodeType === 1\n        ? name.toLowerCase()\n        : name.toUpperCase().replace(/^#/, '');\n};\nconst MAX_LEN = 100;\nexport const getSelector = (node) => {\n    let sel = '';\n    try {\n        while (node?.nodeType !== 9) {\n            const el = node;\n            const part = el.id\n                ? '#' + el.id\n                : [getName(el), ...Array.from(el.classList).sort()].join('.');\n            if (sel.length + part.length > MAX_LEN - 1) {\n                return sel || part;\n            }\n            sel = sel ? part + '>' + sel : part;\n            if (el.id) {\n                break;\n            }\n            node = el.parentNode;\n        }\n    }\n    catch {\n        // Do nothing...\n    }\n    return sel;\n};\n", "/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { LayoutShiftManager } from '../lib/LayoutShiftManager.js';\nimport { getLoadState } from '../lib/getLoadState.js';\nimport { getSelector } from '../lib/getSelector.js';\nimport { initUnique } from '../lib/initUnique.js';\nimport { onCLS as unattributedOnCLS } from '../onCLS.js';\nconst getLargestLayoutShiftEntry = (entries) => {\n    return entries.reduce((a, b) => (a.value > b.value ? a : b));\n};\nconst getLargestLayoutShiftSource = (sources) => {\n    return sources.find((s) => s.node?.nodeType === 1) || sources[0];\n};\n/**\n * Calculates the [CLS](https://web.dev/articles/cls) value for the current page and\n * calls the `callback` function once the value is ready to be reported, along\n * with all `layout-shift` performance entries that were used in the metric\n * value calculation. The reported value is a `double` (corresponding to a\n * [layout shift score](https://web.dev/articles/cls#layout_shift_score)).\n *\n * If the `reportAllChanges` configuration option is set to `true`, the\n * `callback` function will be called as soon as the value is initially\n * determined as well as any time the value changes throughout the page\n * lifespan.\n *\n * _**Important:** CLS should be continually monitored for changes throughout\n * the entire lifespan of a page\u2014including if the user returns to the page after\n * it's been hidden/backgrounded. However, since browsers often [will not fire\n * additional callbacks once the user has backgrounded a\n * page](https://developer.chrome.com/blog/page-lifecycle-api/#advice-hidden),\n * `callback` is always called when the page's visibility state changes to\n * hidden. As a result, the `callback` function might be called multiple times\n * during the same page load._\n */\nexport const onCLS = (onReport, opts = {}) => {\n    // Clone the opts object to ensure it's unique, so we can initialize a\n    // single instance of the `LayoutShiftManager` class that's shared only with\n    // this function invocation and the `unattributedOnCLS()` invocation below\n    // (which is passed the same `opts` object).\n    opts = Object.assign({}, opts);\n    const layoutShiftManager = initUnique(opts, LayoutShiftManager);\n    const layoutShiftTargetMap = new WeakMap();\n    layoutShiftManager._onAfterProcessingUnexpectedShift = (entry) => {\n        if (entry?.sources?.length) {\n            const largestSource = getLargestLayoutShiftSource(entry.sources);\n            const node = largestSource?.node;\n            if (node) {\n                const customTarget = opts.generateTarget?.(node) ?? getSelector(node);\n                layoutShiftTargetMap.set(largestSource, customTarget);\n            }\n        }\n    };\n    const attributeCLS = (metric) => {\n        // Use an empty object if no other attribution has been set.\n        let attribution = {};\n        if (metric.entries.length) {\n            const largestEntry = getLargestLayoutShiftEntry(metric.entries);\n            if (largestEntry?.sources?.length) {\n                const largestSource = getLargestLayoutShiftSource(largestEntry.sources);\n                if (largestSource) {\n                    attribution = {\n                        largestShiftTarget: layoutShiftTargetMap.get(largestSource),\n                        largestShiftTime: largestEntry.startTime,\n                        largestShiftValue: largestEntry.value,\n                        largestShiftSource: largestSource,\n                        largestShiftEntry: largestEntry,\n                        loadState: getLoadState(largestEntry.startTime),\n                    };\n                }\n            }\n        }\n        // Use `Object.assign()` to ensure the original metric object is returned.\n        const metricWithAttribution = Object.assign(metric, { attribution });\n        return metricWithAttribution;\n    };\n    unattributedOnCLS((metric) => {\n        const metricWithAttribution = attributeCLS(metric);\n        onReport(metricWithAttribution);\n    }, opts);\n};\n", "/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getBFCacheRestoreTime } from '../lib/bfcache.js';\nimport { getLoadState } from '../lib/getLoadState.js';\nimport { getNavigationEntry } from '../lib/getNavigationEntry.js';\nimport { onFCP as unattributedOnFCP } from '../onFCP.js';\nconst attributeFCP = (metric) => {\n    // Use a default object if no other attribution has been set.\n    let attribution = {\n        timeToFirstByte: 0,\n        firstByteToFCP: metric.value,\n        loadState: getLoadState(getBFCacheRestoreTime()),\n    };\n    if (metric.entries.length) {\n        const navigationEntry = getNavigationEntry();\n        const fcpEntry = metric.entries.at(-1);\n        if (navigationEntry) {\n            const activationStart = navigationEntry.activationStart || 0;\n            const ttfb = Math.max(0, navigationEntry.responseStart - activationStart);\n            attribution = {\n                timeToFirstByte: ttfb,\n                firstByteToFCP: metric.value - ttfb,\n                loadState: getLoadState(metric.entries[0].startTime),\n                navigationEntry,\n                fcpEntry,\n            };\n        }\n    }\n    // Use `Object.assign()` to ensure the original metric object is returned.\n    const metricWithAttribution = Object.assign(metric, { attribution });\n    return metricWithAttribution;\n};\n/**\n * Calculates the [FCP](https://web.dev/articles/fcp) value for the current page and\n * calls the `callback` function once the value is ready, along with the\n * relevant `paint` performance entry used to determine the value. The reported\n * value is a `DOMHighResTimeStamp`.\n */\nexport const onFCP = (onReport, opts = {}) => {\n    unattributedOnFCP((metric) => {\n        const metricWithAttribution = attributeFCP(metric);\n        onReport(metricWithAttribution);\n    }, opts);\n};\n", "/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getLoadState } from '../lib/getLoadState.js';\nimport { getSelector } from '../lib/getSelector.js';\nimport { initUnique } from '../lib/initUnique.js';\nimport { InteractionManager } from '../lib/InteractionManager.js';\nimport { observe } from '../lib/observe.js';\nimport { whenIdleOrHidden } from '../lib/whenIdleOrHidden.js';\nimport { onINP as unattributedOnINP } from '../onINP.js';\n// The maximum number of previous frames for which data is kept.\n// Storing data about previous frames is necessary to handle cases where event\n// and LoAF entries are dispatched out of order, and so a buffer of previous\n// frame data is needed to determine various bits of INP attribution once all\n// the frame-related data has come in.\n// In most cases this out-of-order data is only off by a frame or two, so\n// keeping the most recent 50 should be more than sufficient.\nconst MAX_PREVIOUS_FRAMES = 50;\n/**\n * Calculates the [INP](https://web.dev/articles/inp) value for the current\n * page and calls the `callback` function once the value is ready, along with\n * the `event` performance entries reported for that interaction. The reported\n * value is a `DOMHighResTimeStamp`.\n *\n * A custom `durationThreshold` configuration option can optionally be passed\n * to control what `event-timing` entries are considered for INP reporting. The\n * default threshold is `40`, which means INP scores of less than 40 will not\n * be reported. To avoid reporting no interactions in these cases, the library\n * will fall back to the input delay of the first interaction. Note that this\n * will not affect your 75th percentile INP value unless that value is also\n * less than 40 (well below the recommended\n * [good](https://web.dev/articles/inp#what_is_a_good_inp_score) threshold).\n *\n * If the `reportAllChanges` configuration option is set to `true`, the\n * `callback` function will be called as soon as the value is initially\n * determined as well as any time the value changes throughout the page\n * lifespan.\n *\n * _**Important:** INP should be continually monitored for changes throughout\n * the entire lifespan of a page\u2014including if the user returns to the page after\n * it has been hidden/backgrounded. However, since browsers often [will not fire\n * additional callbacks once the user has backgrounded a\n * page](https://developer.chrome.com/blog/page-lifecycle-api/#advice-hidden),\n * `callback` is always called when the page's visibility state changes to\n * hidden. As a result, the `callback` function might be called multiple times\n * during the same page load._\n */\nexport const onINP = (onReport, opts = {}) => {\n    // Clone the opts object to ensure it's unique, so we can initialize a\n    // single instance of the `InteractionManager` class that's shared only with\n    // this function invocation and the `unattributedOnINP()` invocation below\n    // (which is passed the same `opts` object).\n    opts = Object.assign({}, opts);\n    const interactionManager = initUnique(opts, InteractionManager);\n    // A list of LoAF entries that have been dispatched and could potentially\n    // intersect with the INP candidate interaction. Note that periodically this\n    // list is cleaned up and entries that are known to not match INP are removed.\n    let pendingLoAFs = [];\n    // An array of groups of all the event timing entries that occurred within a\n    // particular frame. Note that periodically this array is cleaned up and entries\n    // that are known to not match INP are removed.\n    let pendingEntriesGroups = [];\n    // The `processingEnd` time of most recently-processed event, chronologically.\n    let latestProcessingEnd = 0;\n    // A WeakMap to look up the event-timing-entries group of a given entry.\n    // Note that this only maps from \"important\" entries: either the first input or\n    // those with an `interactionId`.\n    const entryToEntriesGroupMap = new WeakMap();\n    // A mapping of interactionIds to the target Node.\n    const interactionTargetMap = new WeakMap();\n    // A boolean flag indicating whether or not a cleanup task has been queued.\n    let cleanupPending = false;\n    /**\n     * Adds new LoAF entries to the `pendingLoAFs` list.\n     */\n    const handleLoAFEntries = (entries) => {\n        pendingLoAFs = pendingLoAFs.concat(entries);\n        queueCleanup();\n    };\n    const saveInteractionTarget = (interaction) => {\n        if (!interactionTargetMap.get(interaction)) {\n            const node = interaction.entries[0].target;\n            if (node) {\n                const customTarget = opts.generateTarget?.(node) ?? getSelector(node);\n                interactionTargetMap.set(interaction, customTarget);\n            }\n        }\n    };\n    /**\n     * Groups entries that were presented within the same animation frame by\n     * a common `renderTime`. This function works by referencing\n     * `pendingEntriesGroups` and using an existing render time if one is found\n     * (otherwise creating a new one). This function also adds all interaction\n     * entries to an `entryToRenderTimeMap` WeakMap so that the \"grouped\" entries\n     * can be looked up later.\n     */\n    const groupEntriesByRenderTime = (entry) => {\n        const renderTime = entry.startTime + entry.duration;\n        let group;\n        latestProcessingEnd = Math.max(latestProcessingEnd, entry.processingEnd);\n        // Iterate over all previous render times in reverse order to find a match.\n        // Go in reverse since the most likely match will be at the end.\n        for (let i = pendingEntriesGroups.length - 1; i >= 0; i--) {\n            const potentialGroup = pendingEntriesGroups[i];\n            // If a group's render time is within 8ms of the entry's render time,\n            // assume they were part of the same frame and add it to the group.\n            if (Math.abs(renderTime - potentialGroup.renderTime) <= 8) {\n                group = potentialGroup;\n                group.startTime = Math.min(entry.startTime, group.startTime);\n                group.processingStart = Math.min(entry.processingStart, group.processingStart);\n                group.processingEnd = Math.max(entry.processingEnd, group.processingEnd);\n                group.entries.push(entry);\n                break;\n            }\n        }\n        // If there was no matching group, assume this is a new frame.\n        if (!group) {\n            group = {\n                startTime: entry.startTime,\n                processingStart: entry.processingStart,\n                processingEnd: entry.processingEnd,\n                renderTime,\n                entries: [entry],\n            };\n            pendingEntriesGroups.push(group);\n        }\n        // Store the grouped render time for this entry for reference later.\n        if (entry.interactionId || entry.entryType === 'first-input') {\n            entryToEntriesGroupMap.set(entry, group);\n        }\n        queueCleanup();\n    };\n    const queueCleanup = () => {\n        // Queue cleanup of entries that are not part of any INP candidates.\n        if (!cleanupPending) {\n            whenIdleOrHidden(cleanupEntries);\n            cleanupPending = true;\n        }\n    };\n    const cleanupEntries = () => {\n        // Keep all render times that are part of a pending INP candidate or\n        // that occurred within the 50 most recently-dispatched groups of events.\n        const longestInteractionGroups = interactionManager._longestInteractionList.map((i) => {\n            return entryToEntriesGroupMap.get(i.entries[0]);\n        });\n        const minIndex = pendingEntriesGroups.length - MAX_PREVIOUS_FRAMES;\n        pendingEntriesGroups = pendingEntriesGroups.filter((group, index) => {\n            if (index >= minIndex)\n                return true;\n            return longestInteractionGroups.includes(group);\n        });\n        // Keep all pending LoAF entries that either:\n        // 1) intersect with entries in the newly cleaned up `pendingEntriesGroups`\n        // 2) occur after the most recently-processed event entry (for up to MAX_PREVIOUS_FRAMES)\n        const loafsToKeep = new Set();\n        for (const group of pendingEntriesGroups) {\n            const loafs = getIntersectingLoAFs(group.startTime, group.processingEnd);\n            for (const loaf of loafs) {\n                loafsToKeep.add(loaf);\n            }\n        }\n        const prevFrameIndexCutoff = pendingLoAFs.length - 1 - MAX_PREVIOUS_FRAMES;\n        // Filter `pendingLoAFs` to preserve LoAF order.\n        pendingLoAFs = pendingLoAFs.filter((loaf, index) => {\n            if (loaf.startTime > latestProcessingEnd &&\n                index > prevFrameIndexCutoff) {\n                return true;\n            }\n            return loafsToKeep.has(loaf);\n        });\n        cleanupPending = false;\n    };\n    async function handleOnEachInteractionCallback(entry) {\n        if (!opts.onEachInteraction) {\n            return;\n        }\n        // Wait a microtask so this \"pre\" processing callback actually\n        // becomes a \"post\" processing callback.\n        void (await Promise.resolve());\n        if (!entry.interactionId) {\n            return;\n        }\n        const interaction = attributeINP({\n            entries: [entry],\n            // The only value we really need for `attributeINP` is `entries`\n            // Everything else is included to fill out the type.\n            name: 'INP',\n            rating: 'good',\n            value: entry.duration,\n            delta: entry.duration,\n            navigationType: 'navigate',\n            id: 'N/A',\n        });\n        opts.onEachInteraction(interaction);\n    }\n    interactionManager._onBeforeProcessingEntry = (entry) => {\n        void handleOnEachInteractionCallback(entry);\n        groupEntriesByRenderTime(entry);\n    };\n    interactionManager._onAfterProcessingINPCandidate = saveInteractionTarget;\n    const getIntersectingLoAFs = (start, end) => {\n        const intersectingLoAFs = [];\n        for (const loaf of pendingLoAFs) {\n            // If the LoAF ends before the given start time, ignore it.\n            if (loaf.startTime + loaf.duration < start)\n                continue;\n            // If the LoAF starts after the given end time, ignore it and all\n            // subsequent pending LoAFs (because they're in time order).\n            if (loaf.startTime > end)\n                break;\n            // Still here? If so this LoAF intersects with the interaction.\n            intersectingLoAFs.push(loaf);\n        }\n        return intersectingLoAFs;\n    };\n    const attributeLoAFDetails = (attribution) => {\n        // If there is no LoAF data then nothing further to attribute\n        if (!attribution.longAnimationFrameEntries?.length) {\n            return;\n        }\n        const interactionTime = attribution.interactionTime;\n        const inputDelay = attribution.inputDelay;\n        const processingDuration = attribution.processingDuration;\n        // Stats across all LoAF entries and scripts.\n        let totalScriptDuration = 0;\n        let totalStyleAndLayoutDuration = 0;\n        let totalPaintDuration = 0;\n        let longestScriptDuration = 0;\n        let longestScriptEntry;\n        let longestScriptSubpart;\n        for (const loafEntry of attribution.longAnimationFrameEntries) {\n            totalStyleAndLayoutDuration =\n                totalStyleAndLayoutDuration +\n                    loafEntry.startTime +\n                    loafEntry.duration -\n                    loafEntry.styleAndLayoutStart;\n            for (const script of loafEntry.scripts) {\n                const scriptEndTime = script.startTime + script.duration;\n                if (scriptEndTime < interactionTime) {\n                    continue;\n                }\n                const intersectingScriptDuration = scriptEndTime - Math.max(interactionTime, script.startTime);\n                // Since forcedStyleAndLayoutDuration doesn't provide timestamps, we\n                // apportion the total based on the intersectingScriptDuration. Not\n                // correct depending on when it occurred, but the best we can do.\n                const intersectingForceStyleAndLayoutDuration = script.duration\n                    ? (intersectingScriptDuration / script.duration) *\n                        script.forcedStyleAndLayoutDuration\n                    : 0;\n                // For scripts we exclude forcedStyleAndLayout (same as DevTools does\n                // in its summary totals) and instead include that in\n                // totalStyleAndLayoutDuration\n                totalScriptDuration +=\n                    intersectingScriptDuration - intersectingForceStyleAndLayoutDuration;\n                totalStyleAndLayoutDuration += intersectingForceStyleAndLayoutDuration;\n                if (intersectingScriptDuration > longestScriptDuration) {\n                    // Set the subpart this occurred in.\n                    longestScriptSubpart =\n                        script.startTime < interactionTime + inputDelay\n                            ? 'input-delay'\n                            : script.startTime >=\n                                interactionTime + inputDelay + processingDuration\n                                ? 'presentation-delay'\n                                : 'processing-duration';\n                    longestScriptEntry = script;\n                    longestScriptDuration = intersectingScriptDuration;\n                }\n            }\n        }\n        // Calculate the totalPaintDuration from the last LoAF after\n        // presentationDelay starts (where available)\n        const lastLoAF = attribution.longAnimationFrameEntries.at(-1);\n        const lastLoAFEndTime = lastLoAF\n            ? lastLoAF.startTime + lastLoAF.duration\n            : 0;\n        if (lastLoAFEndTime >= interactionTime + inputDelay + processingDuration) {\n            totalPaintDuration = attribution.nextPaintTime - lastLoAFEndTime;\n        }\n        if (longestScriptEntry && longestScriptSubpart) {\n            attribution.longestScript = {\n                entry: longestScriptEntry,\n                subpart: longestScriptSubpart,\n                intersectingDuration: longestScriptDuration,\n            };\n        }\n        attribution.totalScriptDuration = totalScriptDuration;\n        attribution.totalStyleAndLayoutDuration = totalStyleAndLayoutDuration;\n        attribution.totalPaintDuration = totalPaintDuration;\n        attribution.totalUnattributedDuration =\n            attribution.nextPaintTime -\n                interactionTime -\n                totalScriptDuration -\n                totalStyleAndLayoutDuration -\n                totalPaintDuration;\n    };\n    const attributeINP = (metric) => {\n        const firstEntry = metric.entries[0];\n        const group = entryToEntriesGroupMap.get(firstEntry);\n        const processingStart = firstEntry.processingStart;\n        // Due to the fact that durations can be rounded down to the nearest 8ms,\n        // we have to clamp `nextPaintTime` so it doesn't appear to occur before\n        // processing starts. Note: we can't use `processingEnd` since processing\n        // can extend beyond the event duration in some cases (see next comment).\n        const nextPaintTime = Math.max(firstEntry.startTime + firstEntry.duration, processingStart);\n        // For the purposes of attribution, clamp `processingEnd` to `nextPaintTime`,\n        // so processing is never reported as taking longer than INP (which can\n        // happen via the web APIs in the case of sync modals, e.g. `alert()`).\n        // See: https://github.com/GoogleChrome/web-vitals/issues/492\n        const processingEnd = Math.min(group.processingEnd, nextPaintTime);\n        // Sort the entries in processing time order.\n        const processedEventEntries = group.entries.sort((a, b) => {\n            return a.processingStart - b.processingStart;\n        });\n        const longAnimationFrameEntries = getIntersectingLoAFs(firstEntry.startTime, processingEnd);\n        const interaction = interactionManager._longestInteractionMap.get(firstEntry.interactionId);\n        const attribution = {\n            // TS flags the next line because `interactionTargetMap.get()` might\n            // return `undefined`, but we ignore this assuming the user knows what\n            // they are doing.\n            interactionTarget: interactionTargetMap.get(interaction),\n            interactionType: firstEntry.name.startsWith('key')\n                ? 'keyboard'\n                : 'pointer',\n            interactionTime: firstEntry.startTime,\n            nextPaintTime: nextPaintTime,\n            processedEventEntries: processedEventEntries,\n            longAnimationFrameEntries: longAnimationFrameEntries,\n            inputDelay: processingStart - firstEntry.startTime,\n            processingDuration: processingEnd - processingStart,\n            presentationDelay: nextPaintTime - processingEnd,\n            loadState: getLoadState(firstEntry.startTime),\n            longestScript: undefined,\n            totalScriptDuration: undefined,\n            totalStyleAndLayoutDuration: undefined,\n            totalPaintDuration: undefined,\n            totalUnattributedDuration: undefined,\n        };\n        attributeLoAFDetails(attribution);\n        // Use `Object.assign()` to ensure the original metric object is returned.\n        const metricWithAttribution = Object.assign(metric, { attribution });\n        return metricWithAttribution;\n    };\n    // Start observing LoAF entries for attribution.\n    observe('long-animation-frame', handleLoAFEntries);\n    unattributedOnINP((metric) => {\n        const metricWithAttribution = attributeINP(metric);\n        onReport(metricWithAttribution);\n    }, opts);\n};\n", "/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getNavigationEntry } from '../lib/getNavigationEntry.js';\nimport { getSelector } from '../lib/getSelector.js';\nimport { initUnique } from '../lib/initUnique.js';\nimport { LCPEntryManager } from '../lib/LCPEntryManager.js';\nimport { onLCP as unattributedOnLCP } from '../onLCP.js';\n/**\n * Calculates the [LCP](https://web.dev/articles/lcp) value for the current page and\n * calls the `callback` function once the value is ready (along with the\n * relevant `largest-contentful-paint` performance entry used to determine the\n * value). The reported value is a `DOMHighResTimeStamp`.\n *\n * If the `reportAllChanges` configuration option is set to `true`, the\n * `callback` function will be called any time a new `largest-contentful-paint`\n * performance entry is dispatched, or once the final value of the metric has\n * been determined.\n */\nexport const onLCP = (onReport, opts = {}) => {\n    // Clone the opts object to ensure it's unique, so we can initialize a\n    // single instance of the `LCPEntryManager` class that's shared only with\n    // this function invocation and the `unattributedOnLCP()` invocation below\n    // (which is passed the same `opts` object).\n    opts = Object.assign({}, opts);\n    const lcpEntryManager = initUnique(opts, LCPEntryManager);\n    const lcpTargetMap = new WeakMap();\n    lcpEntryManager._onBeforeProcessingEntry = (entry) => {\n        const node = entry.element;\n        if (node) {\n            const customTarget = opts.generateTarget?.(node) ?? getSelector(node);\n            lcpTargetMap.set(entry, customTarget);\n        }\n    };\n    const attributeLCP = (metric) => {\n        // Use a default object if no other attribution has been set.\n        let attribution = {\n            timeToFirstByte: 0,\n            resourceLoadDelay: 0,\n            resourceLoadDuration: 0,\n            elementRenderDelay: metric.value,\n        };\n        if (metric.entries.length) {\n            const navigationEntry = getNavigationEntry();\n            if (navigationEntry) {\n                const activationStart = navigationEntry.activationStart || 0;\n                // The `metric.entries.length` check ensures there will be an entry.\n                const lcpEntry = metric.entries.at(-1);\n                const lcpResourceEntry = lcpEntry.url &&\n                    performance\n                        .getEntriesByType('resource')\n                        .filter((e) => e.name === lcpEntry.url)[0];\n                const ttfb = Math.max(0, navigationEntry.responseStart - activationStart);\n                const lcpRequestStart = Math.max(ttfb, \n                // Prefer `requestStart` (if TOA is set), otherwise use `startTime`.\n                lcpResourceEntry\n                    ? (lcpResourceEntry.requestStart || lcpResourceEntry.startTime) -\n                        activationStart\n                    : 0);\n                const lcpResponseEnd = Math.min(\n                // Cap at LCP time (videos continue downloading after LCP for example)\n                metric.value, Math.max(lcpRequestStart, lcpResourceEntry\n                    ? lcpResourceEntry.responseEnd - activationStart\n                    : 0));\n                attribution = {\n                    target: lcpTargetMap.get(lcpEntry),\n                    timeToFirstByte: ttfb,\n                    resourceLoadDelay: lcpRequestStart - ttfb,\n                    resourceLoadDuration: lcpResponseEnd - lcpRequestStart,\n                    elementRenderDelay: metric.value - lcpResponseEnd,\n                    navigationEntry,\n                    lcpEntry,\n                };\n                // Only attribute the URL and resource entry if they exist.\n                if (lcpEntry.url) {\n                    attribution.url = lcpEntry.url;\n                }\n                if (lcpResourceEntry) {\n                    attribution.lcpResourceEntry = lcpResourceEntry;\n                }\n            }\n        }\n        // Use `Object.assign()` to ensure the original metric object is returned.\n        const metricWithAttribution = Object.assign(metric, { attribution });\n        return metricWithAttribution;\n    };\n    unattributedOnLCP((metric) => {\n        const metricWithAttribution = attributeLCP(metric);\n        onReport(metricWithAttribution);\n    }, opts);\n};\n", "/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { onTTFB as unattributedOnTTFB } from '../onTTFB.js';\nconst attributeTTFB = (metric) => {\n    // Use a default object if no other attribution has been set.\n    let attribution = {\n        waitingDuration: 0,\n        cacheDuration: 0,\n        dnsDuration: 0,\n        connectionDuration: 0,\n        requestDuration: 0,\n    };\n    if (metric.entries.length) {\n        const navigationEntry = metric.entries[0];\n        const activationStart = navigationEntry.activationStart || 0;\n        // Measure from workerStart or fetchStart so any service worker startup\n        // time is included in cacheDuration (which also includes other sw time\n        // anyway, that cannot be accurately split out cross-browser).\n        const waitEnd = Math.max((navigationEntry.workerStart || navigationEntry.fetchStart) -\n            activationStart, 0);\n        const dnsStart = Math.max(navigationEntry.domainLookupStart - activationStart, 0);\n        const connectStart = Math.max(navigationEntry.connectStart - activationStart, 0);\n        const connectEnd = Math.max(navigationEntry.connectEnd - activationStart, 0);\n        attribution = {\n            waitingDuration: waitEnd,\n            cacheDuration: dnsStart - waitEnd,\n            // dnsEnd usually equals connectStart but use connectStart over dnsEnd\n            // for dnsDuration in case there ever is a gap.\n            dnsDuration: connectStart - dnsStart,\n            connectionDuration: connectEnd - connectStart,\n            // There is often a gap between connectEnd and requestStart. Attribute\n            // that to requestDuration so connectionDuration remains 0 for\n            // service worker controlled requests were connectStart and connectEnd\n            // are the same.\n            requestDuration: metric.value - connectEnd,\n            navigationEntry: navigationEntry,\n        };\n    }\n    // Use `Object.assign()` to ensure the original metric object is returned.\n    const metricWithAttribution = Object.assign(metric, { attribution });\n    return metricWithAttribution;\n};\n/**\n * Calculates the [TTFB](https://web.dev/articles/ttfb) value for the\n * current page and calls the `callback` function once the page has loaded,\n * along with the relevant `navigation` performance entry used to determine the\n * value. The reported value is a `DOMHighResTimeStamp`.\n *\n * Note, this function waits until after the page is loaded to call `callback`\n * in order to ensure all properties of the `navigation` entry are populated.\n * This is useful if you want to report on other metrics exposed by the\n * [Navigation Timing API](https://w3c.github.io/navigation-timing/). For\n * example, the TTFB metric starts from the page's [time\n * origin](https://www.w3.org/TR/hr-time-2/#sec-time-origin), which means it\n * includes time spent on DNS lookup, connection negotiation, network latency,\n * and server processing time.\n */\nexport const onTTFB = (onReport, opts = {}) => {\n    unattributedOnTTFB((metric) => {\n        const metricWithAttribution = attributeTTFB(metric);\n        onReport(metricWithAttribution);\n    }, opts);\n};\n"],
  "mappings": "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",
  "names": ["po", "po", "po", "interaction", "po", "po", "onCLS", "onFCP", "onINP", "onLCP", "onTTFB", "onCLS", "onFCP", "onINP", "onLCP", "onTTFB"]
}
