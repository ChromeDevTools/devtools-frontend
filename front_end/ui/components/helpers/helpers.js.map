{
  "version": 3,
  "sources": ["../../../../../../../front_end/ui/components/helpers/component-server-setup.ts", "../../../../../../../front_end/ui/components/helpers/directives.ts", "../../../../../../../front_end/ui/components/helpers/get-root-node.ts", "../../../../../../../front_end/ui/components/helpers/scheduled-render.ts"],
  "sourcesContent": ["// Copyright 2020 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Common from '../../../core/common/common.js';\nimport * as ThemeSupport from '../../legacy/theme_support/theme_support.js';\n\n/**\n * Houses any setup required to run the component docs server. Currently this is\n * only populating the runtime CSS cache but may be extended in the future.\n */\nexport async function setup(): Promise<void> {\n  const setting = {\n    get() {\n      return 'default';\n    },\n    addChangeListener: () => {},\n  } as unknown as Common.Settings.Setting<string>;\n  ThemeSupport.ThemeSupport.instance({forceNew: true, setting});\n}\n", "// Copyright 2021 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Lit from '../../lit/lit.js';\n\n/**\n * Provides a hook to get a callback when a Lit node is rendered into the DOM:\n * @example\n *\n * ```\n * <p on-render=${nodeRenderedCallback(node => ...)}>\n * ```\n */\nclass NodeRenderedCallback extends Lit.Directive.Directive {\n  constructor(partInfo: Lit.Directive.PartInfo) {\n    super(partInfo);\n\n    if (partInfo.type !== Lit.Directive.PartType.ATTRIBUTE) {\n      throw new Error('Node rendered callback directive must be used as an attribute.');\n    }\n  }\n\n  override update(part: Lit.Directive.ElementPart, [callback]: Lit.Directive.DirectiveParameters<this>): void {\n    callback(part.element);\n  }\n\n  /*\n   * Because this directive doesn't render anything, there's no implementation\n   * here for the render method. But we need it to state that it takes in a\n   * callback function at the callsite. Without this definition, the types in\n   * the update() method above don't get correctly picked up.\n   */\n  render(_callback: (domNode: Element) => void): void {\n  }\n}\n\nexport const nodeRenderedCallback = Lit.Directive.directive(NodeRenderedCallback);\n", "// Copyright 2021 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/**\n * Function to return the root node of a given node.\n */\nexport function getRootNode(node: Node): ShadowRoot|Document {\n  const potentialRoot = node.getRootNode();\n  if (!(potentialRoot instanceof Document || potentialRoot instanceof ShadowRoot)) {\n    throw new Error(`Expected root of widget to be a document or shadowRoot, but was \"${potentialRoot.nodeName}\"`);\n  }\n  return potentialRoot;\n}\n", "// Copyright 2021 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as RenderCoordinator from '../render_coordinator/render_coordinator.js';\n\nexport type RenderCallback = () => (void|Promise<void>);\n\nconst requests = new Map<HTMLElement, {callback: RenderCallback, promise: Promise<void>}>();\nconst active = new Set<HTMLElement>();\n\nexport function scheduleRender(component: HTMLElement, callback: RenderCallback): Promise<void> {\n  const request = requests.get(component);\n  if (request !== undefined) {\n    if (request.callback !== callback) {\n      throw new TypeError(\n          `Incompatible callback arguments for scheduling rendering of ${component.nodeName.toLowerCase()}`);\n    }\n    return request.promise;\n  }\n\n  const promise = RenderCoordinator.write(async () => {\n    try {\n      active.add(component);\n      requests.delete(component);\n      await callback.call(component);\n    } catch (error) {\n      console.error(`ScheduledRender: rendering ${component.nodeName.toLowerCase()}:`);\n      console.error(error);\n      throw error;\n    } finally {\n      active.delete(component);\n    }\n  });\n\n  requests.set(component, {callback, promise});\n  return promise;\n}\n\nexport function isScheduledRender(component: HTMLElement): boolean {\n  return active.has(component);\n}\n"],
  "mappings": ";;;;;;;;;;;AAKA,YAAY,kBAAkB;AAM9B,eAAsB,QAAuB;AAC3C,QAAM,UAAU;IACd,MAAM;AACJ,aAAO;IACT;IACA,mBAAmB,MAAM;IAAC;EAC5B;AACA,EAAa,0BAAa,SAAS,EAAC,UAAU,MAAM,QAAO,CAAC;AAC9D;;;;;;;ACfA,YAAY,SAAS;AAUrB,IAAM,uBAAN,cAAuC,cAAU,UAAU;EACzD,YAAY,UAAkC;AAC5C,UAAM,QAAQ;AAEd,QAAI,SAAS,SAAa,cAAU,SAAS,WAAW;AACtD,YAAM,IAAI,MAAM,gEAAgE;IAClF;EACF;EAES,OAAO,MAAiC,CAAC,QAAQ,GAAkD;AAC1G,aAAS,KAAK,OAAO;EACvB;;;;;;;EAQA,OAAO,WAA6C;EACpD;AACF;AAEO,IAAM,uBAA2B,cAAU,UAAU,oBAAoB;;;;;;;AC9BzE,SAAS,YAAY,MAAiC;AAC3D,QAAM,gBAAgB,KAAK,YAAY;AACvC,MAAI,EAAE,yBAAyB,YAAY,yBAAyB,aAAa;AAC/E,UAAM,IAAI,MAAM,oEAAoE,cAAc,QAAQ,GAAG;EAC/G;AACA,SAAO;AACT;;;;;;;;ACTA,YAAY,uBAAuB;AAInC,IAAM,WAAW,oBAAI,IAAqE;AAC1F,IAAM,SAAS,oBAAI,IAAiB;AAE7B,SAAS,eAAe,WAAwB,UAAyC;AAC9F,QAAM,UAAU,SAAS,IAAI,SAAS;AACtC,MAAI,YAAY,QAAW;AACzB,QAAI,QAAQ,aAAa,UAAU;AACjC,YAAM,IAAI;QACN,+DAA+D,UAAU,SAAS,YAAY,CAAC;MAAE;IACvG;AACA,WAAO,QAAQ;EACjB;AAEA,QAAM,UAA4B,wBAAM,YAAY;AAClD,QAAI;AACF,aAAO,IAAI,SAAS;AACpB,eAAS,OAAO,SAAS;AACzB,YAAM,SAAS,KAAK,SAAS;IAC/B,SAAS,OAAO;AACd,cAAQ,MAAM,8BAA8B,UAAU,SAAS,YAAY,CAAC,GAAG;AAC/E,cAAQ,MAAM,KAAK;AACnB,YAAM;IACR,UAAA;AACE,aAAO,OAAO,SAAS;IACzB;EACF,CAAC;AAED,WAAS,IAAI,WAAW,EAAC,UAAU,QAAO,CAAC;AAC3C,SAAO;AACT;AAEO,SAAS,kBAAkB,WAAiC;AACjE,SAAO,OAAO,IAAI,SAAS;AAC7B;",
  "names": []
}
