{
  "version": 3,
  "sources": ["render_coordinator.prebundle.ts"],
  "sourcesContent": ["// Copyright 2021 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nexport interface CoordinatorCallback<T> {\n  (): T|PromiseLike<T>;\n}\n\nclass WorkItem<T> {\n  readonly promise: Promise<T>;\n  readonly trigger: () => void;\n  readonly cancel: (e: Error) => void;\n  readonly label: string;\n  handler: CoordinatorCallback<T>;\n\n  constructor(label: string, handler: CoordinatorCallback<T>) {\n    const {promise, resolve, reject} = Promise.withResolvers<void>();\n    this.promise = promise.then(() => this.handler());\n    this.trigger = resolve;\n    this.cancel = reject;\n    this.label = label;\n    this.handler = handler;\n  }\n}\n\nexport interface LoggingRecord {\n  time: number;\n  value: string;\n}\n\nconst enum ACTION {\n  READ = 'read',\n  WRITE = 'write',\n}\n\nexport class RenderCoordinatorQueueEmptyEvent extends Event {\n  static readonly eventName = 'renderqueueempty';\n  constructor() {\n    super(RenderCoordinatorQueueEmptyEvent.eventName);\n  }\n}\n\nexport class RenderCoordinatorNewFrameEvent extends Event {\n  static readonly eventName = 'newframe';\n  constructor() {\n    super(RenderCoordinatorNewFrameEvent.eventName);\n  }\n}\n\nexport interface LoggingOptions {\n  // If true, only log activity with an explicit label.\n  // This does not affect logging frames or queue empty events.\n  // Defaults to false.\n  onlyNamed?: boolean;\n\n  // Configurable log storage limit, defaults to 100.\n  storageLimit?: number;\n}\n\nlet loggingEnabled: null|LoggingOptions = null;\nconst loggingRecords: LoggingRecord[] = [];\n\nexport function setLoggingEnabled(enabled: false): void;\nexport function setLoggingEnabled(enabled: true, options?: LoggingOptions): void;\nexport function setLoggingEnabled(enabled: boolean, options: LoggingOptions = {}): void {\n  if (enabled) {\n    loggingEnabled = {\n      onlyNamed: options.onlyNamed,\n      storageLimit: options.storageLimit,\n    };\n  } else {\n    loggingEnabled = null;\n    loggingRecords.length = 0;\n  }\n}\n\nconst UNNAMED_READ = 'Unnamed read';\nconst UNNAMED_WRITE = 'Unnamed write';\nconst UNNAMED_SCROLL = 'Unnamed scroll';\nconst DEADLOCK_TIMEOUT = 1500;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(globalThis as any).__getRenderCoordinatorPendingFrames = function(): number {\n  return hasPendingWork() ? 1 : 0;\n};\n\nlet pendingReaders: Array<WorkItem<unknown>> = [];\nlet pendingWriters: Array<WorkItem<unknown>> = [];\nlet scheduledWorkId = 0;\n\nexport function hasPendingWork(): boolean {\n  return pendingReaders.length + pendingWriters.length !== 0;\n}\n\nexport function done(options?: {waitForWork: boolean}): Promise<void> {\n  if (!hasPendingWork() && !options?.waitForWork) {\n    logIfEnabled('[Queue empty]');\n    return Promise.resolve();\n  }\n  return new Promise(\n      resolve => window.addEventListener(RenderCoordinatorQueueEmptyEvent.eventName, () => resolve(), {once: true}));\n}\n\n/**\n * Schedules a 'read' job which is being executed within an animation frame\n * before all 'write' jobs. If multiple jobs are scheduled with the same\n * non-empty label, only the latest callback would be executed. Such\n * invocations would return the same promise that will resolve to the value of\n * the latest callback.\n */\nexport async function read<T>(callback: CoordinatorCallback<T>): Promise<T>;\nexport async function read<T>(label: string, callback: CoordinatorCallback<T>): Promise<T>;\nexport async function read<T>(\n    labelOrCallback: CoordinatorCallback<T>|string, callback?: CoordinatorCallback<T>): Promise<T> {\n  if (typeof labelOrCallback === 'string') {\n    if (!callback) {\n      throw new Error('Read called with label but no callback');\n    }\n    return await enqueueHandler(ACTION.READ, labelOrCallback, callback);\n  }\n\n  return await enqueueHandler(ACTION.READ, UNNAMED_READ, labelOrCallback);\n}\n\n/**\n * Schedules a 'write' job which is being executed within an animation frame\n * after all 'read' and 'scroll' jobs. If multiple jobs are scheduled with\n * the same non-empty label, only the latest callback would be executed. Such\n * invocations would return the same promise that will resolve when the latest callback is run.\n */\nexport async function write<T>(callback: CoordinatorCallback<T>): Promise<T>;\nexport async function write<T>(label: string, callback: CoordinatorCallback<T>): Promise<T>;\nexport async function write<T>(\n    labelOrCallback: CoordinatorCallback<T>|string, callback?: CoordinatorCallback<T>): Promise<T> {\n  if (typeof labelOrCallback === 'string') {\n    if (!callback) {\n      throw new Error('Write called with label but no callback');\n    }\n    return await enqueueHandler(ACTION.WRITE, labelOrCallback, callback);\n  }\n\n  return await enqueueHandler(ACTION.WRITE, UNNAMED_WRITE, labelOrCallback);\n}\n\nexport function takeLoggingRecords(): LoggingRecord[] {\n  const logs = [...loggingRecords];\n  loggingRecords.length = 0;\n  return logs;\n}\n\n/**\n * We offer a convenience function for scroll-based activity, but often triggering a scroll\n * requires a layout pass, thus it is better handled as a read activity, i.e. we wait until\n * the layout-triggering work has been completed then it should be possible to scroll without\n * first forcing layout.  If multiple jobs are scheduled with the same non-empty label, only\n * the latest callback would be executed. Such invocations would return the same promise that\n * will resolve when the latest callback is run.\n */\nexport async function scroll<T>(callback: CoordinatorCallback<T>): Promise<T>;\nexport async function scroll<T>(label: string, callback: CoordinatorCallback<T>): Promise<T>;\nexport async function scroll<T>(\n    labelOrCallback: CoordinatorCallback<T>|string, callback?: CoordinatorCallback<T>): Promise<T> {\n  if (typeof labelOrCallback === 'string') {\n    if (!callback) {\n      throw new Error('Scroll called with label but no callback');\n    }\n    return await enqueueHandler(ACTION.READ, labelOrCallback, callback);\n  }\n\n  return await enqueueHandler(ACTION.READ, UNNAMED_SCROLL, labelOrCallback);\n}\n\nfunction enqueueHandler<T>(action: ACTION, label: string, callback: CoordinatorCallback<T>): Promise<T> {\n  const hasName = ![UNNAMED_READ, UNNAMED_WRITE, UNNAMED_SCROLL].includes(label);\n  label = `${action === ACTION.READ ? '[Read]' : '[Write]'}: ${label}`;\n\n  let workItems = null;\n  switch (action) {\n    case ACTION.READ:\n      workItems = pendingReaders;\n      break;\n\n    case ACTION.WRITE:\n      workItems = pendingWriters;\n      break;\n\n    default:\n      throw new Error(`Unknown action: ${action}`);\n  }\n\n  let workItem = hasName ? workItems.find(w => w.label === label) as WorkItem<T>| undefined : undefined;\n  if (!workItem) {\n    workItem = new WorkItem<T>(label, callback);\n    workItems.push(workItem);\n  } else {\n    // We are always using the latest handler, so that we don't end up with a\n    // stale results. We are reusing the promise to avoid blocking the first invocation, when\n    // it is being \"overridden\" by another one.\n    workItem.handler = callback;\n  }\n\n  scheduleWork();\n  return workItem.promise;\n}\n\nfunction scheduleWork(): void {\n  if (scheduledWorkId !== 0) {\n    return;\n  }\n\n  scheduledWorkId = requestAnimationFrame(async () => {\n    if (!hasPendingWork()) {\n      // All pending work has completed.\n      // The events dispatched below are mostly for testing contexts.\n      window.dispatchEvent(new RenderCoordinatorQueueEmptyEvent());\n\n      logIfEnabled('[Queue empty]');\n      scheduledWorkId = 0;\n      return;\n    }\n\n    window.dispatchEvent(new RenderCoordinatorNewFrameEvent());\n    logIfEnabled('[New frame]');\n\n    const readers = pendingReaders;\n    pendingReaders = [];\n    const writers = pendingWriters;\n    pendingWriters = [];\n\n    // Start with all the readers and allow them\n    // to proceed together.\n    for (const reader of readers) {\n      logIfEnabled(reader.label);\n      reader.trigger();\n    }\n\n    // Wait for them all to be done.\n    try {\n      await Promise.race([\n        Promise.all(readers.map(r => r.promise)),\n        new Promise((_, reject) => {\n          window.setTimeout(\n              () => reject(new Error(`Readers took over ${DEADLOCK_TIMEOUT}ms. Possible deadlock?`)), DEADLOCK_TIMEOUT);\n        }),\n      ]);\n    } catch (err) {\n      rejectAll(readers, err);\n    }\n\n    // Next do all the writers as a block.\n    for (const writer of writers) {\n      logIfEnabled(writer.label);\n      writer.trigger();\n    }\n\n    // And wait for them to be done, too.\n    try {\n      await Promise.race([\n        Promise.all(writers.map(w => w.promise)),\n        new Promise((_, reject) => {\n          window.setTimeout(\n              () => reject(new Error(`Writers took over ${DEADLOCK_TIMEOUT}ms. Possible deadlock?`)), DEADLOCK_TIMEOUT);\n        }),\n      ]);\n    } catch (err) {\n      rejectAll(writers, err);\n    }\n\n    // Since there may have been more work requested in\n    // the callback of a reader / writer, we attempt to schedule\n    // it at this point.\n    scheduledWorkId = 0;\n    scheduleWork();\n  });\n}\n\nfunction rejectAll(handlers: Array<WorkItem<unknown>>, error: Error): void {\n  for (const handler of handlers) {\n    handler.cancel(error);\n  }\n}\n\nexport function cancelPending(): void {\n  const error = new Error();\n  rejectAll(pendingReaders, error);\n  rejectAll(pendingWriters, error);\n}\n\nfunction logIfEnabled(value: string): void {\n  if (loggingEnabled === null) {\n    return;\n  }\n  if (loggingEnabled.onlyNamed) {\n    if (value.endsWith(UNNAMED_READ) || value.endsWith(UNNAMED_WRITE) || value.endsWith(UNNAMED_SCROLL)) {\n      return;\n    }\n  }\n\n  loggingRecords.push({time: performance.now(), value});\n\n  // Keep the log at the log size.\n  const loggingLimit = loggingEnabled.storageLimit ?? 100;\n  while (loggingRecords.length > loggingLimit) {\n    loggingRecords.shift();\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
