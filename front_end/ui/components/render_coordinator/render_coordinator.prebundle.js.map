{"version":3,"file":"render_coordinator.prebundle.js","sourceRoot":"","sources":["render_coordinator.prebundle.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2021 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nexport interface CoordinatorCallback<T> {\n  (): T|PromiseLike<T>;\n}\n\nclass WorkItem<T> {\n  readonly promise: Promise<T>;\n  readonly trigger: () => void;\n  readonly cancel: (e: Error) => void;\n  readonly label: string;\n  handler: CoordinatorCallback<T>;\n\n  constructor(label: string, handler: CoordinatorCallback<T>) {\n    const {promise, resolve, reject} = Promise.withResolvers<void>();\n    this.promise = promise.then(() => this.handler());\n    this.trigger = resolve;\n    this.cancel = reject;\n    this.label = label;\n    this.handler = handler;\n  }\n}\n\nexport interface LoggingRecord {\n  time: number;\n  value: string;\n}\n\nconst enum ACTION {\n  READ = 'read',\n  WRITE = 'write',\n}\n\nexport class RenderCoordinatorQueueEmptyEvent extends Event {\n  static readonly eventName = 'renderqueueempty';\n  constructor() {\n    super(RenderCoordinatorQueueEmptyEvent.eventName);\n  }\n}\n\nexport class RenderCoordinatorNewFrameEvent extends Event {\n  static readonly eventName = 'newframe';\n  constructor() {\n    super(RenderCoordinatorNewFrameEvent.eventName);\n  }\n}\n\nexport interface LoggingOptions {\n  // If true, only log activity with an explicit label.\n  // This does not affect logging frames or queue empty events.\n  // Defaults to false.\n  onlyNamed?: boolean;\n\n  // Configurable log storage limit, defaults to 100.\n  storageLimit?: number;\n}\n\nlet loggingEnabled: null|LoggingOptions = null;\nconst loggingRecords: LoggingRecord[] = [];\n\nexport function setLoggingEnabled(enabled: false): void;\nexport function setLoggingEnabled(enabled: true, options?: LoggingOptions): void;\nexport function setLoggingEnabled(enabled: boolean, options: LoggingOptions = {}): void {\n  if (enabled) {\n    loggingEnabled = {\n      onlyNamed: options.onlyNamed,\n      storageLimit: options.storageLimit,\n    };\n  } else {\n    loggingEnabled = null;\n    loggingRecords.length = 0;\n  }\n}\n\nconst UNNAMED_READ = 'Unnamed read';\nconst UNNAMED_WRITE = 'Unnamed write';\nconst UNNAMED_SCROLL = 'Unnamed scroll';\nconst DEADLOCK_TIMEOUT = 1500;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(globalThis as any).__getRenderCoordinatorPendingFrames = function(): number {\n  return hasPendingWork() ? 1 : 0;\n};\n\nlet pendingReaders: Array<WorkItem<unknown>> = [];\nlet pendingWriters: Array<WorkItem<unknown>> = [];\nlet scheduledWorkId = 0;\n\nexport function hasPendingWork(): boolean {\n  return pendingReaders.length + pendingWriters.length !== 0;\n}\n\nexport function done(options?: {waitForWork: boolean}): Promise<void> {\n  if (!hasPendingWork() && !options?.waitForWork) {\n    logIfEnabled('[Queue empty]');\n    return Promise.resolve();\n  }\n  return new Promise(\n      resolve => window.addEventListener(RenderCoordinatorQueueEmptyEvent.eventName, () => resolve(), {once: true}));\n}\n\n/**\n * Schedules a 'read' job which is being executed within an animation frame\n * before all 'write' jobs. If multiple jobs are scheduled with the same\n * non-empty label, only the latest callback would be executed. Such\n * invocations would return the same promise that will resolve to the value of\n * the latest callback.\n */\nexport async function read<T>(callback: CoordinatorCallback<T>): Promise<T>;\nexport async function read<T>(label: string, callback: CoordinatorCallback<T>): Promise<T>;\nexport async function read<T>(\n    labelOrCallback: CoordinatorCallback<T>|string, callback?: CoordinatorCallback<T>): Promise<T> {\n  if (typeof labelOrCallback === 'string') {\n    if (!callback) {\n      throw new Error('Read called with label but no callback');\n    }\n    return await enqueueHandler(ACTION.READ, labelOrCallback, callback);\n  }\n\n  return await enqueueHandler(ACTION.READ, UNNAMED_READ, labelOrCallback);\n}\n\n/**\n * Schedules a 'write' job which is being executed within an animation frame\n * after all 'read' and 'scroll' jobs. If multiple jobs are scheduled with\n * the same non-empty label, only the latest callback would be executed. Such\n * invocations would return the same promise that will resolve when the latest callback is run.\n */\nexport async function write<T>(callback: CoordinatorCallback<T>): Promise<T>;\nexport async function write<T>(label: string, callback: CoordinatorCallback<T>): Promise<T>;\nexport async function write<T>(\n    labelOrCallback: CoordinatorCallback<T>|string, callback?: CoordinatorCallback<T>): Promise<T> {\n  if (typeof labelOrCallback === 'string') {\n    if (!callback) {\n      throw new Error('Write called with label but no callback');\n    }\n    return await enqueueHandler(ACTION.WRITE, labelOrCallback, callback);\n  }\n\n  return await enqueueHandler(ACTION.WRITE, UNNAMED_WRITE, labelOrCallback);\n}\n\nexport function takeLoggingRecords(): LoggingRecord[] {\n  const logs = [...loggingRecords];\n  loggingRecords.length = 0;\n  return logs;\n}\n\n/**\n * We offer a convenience function for scroll-based activity, but often triggering a scroll\n * requires a layout pass, thus it is better handled as a read activity, i.e. we wait until\n * the layout-triggering work has been completed then it should be possible to scroll without\n * first forcing layout.  If multiple jobs are scheduled with the same non-empty label, only\n * the latest callback would be executed. Such invocations would return the same promise that\n * will resolve when the latest callback is run.\n */\nexport async function scroll<T>(callback: CoordinatorCallback<T>): Promise<T>;\nexport async function scroll<T>(label: string, callback: CoordinatorCallback<T>): Promise<T>;\nexport async function scroll<T>(\n    labelOrCallback: CoordinatorCallback<T>|string, callback?: CoordinatorCallback<T>): Promise<T> {\n  if (typeof labelOrCallback === 'string') {\n    if (!callback) {\n      throw new Error('Scroll called with label but no callback');\n    }\n    return await enqueueHandler(ACTION.READ, labelOrCallback, callback);\n  }\n\n  return await enqueueHandler(ACTION.READ, UNNAMED_SCROLL, labelOrCallback);\n}\n\nfunction enqueueHandler<T>(action: ACTION, label: string, callback: CoordinatorCallback<T>): Promise<T> {\n  const hasName = ![UNNAMED_READ, UNNAMED_WRITE, UNNAMED_SCROLL].includes(label);\n  label = `${action === ACTION.READ ? '[Read]' : '[Write]'}: ${label}`;\n\n  let workItems = null;\n  switch (action) {\n    case ACTION.READ:\n      workItems = pendingReaders;\n      break;\n\n    case ACTION.WRITE:\n      workItems = pendingWriters;\n      break;\n\n    default:\n      throw new Error(`Unknown action: ${action}`);\n  }\n\n  let workItem = hasName ? workItems.find(w => w.label === label) as WorkItem<T>| undefined : undefined;\n  if (!workItem) {\n    workItem = new WorkItem<T>(label, callback);\n    workItems.push(workItem);\n  } else {\n    // We are always using the latest handler, so that we don't end up with a\n    // stale results. We are reusing the promise to avoid blocking the first invocation, when\n    // it is being \"overridden\" by another one.\n    workItem.handler = callback;\n  }\n\n  scheduleWork();\n  return workItem.promise;\n}\n\nfunction scheduleWork(): void {\n  if (scheduledWorkId !== 0) {\n    return;\n  }\n\n  scheduledWorkId = requestAnimationFrame(async () => {\n    if (!hasPendingWork()) {\n      // All pending work has completed.\n      // The events dispatched below are mostly for testing contexts.\n      window.dispatchEvent(new RenderCoordinatorQueueEmptyEvent());\n\n      logIfEnabled('[Queue empty]');\n      scheduledWorkId = 0;\n      return;\n    }\n\n    window.dispatchEvent(new RenderCoordinatorNewFrameEvent());\n    logIfEnabled('[New frame]');\n\n    const readers = pendingReaders;\n    pendingReaders = [];\n    const writers = pendingWriters;\n    pendingWriters = [];\n\n    // Start with all the readers and allow them\n    // to proceed together.\n    for (const reader of readers) {\n      logIfEnabled(reader.label);\n      reader.trigger();\n    }\n\n    // Wait for them all to be done.\n    try {\n      await Promise.race([\n        Promise.all(readers.map(r => r.promise)),\n        new Promise((_, reject) => {\n          window.setTimeout(\n              () => reject(new Error(`Readers took over ${DEADLOCK_TIMEOUT}ms. Possible deadlock?`)), DEADLOCK_TIMEOUT);\n        }),\n      ]);\n    } catch (err) {\n      rejectAll(readers, err);\n    }\n\n    // Next do all the writers as a block.\n    for (const writer of writers) {\n      logIfEnabled(writer.label);\n      writer.trigger();\n    }\n\n    // And wait for them to be done, too.\n    try {\n      await Promise.race([\n        Promise.all(writers.map(w => w.promise)),\n        new Promise((_, reject) => {\n          window.setTimeout(\n              () => reject(new Error(`Writers took over ${DEADLOCK_TIMEOUT}ms. Possible deadlock?`)), DEADLOCK_TIMEOUT);\n        }),\n      ]);\n    } catch (err) {\n      rejectAll(writers, err);\n    }\n\n    // Since there may have been more work requested in\n    // the callback of a reader / writer, we attempt to schedule\n    // it at this point.\n    scheduledWorkId = 0;\n    scheduleWork();\n  });\n}\n\nfunction rejectAll(handlers: Array<WorkItem<unknown>>, error: Error): void {\n  for (const handler of handlers) {\n    handler.cancel(error);\n  }\n}\n\nexport function cancelPending(): void {\n  const error = new Error();\n  rejectAll(pendingReaders, error);\n  rejectAll(pendingWriters, error);\n}\n\nfunction logIfEnabled(value: string): void {\n  if (loggingEnabled === null) {\n    return;\n  }\n  if (loggingEnabled.onlyNamed) {\n    if (value.endsWith(UNNAMED_READ) || value.endsWith(UNNAMED_WRITE) || value.endsWith(UNNAMED_SCROLL)) {\n      return;\n    }\n  }\n\n  loggingRecords.push({time: performance.now(), value});\n\n  // Keep the log at the log size.\n  const loggingLimit = loggingEnabled.storageLimit ?? 100;\n  while (loggingRecords.length > loggingLimit) {\n    loggingRecords.shift();\n  }\n}\n"]}