{"version":3,"file":"TimelineOverviewCalculator.js","sourceRoot":"","sources":["../../../../../../../../front_end/ui/legacy/components/perf_ui/TimelineOverviewCalculator.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2023 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as i18n from '../../../../core/i18n/i18n.js';\nimport type * as NetworkTimeCalculator from '../../../../models/network_time_calculator/network_time_calculator.js';\nimport * as Trace from '../../../../models/trace/trace.js';\n\nexport class TimelineOverviewCalculator implements NetworkTimeCalculator.Calculator {\n  #minimumBoundary: Trace.Types.Timing.Milli = Trace.Types.Timing.Milli(0);\n  #maximumBoundary: Trace.Types.Timing.Milli = Trace.Types.Timing.Milli(100);\n\n  #displayWidth = 0;\n  private navStartTimes?: readonly Trace.Types.Events.NavigationStart[];\n\n  /**\n   * Given a timestamp, returns its x position in the minimap.\n   *\n   * @param time\n   * @returns position in pixel\n   */\n  computePosition(time: Trace.Types.Timing.Milli): number {\n    return (time - this.#minimumBoundary) / this.boundarySpan() * this.#displayWidth;\n  }\n\n  positionToTime(position: number): Trace.Types.Timing.Milli {\n    if (this.#displayWidth === 0) {\n      return Trace.Types.Timing.Milli(0);\n    }\n    return Trace.Types.Timing.Milli(position / this.#displayWidth * this.boundarySpan() + this.#minimumBoundary);\n  }\n\n  setBounds(minimumBoundary: Trace.Types.Timing.Milli, maximumBoundary: Trace.Types.Timing.Milli): void {\n    this.#minimumBoundary = minimumBoundary;\n    this.#maximumBoundary = maximumBoundary;\n  }\n\n  setNavStartTimes(navStartTimes: readonly Trace.Types.Events.NavigationStart[]): void {\n    this.navStartTimes = navStartTimes;\n  }\n\n  setDisplayWidth(clientWidth: number): void {\n    this.#displayWidth = clientWidth;\n  }\n\n  reset(): void {\n    this.setBounds(\n        Trace.Types.Timing.Milli(0),\n        Trace.Types.Timing.Milli(100),\n    );\n  }\n\n  formatValue(time: Trace.Types.Timing.Milli, precision?: number): string {\n    // If there are nav start times the value needs to be remapped.\n    if (this.navStartTimes) {\n      // Find the latest possible nav start time which is considered earlier\n      // than the value passed through.\n      for (let i = this.navStartTimes.length - 1; i >= 0; i--) {\n        const startTimeMilliseconds = Trace.Helpers.Timing.microToMilli(\n            this.navStartTimes[i].ts,\n        );\n\n        if (time > startTimeMilliseconds) {\n          time = Trace.Types.Timing.Milli(time - (startTimeMilliseconds - this.zeroTime()));\n          break;\n        }\n      }\n    }\n\n    return i18n.TimeUtilities.preciseMillisToString(time - this.zeroTime(), precision);\n  }\n\n  maximumBoundary(): Trace.Types.Timing.Milli {\n    return this.#maximumBoundary;\n  }\n\n  minimumBoundary(): Trace.Types.Timing.Milli {\n    return this.#minimumBoundary;\n  }\n\n  zeroTime(): Trace.Types.Timing.Milli {\n    return this.#minimumBoundary;\n  }\n\n  /**\n   * This function returns the time different between min time and max time of current minimap.\n   *\n   * @returns the time range in milliseconds\n   */\n  boundarySpan(): Trace.Types.Timing.Milli {\n    return Trace.Types.Timing.Milli(this.#maximumBoundary - this.#minimumBoundary);\n  }\n}\n"]}