{"version":3,"names":["_t","require","addComment","_addComment","addComments","_addComments","shareCommentsWithSiblings","key","node","trailing","trailingComments","leading","leadingComments","prev","getSibling","next","hasPrev","Boolean","hasNext","removeIfExisting","list","toRemove","lastFoundIndex","filter","el","i","indexOf","type","content","line","comments"],"sources":["../../src/path/comments.ts"],"sourcesContent":["// This file contains methods responsible for dealing with comments.\nimport type * as t from \"@babel/types\";\nimport type NodePath from \"./index.ts\";\nimport {\n  addComment as _addComment,\n  addComments as _addComments,\n} from \"@babel/types\";\n\n/**\n * Share comments amongst siblings.\n */\n\nexport function shareCommentsWithSiblings(this: NodePath) {\n  // NOTE: this assumes numbered keys\n  if (typeof this.key === \"string\") return;\n\n  const node = this.node;\n  if (!node) return;\n\n  const trailing = node.trailingComments;\n  const leading = node.leadingComments;\n  if (!trailing && !leading) return;\n\n  const prev = this.getSibling(this.key - 1);\n  const next = this.getSibling(this.key + 1);\n  const hasPrev = Boolean(prev.node);\n  const hasNext = Boolean(next.node);\n\n  if (hasPrev) {\n    if (leading) {\n      prev.addComments(\n        \"trailing\",\n        removeIfExisting(leading, prev.node.trailingComments),\n      );\n    }\n    if (trailing && !hasNext) prev.addComments(\"trailing\", trailing);\n  }\n  if (hasNext) {\n    if (trailing) {\n      next.addComments(\n        \"leading\",\n        removeIfExisting(trailing, next.node.leadingComments),\n      );\n    }\n    if (leading && !hasPrev) next.addComments(\"leading\", leading);\n  }\n}\n\nfunction removeIfExisting<T>(list: T[], toRemove?: T[]): T[] {\n  if (!toRemove) return list;\n  let lastFoundIndex = -1;\n  return list.filter(el => {\n    const i = toRemove.indexOf(el, lastFoundIndex);\n    if (i === -1) return true;\n    lastFoundIndex = i;\n  });\n}\n\nexport function addComment(\n  this: NodePath,\n  type: t.CommentTypeShorthand,\n  content: string,\n  line?: boolean,\n) {\n  _addComment(this.node, type, content, line);\n}\n\n/**\n * Give node `comments` of the specified `type`.\n */\n\nexport function addComments(\n  this: NodePath,\n  type: t.CommentTypeShorthand,\n  comments: t.Comment[],\n) {\n  _addComments(this.node, type, comments);\n}\n"],"mappings":";;;;;;;;AAGA,IAAAA,EAAA,GAAAC,OAAA;AAGsB;EAFpBC,UAAU,EAAIC,WAAW;EACzBC,WAAW,EAAIC;AAAY,IAAAL,EAAA;AAOtB,SAASM,yBAAyBA,CAAA,EAAiB;EAExD,IAAI,OAAO,IAAI,CAACC,GAAG,KAAK,QAAQ,EAAE;EAElC,MAAMC,IAAI,GAAG,IAAI,CAACA,IAAI;EACtB,IAAI,CAACA,IAAI,EAAE;EAEX,MAAMC,QAAQ,GAAGD,IAAI,CAACE,gBAAgB;EACtC,MAAMC,OAAO,GAAGH,IAAI,CAACI,eAAe;EACpC,IAAI,CAACH,QAAQ,IAAI,CAACE,OAAO,EAAE;EAE3B,MAAME,IAAI,GAAG,IAAI,CAACC,UAAU,CAAC,IAAI,CAACP,GAAG,GAAG,CAAC,CAAC;EAC1C,MAAMQ,IAAI,GAAG,IAAI,CAACD,UAAU,CAAC,IAAI,CAACP,GAAG,GAAG,CAAC,CAAC;EAC1C,MAAMS,OAAO,GAAGC,OAAO,CAACJ,IAAI,CAACL,IAAI,CAAC;EAClC,MAAMU,OAAO,GAAGD,OAAO,CAACF,IAAI,CAACP,IAAI,CAAC;EAElC,IAAIQ,OAAO,EAAE;IACX,IAAIL,OAAO,EAAE;MACXE,IAAI,CAACT,WAAW,CACd,UAAU,EACVe,gBAAgB,CAACR,OAAO,EAAEE,IAAI,CAACL,IAAI,CAACE,gBAAgB,CACtD,CAAC;IACH;IACA,IAAID,QAAQ,IAAI,CAACS,OAAO,EAAEL,IAAI,CAACT,WAAW,CAAC,UAAU,EAAEK,QAAQ,CAAC;EAClE;EACA,IAAIS,OAAO,EAAE;IACX,IAAIT,QAAQ,EAAE;MACZM,IAAI,CAACX,WAAW,CACd,SAAS,EACTe,gBAAgB,CAACV,QAAQ,EAAEM,IAAI,CAACP,IAAI,CAACI,eAAe,CACtD,CAAC;IACH;IACA,IAAID,OAAO,IAAI,CAACK,OAAO,EAAED,IAAI,CAACX,WAAW,CAAC,SAAS,EAAEO,OAAO,CAAC;EAC/D;AACF;AAEA,SAASQ,gBAAgBA,CAAIC,IAAS,EAAEC,QAAc,EAAO;EAC3D,IAAI,CAACA,QAAQ,EAAE,OAAOD,IAAI;EAC1B,IAAIE,cAAc,GAAG,CAAC,CAAC;EACvB,OAAOF,IAAI,CAACG,MAAM,CAACC,EAAE,IAAI;IACvB,MAAMC,CAAC,GAAGJ,QAAQ,CAACK,OAAO,CAACF,EAAE,EAAEF,cAAc,CAAC;IAC9C,IAAIG,CAAC,KAAK,CAAC,CAAC,EAAE,OAAO,IAAI;IACzBH,cAAc,GAAGG,CAAC;EACpB,CAAC,CAAC;AACJ;AAEO,SAASvB,UAAUA,CAExByB,IAA4B,EAC5BC,OAAe,EACfC,IAAc,EACd;EACA1B,WAAW,CAAC,IAAI,CAACK,IAAI,EAAEmB,IAAI,EAAEC,OAAO,EAAEC,IAAI,CAAC;AAC7C;AAMO,SAASzB,WAAWA,CAEzBuB,IAA4B,EAC5BG,QAAqB,EACrB;EACAzB,YAAY,CAAC,IAAI,CAACG,IAAI,EAAEmB,IAAI,EAAEG,QAAQ,CAAC;AACzC"}