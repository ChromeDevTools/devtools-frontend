/**
 * Copyright 2022 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { EventResponse } from '../protocol/protocol.js';
import { ZodType, z as zod } from 'zod';
export declare function parseObject<T extends ZodType>(obj: unknown, schema: T): zod.infer<T>;
export declare namespace CommonDataTypes {
    export const SharedReferenceSchema: zod.ZodObject<{
        sharedId: zod.ZodString;
    }, "strip", zod.ZodTypeAny, {
        sharedId: string;
    }, {
        sharedId: string;
    }>;
    export type SharedReference = zod.infer<typeof SharedReferenceSchema>;
    export const RemoteReferenceSchema: zod.ZodObject<{
        handle: zod.ZodString;
    }, "strip", zod.ZodTypeAny, {
        handle: string;
    }, {
        handle: string;
    }>;
    export type RemoteReference = zod.infer<typeof RemoteReferenceSchema>;
    const PrimitiveProtocolValueSchema: zod.ZodUnion<[zod.ZodObject<{
        type: zod.ZodLiteral<"undefined">;
    }, "strip", zod.ZodTypeAny, {
        type: "undefined";
    }, {
        type: "undefined";
    }>, zod.ZodObject<{
        type: zod.ZodLiteral<"null">;
    }, "strip", zod.ZodTypeAny, {
        type: "null";
    }, {
        type: "null";
    }>, zod.ZodObject<{
        type: zod.ZodLiteral<"string">;
        value: zod.ZodString;
    }, "strip", zod.ZodTypeAny, {
        type: "string";
        value: string;
    }, {
        type: "string";
        value: string;
    }>, zod.ZodObject<{
        type: zod.ZodLiteral<"number">;
        value: zod.ZodUnion<[zod.ZodEnum<["NaN", "-0", "Infinity", "+Infinity", "-Infinity"]>, zod.ZodNumber]>;
    }, "strip", zod.ZodTypeAny, {
        type: "number";
        value: number | "NaN" | "-0" | "Infinity" | "+Infinity" | "-Infinity";
    }, {
        type: "number";
        value: number | "NaN" | "-0" | "Infinity" | "+Infinity" | "-Infinity";
    }>, zod.ZodObject<{
        type: zod.ZodLiteral<"boolean">;
        value: zod.ZodBoolean;
    }, "strip", zod.ZodTypeAny, {
        type: "boolean";
        value: boolean;
    }, {
        type: "boolean";
        value: boolean;
    }>, zod.ZodObject<{
        type: zod.ZodLiteral<"bigint">;
        value: zod.ZodString;
    }, "strip", zod.ZodTypeAny, {
        type: "bigint";
        value: string;
    }, {
        type: "bigint";
        value: string;
    }>]>;
    export type PrimitiveProtocolValue = zod.infer<typeof PrimitiveProtocolValueSchema>;
    export type LocalValue = PrimitiveProtocolValue | ArrayLocalValue | DateLocalValue | MapLocalValue | ObjectLocalValue | RegExpLocalValue | SetLocalValue;
    export const LocalValueSchema: zod.ZodType<LocalValue>;
    const ListLocalValueSchema: zod.ZodArray<zod.ZodUnion<[zod.ZodObject<{
        sharedId: zod.ZodString;
    }, "strip", zod.ZodTypeAny, {
        sharedId: string;
    }, {
        sharedId: string;
    }>, zod.ZodObject<{
        handle: zod.ZodString;
    }, "strip", zod.ZodTypeAny, {
        handle: string;
    }, {
        handle: string;
    }>, ZodType<any, zod.ZodTypeDef, any>]>, "many">;
    export type ListLocalValue = zod.infer<typeof ListLocalValueSchema>;
    const ArrayLocalValueSchema: zod.ZodType;
    export type ArrayLocalValue = zod.infer<typeof ArrayLocalValueSchema>;
    const DateLocalValueSchema: zod.ZodObject<{
        type: zod.ZodLiteral<"date">;
        value: zod.ZodString;
    }, "strip", zod.ZodTypeAny, {
        type: "date";
        value: string;
    }, {
        type: "date";
        value: string;
    }>;
    export type DateLocalValue = zod.infer<typeof DateLocalValueSchema>;
    const MappingLocalValueSchema: zod.ZodType;
    export type MappingLocalValue = zod.infer<typeof MappingLocalValueSchema>;
    const MapLocalValueSchema: zod.ZodObject<{
        type: zod.ZodLiteral<"map">;
        value: zod.ZodArray<ZodType<any, zod.ZodTypeDef, any>, "many">;
    }, "strip", zod.ZodTypeAny, {
        type: "map";
        value: any[];
    }, {
        type: "map";
        value: any[];
    }>;
    export type MapLocalValue = zod.infer<typeof MapLocalValueSchema>;
    const ObjectLocalValueSchema: zod.ZodObject<{
        type: zod.ZodLiteral<"object">;
        value: zod.ZodArray<ZodType<any, zod.ZodTypeDef, any>, "many">;
    }, "strip", zod.ZodTypeAny, {
        type: "object";
        value: any[];
    }, {
        type: "object";
        value: any[];
    }>;
    export type ObjectLocalValue = zod.infer<typeof ObjectLocalValueSchema>;
    const RegExpLocalValueSchema: zod.ZodType;
    export type RegExpLocalValue = zod.infer<typeof RegExpLocalValueSchema>;
    const SetLocalValueSchema: zod.ZodType;
    export type SetLocalValue = zod.infer<typeof SetLocalValueSchema>;
    export type RemoteValue = PrimitiveProtocolValue | SymbolRemoteValue | ArrayRemoteValue | ObjectRemoteValue | FunctionRemoteValue | RegExpRemoteValue | DateRemoteValue | MapRemoteValue | SetRemoteValue | WeakMapRemoteValue | WeakSetRemoteValue | IteratorRemoteValue | GeneratorRemoteValue | ProxyRemoteValue | ErrorRemoteValue | PromiseRemoteValue | TypedArrayRemoteValue | ArrayBufferRemoteValue | NodeRemoteValue | WindowProxyRemoteValue;
    export type ListRemoteValue = RemoteValue[];
    export type MappingRemoteValue = [RemoteValue | string, RemoteValue][];
    export type SymbolRemoteValue = RemoteReference & {
        type: 'symbol';
    };
    export type ArrayRemoteValue = RemoteReference & {
        type: 'array';
        value?: ListRemoteValue;
    };
    export type ObjectRemoteValue = RemoteReference & {
        type: 'object';
        value?: MappingRemoteValue;
    };
    export type FunctionRemoteValue = RemoteReference & {
        type: 'function';
    };
    export type RegExpRemoteValue = RemoteReference & RegExpLocalValue;
    export type DateRemoteValue = RemoteReference & DateLocalValue;
    export type MapRemoteValue = RemoteReference & {
        type: 'map';
        value: MappingRemoteValue;
    };
    export type SetRemoteValue = RemoteReference & {
        type: 'set';
        value: ListRemoteValue;
    };
    export type WeakMapRemoteValue = RemoteReference & {
        type: 'weakmap';
    };
    export type WeakSetRemoteValue = RemoteReference & {
        type: 'weakset';
    };
    export type IteratorRemoteValue = RemoteReference & {
        type: 'iterator';
    };
    export type GeneratorRemoteValue = RemoteReference & {
        type: 'generator';
    };
    export type ProxyRemoteValue = RemoteReference & {
        type: 'proxy';
    };
    export type ErrorRemoteValue = RemoteReference & {
        type: 'error';
    };
    export type PromiseRemoteValue = RemoteReference & {
        type: 'promise';
    };
    export type TypedArrayRemoteValue = RemoteReference & {
        type: 'typedarray';
    };
    export type ArrayBufferRemoteValue = RemoteReference & {
        type: 'arraybuffer';
    };
    export type NodeRemoteValue = SharedReference & RemoteReference & {
        type: 'node';
        value?: NodeProperties;
    };
    export type NodeProperties = RemoteReference & {
        nodeType: number;
        nodeValue: string;
        localName?: string;
        namespaceURI?: string;
        childNodeCount: number;
        children?: [NodeRemoteValue];
        attributes?: unknown;
        shadowRoot?: NodeRemoteValue | null;
    };
    export type WindowProxyRemoteValue = RemoteReference & {
        type: 'window';
    };
    export const BrowsingContextSchema: zod.ZodString;
    export type BrowsingContext = zod.infer<typeof BrowsingContextSchema>;
    export {};
}
export declare namespace Script {
    export type Command = EvaluateCommand | CallFunctionCommand | GetRealmsCommand | DisownCommand;
    export type CommandResult = EvaluateResult | CallFunctionResult | GetRealmsResult | DisownResult;
    export type Realm = string;
    export type ScriptResult = ScriptResultSuccess | ScriptResultException;
    export type ScriptResultSuccess = {
        type: 'success';
        result: CommonDataTypes.RemoteValue;
        realm: string;
    };
    export type ScriptResultException = {
        exceptionDetails: ExceptionDetails;
        type: 'exception';
        realm: string;
    };
    export type ExceptionDetails = {
        columnNumber: number;
        exception: CommonDataTypes.RemoteValue;
        lineNumber: number;
        stackTrace: Script.StackTrace;
        text: string;
    };
    export type RealmInfo = WindowRealmInfo | DedicatedWorkerRealmInfo | SharedWorkerRealmInfo | ServiceWorkerRealmInfo | WorkerRealmInfo | PaintWorkletRealmInfo | AudioWorkletRealmInfo | WorkletRealmInfo;
    export type BaseRealmInfo = {
        realm: Realm;
        origin: string;
    };
    export type WindowRealmInfo = BaseRealmInfo & {
        type: 'window';
        context: CommonDataTypes.BrowsingContext;
        sandbox?: string;
    };
    export type DedicatedWorkerRealmInfo = BaseRealmInfo & {
        type: 'dedicated-worker';
    };
    export type SharedWorkerRealmInfo = BaseRealmInfo & {
        type: 'shared-worker';
    };
    export type ServiceWorkerRealmInfo = BaseRealmInfo & {
        type: 'service-worker';
    };
    export type WorkerRealmInfo = BaseRealmInfo & {
        type: 'worker';
    };
    export type PaintWorkletRealmInfo = BaseRealmInfo & {
        type: 'paint-worklet';
    };
    export type AudioWorkletRealmInfo = BaseRealmInfo & {
        type: 'audio-worklet';
    };
    export type WorkletRealmInfo = BaseRealmInfo & {
        type: 'worklet';
    };
    export const GetRealmsParametersSchema: zod.ZodObject<{
        context: zod.ZodOptional<zod.ZodString>;
        type: zod.ZodOptional<zod.ZodEnum<["window", "dedicated-worker", "shared-worker", "service-worker", "worker", "paint-worklet", "audio-worklet", "worklet"]>>;
    }, "strip", zod.ZodTypeAny, {
        type?: "window" | "dedicated-worker" | "shared-worker" | "service-worker" | "worker" | "paint-worklet" | "audio-worklet" | "worklet" | undefined;
        context?: string | undefined;
    }, {
        type?: "window" | "dedicated-worker" | "shared-worker" | "service-worker" | "worker" | "paint-worklet" | "audio-worklet" | "worklet" | undefined;
        context?: string | undefined;
    }>;
    export type GetRealmsParameters = zod.infer<typeof GetRealmsParametersSchema>;
    export function parseGetRealmsParams(params: unknown): GetRealmsParameters;
    export type GetRealmsCommand = {
        method: 'script.getRealms';
        params: GetRealmsParameters;
    };
    export type GetRealmsResult = {
        result: {
            realms: RealmInfo[];
        };
    };
    export type EvaluateCommand = {
        method: 'script.evaluate';
        params: EvaluateParameters;
    };
    const ContextTargetSchema: zod.ZodObject<{
        context: zod.ZodString;
        sandbox: zod.ZodOptional<zod.ZodString>;
    }, "strip", zod.ZodTypeAny, {
        sandbox?: string | undefined;
        context: string;
    }, {
        sandbox?: string | undefined;
        context: string;
    }>;
    export type ContextTarget = zod.infer<typeof ContextTargetSchema>;
    const TargetSchema: zod.ZodUnion<[zod.ZodObject<{
        realm: zod.ZodString;
    }, "strip", zod.ZodTypeAny, {
        realm: string;
    }, {
        realm: string;
    }>, zod.ZodObject<{
        context: zod.ZodString;
        sandbox: zod.ZodOptional<zod.ZodString>;
    }, "strip", zod.ZodTypeAny, {
        sandbox?: string | undefined;
        context: string;
    }, {
        sandbox?: string | undefined;
        context: string;
    }>]>;
    export type Target = zod.infer<typeof TargetSchema>;
    const OwnershipModelSchema: zod.ZodEnum<["root", "none"]>;
    export type OwnershipModel = zod.infer<typeof OwnershipModelSchema>;
    const EvaluateParametersSchema: zod.ZodObject<{
        expression: zod.ZodString;
        awaitPromise: zod.ZodBoolean;
        target: zod.ZodUnion<[zod.ZodObject<{
            realm: zod.ZodString;
        }, "strip", zod.ZodTypeAny, {
            realm: string;
        }, {
            realm: string;
        }>, zod.ZodObject<{
            context: zod.ZodString;
            sandbox: zod.ZodOptional<zod.ZodString>;
        }, "strip", zod.ZodTypeAny, {
            sandbox?: string | undefined;
            context: string;
        }, {
            sandbox?: string | undefined;
            context: string;
        }>]>;
        resultOwnership: zod.ZodOptional<zod.ZodEnum<["root", "none"]>>;
    }, "strip", zod.ZodTypeAny, {
        resultOwnership?: "root" | "none" | undefined;
        expression: string;
        awaitPromise: boolean;
        target: {
            realm: string;
        } | {
            sandbox?: string | undefined;
            context: string;
        };
    }, {
        resultOwnership?: "root" | "none" | undefined;
        expression: string;
        awaitPromise: boolean;
        target: {
            realm: string;
        } | {
            sandbox?: string | undefined;
            context: string;
        };
    }>;
    export type EvaluateParameters = zod.infer<typeof EvaluateParametersSchema>;
    export function parseEvaluateParams(params: unknown): EvaluateParameters;
    export type EvaluateResult = {
        result: ScriptResult;
    };
    export type DisownCommand = {
        method: 'script.disown';
        params: EvaluateParameters;
    };
    const DisownParametersSchema: zod.ZodObject<{
        target: zod.ZodUnion<[zod.ZodObject<{
            realm: zod.ZodString;
        }, "strip", zod.ZodTypeAny, {
            realm: string;
        }, {
            realm: string;
        }>, zod.ZodObject<{
            context: zod.ZodString;
            sandbox: zod.ZodOptional<zod.ZodString>;
        }, "strip", zod.ZodTypeAny, {
            sandbox?: string | undefined;
            context: string;
        }, {
            sandbox?: string | undefined;
            context: string;
        }>]>;
        handles: zod.ZodArray<zod.ZodString, "many">;
    }, "strip", zod.ZodTypeAny, {
        target: {
            realm: string;
        } | {
            sandbox?: string | undefined;
            context: string;
        };
        handles: string[];
    }, {
        target: {
            realm: string;
        } | {
            sandbox?: string | undefined;
            context: string;
        };
        handles: string[];
    }>;
    export type DisownParameters = zod.infer<typeof DisownParametersSchema>;
    export function parseDisownParams(params: unknown): DisownParameters;
    export type DisownResult = {
        result: {};
    };
    export type CallFunctionCommand = {
        method: 'script.callFunction';
        params: CallFunctionParameters;
    };
    const ArgumentValueSchema: zod.ZodUnion<[zod.ZodObject<{
        handle: zod.ZodString;
    }, "strip", zod.ZodTypeAny, {
        handle: string;
    }, {
        handle: string;
    }>, zod.ZodObject<{
        sharedId: zod.ZodString;
    }, "strip", zod.ZodTypeAny, {
        sharedId: string;
    }, {
        sharedId: string;
    }>, ZodType<any, zod.ZodTypeDef, any>]>;
    export type ArgumentValue = zod.infer<typeof ArgumentValueSchema>;
    const ScriptCallFunctionParametersSchema: zod.ZodObject<{
        functionDeclaration: zod.ZodString;
        target: zod.ZodUnion<[zod.ZodObject<{
            realm: zod.ZodString;
        }, "strip", zod.ZodTypeAny, {
            realm: string;
        }, {
            realm: string;
        }>, zod.ZodObject<{
            context: zod.ZodString;
            sandbox: zod.ZodOptional<zod.ZodString>;
        }, "strip", zod.ZodTypeAny, {
            sandbox?: string | undefined;
            context: string;
        }, {
            sandbox?: string | undefined;
            context: string;
        }>]>;
        arguments: zod.ZodOptional<zod.ZodArray<zod.ZodUnion<[zod.ZodObject<{
            handle: zod.ZodString;
        }, "strip", zod.ZodTypeAny, {
            handle: string;
        }, {
            handle: string;
        }>, zod.ZodObject<{
            sharedId: zod.ZodString;
        }, "strip", zod.ZodTypeAny, {
            sharedId: string;
        }, {
            sharedId: string;
        }>, ZodType<any, zod.ZodTypeDef, any>]>, "many">>;
        this: zod.ZodOptional<zod.ZodUnion<[zod.ZodObject<{
            handle: zod.ZodString;
        }, "strip", zod.ZodTypeAny, {
            handle: string;
        }, {
            handle: string;
        }>, zod.ZodObject<{
            sharedId: zod.ZodString;
        }, "strip", zod.ZodTypeAny, {
            sharedId: string;
        }, {
            sharedId: string;
        }>, ZodType<any, zod.ZodTypeDef, any>]>>;
        awaitPromise: zod.ZodBoolean;
        resultOwnership: zod.ZodOptional<zod.ZodEnum<["root", "none"]>>;
    }, "strip", zod.ZodTypeAny, {
        resultOwnership?: "root" | "none" | undefined;
        arguments?: any[] | undefined;
        this?: any;
        awaitPromise: boolean;
        target: {
            realm: string;
        } | {
            sandbox?: string | undefined;
            context: string;
        };
        functionDeclaration: string;
    }, {
        resultOwnership?: "root" | "none" | undefined;
        arguments?: any[] | undefined;
        this?: any;
        awaitPromise: boolean;
        target: {
            realm: string;
        } | {
            sandbox?: string | undefined;
            context: string;
        };
        functionDeclaration: string;
    }>;
    export type CallFunctionParameters = zod.infer<typeof ScriptCallFunctionParametersSchema>;
    export function parseCallFunctionParams(params: unknown): CallFunctionParameters;
    export type CallFunctionResult = {
        result: ScriptResult;
    };
    export type Source = {
        realm: Realm;
        context?: CommonDataTypes.BrowsingContext;
    };
    export type StackTrace = {
        callFrames: StackFrame[];
    };
    export type StackFrame = {
        columnNumber: number;
        functionName: string;
        lineNumber: number;
        url: string;
    };
    export {};
}
export declare namespace BrowsingContext {
    export type Command = GetTreeCommand | NavigateCommand | CreateCommand | CloseCommand;
    export type CommandResult = GetTreeResult | NavigateResult | CreateResult | CloseResult;
    export type Event = LoadEvent | DomContentLoadedEvent | ContextCreatedEvent | ContextDestroyedEvent;
    export type Navigation = string;
    export type GetTreeCommand = {
        method: 'browsingContext.getTree';
        params: GetTreeParameters;
    };
    const GetTreeParametersSchema: zod.ZodObject<{
        maxDepth: zod.ZodOptional<zod.ZodNumber>;
        root: zod.ZodOptional<zod.ZodString>;
    }, "strip", zod.ZodTypeAny, {
        root?: string | undefined;
        maxDepth?: number | undefined;
    }, {
        root?: string | undefined;
        maxDepth?: number | undefined;
    }>;
    export type GetTreeParameters = zod.infer<typeof GetTreeParametersSchema>;
    export function parseGetTreeParams(params: unknown): GetTreeParameters;
    export type GetTreeResult = {
        result: {
            contexts: InfoList;
        };
    };
    export type InfoList = Info[];
    export type Info = {
        context: CommonDataTypes.BrowsingContext;
        parent?: CommonDataTypes.BrowsingContext | null;
        url: string;
        children: InfoList | null;
    };
    export type NavigateCommand = {
        method: 'browsingContext.navigate';
        params: NavigateParameters;
    };
    const ReadinessStateSchema: zod.ZodEnum<["none", "interactive", "complete"]>;
    export type ReadinessState = zod.infer<typeof ReadinessStateSchema>;
    const NavigateParametersSchema: zod.ZodObject<{
        context: zod.ZodString;
        url: zod.ZodString;
        wait: zod.ZodOptional<zod.ZodEnum<["none", "interactive", "complete"]>>;
    }, "strip", zod.ZodTypeAny, {
        wait?: "none" | "interactive" | "complete" | undefined;
        url: string;
        context: string;
    }, {
        wait?: "none" | "interactive" | "complete" | undefined;
        url: string;
        context: string;
    }>;
    export type NavigateParameters = zod.infer<typeof NavigateParametersSchema>;
    export function parseNavigateParams(params: unknown): NavigateParameters;
    export type NavigateResult = {
        result: {
            navigation: Navigation | null;
            url: string;
        };
    };
    export type CreateCommand = {
        method: 'browsingContext.create';
        params: CreateParameters;
    };
    const CreateParametersSchema: zod.ZodObject<{
        type: zod.ZodEnum<["tab", "window"]>;
        referenceContext: zod.ZodOptional<zod.ZodString>;
    }, "strip", zod.ZodTypeAny, {
        referenceContext?: string | undefined;
        type: "window" | "tab";
    }, {
        referenceContext?: string | undefined;
        type: "window" | "tab";
    }>;
    export type CreateParameters = zod.infer<typeof CreateParametersSchema>;
    export function parseCreateParams(params: unknown): CreateParameters;
    export type CreateResult = {
        result: Info;
    };
    export type CloseCommand = {
        method: 'browsingContext.close';
        params: CloseParameters;
    };
    const CloseParametersSchema: zod.ZodObject<{
        context: zod.ZodString;
    }, "strip", zod.ZodTypeAny, {
        context: string;
    }, {
        context: string;
    }>;
    export type CloseParameters = zod.infer<typeof CloseParametersSchema>;
    export function parseCloseParams(params: unknown): CloseParameters;
    export type CloseResult = {
        result: {};
    };
    export type LoadEvent = EventResponse<EventNames.LoadEvent, NavigationInfo>;
    export type DomContentLoadedEvent = EventResponse<EventNames.DomContentLoadedEvent, NavigationInfo>;
    export type NavigationInfo = {
        context: CommonDataTypes.BrowsingContext;
        navigation: Navigation | null;
        url: string;
    };
    export type ContextCreatedEvent = EventResponse<EventNames.ContextCreatedEvent, BrowsingContext.Info>;
    export type ContextDestroyedEvent = EventResponse<EventNames.ContextDestroyedEvent, BrowsingContext.Info>;
    export const AllEvents = "browsingContext";
    export enum EventNames {
        LoadEvent = "browsingContext.load",
        DomContentLoadedEvent = "browsingContext.domContentLoaded",
        ContextCreatedEvent = "browsingContext.contextCreated",
        ContextDestroyedEvent = "browsingContext.contextDestroyed"
    }
    export {};
}
export declare namespace Log {
    type LogEntry = GenericLogEntry | ConsoleLogEntry | JavascriptLogEntry;
    type Event = LogEntryAddedEvent;
    type LogLevel = 'debug' | 'info' | 'warn' | 'error';
    type BaseLogEntry = {
        level: LogLevel;
        source: Script.Source;
        text: string | null;
        timestamp: number;
        stackTrace?: Script.StackTrace;
    };
    type GenericLogEntry = BaseLogEntry & {
        type: string;
    };
    type ConsoleLogEntry = BaseLogEntry & {
        type: 'console';
        method: string;
        args: CommonDataTypes.RemoteValue[];
    };
    type JavascriptLogEntry = BaseLogEntry & {
        type: 'javascript';
    };
    type LogEntryAddedEvent = EventResponse<EventNames.LogEntryAddedEvent, LogEntry>;
    const AllEvents = "log";
    enum EventNames {
        LogEntryAddedEvent = "log.entryAdded"
    }
}
export declare namespace CDP {
    export type Command = SendCommandCommand | GetSessionCommand;
    export type CommandResult = SendCommandResult | GetSessionResult;
    export type Event = EventReceivedEvent;
    export type SendCommandCommand = {
        method: 'cdp.sendCommand';
        params: SendCommandParams;
    };
    const SendCommandParamsSchema: zod.ZodObject<{
        cdpMethod: zod.ZodString;
        cdpParams: zod.ZodObject<{}, "passthrough", zod.ZodTypeAny, {}, {}>;
        cdpSession: zod.ZodOptional<zod.ZodString>;
    }, "strip", zod.ZodTypeAny, {
        cdpSession?: string | undefined;
        cdpMethod: string;
        cdpParams: {};
    }, {
        cdpSession?: string | undefined;
        cdpMethod: string;
        cdpParams: {};
    }>;
    export type SendCommandParams = zod.infer<typeof SendCommandParamsSchema>;
    export function parseSendCommandParams(params: unknown): SendCommandParams;
    export type SendCommandResult = {
        result: unknown;
    };
    export type GetSessionCommand = {
        method: 'cdp.getSession';
        params: GetSessionParams;
    };
    const GetSessionParamsSchema: zod.ZodObject<{
        context: zod.ZodString;
    }, "strip", zod.ZodTypeAny, {
        context: string;
    }, {
        context: string;
    }>;
    export type GetSessionParams = zod.infer<typeof GetSessionParamsSchema>;
    export function parseGetSessionParams(params: unknown): GetSessionParams;
    export type GetSessionResult = {
        result: {
            session: string;
        };
    };
    export type EventReceivedEvent = EventResponse<EventNames.EventReceivedEvent, EventReceivedParams>;
    export type EventReceivedParams = {
        cdpMethod: string;
        cdpParams: object;
        cdpSession: string;
    };
    export const AllEvents = "cdp";
    export enum EventNames {
        EventReceivedEvent = "cdp.eventReceived"
    }
    export {};
}
export declare namespace Session {
    export type Command = StatusCommand | SubscribeCommand | UnsubscribeCommand;
    export type CommandResult = StatusResult | SubscribeResult | UnsubscribeResult;
    export type StatusCommand = {
        method: 'session.status';
        params: {};
    };
    export type StatusResult = {
        result: {
            ready: boolean;
            message: string;
        };
    };
    export type SubscribeCommand = {
        method: 'session.subscribe';
        params: SubscribeParameters;
    };
    const SubscribeParametersEventSchema: zod.ZodEnum<["browsingContext", BrowsingContext.EventNames.ContextCreatedEvent, BrowsingContext.EventNames.ContextDestroyedEvent, BrowsingContext.EventNames.DomContentLoadedEvent, BrowsingContext.EventNames.LoadEvent, "log", Log.EventNames.LogEntryAddedEvent, "cdp", CDP.EventNames.EventReceivedEvent]>;
    export type SubscribeParametersEvent = zod.infer<typeof SubscribeParametersEventSchema>;
    const SubscribeParametersSchema: zod.ZodObject<{
        events: zod.ZodArray<zod.ZodEnum<["browsingContext", BrowsingContext.EventNames.ContextCreatedEvent, BrowsingContext.EventNames.ContextDestroyedEvent, BrowsingContext.EventNames.DomContentLoadedEvent, BrowsingContext.EventNames.LoadEvent, "log", Log.EventNames.LogEntryAddedEvent, "cdp", CDP.EventNames.EventReceivedEvent]>, "many">;
        contexts: zod.ZodOptional<zod.ZodArray<zod.ZodString, "many">>;
    }, "strip", zod.ZodTypeAny, {
        contexts?: string[] | undefined;
        events: ("browsingContext" | "log" | "cdp" | BrowsingContext.EventNames | Log.EventNames.LogEntryAddedEvent | CDP.EventNames.EventReceivedEvent)[];
    }, {
        contexts?: string[] | undefined;
        events: ("browsingContext" | "log" | "cdp" | BrowsingContext.EventNames | Log.EventNames.LogEntryAddedEvent | CDP.EventNames.EventReceivedEvent)[];
    }>;
    export type SubscribeParameters = zod.infer<typeof SubscribeParametersSchema>;
    export function parseSubscribeParams(params: unknown): SubscribeParameters;
    export type SubscribeResult = {
        result: {};
    };
    export type UnsubscribeCommand = {
        method: 'session.unsubscribe';
        params: SubscribeParameters;
    };
    export type UnsubscribeResult = {
        result: {};
    };
    export {};
}
