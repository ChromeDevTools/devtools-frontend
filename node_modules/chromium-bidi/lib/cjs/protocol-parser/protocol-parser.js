"use strict";
/**
 * Copyright 2022 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Session = exports.CDP = exports.Log = exports.BrowsingContext = exports.Script = exports.CommonDataTypes = exports.parseObject = void 0;
/**
 * @file Provides parsing and validator for WebDriver BiDi protocol.
 * Parser types should match the `../protocol` types.
 */
const MAX_INT = 9007199254740991;
const protocol_js_1 = require("../protocol/protocol.js");
const zod_1 = require("zod");
function parseObject(obj, schema) {
    const parseResult = schema.safeParse(obj);
    if (parseResult.success) {
        return parseResult.data;
    }
    const errorMessage = parseResult.error.errors
        .map((e) => `${e.message} in ` +
        `${e.path.map((p) => JSON.stringify(p)).join('/')}.`)
        .join(' ');
    throw new protocol_js_1.Message.InvalidArgumentException(errorMessage);
}
exports.parseObject = parseObject;
var CommonDataTypes;
(function (CommonDataTypes) {
    CommonDataTypes.SharedReferenceSchema = zod_1.z.object({
        sharedId: zod_1.z.string().min(1),
    });
    CommonDataTypes.RemoteReferenceSchema = zod_1.z.object({
        handle: zod_1.z.string().min(1),
    });
    // UndefinedValue = {
    //   type: "undefined",
    // }
    const UndefinedValueSchema = zod_1.z.object({ type: zod_1.z.literal('undefined') });
    //
    // NullValue = {
    //   type: "null",
    // }
    const NullValueSchema = zod_1.z.object({ type: zod_1.z.literal('null') });
    // StringValue = {
    //   type: "string",
    //   value: text,
    // }
    const StringValueSchema = zod_1.z.object({
        type: zod_1.z.literal('string'),
        value: zod_1.z.string(),
    });
    // SpecialNumber = "NaN" / "-0" / "+Infinity" / "-Infinity";
    const SpecialNumberSchema = zod_1.z.enum([
        'NaN',
        '-0',
        'Infinity',
        '+Infinity',
        '-Infinity',
    ]);
    //
    // NumberValue = {
    //   type: "number",
    //   value: number / SpecialNumber,
    // }
    const NumberValueSchema = zod_1.z.object({
        type: zod_1.z.literal('number'),
        value: zod_1.z.union([SpecialNumberSchema, zod_1.z.number()]),
    });
    // BooleanValue = {
    //   type: "boolean",
    //   value: bool,
    // }
    const BooleanValueSchema = zod_1.z.object({
        type: zod_1.z.literal('boolean'),
        value: zod_1.z.boolean(),
    });
    // BigIntValue = {
    //   type: "bigint",
    //   value: text,
    // }
    const BigIntValueSchema = zod_1.z.object({
        type: zod_1.z.literal('bigint'),
        value: zod_1.z.string(),
    });
    const PrimitiveProtocolValueSchema = zod_1.z.union([
        UndefinedValueSchema,
        NullValueSchema,
        StringValueSchema,
        NumberValueSchema,
        BooleanValueSchema,
        BigIntValueSchema,
    ]);
    CommonDataTypes.LocalValueSchema = zod_1.z.lazy(() => zod_1.z.union([
        PrimitiveProtocolValueSchema,
        ArrayLocalValueSchema,
        DateLocalValueSchema,
        MapLocalValueSchema,
        ObjectLocalValueSchema,
        RegExpLocalValueSchema,
        SetLocalValueSchema,
    ]));
    // Order is important, as `parse` is processed in the same order.
    // `SharedReferenceSchema`->`RemoteReferenceSchema`->`LocalValueSchema`.
    const LocalOrRemoteValueSchema = zod_1.z.union([
        CommonDataTypes.SharedReferenceSchema,
        CommonDataTypes.RemoteReferenceSchema,
        CommonDataTypes.LocalValueSchema,
    ]);
    // ListLocalValue = [*LocalValue];
    const ListLocalValueSchema = zod_1.z.array(LocalOrRemoteValueSchema);
    // ArrayLocalValue = {
    //   type: "array",
    //   value: ListLocalValue,
    // }
    const ArrayLocalValueSchema = zod_1.z.lazy(() => zod_1.z.object({
        type: zod_1.z.literal('array'),
        value: ListLocalValueSchema,
    }));
    // DateLocalValue = {
    //   type: "date",
    //   value: text
    // }
    const DateLocalValueSchema = zod_1.z.object({
        type: zod_1.z.literal('date'),
        value: zod_1.z.string().min(1),
    });
    // MappingLocalValue = [*[(LocalValue / text), LocalValue]];
    const MappingLocalValueSchema = zod_1.z.lazy(() => zod_1.z.tuple([
        zod_1.z.union([zod_1.z.string(), LocalOrRemoteValueSchema]),
        LocalOrRemoteValueSchema,
    ]));
    // MapLocalValue = {
    //   type: "map",
    //   value: MappingLocalValue,
    // }
    const MapLocalValueSchema = zod_1.z.object({
        type: zod_1.z.literal('map'),
        value: zod_1.z.array(MappingLocalValueSchema),
    });
    // ObjectLocalValue = {
    //   type: "object",
    //   value: MappingLocalValue,
    // }
    const ObjectLocalValueSchema = zod_1.z.object({
        type: zod_1.z.literal('object'),
        value: zod_1.z.array(MappingLocalValueSchema),
    });
    // RegExpLocalValue = {
    //   type: "regexp",
    //   value: RegExpValue,
    // }
    const RegExpLocalValueSchema = zod_1.z.lazy(() => zod_1.z.object({
        type: zod_1.z.literal('regexp'),
        value: zod_1.z.object({
            pattern: zod_1.z.string(),
            flags: zod_1.z.string().optional(),
        }),
    }));
    // SetLocalValue = {
    //   type: "set",
    //   value: ListLocalValue,
    // }
    const SetLocalValueSchema = zod_1.z.lazy(() => zod_1.z.object({
        type: zod_1.z.literal('set'),
        value: ListLocalValueSchema,
    }));
    // BrowsingContext = text;
    CommonDataTypes.BrowsingContextSchema = zod_1.z.string();
})(CommonDataTypes = exports.CommonDataTypes || (exports.CommonDataTypes = {}));
var Script;
(function (Script) {
    const RealmTypeSchema = zod_1.z.enum([
        'window',
        'dedicated-worker',
        'shared-worker',
        'service-worker',
        'worker',
        'paint-worklet',
        'audio-worklet',
        'worklet',
    ]);
    Script.GetRealmsParametersSchema = zod_1.z.object({
        context: CommonDataTypes.BrowsingContextSchema.optional(),
        type: RealmTypeSchema.optional(),
    });
    function parseGetRealmsParams(params) {
        return parseObject(params, Script.GetRealmsParametersSchema);
    }
    Script.parseGetRealmsParams = parseGetRealmsParams;
    // ContextTarget = {
    //   context: BrowsingContext,
    //   ?sandbox: text
    // }
    const ContextTargetSchema = zod_1.z.object({
        context: CommonDataTypes.BrowsingContextSchema,
        sandbox: zod_1.z.string().optional(),
    });
    // RealmTarget = {realm: Realm};
    const RealmTargetSchema = zod_1.z.object({
        realm: zod_1.z.string().min(1),
    });
    //
    // Target = (
    //   RealmTarget //
    //   ContextTarget
    // );
    // Order is important, as `parse` is processed in the same order.
    // `RealmTargetSchema` has higher priority.
    const TargetSchema = zod_1.z.union([RealmTargetSchema, ContextTargetSchema]);
    const OwnershipModelSchema = zod_1.z.enum(['root', 'none']);
    // ScriptEvaluateParameters = {
    //   expression: text;
    //   target: Target;
    //   ?awaitPromise: bool;
    //   ?resultOwnership: OwnershipModel;
    // }
    const EvaluateParametersSchema = zod_1.z.object({
        expression: zod_1.z.string(),
        awaitPromise: zod_1.z.boolean(),
        target: TargetSchema,
        resultOwnership: OwnershipModelSchema.optional(),
    });
    function parseEvaluateParams(params) {
        return parseObject(params, EvaluateParametersSchema);
    }
    Script.parseEvaluateParams = parseEvaluateParams;
    const DisownParametersSchema = zod_1.z.object({
        target: TargetSchema,
        handles: zod_1.z.array(zod_1.z.string()),
    });
    function parseDisownParams(params) {
        return parseObject(params, DisownParametersSchema);
    }
    Script.parseDisownParams = parseDisownParams;
    const ArgumentValueSchema = zod_1.z.union([
        CommonDataTypes.RemoteReferenceSchema,
        CommonDataTypes.SharedReferenceSchema,
        CommonDataTypes.LocalValueSchema,
    ]);
    const ScriptCallFunctionParametersSchema = zod_1.z.object({
        functionDeclaration: zod_1.z.string(),
        target: TargetSchema,
        arguments: zod_1.z.array(ArgumentValueSchema).optional(),
        this: ArgumentValueSchema.optional(),
        awaitPromise: zod_1.z.boolean(),
        resultOwnership: OwnershipModelSchema.optional(),
    });
    function parseCallFunctionParams(params) {
        return parseObject(params, ScriptCallFunctionParametersSchema);
    }
    Script.parseCallFunctionParams = parseCallFunctionParams;
})(Script = exports.Script || (exports.Script = {}));
// https://w3c.github.io/webdriver-bidi/#module-browsingContext
var BrowsingContext;
(function (BrowsingContext) {
    const GetTreeParametersSchema = zod_1.z.object({
        maxDepth: zod_1.z.number().int().nonnegative().max(MAX_INT).optional(),
        root: CommonDataTypes.BrowsingContextSchema.optional(),
    });
    function parseGetTreeParams(params) {
        return parseObject(params, GetTreeParametersSchema);
    }
    BrowsingContext.parseGetTreeParams = parseGetTreeParams;
    const ReadinessStateSchema = zod_1.z.enum(['none', 'interactive', 'complete']);
    // BrowsingContextNavigateParameters = {
    //   context: BrowsingContext,
    //   url: text,
    //   ?wait: ReadinessState,
    // }
    // ReadinessState = "none" / "interactive" / "complete"
    const NavigateParametersSchema = zod_1.z.object({
        context: CommonDataTypes.BrowsingContextSchema,
        url: zod_1.z.string().url(),
        wait: ReadinessStateSchema.optional(),
    });
    function parseNavigateParams(params) {
        return parseObject(params, NavigateParametersSchema);
    }
    BrowsingContext.parseNavigateParams = parseNavigateParams;
    // BrowsingContextCreateType = "tab" / "window"
    //
    // BrowsingContextCreateParameters = {
    //   type: BrowsingContextCreateType
    // }
    const CreateParametersSchema = zod_1.z.object({
        type: zod_1.z.enum(['tab', 'window']),
        referenceContext: CommonDataTypes.BrowsingContextSchema.optional(),
    });
    function parseCreateParams(params) {
        return parseObject(params, CreateParametersSchema);
    }
    BrowsingContext.parseCreateParams = parseCreateParams;
    // BrowsingContextCloseParameters = {
    //   context: BrowsingContext
    // }
    const CloseParametersSchema = zod_1.z.object({
        context: CommonDataTypes.BrowsingContextSchema,
    });
    function parseCloseParams(params) {
        return parseObject(params, CloseParametersSchema);
    }
    BrowsingContext.parseCloseParams = parseCloseParams;
    BrowsingContext.AllEvents = 'browsingContext';
    let EventNames;
    (function (EventNames) {
        EventNames["LoadEvent"] = "browsingContext.load";
        EventNames["DomContentLoadedEvent"] = "browsingContext.domContentLoaded";
        EventNames["ContextCreatedEvent"] = "browsingContext.contextCreated";
        EventNames["ContextDestroyedEvent"] = "browsingContext.contextDestroyed";
    })(EventNames = BrowsingContext.EventNames || (BrowsingContext.EventNames = {}));
})(BrowsingContext = exports.BrowsingContext || (exports.BrowsingContext = {}));
// https://w3c.github.io/webdriver-bidi/#module-log
var Log;
(function (Log) {
    Log.AllEvents = 'log';
    let EventNames;
    (function (EventNames) {
        EventNames["LogEntryAddedEvent"] = "log.entryAdded";
    })(EventNames = Log.EventNames || (Log.EventNames = {}));
})(Log = exports.Log || (exports.Log = {}));
var CDP;
(function (CDP) {
    const SendCommandParamsSchema = zod_1.z.object({
        cdpMethod: zod_1.z.string(),
        // `passthrough` allows object to have any fields.
        // https://github.com/colinhacks/zod#passthrough
        cdpParams: zod_1.z.object({}).passthrough(),
        cdpSession: zod_1.z.string().optional(),
    });
    function parseSendCommandParams(params) {
        return parseObject(params, SendCommandParamsSchema);
    }
    CDP.parseSendCommandParams = parseSendCommandParams;
    const GetSessionParamsSchema = zod_1.z.object({
        context: CommonDataTypes.BrowsingContextSchema,
    });
    function parseGetSessionParams(params) {
        return parseObject(params, GetSessionParamsSchema);
    }
    CDP.parseGetSessionParams = parseGetSessionParams;
    CDP.AllEvents = 'cdp';
    let EventNames;
    (function (EventNames) {
        EventNames["EventReceivedEvent"] = "cdp.eventReceived";
    })(EventNames = CDP.EventNames || (CDP.EventNames = {}));
})(CDP = exports.CDP || (exports.CDP = {}));
var Session;
(function (Session) {
    const SubscribeParametersEventSchema = zod_1.z.enum([
        BrowsingContext.AllEvents,
        BrowsingContext.EventNames.ContextCreatedEvent,
        BrowsingContext.EventNames.ContextDestroyedEvent,
        BrowsingContext.EventNames.DomContentLoadedEvent,
        BrowsingContext.EventNames.LoadEvent,
        Log.AllEvents,
        Log.EventNames.LogEntryAddedEvent,
        CDP.AllEvents,
        CDP.EventNames.EventReceivedEvent,
    ]);
    // SessionSubscribeParameters = {
    //   events: [*text],
    //   ?contexts: [*BrowsingContext],
    // }
    const SubscribeParametersSchema = zod_1.z.object({
        events: zod_1.z.array(SubscribeParametersEventSchema),
        contexts: zod_1.z.array(CommonDataTypes.BrowsingContextSchema).optional(),
    });
    function parseSubscribeParams(params) {
        return parseObject(params, SubscribeParametersSchema);
    }
    Session.parseSubscribeParams = parseSubscribeParams;
})(Session = exports.Session || (exports.Session = {}));
//# sourceMappingURL=protocol-parser.js.map