{"version":3,"file":"exportParser.cjs","names":["_jsdoccomment","require","_debug","_interopRequireDefault","e","__esModule","default","debug","debugModule","createNode","props","getSymbolValue","symbol","type","value","getIdentifier","node","globals","scope","opts","simpleIdentifier","identifierLiteral","name","block","createSymbol","getSymbol","opt","val","prototype","left","right","method","body","key","parent","obj","object","propertySymbol","property","computed","propertyValue","prop","properties","includes","propVal","createBlockSymbol","isGlobal","window","special","nde","id","valueSymbol","initVariables","declaration","expression","childNode","declarations","initWindow","kind","mapVariables","isExport","exported","ANONYMOUS_DEFAULT","specifier","specifiers","local","ancestorsOnly","Boolean","init","findNode","cache","blockCache","slice","push","propval","Object","values","Array","isArray","some","exportTypes","Set","ignorableNestedTypes","getExportAncestor","idx","ignorableIfDeep","has","canBeExportedByAncestorType","canExportChildrenType","isExportByAncestor","findExportedNode","pval","isNodeExported","moduleExports","module","exports","initModuleExports","esm","parseRecursive","globalVars","parse","ast","accessibilityNodes","isPrivate","accessibility","undefined","isUncommentedExport","sourceCode","settings","exportNode","findJSDocComment","parseResult","_default"],"sources":["../src/exportParser.js"],"sourcesContent":["import {\n  findJSDocComment,\n} from '@es-joy/jsdoccomment';\nimport debugModule from 'debug';\n\nconst debug = debugModule('requireExportJsdoc');\n\n/**\n * @typedef {{\n *   value: string\n * }} ValueObject\n */\n\n/**\n * @typedef {{\n *   type?: string,\n *   value?: ValueObject|import('eslint').Rule.Node|import('@typescript-eslint/types').TSESTree.Node,\n *   props: {\n *     [key: string]: CreatedNode|null,\n *   },\n *   special?: true,\n *   globalVars?: CreatedNode,\n *   exported?: boolean,\n *   ANONYMOUS_DEFAULT?: import('eslint').Rule.Node\n * }} CreatedNode\n */\n\n/**\n * @returns {CreatedNode}\n */\nconst createNode = function () {\n  return {\n    props: {},\n  };\n};\n\n/**\n * @param {CreatedNode|null} symbol\n * @returns {string|null}\n */\nconst getSymbolValue = function (symbol) {\n  /* c8 ignore next 3 */\n  if (!symbol) {\n    return null;\n  }\n\n  /* c8 ignore else */\n  if (symbol.type === 'literal') {\n    return /** @type {ValueObject} */ (symbol.value).value;\n  }\n  /* c8 ignore next 2 */\n  // eslint-disable-next-line @stylistic/padding-line-between-statements -- c8\n  return null;\n};\n\n/**\n *\n * @param {import('estree').Identifier} node\n * @param {CreatedNode} globals\n * @param {CreatedNode} scope\n * @param {SymbolOptions} opts\n * @returns {CreatedNode|null}\n */\nconst getIdentifier = function (node, globals, scope, opts) {\n  if (opts.simpleIdentifier) {\n    // Type is Identier for noncomputed properties\n    const identifierLiteral = createNode();\n    identifierLiteral.type = 'literal';\n    identifierLiteral.value = {\n      value: node.name,\n    };\n\n    return identifierLiteral;\n  }\n\n  /* c8 ignore next */\n  const block = scope || globals;\n\n  // As scopes are not currently supported, they are not traversed upwards recursively\n  if (block.props[node.name]) {\n    return block.props[node.name];\n  }\n\n  // Seems this will only be entered once scopes added and entered\n  /* c8 ignore next 3 */\n  if (globals.props[node.name]) {\n    return globals.props[node.name];\n  }\n\n  return null;\n};\n\n/**\n * @callback CreateSymbol\n * @param {import('eslint').Rule.Node|null} node\n * @param {CreatedNode} globals\n * @param {import('eslint').Rule.Node|import('@typescript-eslint/types').TSESTree.Node|null} value\n * @param {CreatedNode} [scope]\n * @param {boolean|SymbolOptions} [isGlobal]\n * @returns {CreatedNode|null}\n */\n\n/** @type {CreateSymbol} */\nlet createSymbol; // eslint-disable-line prefer-const\n\n/* eslint-disable complexity -- Temporary */\n\n/**\n * @typedef {{\n *   simpleIdentifier?: boolean\n * }} SymbolOptions\n */\n\n/**\n *\n * @param {import('eslint').Rule.Node|import('@typescript-eslint/types').TSESTree.Node} node\n * @param {CreatedNode} globals\n * @param {CreatedNode} scope\n * @param {SymbolOptions} [opt]\n * @returns {CreatedNode|null}\n */\nconst getSymbol = function (node, globals, scope, opt) {\n  /* eslint-enable complexity -- Temporary */\n  const opts = opt || {};\n  /* c8 ignore next */\n  switch (node.type) {\n    /* c8 ignore next 4 -- No longer needed? */\n    case 'ArrowFunctionExpression':\n\n    // Fallthrough\n    case 'ClassDeclaration':\n\n    case 'FunctionDeclaration':\n\n    case 'FunctionExpression':\n    case 'TSEnumDeclaration':\n    case 'TSInterfaceDeclaration':\n    case 'TSTypeAliasDeclaration': {\n      const val = createNode();\n      val.props.prototype = createNode();\n      val.props.prototype.type = 'object';\n      val.type = 'object';\n      val.value = node;\n\n      return val;\n    }\n\n    case 'AssignmentExpression': {\n      return createSymbol(\n      /** @type {import('eslint').Rule.Node} */\n        (node.left),\n        globals,\n        /** @type {import('eslint').Rule.Node} */\n        (node.right),\n        scope,\n        opts,\n      );\n    }\n\n    case 'ClassBody': {\n      const val = createNode();\n      for (const method of node.body) {\n        // StaticBlock\n        if (!('key' in method)) {\n          continue;\n        }\n\n        val.props[\n        /** @type {import('estree').Identifier} */ (\n          /** @type {import('estree').MethodDefinition} */ (\n              method\n            ).key\n          ).name\n        ] = createNode();\n        /** @type {{[key: string]: CreatedNode}} */ (val.props)[\n        /** @type {import('estree').Identifier} */ (\n          /** @type {import('estree').MethodDefinition} */ (\n              method\n            ).key\n          ).name\n        ].type = 'object';\n        /** @type {{[key: string]: CreatedNode}} */ (val.props)[\n        /** @type {import('estree').Identifier} */ (\n          /** @type {import('estree').MethodDefinition} */ (\n              method\n            ).key\n          ).name\n        ].value = /** @type {import('eslint').Rule.Node} */ (\n        /** @type {import('estree').MethodDefinition} */ (method).value\n        );\n      }\n\n      val.type = 'object';\n      val.value = node.parent;\n\n      return val;\n    }\n\n    case 'ClassExpression': {\n      return getSymbol(\n      /** @type {import('eslint').Rule.Node} */\n        (node.body),\n        globals,\n        scope,\n        opts,\n      );\n    }\n\n    case 'Identifier': {\n      return getIdentifier(node, globals, scope, opts);\n    }\n\n    case 'Literal': {\n      const val = createNode();\n      val.type = 'literal';\n      val.value = node;\n\n      return val;\n    }\n\n    case 'MemberExpression': {\n      const obj = getSymbol(\n      /** @type {import('eslint').Rule.Node} */\n        (node.object),\n        globals,\n        scope,\n        opts,\n      );\n      const propertySymbol = getSymbol(\n      /** @type {import('eslint').Rule.Node} */\n        (node.property),\n        globals,\n        scope,\n        {\n          simpleIdentifier: !node.computed,\n        },\n      );\n      const propertyValue = getSymbolValue(propertySymbol);\n\n      /* c8 ignore else */\n      if (obj && propertyValue && obj.props[propertyValue]) {\n        const block = obj.props[propertyValue];\n\n        return block;\n      }\n      /* c8 ignore next 11 */\n      /*\n    if (opts.createMissingProps && propertyValue) {\n      obj.props[propertyValue] = createNode();\n\n      return obj.props[propertyValue];\n    }\n    */\n      // eslint-disable-next-line @stylistic/padding-line-between-statements -- c8\n      debug(`MemberExpression: Missing property ${\n      /** @type {import('estree').PrivateIdentifier} */ (node.property).name\n      }`);\n      /* c8 ignore next 2 */\n      return null;\n    }\n\n    case 'ObjectExpression': {\n      const val = createNode();\n      val.type = 'object';\n      for (const prop of node.properties) {\n        if ([\n        // @babel/eslint-parser\n          'ExperimentalSpreadProperty',\n\n          // typescript-eslint, espree, acorn, etc.\n          'SpreadElement',\n        ].includes(prop.type)) {\n          continue;\n        }\n\n        const propVal = getSymbol(\n        /** @type {import('eslint').Rule.Node} */ (\n          /** @type {import('estree').Property} */\n            (prop).value\n          ),\n          globals,\n          scope,\n          opts,\n        );\n        /* c8 ignore next 8 */\n        if (propVal) {\n          val.props[\n          /** @type {import('estree').PrivateIdentifier} */\n            (\n            /** @type {import('estree').Property} */ (prop).key\n            ).name\n          ] = propVal;\n        }\n      }\n\n      return val;\n    }\n  }\n  /* c8 ignore next 2 */\n  // eslint-disable-next-line @stylistic/padding-line-between-statements -- c8\n  return null;\n};\n\n/**\n *\n * @param {CreatedNode} block\n * @param {string} name\n * @param {CreatedNode|null} value\n * @param {CreatedNode} globals\n * @param {boolean|SymbolOptions|undefined} isGlobal\n * @returns {void}\n */\nconst createBlockSymbol = function (block, name, value, globals, isGlobal) {\n  block.props[name] = value;\n  if (isGlobal && globals.props.window && globals.props.window.special) {\n    globals.props.window.props[name] = value;\n  }\n};\n\ncreateSymbol = function (node, globals, value, scope, isGlobal) {\n  const block = scope || globals;\n  /* c8 ignore next 3 */\n  if (!node) {\n    return null;\n  }\n\n  let symbol;\n  switch (node.type) {\n    case 'ClassDeclaration':\n      /* c8 ignore next */\n      // @ts-expect-error TS OK\n      // Fall through\n    case 'FunctionDeclaration': case 'TSEnumDeclaration':\n      /* c8 ignore next */\n      // @ts-expect-error TS OK\n      // Fall through\n    case 'TSInterfaceDeclaration': case 'TSTypeAliasDeclaration': {\n      const nde = /** @type {import('estree').ClassDeclaration} */ (node);\n      /* c8 ignore else */\n      if (nde.id && nde.id.type === 'Identifier') {\n        return createSymbol(\n        /** @type {import('eslint').Rule.Node} */ (nde.id),\n          globals,\n          node,\n          globals,\n        );\n      }\n      /* c8 ignore next 3 */\n      // eslint-disable-next-line @stylistic/padding-line-between-statements -- c8\n      break;\n    }\n\n    case 'Identifier': {\n      const nde = /** @type {import('estree').Identifier} */ (node);\n      if (value) {\n        const valueSymbol = getSymbol(value, globals, block);\n        /* c8 ignore else */\n        if (valueSymbol) {\n          createBlockSymbol(block, nde.name, valueSymbol, globals, isGlobal);\n\n          return block.props[nde.name];\n        }\n        /* c8 ignore next 2 */\n        // eslint-disable-next-line @stylistic/padding-line-between-statements -- c8\n        debug('Identifier: Missing value symbol for %s', nde.name);\n      } else {\n        createBlockSymbol(block, nde.name, createNode(), globals, isGlobal);\n\n        return block.props[nde.name];\n      }\n      /* c8 ignore next 3 */\n      // eslint-disable-next-line @stylistic/padding-line-between-statements -- c8\n      break;\n    }\n\n    case 'MemberExpression': {\n      const nde = /** @type {import('estree').MemberExpression} */ (node);\n      symbol = getSymbol(\n      /** @type {import('eslint').Rule.Node} */ (nde.object), globals, block,\n      );\n\n      const propertySymbol = getSymbol(\n      /** @type {import('eslint').Rule.Node} */ (nde.property),\n        globals,\n        block,\n        {\n          simpleIdentifier: !nde.computed,\n        },\n      );\n      const propertyValue = getSymbolValue(propertySymbol);\n      if (symbol && propertyValue) {\n        createBlockSymbol(symbol, propertyValue, getSymbol(\n        /** @type {import('eslint').Rule.Node} */\n          (value), globals, block,\n        ), globals, isGlobal);\n        return symbol.props[propertyValue];\n      }\n\n      debug(\n        'MemberExpression: Missing symbol: %s',\n        /** @type {import('estree').Identifier} */ (\n          nde.property\n        ).name,\n      );\n      break;\n    }\n  }\n\n  return null;\n};\n\n/**\n * Creates variables from variable definitions\n * @param {import('eslint').Rule.Node} node\n * @param {CreatedNode} globals\n * @param {import('./rules/requireJsdoc.js').RequireJsdocOpts} opts\n * @returns {void}\n */\nconst initVariables = function (node, globals, opts) {\n  switch (node.type) {\n    case 'ExportNamedDeclaration': {\n      if (node.declaration) {\n        initVariables(\n        /** @type {import('eslint').Rule.Node} */\n          (node.declaration),\n          globals,\n          opts,\n        );\n      }\n\n      break;\n    }\n\n    case 'ExpressionStatement': {\n      initVariables(\n      /** @type {import('eslint').Rule.Node} */\n        (node.expression),\n        globals,\n        opts,\n      );\n      break;\n    }\n\n    case 'Program': {\n      for (const childNode of node.body) {\n        initVariables(\n        /** @type {import('eslint').Rule.Node} */\n          (childNode),\n          globals,\n          opts,\n        );\n      }\n\n      break;\n    }\n\n    case 'VariableDeclaration': {\n      for (const declaration of node.declarations) {\n      // let and const\n        const symbol = createSymbol(\n        /** @type {import('eslint').Rule.Node} */\n          (declaration.id),\n          globals,\n          null,\n          globals,\n        );\n        if (opts.initWindow && node.kind === 'var' && globals.props.window) {\n        // If var, also add to window\n          globals.props.window.props[\n          /** @type {import('estree').Identifier} */\n            (declaration.id).name\n          ] = symbol;\n        }\n      }\n\n      break;\n    }\n  }\n};\n\n/* eslint-disable complexity -- Temporary */\n\n/**\n * Populates variable maps using AST\n * @param {import('eslint').Rule.Node|import('@typescript-eslint/types').TSESTree.Node} node\n * @param {CreatedNode} globals\n * @param {import('./rules/requireJsdoc.js').RequireJsdocOpts} opt\n * @param {true} [isExport]\n * @returns {boolean}\n */\nconst mapVariables = function (node, globals, opt, isExport) {\n  /* eslint-enable complexity -- Temporary */\n  /* c8 ignore next */\n  const opts = opt || {};\n  /* c8 ignore next */\n  switch (node.type) {\n    case 'AssignmentExpression': {\n      createSymbol(\n      /** @type {import('eslint').Rule.Node} */\n        (node.left),\n        globals,\n        /** @type {import('eslint').Rule.Node} */\n        (node.right),\n      );\n      break;\n    }\n\n    case 'ClassDeclaration': {\n      createSymbol(\n      /** @type {import('eslint').Rule.Node|null} */ (node.id),\n        globals,\n        /** @type {import('eslint').Rule.Node} */ (node.body),\n        globals,\n      );\n      break;\n    }\n\n    case 'ExportDefaultDeclaration': {\n      const symbol = createSymbol(\n      /** @type {import('eslint').Rule.Node} */\n        (node.declaration),\n        globals,\n        /** @type {import('eslint').Rule.Node} */\n        (node.declaration),\n      );\n      if (symbol) {\n        symbol.exported = true;\n        /* c8 ignore next 6 */\n      } else {\n      // if (!node.id) {\n        globals.ANONYMOUS_DEFAULT = /** @type {import('eslint').Rule.Node} */ (\n          node.declaration\n        );\n      }\n\n      break;\n    }\n\n    case 'ExportNamedDeclaration': {\n      if (node.declaration) {\n        if (node.declaration.type === 'VariableDeclaration') {\n          mapVariables(\n          /** @type {import('eslint').Rule.Node} */\n            (node.declaration),\n            globals,\n            opts,\n            true,\n          );\n        } else {\n          const symbol = createSymbol(\n          /** @type {import('eslint').Rule.Node} */\n            (node.declaration),\n            globals,\n            /** @type {import('eslint').Rule.Node} */\n            (node.declaration),\n          );\n          /* c8 ignore next 3 */\n          if (symbol) {\n            symbol.exported = true;\n          }\n        }\n      }\n\n      for (const specifier of node.specifiers) {\n        mapVariables(\n        /** @type {import('eslint').Rule.Node} */\n          (specifier),\n          globals,\n          opts,\n        );\n      }\n\n      break;\n    }\n\n    case 'ExportSpecifier': {\n      const symbol = getSymbol(\n      /** @type {import('eslint').Rule.Node} */\n        (node.local),\n        globals,\n        globals,\n      );\n      /* c8 ignore next 3 */\n      if (symbol) {\n        symbol.exported = true;\n      }\n\n      break;\n    }\n\n    case 'ExpressionStatement': {\n      mapVariables(\n      /** @type {import('eslint').Rule.Node} */\n        (node.expression),\n        globals,\n        opts,\n      );\n      break;\n    }\n\n    case 'FunctionDeclaration':\n\n    case 'TSTypeAliasDeclaration': {\n    /* c8 ignore next 10 */\n      if (/** @type {import('estree').Identifier} */ (node.id).type === 'Identifier') {\n        createSymbol(\n        /** @type {import('eslint').Rule.Node} */\n          (node.id),\n          globals,\n          node,\n          globals,\n          true,\n        );\n      }\n\n      break;\n    }\n\n    case 'Program': {\n      if (opts.ancestorsOnly) {\n        return false;\n      }\n\n      for (const childNode of node.body) {\n        mapVariables(\n        /** @type {import('eslint').Rule.Node} */\n          (childNode),\n          globals,\n          opts,\n        );\n      }\n\n      break;\n    }\n\n    case 'VariableDeclaration': {\n      for (const declaration of node.declarations) {\n        const isGlobal = Boolean(opts.initWindow && node.kind === 'var' && globals.props.window);\n        const symbol = createSymbol(\n        /** @type {import('eslint').Rule.Node} */\n          (declaration.id),\n          globals,\n          /** @type {import('eslint').Rule.Node} */\n          (declaration.init),\n          globals,\n          isGlobal,\n        );\n        if (symbol && isExport) {\n          symbol.exported = true;\n        }\n      }\n\n      break;\n    }\n\n    default: {\n    /* c8 ignore next */\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n *\n * @param {import('eslint').Rule.Node} node\n * @param {CreatedNode|ValueObject|string|undefined|\n *   import('eslint').Rule.Node|import('@typescript-eslint/types').TSESTree.Node} block\n * @param {(CreatedNode|ValueObject|string|\n *   import('eslint').Rule.Node|import('@typescript-eslint/types').TSESTree.Node)[]} [cache]\n * @returns {boolean}\n */\nconst findNode = function (node, block, cache) {\n  let blockCache = cache || [];\n  if (!block || blockCache.includes(block)) {\n    return false;\n  }\n\n  blockCache = blockCache.slice();\n  blockCache.push(block);\n\n  if (\n    typeof block === 'object' &&\n    'type' in block &&\n    (block.type === 'object' || block.type === 'MethodDefinition') &&\n    block.value === node\n  ) {\n    return true;\n  }\n\n  if (typeof block !== 'object') {\n    return false;\n  }\n\n  const props = ('props' in block && block.props) || ('body' in block && block.body);\n  for (const propval of Object.values(props || {})) {\n    if (Array.isArray(propval)) {\n      /* c8 ignore next 5 */\n      if (propval.some((val) => {\n        return findNode(node, val, blockCache);\n      })) {\n        return true;\n      }\n    } else if (findNode(node, propval, blockCache)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nconst exportTypes = new Set([\n  'ExportDefaultDeclaration', 'ExportNamedDeclaration',\n]);\nconst ignorableNestedTypes = new Set([\n  'ArrowFunctionExpression', 'FunctionDeclaration', 'FunctionExpression',\n]);\n\n/**\n * @param {import('eslint').Rule.Node} nde\n * @returns {import('eslint').Rule.Node|false}\n */\nconst getExportAncestor = function (nde) {\n  let node = nde;\n  let idx = 0;\n  const ignorableIfDeep = ignorableNestedTypes.has(nde?.type);\n  while (node) {\n    // Ignore functions nested more deeply than say `export default function () {}`\n    if (idx >= 2 && ignorableIfDeep) {\n      break;\n    }\n\n    if (exportTypes.has(node.type)) {\n      return node;\n    }\n\n    node = node.parent;\n    idx++;\n  }\n\n  return false;\n};\n\nconst canBeExportedByAncestorType = new Set([\n  'ClassProperty',\n  'Method',\n  'PropertyDefinition',\n  'TSMethodSignature',\n  'TSPropertySignature',\n]);\n\nconst canExportChildrenType = new Set([\n  'ClassBody',\n  'ClassDeclaration',\n  'ClassDefinition',\n  'ClassExpression',\n  'Program',\n  'TSInterfaceBody',\n  'TSInterfaceDeclaration',\n  'TSTypeAliasDeclaration',\n  'TSTypeLiteral',\n  'TSTypeParameterInstantiation',\n  'TSTypeReference',\n]);\n\n/**\n * @param {import('eslint').Rule.Node} nde\n * @returns {false|import('eslint').Rule.Node}\n */\nconst isExportByAncestor = function (nde) {\n  if (!canBeExportedByAncestorType.has(nde.type)) {\n    return false;\n  }\n\n  let node = nde.parent;\n  while (node) {\n    if (exportTypes.has(node.type)) {\n      return node;\n    }\n\n    if (!canExportChildrenType.has(node.type)) {\n      return false;\n    }\n\n    node = node.parent;\n  }\n\n  return false;\n};\n\n/**\n *\n * @param {CreatedNode} block\n * @param {import('eslint').Rule.Node} node\n * @param {CreatedNode[]} [cache] Currently unused\n * @returns {boolean}\n */\nconst findExportedNode = function (block, node, cache) {\n  /* c8 ignore next 3 */\n  if (block === null) {\n    return false;\n  }\n\n  const blockCache = cache || [];\n  const {\n    props,\n  } = block;\n  for (const propval of Object.values(props)) {\n    const pval = /** @type {CreatedNode} */ (propval);\n    blockCache.push(pval);\n    if (pval.exported && (node === pval.value || findNode(node, pval.value))) {\n      return true;\n    }\n\n    // No need to check `propval` for exported nodes as ESM\n    //  exports are only global\n  }\n\n  return false;\n};\n\n/**\n *\n * @param {import('eslint').Rule.Node} node\n * @param {CreatedNode} globals\n * @param {import('./rules/requireJsdoc.js').RequireJsdocOpts} opt\n * @returns {boolean}\n */\nconst isNodeExported = function (node, globals, opt) {\n  const moduleExports = globals.props.module?.props?.exports;\n  if (\n    opt.initModuleExports && moduleExports && findNode(node, moduleExports)\n  ) {\n    return true;\n  }\n\n  if (opt.initWindow && globals.props.window && findNode(node, globals.props.window)) {\n    return true;\n  }\n\n  if (opt.esm && findExportedNode(globals, node)) {\n    return true;\n  }\n\n  return false;\n};\n\n/**\n *\n * @param {import('eslint').Rule.Node} node\n * @param {CreatedNode} globalVars\n * @param {import('./rules/requireJsdoc.js').RequireJsdocOpts} opts\n * @returns {boolean}\n */\nconst parseRecursive = function (node, globalVars, opts) {\n  // Iterate from top using recursion - stop at first processed node from top\n  if (node.parent && parseRecursive(node.parent, globalVars, opts)) {\n    return true;\n  }\n\n  return mapVariables(node, globalVars, opts);\n};\n\n/**\n *\n * @param {import('eslint').Rule.Node} ast\n * @param {import('eslint').Rule.Node} node\n * @param {import('./rules/requireJsdoc.js').RequireJsdocOpts} opt\n * @returns {CreatedNode}\n */\nconst parse = function (ast, node, opt) {\n  /* c8 ignore next 6 */\n  const opts = opt || {\n    ancestorsOnly: false,\n    esm: true,\n    initModuleExports: true,\n    initWindow: true,\n  };\n\n  const globalVars = createNode();\n  if (opts.initModuleExports) {\n    globalVars.props.module = createNode();\n    globalVars.props.module.props.exports = createNode();\n    globalVars.props.exports = globalVars.props.module.props.exports;\n  }\n\n  if (opts.initWindow) {\n    globalVars.props.window = createNode();\n    globalVars.props.window.special = true;\n  }\n\n  if (opts.ancestorsOnly) {\n    parseRecursive(node, globalVars, opts);\n  } else {\n    initVariables(ast, globalVars, opts);\n    mapVariables(ast, globalVars, opts);\n  }\n\n  return {\n    globalVars,\n    props: {},\n  };\n};\n\nconst accessibilityNodes = new Set([\n  'MethodDefinition',\n  'PropertyDefinition',\n]);\n\n/**\n *\n * @param {import('eslint').Rule.Node} node\n * @returns {boolean}\n */\nconst isPrivate = (node) => {\n  return accessibilityNodes.has(node.type) &&\n    (\n      'accessibility' in node &&\n      node.accessibility !== 'public' && node.accessibility !== undefined\n    ) ||\n  'key' in node &&\n    node.key.type === 'PrivateIdentifier';\n};\n\n/**\n *\n * @param {import('eslint').Rule.Node} node\n * @param {import('eslint').SourceCode} sourceCode\n * @param {import('./rules/requireJsdoc.js').RequireJsdocOpts} opt\n * @param {import('./iterateJsdoc.js').Settings} settings\n * @returns {boolean}\n */\nconst isUncommentedExport = function (node, sourceCode, opt, settings) {\n  // console.log({node});\n  // Optimize with ancestor check for esm\n  if (opt.esm) {\n    if (isPrivate(node) ||\n      node.parent && isPrivate(node.parent)) {\n      return false;\n    }\n\n    const exportNode = getExportAncestor(node);\n\n    // Is export node comment\n    if (exportNode && !findJSDocComment(exportNode, sourceCode, settings)) {\n      return true;\n    }\n\n    /**\n     * Some typescript types are not in variable map, but inherit exported (interface property and method)\n     */\n    if (\n      isExportByAncestor(node) &&\n      !findJSDocComment(node, sourceCode, settings)\n    ) {\n      return true;\n    }\n  }\n\n  const ast = /** @type {unknown} */ (sourceCode.ast);\n\n  const parseResult = parse(\n    /** @type {import('eslint').Rule.Node} */\n    (ast),\n    node,\n    opt,\n  );\n\n  return isNodeExported(\n    node, /** @type {CreatedNode} */ (parseResult.globalVars), opt,\n  );\n};\n\nexport default {\n  isUncommentedExport,\n  parse,\n};\n"],"mappings":"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","ignoreList":[]}