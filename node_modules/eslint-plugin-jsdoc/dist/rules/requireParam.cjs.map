{"version":3,"file":"requireParam.cjs","names":["_iterateJsdoc","_interopRequireDefault","require","e","__esModule","default","rootNamer","desiredRoots","currentIndex","name","idx","incremented","length","base","suffix","shift","_default","exports","iterateJsdoc","context","jsdoc","node","utils","avoidDocs","hasTag","autoIncrementBase","checkDestructured","checkDestructuredRoots","checkRestProperty","checkTypesPattern","enableFixer","enableRestElementFixer","enableRootFixer","ignoreWhenAllParamsMissing","interfaceExemptsParamsCheck","unnamedRootBase","useDefaultObjectProperties","options","parent","type","id","typeAnnotation","preferredTagName","getPreferredTagName","tagName","functionParameterNames","getFunctionParameterNames","jsdocParameterNames","getJsdocTagsDeep","shallowJsdocParameterNames","filter","tag","includes","map","checkTypesRegex","getRegexFromString","missingTags","flattenedRoots","flattenRoots","names","paramIndex","hasParamIndex","cur","dropPathSegmentQuotes","String","getParamIndex","setParamIndex","entries","findExpectedIndex","jsdocTags","indexAtFunctionParams","remainingFlattenedRoots","slice","foundIndex","findIndex","newAdd","some","flattenedRoot","endsWith","tags","tagLineCount","source","tokens","end","nextRootName","namer","thisOffset","functionParameterIdx","functionParameterName","inc","Array","isArray","matchedJsdoc","rootName","search","hasPropertyRest","hasRestElement","rests","notCheckingNames","paramName","find","fpn","emptyParamIdx","push","remove","fullParamName","notCheckingName","paramType","comparePaths","undefined","startsWith","funcParamName","restElement","fix","createTokens","tagIndex","sourceIndex","spliceCount","number","delimiter","description","lineEnd","postDelimiter","postName","postTag","postType","start","splice","inlineTags","optional","problems","firstNumber","src","offset","expectedIdx","firstParamLine","baseOffset","fixer","missingTag","makeMultiline","reportJSDoc","contextDefaults","meta","docs","url","fixable","schema","additionalProperties","properties","checkConstructors","checkGetters","checkSetters","contexts","items","anyOf","comment","exemptedBy","noTracking","module"],"sources":["../../src/rules/requireParam.js"],"sourcesContent":["import iterateJsdoc from '../iterateJsdoc.js';\n\n/**\n * @typedef {[string, boolean, () => RootNamerReturn]} RootNamerReturn\n */\n\n/**\n * @param {string[]} desiredRoots\n * @param {number} currentIndex\n * @returns {RootNamerReturn}\n */\nconst rootNamer = (desiredRoots, currentIndex) => {\n  /** @type {string} */\n  let name;\n  let idx = currentIndex;\n  const incremented = desiredRoots.length <= 1;\n  if (incremented) {\n    const base = desiredRoots[0];\n    const suffix = idx++;\n    name = `${base}${suffix}`;\n  } else {\n    name = /** @type {string} */ (desiredRoots.shift());\n  }\n\n  return [\n    name,\n    incremented,\n    () => {\n      return rootNamer(desiredRoots, idx);\n    },\n  ];\n};\n\n/* eslint-disable complexity -- Temporary */\nexport default iterateJsdoc(({\n  context,\n  jsdoc,\n  node,\n  utils,\n}) => {\n  /* eslint-enable complexity -- Temporary */\n  if (utils.avoidDocs()) {\n    return;\n  }\n\n  // Param type is specified by type in @type\n  if (utils.hasTag('type')) {\n    return;\n  }\n\n  const {\n    autoIncrementBase = 0,\n    checkDestructured = true,\n    checkDestructuredRoots = true,\n    checkRestProperty = false,\n    checkTypesPattern = '/^(?:[oO]bject|[aA]rray|PlainObject|Generic(?:Object|Array))$/',\n    enableFixer = true,\n    enableRestElementFixer = true,\n    enableRootFixer = true,\n    ignoreWhenAllParamsMissing = false,\n    interfaceExemptsParamsCheck = false,\n    unnamedRootBase = [\n      'root',\n    ],\n    useDefaultObjectProperties = false,\n  } = context.options[0] || {};\n\n  if (interfaceExemptsParamsCheck && node &&\n    node.parent?.type === 'VariableDeclarator' &&\n    'typeAnnotation' in node.parent.id && node.parent.id.typeAnnotation) {\n    return;\n  }\n\n  const preferredTagName = /** @type {string} */ (utils.getPreferredTagName({\n    tagName: 'param',\n  }));\n  if (!preferredTagName) {\n    return;\n  }\n\n  const functionParameterNames = utils.getFunctionParameterNames(useDefaultObjectProperties, interfaceExemptsParamsCheck);\n  if (!functionParameterNames.length) {\n    return;\n  }\n\n  const jsdocParameterNames =\n    /**\n     * @type {{\n     *   idx: import('../iterateJsdoc.js').Integer;\n     *   name: string;\n     *   type: string;\n     * }[]}\n     */ (utils.getJsdocTagsDeep(preferredTagName));\n\n  if (ignoreWhenAllParamsMissing && !jsdocParameterNames.length) {\n    return;\n  }\n\n  const shallowJsdocParameterNames = jsdocParameterNames.filter((tag) => {\n    return !tag.name.includes('.');\n  }).map((tag, idx) => {\n    return {\n      ...tag,\n      idx,\n    };\n  });\n\n  const checkTypesRegex = utils.getRegexFromString(checkTypesPattern);\n\n  /**\n   * @type {{\n   *   functionParameterIdx: import('../iterateJsdoc.js').Integer,\n   *   functionParameterName: string,\n   *   inc: boolean|undefined,\n   *   remove?: true,\n   *   type?: string|undefined\n   * }[]}\n   */\n  const missingTags = [];\n  const flattenedRoots = utils.flattenRoots(functionParameterNames).names;\n\n  /**\n   * @type {{\n   *   [key: string]: import('../iterateJsdoc.js').Integer\n   * }}\n   */\n  const paramIndex = {};\n\n  /**\n   * @param {string} cur\n   * @returns {boolean}\n   */\n  const hasParamIndex = (cur) => {\n    return utils.dropPathSegmentQuotes(String(cur)) in paramIndex;\n  };\n\n  /**\n   *\n   * @param {string|number|undefined} cur\n   * @returns {import('../iterateJsdoc.js').Integer}\n   */\n  const getParamIndex = (cur) => {\n    return paramIndex[utils.dropPathSegmentQuotes(String(cur))];\n  };\n\n  /**\n   *\n   * @param {string} cur\n   * @param {import('../iterateJsdoc.js').Integer} idx\n   * @returns {void}\n   */\n  const setParamIndex = (cur, idx) => {\n    paramIndex[utils.dropPathSegmentQuotes(String(cur))] = idx;\n  };\n\n  for (const [\n    idx,\n    cur,\n  ] of flattenedRoots.entries()) {\n    setParamIndex(cur, idx);\n  }\n\n  /**\n   *\n   * @param {(import('@es-joy/jsdoccomment').JsdocTagWithInline & {\n   *   newAdd?: boolean\n   * })[]} jsdocTags\n   * @param {import('../iterateJsdoc.js').Integer} indexAtFunctionParams\n   * @returns {{\n   *   foundIndex: import('../iterateJsdoc.js').Integer,\n   *   tagLineCount: import('../iterateJsdoc.js').Integer,\n   * }}\n   */\n  const findExpectedIndex = (jsdocTags, indexAtFunctionParams) => {\n    // Get the parameters that come after the current index in the flattened order\n    const remainingFlattenedRoots = flattenedRoots.slice((indexAtFunctionParams || 0) + 1);\n\n    // Find the first existing tag that comes after the current parameter in the flattened order\n    const foundIndex = jsdocTags.findIndex(({\n      name,\n      newAdd,\n    }) => {\n      if (newAdd) {\n        return false;\n      }\n\n      // Check if the tag name matches any of the remaining flattened roots\n      return remainingFlattenedRoots.some((flattenedRoot) => {\n        // The flattened roots don't have the root prefix (e.g., \"bar\", \"bar.baz\")\n        // but JSDoc tags do (e.g., \"root0\", \"root0.bar\", \"root0.bar.baz\")\n        // So we need to check if the tag name ends with the flattened root\n\n        // Check if tag name ends with \".<flattenedRoot>\"\n        if (name.endsWith(`.${flattenedRoot}`)) {\n          return true;\n        }\n\n        // Also check if tag name exactly matches the flattenedRoot\n        //   (for single-level params)\n        if (name === flattenedRoot) {\n          return true;\n        }\n\n        return false;\n      });\n    });\n\n    const tags = foundIndex > -1 ?\n      jsdocTags.slice(0, foundIndex) :\n      jsdocTags.filter(({\n        tag,\n      }) => {\n        return tag === preferredTagName;\n      });\n\n    let tagLineCount = 0;\n    for (const {\n      source,\n    } of tags) {\n      for (const {\n        tokens: {\n          end,\n        },\n      } of source) {\n        if (!end) {\n          tagLineCount++;\n        }\n      }\n    }\n\n    return {\n      foundIndex,\n      tagLineCount,\n    };\n  };\n\n  let [\n    nextRootName,\n    incremented,\n    namer,\n  ] = rootNamer([\n    ...unnamedRootBase,\n  ], autoIncrementBase);\n\n  const thisOffset = functionParameterNames[0] === 'this' ? 1 : 0;\n\n  for (const [\n    functionParameterIdx,\n    functionParameterName,\n  ] of functionParameterNames.entries()) {\n    let inc;\n    if (Array.isArray(functionParameterName)) {\n      const matchedJsdoc = shallowJsdocParameterNames[functionParameterIdx - thisOffset];\n\n      /** @type {string} */\n      let rootName;\n      if (functionParameterName[0]) {\n        rootName = functionParameterName[0];\n      } else if (matchedJsdoc && matchedJsdoc.name) {\n        rootName = matchedJsdoc.name;\n        if (matchedJsdoc.type && matchedJsdoc.type.search(checkTypesRegex) === -1) {\n          continue;\n        }\n      } else {\n        rootName = nextRootName;\n        inc = incremented;\n      }\n\n      [\n        nextRootName,\n        incremented,\n        namer,\n      ] = namer();\n\n      const {\n        hasPropertyRest,\n        hasRestElement,\n        names,\n        rests,\n      } = /**\n           * @type {import('../jsdocUtils.js').FlattendRootInfo & {\n           *   annotationParamName?: string | undefined;\n           * }}\n           */ (functionParameterName[1]);\n      const notCheckingNames = [];\n      if (!enableRestElementFixer && hasRestElement) {\n        continue;\n      }\n\n      if (!checkDestructuredRoots) {\n        continue;\n      }\n\n      for (const [\n        idx,\n        paramName,\n      ] of names.entries()) {\n        // Add root if the root name is not in the docs (and is not already\n        //  in the tags to be fixed)\n        if (!jsdocParameterNames.find(({\n          name,\n        }) => {\n          return name === rootName;\n        }) && !missingTags.find(({\n          functionParameterName: fpn,\n        }) => {\n          return fpn === rootName;\n        })) {\n          const emptyParamIdx = jsdocParameterNames.findIndex(({\n            name,\n          }) => {\n            return !name;\n          });\n\n          if (emptyParamIdx > -1) {\n            missingTags.push({\n              functionParameterIdx: emptyParamIdx,\n              functionParameterName: rootName,\n              inc,\n              remove: true,\n            });\n          } else {\n            missingTags.push({\n              functionParameterIdx: hasParamIndex(rootName) ?\n                getParamIndex(rootName) :\n                getParamIndex(paramName),\n              functionParameterName: rootName,\n              inc,\n            });\n          }\n        }\n\n        if (!checkDestructured) {\n          continue;\n        }\n\n        if (!checkRestProperty && rests[idx]) {\n          continue;\n        }\n\n        const fullParamName = `${rootName}.${paramName}`;\n\n        const notCheckingName = jsdocParameterNames.find(({\n          name,\n          type: paramType,\n        }) => {\n          return utils.comparePaths(name)(fullParamName) && paramType.search(checkTypesRegex) === -1 && paramType !== '';\n        });\n\n        if (notCheckingName !== undefined) {\n          notCheckingNames.push(notCheckingName.name);\n        }\n\n        if (notCheckingNames.find((name) => {\n          return fullParamName.startsWith(name);\n        })) {\n          continue;\n        }\n\n        if (jsdocParameterNames && !jsdocParameterNames.find(({\n          name,\n        }) => {\n          return utils.comparePaths(name)(fullParamName);\n        })) {\n          missingTags.push({\n            functionParameterIdx: getParamIndex(\n              functionParameterName[0] ? fullParamName : paramName,\n            ),\n            functionParameterName: fullParamName,\n            inc,\n            type: hasRestElement && !hasPropertyRest ? '{...any}' : undefined,\n          });\n        }\n      }\n\n      continue;\n    }\n\n    /** @type {string} */\n    let funcParamName;\n    let type;\n    if (typeof functionParameterName === 'object') {\n      if (!enableRestElementFixer && functionParameterName.restElement) {\n        continue;\n      }\n\n      funcParamName = /** @type {string} */ (functionParameterName.name);\n      type = '{...any}';\n    } else {\n      funcParamName = /** @type {string} */ (functionParameterName);\n    }\n\n    if (jsdocParameterNames && !jsdocParameterNames.find(({\n      name,\n    }) => {\n      return name === funcParamName;\n    }) && funcParamName !== 'this') {\n      missingTags.push({\n        functionParameterIdx: getParamIndex(funcParamName),\n        functionParameterName: funcParamName,\n        inc,\n        type,\n      });\n    }\n  }\n\n  /**\n   *\n   * @param {{\n   *   functionParameterIdx: import('../iterateJsdoc.js').Integer,\n   *   functionParameterName: string,\n   *   remove?: true,\n   *   inc?: boolean,\n   *   type?: string\n   * }} cfg\n   */\n  const fix = ({\n    functionParameterIdx,\n    functionParameterName,\n    inc,\n    remove,\n    type,\n  }) => {\n    if (inc && !enableRootFixer) {\n      return;\n    }\n\n    /**\n     *\n     * @param {import('../iterateJsdoc.js').Integer} tagIndex\n     * @param {import('../iterateJsdoc.js').Integer} sourceIndex\n     * @param {import('../iterateJsdoc.js').Integer} spliceCount\n     * @returns {void}\n     */\n    const createTokens = (tagIndex, sourceIndex, spliceCount) => {\n      // console.log(sourceIndex, tagIndex, jsdoc.tags, jsdoc.source);\n      const tokens = {\n        number: sourceIndex + 1,\n        source: '',\n        tokens: {\n          delimiter: '*',\n          description: '',\n          end: '',\n          lineEnd: '',\n          name: functionParameterName,\n          newAdd: true,\n          postDelimiter: ' ',\n          postName: '',\n          postTag: ' ',\n          postType: type ? ' ' : '',\n          start: jsdoc.source[sourceIndex].tokens.start,\n          tag: `@${preferredTagName}`,\n          type: type ?? '',\n        },\n      };\n\n      /**\n       * @type {(import('@es-joy/jsdoccomment').JsdocTagWithInline & {\n       *   newAdd?: true\n       * })[]}\n       */ (jsdoc.tags).splice(tagIndex, spliceCount, {\n        description: '',\n        inlineTags: [],\n        name: functionParameterName,\n        newAdd: true,\n        optional: false,\n        problems: [],\n        source: [\n          tokens,\n        ],\n        tag: preferredTagName,\n        type: type ?? '',\n      });\n      const firstNumber = jsdoc.source[0].number;\n      jsdoc.source.splice(sourceIndex, spliceCount, tokens);\n      for (const [\n        idx,\n        src,\n      ] of jsdoc.source.slice(sourceIndex).entries()) {\n        src.number = firstNumber + sourceIndex + idx;\n      }\n    };\n\n    const offset = jsdoc.source.findIndex(({\n      tokens: {\n        end,\n        tag,\n      },\n    }) => {\n      return tag || end;\n    });\n    if (remove) {\n      createTokens(functionParameterIdx, offset + functionParameterIdx, 1);\n    } else {\n      const {\n        foundIndex,\n        tagLineCount: expectedIdx,\n      } =\n        findExpectedIndex(jsdoc.tags, functionParameterIdx);\n\n      const firstParamLine = jsdoc.source.findIndex(({\n        tokens,\n      }) => {\n        return tokens.tag === `@${preferredTagName}`;\n      });\n      const baseOffset = foundIndex > -1 || firstParamLine === -1 ?\n        offset :\n        firstParamLine;\n\n      createTokens(expectedIdx, baseOffset + expectedIdx, 0);\n    }\n  };\n\n  /**\n   * @returns {void}\n   */\n  const fixer = () => {\n    for (const missingTag of missingTags) {\n      fix(missingTag);\n    }\n  };\n\n  if (missingTags.length && jsdoc.source.length === 1) {\n    utils.makeMultiline();\n  }\n\n  for (const {\n    functionParameterName,\n  } of missingTags) {\n    utils.reportJSDoc(\n      `Missing JSDoc @${preferredTagName} \"${functionParameterName}\" declaration.`,\n      null,\n      enableFixer ? fixer : null,\n    );\n  }\n}, {\n  contextDefaults: true,\n  meta: {\n    docs: {\n      description: 'Requires that all function parameters are documented with a `@param` tag.',\n      url: 'https://github.com/gajus/eslint-plugin-jsdoc/blob/main/docs/rules/require-param.md#repos-sticky-header',\n    },\n    fixable: 'code',\n    schema: [\n      {\n        additionalProperties: false,\n        properties: {\n          autoIncrementBase: {\n            default: 0,\n            description: `Numeric to indicate the number at which to begin auto-incrementing roots.\nDefaults to \\`0\\`.`,\n            type: 'integer',\n          },\n          checkConstructors: {\n            default: true,\n            description: `A value indicating whether \\`constructor\\`s should be checked. Defaults to\n\\`true\\`.`,\n            type: 'boolean',\n          },\n          checkDestructured: {\n            default: true,\n            description: 'Whether to require destructured properties. Defaults to `true`.',\n            type: 'boolean',\n          },\n          checkDestructuredRoots: {\n            default: true,\n            description: `Whether to check the existence of a corresponding \\`@param\\` for root objects\nof destructured properties (e.g., that for \\`function ({a, b}) {}\\`, that there\nis something like \\`@param myRootObj\\` defined that can correspond to\nthe \\`{a, b}\\` object parameter).\n\nIf \\`checkDestructuredRoots\\` is \\`false\\`, \\`checkDestructured\\` will also be\nimplied to be \\`false\\` (i.e., the inside of the roots will not be checked\neither, e.g., it will also not complain if \\`a\\` or \\`b\\` do not have their own\ndocumentation). Defaults to \\`true\\`.`,\n            type: 'boolean',\n          },\n          checkGetters: {\n            default: false,\n            description: 'A value indicating whether getters should be checked. Defaults to `false`.',\n            type: 'boolean',\n          },\n          checkRestProperty: {\n            default: false,\n            description: `If set to \\`true\\`, will report (and add fixer insertions) for missing rest\nproperties. Defaults to \\`false\\`.\n\nIf set to \\`true\\`, note that you can still document the subproperties of the\nrest property using other jsdoc features, e.g., \\`@typedef\\`:\n\n\\`\\`\\`js\n/**\n * @typedef ExtraOptions\n * @property innerProp1\n * @property innerProp2\n */\n\n/**\n * @param cfg\n * @param cfg.num\n * @param {ExtraOptions} extra\n */\nfunction quux ({num, ...extra}) {\n}\n\\`\\`\\`\n\nSetting this option to \\`false\\` (the default) may be useful in cases where\nyou already have separate \\`@param\\` definitions for each of the properties\nwithin the rest property.\n\nFor example, with the option disabled, this will not give an error despite\n\\`extra\\` not having any definition:\n\n\\`\\`\\`js\n/**\n * @param cfg\n * @param cfg.num\n */\nfunction quux ({num, ...extra}) {\n}\n\\`\\`\\`\n\nNor will this:\n\n\\`\\`\\`js\n/**\n * @param cfg\n * @param cfg.num\n * @param cfg.innerProp1\n * @param cfg.innerProp2\n */\nfunction quux ({num, ...extra}) {\n}\n\\`\\`\\``,\n            type: 'boolean',\n          },\n          checkSetters: {\n            default: false,\n            description: 'A value indicating whether setters should be checked. Defaults to `false`.',\n            type: 'boolean',\n          },\n          checkTypesPattern: {\n            description: `When one specifies a type, unless it is of a generic type, like \\`object\\`\nor \\`array\\`, it may be considered unnecessary to have that object's\ndestructured components required, especially where generated docs will\nlink back to the specified type. For example:\n\n\\`\\`\\`js\n/**\n * @param {SVGRect} bbox - a SVGRect\n */\nexport const bboxToObj = function ({x, y, width, height}) {\n  return {x, y, width, height};\n};\n\\`\\`\\`\n\nBy default \\`checkTypesPattern\\` is set to\n\\`/^(?:[oO]bject|[aA]rray|PlainObject|Generic(?:Object|Array))$/v\\`,\nmeaning that destructuring will be required only if the type of the \\`@param\\`\n(the text between curly brackets) is a match for \"Object\" or \"Array\" (with or\nwithout initial caps), \"PlainObject\", or \"GenericObject\", \"GenericArray\" (or\nif no type is present). So in the above example, the lack of a match will\nmean that no complaint will be given about the undocumented destructured\nparameters.\n\nNote that the \\`/\\` delimiters are optional, but necessary to add flags.\n\nDefaults to using (only) the \\`v\\` flag, so to add your own flags, encapsulate\nyour expression as a string, but like a literal, e.g., \\`/^object$/vi\\`.\n\nYou could set this regular expression to a more expansive list, or you\ncould restrict it such that even types matching those strings would not\nneed destructuring.`,\n            type: 'string',\n          },\n          contexts: {\n            description: `Set this to an array of strings representing the AST context (or an object with\noptional \\`context\\` and \\`comment\\` properties) where you wish the rule to be applied.\n\n\\`context\\` defaults to \\`any\\` and \\`comment\\` defaults to no specific comment context.\n\nOverrides the default contexts (\\`ArrowFunctionExpression\\`, \\`FunctionDeclaration\\`,\n\\`FunctionExpression\\`). May be useful for adding such as\n\\`TSMethodSignature\\` in TypeScript or restricting the contexts\nwhich are checked.\n\nSee the [\"AST and Selectors\"](../#advanced-ast-and-selectors)\nsection of our Advanced docs for more on the expected format.`,\n            items: {\n              anyOf: [\n                {\n                  type: 'string',\n                },\n                {\n                  additionalProperties: false,\n                  properties: {\n                    comment: {\n                      type: 'string',\n                    },\n                    context: {\n                      type: 'string',\n                    },\n                  },\n                  type: 'object',\n                },\n              ],\n            },\n            type: 'array',\n          },\n          enableFixer: {\n            description: 'Whether to enable the fixer. Defaults to `true`.',\n            type: 'boolean',\n          },\n          enableRestElementFixer: {\n            description: `Whether to enable the rest element fixer.\n\nThe fixer will automatically report/insert\n[JSDoc repeatable parameters](https://jsdoc.app/tags-param.html#multiple-types-and-repeatable-parameters)\nif missing.\n\n\\`\\`\\`js\n/**\n  * @param {GenericArray} cfg\n  * @param {number} cfg.\"0\"\n */\nfunction baar ([a, ...extra]) {\n  //\n}\n\\`\\`\\`\n\n...becomes:\n\n\\`\\`\\`js\n/**\n  * @param {GenericArray} cfg\n  * @param {number} cfg.\"0\"\n  * @param {...any} cfg.\"1\"\n */\nfunction baar ([a, ...extra]) {\n  //\n}\n\\`\\`\\`\n\nNote that the type \\`any\\` is included since we don't know of any specific\ntype to use.\n\nDefaults to \\`true\\`.`,\n            type: 'boolean',\n          },\n          enableRootFixer: {\n            description: `Whether to enable the auto-adding of incrementing roots.\n\nThe default behavior of \\`true\\` is for \"root\" to be auto-inserted for missing\nroots, followed by a 0-based auto-incrementing number.\n\nSo for:\n\n\\`\\`\\`js\nfunction quux ({foo}, {bar}, {baz}) {\n}\n\\`\\`\\`\n\n...the default JSDoc that would be added if the fixer is enabled would be:\n\n\\`\\`\\`js\n/**\n* @param root0\n* @param root0.foo\n* @param root1\n* @param root1.bar\n* @param root2\n* @param root2.baz\n*/\n\\`\\`\\`\n\nHas no effect if \\`enableFixer\\` is set to \\`false\\`.`,\n            type: 'boolean',\n          },\n          exemptedBy: {\n            description: `Array of tags (e.g., \\`['type']\\`) whose presence on the document block\navoids the need for a \\`@param\\`. Defaults to an array with\n\\`inheritdoc\\`. If you set this array, it will overwrite the default,\nso be sure to add back \\`inheritdoc\\` if you wish its presence to cause\nexemption of the rule.`,\n            items: {\n              type: 'string',\n            },\n            type: 'array',\n          },\n          ignoreWhenAllParamsMissing: {\n            description: `Set to \\`true\\` to ignore reporting when all params are missing. Defaults to\n\\`false\\`.`,\n            type: 'boolean',\n          },\n          interfaceExemptsParamsCheck: {\n            description: `Set if you wish TypeScript interfaces to exempt checks for the existence of\n\\`@param\\`'s.\n\nWill check for a type defining the function itself (on a variable\ndeclaration) or if there is a single destructured object with a type.\nDefaults to \\`false\\`.`,\n            type: 'boolean',\n          },\n          unnamedRootBase: {\n            description: `An array of root names to use in the fixer when roots are missing. Defaults\nto \\`['root']\\`. Note that only when all items in the array besides the last\nare exhausted will auto-incrementing occur. So, with\n\\`unnamedRootBase: ['arg', 'config']\\`, the following:\n\n\\`\\`\\`js\nfunction quux ({foo}, [bar], {baz}) {\n}\n\\`\\`\\`\n\n...will get the following JSDoc block added:\n\n\\`\\`\\`js\n/**\n* @param arg\n* @param arg.foo\n* @param config0\n* @param config0.\"0\" (\\`bar\\`)\n* @param config1\n* @param config1.baz\n*/\n\\`\\`\\``,\n            items: {\n              type: 'string',\n            },\n            type: 'array',\n          },\n          useDefaultObjectProperties: {\n            description: `Set to \\`true\\` if you wish to expect documentation of properties on objects\nsupplied as default values. Defaults to \\`false\\`.`,\n            type: 'boolean',\n          },\n        },\n        type: 'object',\n      },\n    ],\n    type: 'suggestion',\n  },\n\n  // We cannot cache comment nodes as the contexts may recur with the\n  //  same comment node but a different JS node, and we may need the different\n  //  JS node to ensure we iterate its context\n  noTracking: true,\n});\n"],"mappings":"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,EAAE;UACjBvB,OAAO,EAAE,KAAK;UACdmH,WAAW,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;UACKjF,IAAI,EAAE;QACR,CAAC;QACDgH,YAAY,EAAE;UACZlJ,OAAO,EAAE,KAAK;UACdmH,WAAW,EAAE,4EAA4E;UACzFjF,IAAI,EAAE;QACR,CAAC;QACDV,iBAAiB,EAAE;UACjB2F,WAAW,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;UACRjF,IAAI,EAAE;QACR,CAAC;QACDiH,QAAQ,EAAE;UACRhC,WAAW,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;UAClDiC,KAAK,EAAE;YACLC,KAAK,EAAE,CACL;cACEnH,IAAI,EAAE;YACR,CAAC,EACD;cACE4G,oBAAoB,EAAE,KAAK;cAC3BC,UAAU,EAAE;gBACVO,OAAO,EAAE;kBACPpH,IAAI,EAAE;gBACR,CAAC;gBACDpB,OAAO,EAAE;kBACPoB,IAAI,EAAE;gBACR;cACF,CAAC;cACDA,IAAI,EAAE;YACR,CAAC;UAEL,CAAC;UACDA,IAAI,EAAE;QACR,CAAC;QACDT,WAAW,EAAE;UACX0F,WAAW,EAAE,kDAAkD;UAC/DjF,IAAI,EAAE;QACR,CAAC;QACDR,sBAAsB,EAAE;UACtByF,WAAW,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;UACVjF,IAAI,EAAE;QACR,CAAC;QACDP,eAAe,EAAE;UACfwF,WAAW,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;UAC1CjF,IAAI,EAAE;QACR,CAAC;QACDqH,UAAU,EAAE;UACVpC,WAAW,EAAE;AACzB;AACA;AACA;AACA,uBAAuB;UACXiC,KAAK,EAAE;YACLlH,IAAI,EAAE;UACR,CAAC;UACDA,IAAI,EAAE;QACR,CAAC;QACDN,0BAA0B,EAAE;UAC1BuF,WAAW,EAAE;AACzB,WAAW;UACCjF,IAAI,EAAE;QACR,CAAC;QACDL,2BAA2B,EAAE;UAC3BsF,WAAW,EAAE;AACzB;AACA;AACA;AACA;AACA,uBAAuB;UACXjF,IAAI,EAAE;QACR,CAAC;QACDJ,eAAe,EAAE;UACfqF,WAAW,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;UACKiC,KAAK,EAAE;YACLlH,IAAI,EAAE;UACR,CAAC;UACDA,IAAI,EAAE;QACR,CAAC;QACDH,0BAA0B,EAAE;UAC1BoF,WAAW,EAAE;AACzB,mDAAmD;UACvCjF,IAAI,EAAE;QACR;MACF,CAAC;MACDA,IAAI,EAAE;IACR,CAAC,CACF;IACDA,IAAI,EAAE;EACR,CAAC;EAED;EACA;EACA;EACAsH,UAAU,EAAE;AACd,CAAC,CAAC;AAAAC,MAAA,CAAA7I,OAAA,GAAAA,OAAA,CAAAZ,OAAA","ignoreList":[]}