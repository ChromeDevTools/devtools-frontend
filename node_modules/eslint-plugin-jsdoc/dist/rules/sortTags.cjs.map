{"version":3,"file":"sortTags.cjs","names":["_defaultTagOrder","_interopRequireDefault","require","_iterateJsdoc","e","__esModule","default","_default","exports","iterateJsdoc","context","jsdoc","utils","alphabetizeExtras","linesBetween","reportIntraTagGroupSpacing","reportTagGroupSpacing","tagSequence","defaultTagOrder","options","tagList","flatMap","obj","tags","otherPos","indexOf","endPos","length","ongoingCount","idx","tag","entries","originalIndex","source","originalLine","firstChangedTagLine","firstChangedTagIndex","sortedTags","JSON","parse","stringify","sort","tagNew","tagOld","checkOrSetFirstChanged","newPos","oldPos","preferredNewPos","preferredOldPos","undefined","lastTagsOfGroup","badLastTagsOfGroup","countTagEmptyLines","reduce","acc","tokens","description","end","name","tg","type","empty","Number","innerIdx","currentTag","lastTag","includes","some","tgs","push","ct","fixer","currIdx","newIdx","emptyLine","number","seedTokens","delimiter","start","existingEmptyLines","nextTokens","lineDiff","lines","Array","from","splice","srcIdx","src","reportJSDoc","tagIdx","foundFirstTag","nextIdx","ignore","lastTagOfGroup","firstLine","getFirstLine","fix","itemsToMoveRange","keys","unchangedPriorTagDescriptions","slice","initialOffset","removeTag","changedTags","extraTagCount","changedTag","addTag","addLine","join","iterateAllJsdocs","meta","docs","url","fixable","schema","additionalProperties","properties","items","module"],"sources":["../../src/rules/sortTags.js"],"sourcesContent":["import defaultTagOrder from '../defaultTagOrder.js';\nimport iterateJsdoc from '../iterateJsdoc.js';\n\n// eslint-disable-next-line complexity -- Temporary\nexport default iterateJsdoc(({\n  context,\n  jsdoc,\n  utils,\n}) => {\n  const\n    /**\n     * @type {{\n     *   linesBetween: import('../iterateJsdoc.js').Integer,\n     *   tagSequence: {\n     *     tags: string[]\n     *   }[],\n     *   alphabetizeExtras: boolean,\n     *   reportTagGroupSpacing: boolean,\n     *   reportIntraTagGroupSpacing: boolean,\n     * }}\n     */ {\n      alphabetizeExtras = false,\n      linesBetween = 1,\n      reportIntraTagGroupSpacing = true,\n      reportTagGroupSpacing = true,\n      tagSequence = defaultTagOrder,\n    } = context.options[0] || {};\n\n  const tagList = tagSequence.flatMap((obj) => {\n    /* typeof obj === 'string' ? obj : */\n    return obj.tags;\n  });\n\n  const otherPos = tagList.indexOf('-other');\n  const endPos = otherPos > -1 ? otherPos : tagList.length;\n\n  let ongoingCount = 0;\n  for (const [\n    idx,\n    tag,\n  ] of\n    /**\n     * @type {(\n     *   import('@es-joy/jsdoccomment').JsdocTagWithInline & {\n     *     originalIndex: import('../iterateJsdoc.js').Integer,\n     *     originalLine: import('../iterateJsdoc.js').Integer,\n     *   }\n     * )[]}\n     */ (jsdoc.tags).entries()) {\n    tag.originalIndex = idx;\n    ongoingCount += tag.source.length;\n    tag.originalLine = ongoingCount;\n  }\n\n  /** @type {import('../iterateJsdoc.js').Integer|undefined} */\n  let firstChangedTagLine;\n  /** @type {import('../iterateJsdoc.js').Integer|undefined} */\n  let firstChangedTagIndex;\n\n  /**\n   * @type {(import('comment-parser').Spec & {\n   *   originalIndex: import('../iterateJsdoc.js').Integer,\n   *   originalLine: import('../iterateJsdoc.js').Integer,\n   * })[]}\n   */\n  const sortedTags = JSON.parse(JSON.stringify(jsdoc.tags));\n  sortedTags.sort(({\n    tag: tagNew,\n  }, {\n    originalIndex,\n    originalLine,\n    tag: tagOld,\n  }) => {\n    // Optimize: Just keep relative positions if the same tag name\n    if (tagNew === tagOld) {\n      return 0;\n    }\n\n    const checkOrSetFirstChanged = () => {\n      if (!firstChangedTagLine || originalLine < firstChangedTagLine) {\n        firstChangedTagLine = originalLine;\n        firstChangedTagIndex = originalIndex;\n      }\n    };\n\n    const newPos = tagList.indexOf(tagNew);\n    const oldPos = tagList.indexOf(tagOld);\n\n    const preferredNewPos = newPos === -1 ? endPos : newPos;\n    const preferredOldPos = oldPos === -1 ? endPos : oldPos;\n\n    if (preferredNewPos < preferredOldPos) {\n      checkOrSetFirstChanged();\n      return -1;\n    }\n\n    if (preferredNewPos > preferredOldPos) {\n      return 1;\n    }\n\n    // preferredNewPos === preferredOldPos\n    if (\n      !alphabetizeExtras ||\n\n      // Optimize: If tagNew (or tagOld which is the same) was found in the\n      //   priority array, it can maintain its relative positionâ€”without need\n      //   of alphabetizing (secondary sorting)\n      newPos >= 0\n    ) {\n      return 0;\n    }\n\n    if (tagNew < tagOld) {\n      checkOrSetFirstChanged();\n      return -1;\n    }\n\n    // tagNew > tagOld\n    return 1;\n  });\n\n  if (firstChangedTagLine === undefined) {\n    // Should be ordered by now\n\n    /**\n     * @type {import('comment-parser').Spec[]}\n     */\n    const lastTagsOfGroup = [];\n\n    /**\n     * @type {[\n     *   import('comment-parser').Spec,\n     *   import('../iterateJsdoc.js').Integer\n     * ][]}\n     */\n    const badLastTagsOfGroup = [];\n\n    /**\n     * @param {import('comment-parser').Spec} tag\n     */\n    const countTagEmptyLines = (tag) => {\n      return tag.source.reduce((acc, {\n        tokens: {\n          description,\n          end,\n          name,\n          tag: tg,\n          type,\n        },\n      }) => {\n        const empty = !tg && !type && !name && !description;\n        // Reset the count so long as there is content\n        return empty ? acc + Number(empty && !end) : 0;\n      }, 0);\n    };\n\n    let idx = 0;\n    for (const {\n      tags,\n    } of tagSequence) {\n      let innerIdx;\n      /** @type {import('comment-parser').Spec} */\n      let currentTag;\n      /** @type {import('comment-parser').Spec|undefined} */\n      let lastTag;\n      do {\n        currentTag = jsdoc.tags[idx];\n        if (!currentTag) {\n          idx++;\n          break;\n        }\n\n        innerIdx = tags.indexOf(currentTag.tag);\n\n        if (\n          innerIdx === -1 &&\n          // eslint-disable-next-line no-loop-func -- Safe\n          (!tags.includes('-other') || tagSequence.some(({\n            tags: tgs,\n          }) => {\n            return tgs.includes(currentTag.tag);\n          }))\n        ) {\n          idx++;\n          break;\n        }\n\n        lastTag = currentTag;\n\n        idx++;\n      } while (true);\n\n      idx--;\n\n      if (lastTag) {\n        lastTagsOfGroup.push(lastTag);\n        const ct = countTagEmptyLines(lastTag);\n        if (\n          ct !== linesBetween &&\n          // Use another rule for adding to end (should be of interest outside this rule)\n          jsdoc.tags[idx]\n        ) {\n          badLastTagsOfGroup.push([\n            lastTag, ct,\n          ]);\n        }\n      }\n    }\n\n    if (reportTagGroupSpacing && badLastTagsOfGroup.length) {\n      /**\n       * @param {import('comment-parser').Spec} tg\n       * @returns {() => void}\n       */\n      const fixer = (tg) => {\n        return () => {\n          // Due to https://github.com/syavorsky/comment-parser/issues/110 ,\n          //  we have to modify `jsdoc.source` rather than just modify tags\n          //  directly\n          for (const [\n            currIdx,\n            {\n              tokens,\n            },\n          ] of jsdoc.source.entries()) {\n            if (tokens.tag !== '@' + tg.tag) {\n              continue;\n            }\n\n            // Cannot be `tokens.end`, as dropped off last tag, so safe to\n            //  go on\n            let newIdx = currIdx;\n\n            const emptyLine = () => {\n              return {\n                number: 0,\n                source: '',\n                tokens: utils.seedTokens({\n                  delimiter: '*',\n                  start: jsdoc.source[newIdx - 1].tokens.start,\n                }),\n              };\n            };\n\n            let existingEmptyLines = 0;\n            while (true) {\n              const nextTokens = jsdoc.source[++newIdx]?.tokens;\n\n              /* c8 ignore next 3 -- Guard */\n              if (!nextTokens) {\n                return;\n              }\n\n              // Should be no `nextTokens.end` to worry about since ignored\n              //  if not followed by tag\n\n              if (nextTokens.tag) {\n                // Haven't made it to last tag instance yet, so keep looking\n                if (nextTokens.tag === tokens.tag) {\n                  existingEmptyLines = 0;\n                  continue;\n                }\n\n                const lineDiff = linesBetween - existingEmptyLines;\n                if (lineDiff > 0) {\n                  const lines = Array.from({\n                    length: lineDiff,\n                  }, () => {\n                    return emptyLine();\n                  });\n                  jsdoc.source.splice(newIdx, 0, ...lines);\n                } else {\n                  // lineDiff < 0\n                  jsdoc.source.splice(\n                    newIdx + lineDiff,\n                    -lineDiff,\n                  );\n                }\n\n                break;\n              }\n\n              const empty = !nextTokens.type && !nextTokens.name &&\n                !nextTokens.description;\n\n              if (empty) {\n                existingEmptyLines++;\n              } else {\n                // Has content again, so reset empty line count\n                existingEmptyLines = 0;\n              }\n            }\n\n            break;\n          }\n\n          for (const [\n            srcIdx,\n            src,\n          ] of jsdoc.source.entries()) {\n            src.number = srcIdx;\n          }\n        };\n      };\n\n      for (const [\n        tg,\n      ] of badLastTagsOfGroup) {\n        utils.reportJSDoc(\n          'Tag groups do not have the expected whitespace',\n          tg,\n          fixer(tg),\n        );\n      }\n\n      return;\n    }\n\n    if (!reportIntraTagGroupSpacing) {\n      return;\n    }\n\n    for (const [\n      tagIdx,\n      tag,\n    ] of jsdoc.tags.entries()) {\n      if (!jsdoc.tags[tagIdx + 1] || lastTagsOfGroup.includes(tag)) {\n        continue;\n      }\n\n      const ct = countTagEmptyLines(tag);\n      if (ct) {\n        // eslint-disable-next-line complexity -- Temporary\n        const fixer = () => {\n          let foundFirstTag = false;\n\n          /** @type {string|undefined} */\n          let currentTag;\n\n          for (const [\n            currIdx,\n            {\n              tokens: {\n                description,\n                end,\n                name,\n                tag: tg,\n                type,\n              },\n            },\n          ] of jsdoc.source.entries()) {\n            if (tg) {\n              foundFirstTag = true;\n              currentTag = tg;\n            }\n\n            if (!foundFirstTag) {\n              continue;\n            }\n\n            if (currentTag && !tg && !type && !name && !description && !end) {\n              let nextIdx = currIdx;\n\n              let ignore = true;\n              // Even if a tag of the same name as the last tags in a group,\n              //  could still be an earlier tag in that group\n\n              // eslint-disable-next-line no-loop-func -- Safe\n              if (lastTagsOfGroup.some((lastTagOfGroup) => {\n                return currentTag === '@' + lastTagOfGroup.tag;\n              })) {\n                while (true) {\n                  const nextTokens = jsdoc.source[++nextIdx]?.tokens;\n                  if (!nextTokens) {\n                    break;\n                  }\n\n                  if (!nextTokens.tag) {\n                    continue;\n                  }\n\n                  // Followed by the same tag name, so not actually last in group,\n                  //   and of interest\n                  if (nextTokens.tag === currentTag) {\n                    ignore = false;\n                  }\n                }\n              } else {\n                while (true) {\n                  const nextTokens = jsdoc.source[++nextIdx]?.tokens;\n                  if (!nextTokens || nextTokens.end) {\n                    break;\n                  }\n\n                  // Not the very last tag, so don't ignore\n                  if (nextTokens.tag) {\n                    ignore = false;\n                    break;\n                  }\n                }\n              }\n\n              if (!ignore) {\n                jsdoc.source.splice(currIdx, 1);\n                for (const [\n                  srcIdx,\n                  src,\n                ] of jsdoc.source.entries()) {\n                  src.number = srcIdx;\n                }\n              }\n            }\n          }\n        };\n\n        utils.reportJSDoc(\n          'Intra-group tags have unexpected whitespace',\n          tag,\n          fixer,\n        );\n      }\n    }\n\n    return;\n  }\n\n  const firstLine = utils.getFirstLine();\n\n  const fix = () => {\n    const itemsToMoveRange = [\n      ...Array.from({\n        length: jsdoc.tags.length -\n        /** @type {import('../iterateJsdoc.js').Integer} */ (\n          firstChangedTagIndex\n        ),\n      }).keys(),\n    ];\n\n    const unchangedPriorTagDescriptions = jsdoc.tags.slice(\n      0,\n      firstChangedTagIndex,\n    ).reduce((ct, {\n      source,\n    }) => {\n      return ct + source.length - 1;\n    }, 0);\n\n    // This offset includes not only the offset from where the first tag\n    //   must begin, and the additional offset of where the first changed\n    //   tag begins, but it must also account for prior descriptions\n    const initialOffset = /** @type {import('../iterateJsdoc.js').Integer} */ (\n      firstLine\n    ) + /** @type {import('../iterateJsdoc.js').Integer} */ (firstChangedTagIndex) +\n\n      // May be the first tag, so don't try finding a prior one if so\n      unchangedPriorTagDescriptions;\n\n    // Use `firstChangedTagLine` for line number to begin reporting/splicing\n    for (const idx of itemsToMoveRange) {\n      utils.removeTag(\n        idx +\n        /** @type {import('../iterateJsdoc.js').Integer} */ (\n          firstChangedTagIndex\n        ),\n      );\n    }\n\n    const changedTags = sortedTags.slice(firstChangedTagIndex);\n    let extraTagCount = 0;\n\n    for (const idx of itemsToMoveRange) {\n      const changedTag = changedTags[idx];\n\n      utils.addTag(\n        changedTag.tag,\n        extraTagCount + initialOffset + idx,\n        {\n          ...changedTag.source[0].tokens,\n\n          // `comment-parser` puts the `end` within the `tags` section, so\n          //   avoid adding another to jsdoc.source\n          end: '',\n        },\n      );\n\n      for (const {\n        tokens,\n      } of changedTag.source.slice(1)) {\n        if (!tokens.end) {\n          utils.addLine(\n            extraTagCount + initialOffset + idx + 1,\n            {\n              ...tokens,\n              end: '',\n            },\n          );\n          extraTagCount++;\n        }\n      }\n    }\n  };\n\n  utils.reportJSDoc(\n    `Tags are not in the prescribed order: ${\n      tagList.join(', ') || '(alphabetical)'\n    }`,\n    jsdoc.tags[/** @type {import('../iterateJsdoc.js').Integer} */ (\n      firstChangedTagIndex\n    )],\n    fix,\n    true,\n  );\n}, {\n  iterateAllJsdocs: true,\n  meta: {\n    docs: {\n      description: 'Sorts tags by a specified sequence according to tag name.',\n      url: 'https://github.com/gajus/eslint-plugin-jsdoc/blob/main/docs/rules/sort-tags.md#repos-sticky-header',\n    },\n    fixable: 'code',\n    schema: [\n      {\n        additionalProperties: false,\n        properties: {\n          alphabetizeExtras: {\n            type: 'boolean',\n          },\n          linesBetween: {\n            type: 'integer',\n          },\n          reportIntraTagGroupSpacing: {\n            type: 'boolean',\n          },\n          reportTagGroupSpacing: {\n            type: 'boolean',\n          },\n          tagSequence: {\n            items: {\n              properties: {\n                tags: {\n                  items: {\n                    type: 'string',\n                  },\n                  type: 'array',\n                },\n              },\n              type: 'object',\n            },\n            type: 'array',\n          },\n        },\n        type: 'object',\n      },\n    ],\n    type: 'suggestion',\n  },\n});\n"],"mappings":";;;;;;AAAA,IAAAA,gBAAA,GAAAC,sBAAA,CAAAC,OAAA;AACA,IAAAC,aAAA,GAAAF,sBAAA,CAAAC,OAAA;AAA8C,SAAAD,uBAAAG,CAAA,WAAAA,CAAA,IAAAA,CAAA,CAAAC,UAAA,GAAAD,CAAA,KAAAE,OAAA,EAAAF,CAAA;AAE9C;AAAA,IAAAG,QAAA,GAAAC,OAAA,CAAAF,OAAA,GACe,IAAAG,qBAAY,EAAC,CAAC;EAC3BC,OAAO;EACPC,KAAK;EACLC;AACF,CAAC,KAAK;EACJ;EACE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAAQ;IACFC,iBAAiB,GAAG,KAAK;IACzBC,YAAY,GAAG,CAAC;IAChBC,0BAA0B,GAAG,IAAI;IACjCC,qBAAqB,GAAG,IAAI;IAC5BC,WAAW,GAAGC;EAChB,CAAC,GAAGR,OAAO,CAACS,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;EAE9B,MAAMC,OAAO,GAAGH,WAAW,CAACI,OAAO,CAAEC,GAAG,IAAK;IAC3C;IACA,OAAOA,GAAG,CAACC,IAAI;EACjB,CAAC,CAAC;EAEF,MAAMC,QAAQ,GAAGJ,OAAO,CAACK,OAAO,CAAC,QAAQ,CAAC;EAC1C,MAAMC,MAAM,GAAGF,QAAQ,GAAG,CAAC,CAAC,GAAGA,QAAQ,GAAGJ,OAAO,CAACO,MAAM;EAExD,IAAIC,YAAY,GAAG,CAAC;EACpB,KAAK,MAAM,CACTC,GAAG,EACHC,GAAG,CACJ;EACC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EAASnB,KAAK,CAACY,IAAI,CAAEQ,OAAO,CAAC,CAAC,EAAE;IAC5BD,GAAG,CAACE,aAAa,GAAGH,GAAG;IACvBD,YAAY,IAAIE,GAAG,CAACG,MAAM,CAACN,MAAM;IACjCG,GAAG,CAACI,YAAY,GAAGN,YAAY;EACjC;;EAEA;EACA,IAAIO,mBAAmB;EACvB;EACA,IAAIC,oBAAoB;;EAExB;AACF;AACA;AACA;AACA;AACA;EACE,MAAMC,UAAU,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,SAAS,CAAC7B,KAAK,CAACY,IAAI,CAAC,CAAC;EACzDc,UAAU,CAACI,IAAI,CAAC,CAAC;IACfX,GAAG,EAAEY;EACP,CAAC,EAAE;IACDV,aAAa;IACbE,YAAY;IACZJ,GAAG,EAAEa;EACP,CAAC,KAAK;IACJ;IACA,IAAID,MAAM,KAAKC,MAAM,EAAE;MACrB,OAAO,CAAC;IACV;IAEA,MAAMC,sBAAsB,GAAGA,CAAA,KAAM;MACnC,IAAI,CAACT,mBAAmB,IAAID,YAAY,GAAGC,mBAAmB,EAAE;QAC9DA,mBAAmB,GAAGD,YAAY;QAClCE,oBAAoB,GAAGJ,aAAa;MACtC;IACF,CAAC;IAED,MAAMa,MAAM,GAAGzB,OAAO,CAACK,OAAO,CAACiB,MAAM,CAAC;IACtC,MAAMI,MAAM,GAAG1B,OAAO,CAACK,OAAO,CAACkB,MAAM,CAAC;IAEtC,MAAMI,eAAe,GAAGF,MAAM,KAAK,CAAC,CAAC,GAAGnB,MAAM,GAAGmB,MAAM;IACvD,MAAMG,eAAe,GAAGF,MAAM,KAAK,CAAC,CAAC,GAAGpB,MAAM,GAAGoB,MAAM;IAEvD,IAAIC,eAAe,GAAGC,eAAe,EAAE;MACrCJ,sBAAsB,CAAC,CAAC;MACxB,OAAO,CAAC,CAAC;IACX;IAEA,IAAIG,eAAe,GAAGC,eAAe,EAAE;MACrC,OAAO,CAAC;IACV;;IAEA;IACA,IACE,CAACnC,iBAAiB;IAElB;IACA;IACA;IACAgC,MAAM,IAAI,CAAC,EACX;MACA,OAAO,CAAC;IACV;IAEA,IAAIH,MAAM,GAAGC,MAAM,EAAE;MACnBC,sBAAsB,CAAC,CAAC;MACxB,OAAO,CAAC,CAAC;IACX;;IAEA;IACA,OAAO,CAAC;EACV,CAAC,CAAC;EAEF,IAAIT,mBAAmB,KAAKc,SAAS,EAAE;IACrC;;IAEA;AACJ;AACA;IACI,MAAMC,eAAe,GAAG,EAAE;;IAE1B;AACJ;AACA;AACA;AACA;AACA;IACI,MAAMC,kBAAkB,GAAG,EAAE;;IAE7B;AACJ;AACA;IACI,MAAMC,kBAAkB,GAAItB,GAAG,IAAK;MAClC,OAAOA,GAAG,CAACG,MAAM,CAACoB,MAAM,CAAC,CAACC,GAAG,EAAE;QAC7BC,MAAM,EAAE;UACNC,WAAW;UACXC,GAAG;UACHC,IAAI;UACJ5B,GAAG,EAAE6B,EAAE;UACPC;QACF;MACF,CAAC,KAAK;QACJ,MAAMC,KAAK,GAAG,CAACF,EAAE,IAAI,CAACC,IAAI,IAAI,CAACF,IAAI,IAAI,CAACF,WAAW;QACnD;QACA,OAAOK,KAAK,GAAGP,GAAG,GAAGQ,MAAM,CAACD,KAAK,IAAI,CAACJ,GAAG,CAAC,GAAG,CAAC;MAChD,CAAC,EAAE,CAAC,CAAC;IACP,CAAC;IAED,IAAI5B,GAAG,GAAG,CAAC;IACX,KAAK,MAAM;MACTN;IACF,CAAC,IAAIN,WAAW,EAAE;MAChB,IAAI8C,QAAQ;MACZ;MACA,IAAIC,UAAU;MACd;MACA,IAAIC,OAAO;MACX,GAAG;QACDD,UAAU,GAAGrD,KAAK,CAACY,IAAI,CAACM,GAAG,CAAC;QAC5B,IAAI,CAACmC,UAAU,EAAE;UACfnC,GAAG,EAAE;UACL;QACF;QAEAkC,QAAQ,GAAGxC,IAAI,CAACE,OAAO,CAACuC,UAAU,CAAClC,GAAG,CAAC;QAEvC,IACEiC,QAAQ,KAAK,CAAC,CAAC;QACf;QACC,CAACxC,IAAI,CAAC2C,QAAQ,CAAC,QAAQ,CAAC,IAAIjD,WAAW,CAACkD,IAAI,CAAC,CAAC;UAC7C5C,IAAI,EAAE6C;QACR,CAAC,KAAK;UACJ,OAAOA,GAAG,CAACF,QAAQ,CAACF,UAAU,CAAClC,GAAG,CAAC;QACrC,CAAC,CAAC,CAAC,EACH;UACAD,GAAG,EAAE;UACL;QACF;QAEAoC,OAAO,GAAGD,UAAU;QAEpBnC,GAAG,EAAE;MACP,CAAC,QAAQ,IAAI;MAEbA,GAAG,EAAE;MAEL,IAAIoC,OAAO,EAAE;QACXf,eAAe,CAACmB,IAAI,CAACJ,OAAO,CAAC;QAC7B,MAAMK,EAAE,GAAGlB,kBAAkB,CAACa,OAAO,CAAC;QACtC,IACEK,EAAE,KAAKxD,YAAY;QACnB;QACAH,KAAK,CAACY,IAAI,CAACM,GAAG,CAAC,EACf;UACAsB,kBAAkB,CAACkB,IAAI,CAAC,CACtBJ,OAAO,EAAEK,EAAE,CACZ,CAAC;QACJ;MACF;IACF;IAEA,IAAItD,qBAAqB,IAAImC,kBAAkB,CAACxB,MAAM,EAAE;MACtD;AACN;AACA;AACA;MACM,MAAM4C,KAAK,GAAIZ,EAAE,IAAK;QACpB,OAAO,MAAM;UACX;UACA;UACA;UACA,KAAK,MAAM,CACTa,OAAO,EACP;YACEjB;UACF,CAAC,CACF,IAAI5C,KAAK,CAACsB,MAAM,CAACF,OAAO,CAAC,CAAC,EAAE;YAC3B,IAAIwB,MAAM,CAACzB,GAAG,KAAK,GAAG,GAAG6B,EAAE,CAAC7B,GAAG,EAAE;cAC/B;YACF;;YAEA;YACA;YACA,IAAI2C,MAAM,GAAGD,OAAO;YAEpB,MAAME,SAAS,GAAGA,CAAA,KAAM;cACtB,OAAO;gBACLC,MAAM,EAAE,CAAC;gBACT1C,MAAM,EAAE,EAAE;gBACVsB,MAAM,EAAE3C,KAAK,CAACgE,UAAU,CAAC;kBACvBC,SAAS,EAAE,GAAG;kBACdC,KAAK,EAAEnE,KAAK,CAACsB,MAAM,CAACwC,MAAM,GAAG,CAAC,CAAC,CAAClB,MAAM,CAACuB;gBACzC,CAAC;cACH,CAAC;YACH,CAAC;YAED,IAAIC,kBAAkB,GAAG,CAAC;YAC1B,OAAO,IAAI,EAAE;cACX,MAAMC,UAAU,GAAGrE,KAAK,CAACsB,MAAM,CAAC,EAAEwC,MAAM,CAAC,EAAElB,MAAM;;cAEjD;cACA,IAAI,CAACyB,UAAU,EAAE;gBACf;cACF;;cAEA;cACA;;cAEA,IAAIA,UAAU,CAAClD,GAAG,EAAE;gBAClB;gBACA,IAAIkD,UAAU,CAAClD,GAAG,KAAKyB,MAAM,CAACzB,GAAG,EAAE;kBACjCiD,kBAAkB,GAAG,CAAC;kBACtB;gBACF;gBAEA,MAAME,QAAQ,GAAGnE,YAAY,GAAGiE,kBAAkB;gBAClD,IAAIE,QAAQ,GAAG,CAAC,EAAE;kBAChB,MAAMC,KAAK,GAAGC,KAAK,CAACC,IAAI,CAAC;oBACvBzD,MAAM,EAAEsD;kBACV,CAAC,EAAE,MAAM;oBACP,OAAOP,SAAS,CAAC,CAAC;kBACpB,CAAC,CAAC;kBACF/D,KAAK,CAACsB,MAAM,CAACoD,MAAM,CAACZ,MAAM,EAAE,CAAC,EAAE,GAAGS,KAAK,CAAC;gBAC1C,CAAC,MAAM;kBACL;kBACAvE,KAAK,CAACsB,MAAM,CAACoD,MAAM,CACjBZ,MAAM,GAAGQ,QAAQ,EACjB,CAACA,QACH,CAAC;gBACH;gBAEA;cACF;cAEA,MAAMpB,KAAK,GAAG,CAACmB,UAAU,CAACpB,IAAI,IAAI,CAACoB,UAAU,CAACtB,IAAI,IAChD,CAACsB,UAAU,CAACxB,WAAW;cAEzB,IAAIK,KAAK,EAAE;gBACTkB,kBAAkB,EAAE;cACtB,CAAC,MAAM;gBACL;gBACAA,kBAAkB,GAAG,CAAC;cACxB;YACF;YAEA;UACF;UAEA,KAAK,MAAM,CACTO,MAAM,EACNC,GAAG,CACJ,IAAI5E,KAAK,CAACsB,MAAM,CAACF,OAAO,CAAC,CAAC,EAAE;YAC3BwD,GAAG,CAACZ,MAAM,GAAGW,MAAM;UACrB;QACF,CAAC;MACH,CAAC;MAED,KAAK,MAAM,CACT3B,EAAE,CACH,IAAIR,kBAAkB,EAAE;QACvBvC,KAAK,CAAC4E,WAAW,CACf,gDAAgD,EAChD7B,EAAE,EACFY,KAAK,CAACZ,EAAE,CACV,CAAC;MACH;MAEA;IACF;IAEA,IAAI,CAAC5C,0BAA0B,EAAE;MAC/B;IACF;IAEA,KAAK,MAAM,CACT0E,MAAM,EACN3D,GAAG,CACJ,IAAInB,KAAK,CAACY,IAAI,CAACQ,OAAO,CAAC,CAAC,EAAE;MACzB,IAAI,CAACpB,KAAK,CAACY,IAAI,CAACkE,MAAM,GAAG,CAAC,CAAC,IAAIvC,eAAe,CAACgB,QAAQ,CAACpC,GAAG,CAAC,EAAE;QAC5D;MACF;MAEA,MAAMwC,EAAE,GAAGlB,kBAAkB,CAACtB,GAAG,CAAC;MAClC,IAAIwC,EAAE,EAAE;QACN;QACA,MAAMC,KAAK,GAAGA,CAAA,KAAM;UAClB,IAAImB,aAAa,GAAG,KAAK;;UAEzB;UACA,IAAI1B,UAAU;UAEd,KAAK,MAAM,CACTQ,OAAO,EACP;YACEjB,MAAM,EAAE;cACNC,WAAW;cACXC,GAAG;cACHC,IAAI;cACJ5B,GAAG,EAAE6B,EAAE;cACPC;YACF;UACF,CAAC,CACF,IAAIjD,KAAK,CAACsB,MAAM,CAACF,OAAO,CAAC,CAAC,EAAE;YAC3B,IAAI4B,EAAE,EAAE;cACN+B,aAAa,GAAG,IAAI;cACpB1B,UAAU,GAAGL,EAAE;YACjB;YAEA,IAAI,CAAC+B,aAAa,EAAE;cAClB;YACF;YAEA,IAAI1B,UAAU,IAAI,CAACL,EAAE,IAAI,CAACC,IAAI,IAAI,CAACF,IAAI,IAAI,CAACF,WAAW,IAAI,CAACC,GAAG,EAAE;cAC/D,IAAIkC,OAAO,GAAGnB,OAAO;cAErB,IAAIoB,MAAM,GAAG,IAAI;cACjB;cACA;;cAEA;cACA,IAAI1C,eAAe,CAACiB,IAAI,CAAE0B,cAAc,IAAK;gBAC3C,OAAO7B,UAAU,KAAK,GAAG,GAAG6B,cAAc,CAAC/D,GAAG;cAChD,CAAC,CAAC,EAAE;gBACF,OAAO,IAAI,EAAE;kBACX,MAAMkD,UAAU,GAAGrE,KAAK,CAACsB,MAAM,CAAC,EAAE0D,OAAO,CAAC,EAAEpC,MAAM;kBAClD,IAAI,CAACyB,UAAU,EAAE;oBACf;kBACF;kBAEA,IAAI,CAACA,UAAU,CAAClD,GAAG,EAAE;oBACnB;kBACF;;kBAEA;kBACA;kBACA,IAAIkD,UAAU,CAAClD,GAAG,KAAKkC,UAAU,EAAE;oBACjC4B,MAAM,GAAG,KAAK;kBAChB;gBACF;cACF,CAAC,MAAM;gBACL,OAAO,IAAI,EAAE;kBACX,MAAMZ,UAAU,GAAGrE,KAAK,CAACsB,MAAM,CAAC,EAAE0D,OAAO,CAAC,EAAEpC,MAAM;kBAClD,IAAI,CAACyB,UAAU,IAAIA,UAAU,CAACvB,GAAG,EAAE;oBACjC;kBACF;;kBAEA;kBACA,IAAIuB,UAAU,CAAClD,GAAG,EAAE;oBAClB8D,MAAM,GAAG,KAAK;oBACd;kBACF;gBACF;cACF;cAEA,IAAI,CAACA,MAAM,EAAE;gBACXjF,KAAK,CAACsB,MAAM,CAACoD,MAAM,CAACb,OAAO,EAAE,CAAC,CAAC;gBAC/B,KAAK,MAAM,CACTc,MAAM,EACNC,GAAG,CACJ,IAAI5E,KAAK,CAACsB,MAAM,CAACF,OAAO,CAAC,CAAC,EAAE;kBAC3BwD,GAAG,CAACZ,MAAM,GAAGW,MAAM;gBACrB;cACF;YACF;UACF;QACF,CAAC;QAED1E,KAAK,CAAC4E,WAAW,CACf,6CAA6C,EAC7C1D,GAAG,EACHyC,KACF,CAAC;MACH;IACF;IAEA;EACF;EAEA,MAAMuB,SAAS,GAAGlF,KAAK,CAACmF,YAAY,CAAC,CAAC;EAEtC,MAAMC,GAAG,GAAGA,CAAA,KAAM;IAChB,MAAMC,gBAAgB,GAAG,CACvB,GAAGd,KAAK,CAACC,IAAI,CAAC;MACZzD,MAAM,EAAEhB,KAAK,CAACY,IAAI,CAACI,MAAM,IACzB;MACES,oBAAoB;IAExB,CAAC,CAAC,CAAC8D,IAAI,CAAC,CAAC,CACV;IAED,MAAMC,6BAA6B,GAAGxF,KAAK,CAACY,IAAI,CAAC6E,KAAK,CACpD,CAAC,EACDhE,oBACF,CAAC,CAACiB,MAAM,CAAC,CAACiB,EAAE,EAAE;MACZrC;IACF,CAAC,KAAK;MACJ,OAAOqC,EAAE,GAAGrC,MAAM,CAACN,MAAM,GAAG,CAAC;IAC/B,CAAC,EAAE,CAAC,CAAC;;IAEL;IACA;IACA;IACA,MAAM0E,aAAa,GAAG,mDACpBP,SAAS,IACP,mDAAqD1D,oBAAoB,CAAC;IAE5E;IACA+D,6BAA6B;;IAE/B;IACA,KAAK,MAAMtE,GAAG,IAAIoE,gBAAgB,EAAE;MAClCrF,KAAK,CAAC0F,SAAS,CACbzE,GAAG,IACH;MACEO,oBAAoB,CAExB,CAAC;IACH;IAEA,MAAMmE,WAAW,GAAGlE,UAAU,CAAC+D,KAAK,CAAChE,oBAAoB,CAAC;IAC1D,IAAIoE,aAAa,GAAG,CAAC;IAErB,KAAK,MAAM3E,GAAG,IAAIoE,gBAAgB,EAAE;MAClC,MAAMQ,UAAU,GAAGF,WAAW,CAAC1E,GAAG,CAAC;MAEnCjB,KAAK,CAAC8F,MAAM,CACVD,UAAU,CAAC3E,GAAG,EACd0E,aAAa,GAAGH,aAAa,GAAGxE,GAAG,EACnC;QACE,GAAG4E,UAAU,CAACxE,MAAM,CAAC,CAAC,CAAC,CAACsB,MAAM;QAE9B;QACA;QACAE,GAAG,EAAE;MACP,CACF,CAAC;MAED,KAAK,MAAM;QACTF;MACF,CAAC,IAAIkD,UAAU,CAACxE,MAAM,CAACmE,KAAK,CAAC,CAAC,CAAC,EAAE;QAC/B,IAAI,CAAC7C,MAAM,CAACE,GAAG,EAAE;UACf7C,KAAK,CAAC+F,OAAO,CACXH,aAAa,GAAGH,aAAa,GAAGxE,GAAG,GAAG,CAAC,EACvC;YACE,GAAG0B,MAAM;YACTE,GAAG,EAAE;UACP,CACF,CAAC;UACD+C,aAAa,EAAE;QACjB;MACF;IACF;EACF,CAAC;EAED5F,KAAK,CAAC4E,WAAW,CACf,yCACEpE,OAAO,CAACwF,IAAI,CAAC,IAAI,CAAC,IAAI,gBAAgB,EACtC,EACFjG,KAAK,CAACY,IAAI,EAAC;EACTa,oBAAoB,EACpB,EACF4D,GAAG,EACH,IACF,CAAC;AACH,CAAC,EAAE;EACDa,gBAAgB,EAAE,IAAI;EACtBC,IAAI,EAAE;IACJC,IAAI,EAAE;MACJvD,WAAW,EAAE,2DAA2D;MACxEwD,GAAG,EAAE;IACP,CAAC;IACDC,OAAO,EAAE,MAAM;IACfC,MAAM,EAAE,CACN;MACEC,oBAAoB,EAAE,KAAK;MAC3BC,UAAU,EAAE;QACVvG,iBAAiB,EAAE;UACjB+C,IAAI,EAAE;QACR,CAAC;QACD9C,YAAY,EAAE;UACZ8C,IAAI,EAAE;QACR,CAAC;QACD7C,0BAA0B,EAAE;UAC1B6C,IAAI,EAAE;QACR,CAAC;QACD5C,qBAAqB,EAAE;UACrB4C,IAAI,EAAE;QACR,CAAC;QACD3C,WAAW,EAAE;UACXoG,KAAK,EAAE;YACLD,UAAU,EAAE;cACV7F,IAAI,EAAE;gBACJ8F,KAAK,EAAE;kBACLzD,IAAI,EAAE;gBACR,CAAC;gBACDA,IAAI,EAAE;cACR;YACF,CAAC;YACDA,IAAI,EAAE;UACR,CAAC;UACDA,IAAI,EAAE;QACR;MACF,CAAC;MACDA,IAAI,EAAE;IACR,CAAC,CACF;IACDA,IAAI,EAAE;EACR;AACF,CAAC,CAAC;AAAA0D,MAAA,CAAA9G,OAAA,GAAAA,OAAA,CAAAF,OAAA","ignoreList":[]}