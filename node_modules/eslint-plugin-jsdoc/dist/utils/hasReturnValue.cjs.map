{"version":3,"file":"hasReturnValue.cjs","names":["isNewPromiseExpression","node","type","callee","name","isVoidPromise","typeArguments","params","typeParameters","undefinedKeywords","Set","hasReturnValue","throwOnNullReturn","promFilter","expression","body","some","bodyNode","consequent","alternate","value","argument","Error","cases","someCase","nde","block","handler","finalizer","returnType","typeAnnotation","has","exports","allBrancheshaveReturnValues","lastBodyNode","slice","test","every","consNode","error","message","hasNonEmptyResolverCall","resolverName","elements","element","left","right","arguments","length","undefined","decorators","decorator","computed","key","source","object","property","properties","expressions","subExpression","quasi","declarations","id","init","hasValueOrExecutorHasNonEmptyResolveValue","anyPromiseAsReturn","allBranches","hasReturnMethod","promiseFilter","hasReturn","Boolean","prom"],"sources":["../../src/utils/hasReturnValue.js"],"sourcesContent":["/**\n * @typedef {import('estree').Node|\n *   import('@typescript-eslint/types').TSESTree.Node} ESTreeOrTypeScriptNode\n */\n\n/**\n * Checks if a node is a promise but has no resolve value or an empty value.\n * An `undefined` resolve does not count.\n * @param {ESTreeOrTypeScriptNode|undefined|null} node\n * @returns {boolean|undefined|null}\n */\nconst isNewPromiseExpression = (node) => {\n  return node && node.type === 'NewExpression' && node.callee.type === 'Identifier' &&\n    node.callee.name === 'Promise';\n};\n\n/**\n * @param {ESTreeOrTypeScriptNode|null|undefined} node\n * @returns {boolean}\n */\nconst isVoidPromise = (node) => {\n  return /** @type {import('@typescript-eslint/types').TSESTree.TSTypeReference} */ (node)?.typeArguments?.params?.[0]?.type === 'TSVoidKeyword'\n    /* c8 ignore next 5 */\n    // eslint-disable-next-line @stylistic/operator-linebreak -- c8\n    || /** @type {import('@typescript-eslint/types').TSESTree.TSTypeReference} */ (\n      node\n    // @ts-expect-error Ok\n    )?.typeParameters?.params?.[0]?.type === 'TSVoidKeyword';\n};\n\nconst undefinedKeywords = new Set([\n  'TSNeverKeyword', 'TSUndefinedKeyword', 'TSVoidKeyword',\n]);\n\n/**\n * Checks if a node has a return statement. Void return does not count.\n * @param {ESTreeOrTypeScriptNode|undefined|null} node\n * @param {boolean} [throwOnNullReturn]\n * @param {PromiseFilter} [promFilter]\n * @returns {boolean|undefined}\n */\n// eslint-disable-next-line complexity\nconst hasReturnValue = (node, throwOnNullReturn, promFilter) => {\n  if (!node) {\n    return false;\n  }\n\n  switch (node.type) {\n    case 'ArrowFunctionExpression':\n    case 'FunctionDeclaration':\n    case 'FunctionExpression': {\n      return 'expression' in node && node.expression && (!isNewPromiseExpression(\n        node.body,\n      ) || !isVoidPromise(node.body)) ||\n      hasReturnValue(node.body, throwOnNullReturn, promFilter);\n    }\n\n    case 'BlockStatement': {\n      return node.body.some((bodyNode) => {\n        return bodyNode.type !== 'FunctionDeclaration' && hasReturnValue(bodyNode, throwOnNullReturn, promFilter);\n      });\n    }\n\n    case 'DoWhileStatement':\n    case 'ForInStatement':\n    case 'ForOfStatement':\n\n    case 'ForStatement':\n\n    case 'LabeledStatement':\n    case 'WhileStatement':\n    case 'WithStatement': {\n      return hasReturnValue(node.body, throwOnNullReturn, promFilter);\n    }\n\n    case 'IfStatement': {\n      return hasReturnValue(node.consequent, throwOnNullReturn, promFilter) ||\n      hasReturnValue(node.alternate, throwOnNullReturn, promFilter);\n    }\n\n    case 'MethodDefinition':\n      return hasReturnValue(node.value, throwOnNullReturn, promFilter);\n    case 'ReturnStatement': {\n    // void return does not count.\n      if (node.argument === null) {\n        if (throwOnNullReturn) {\n          throw new Error('Null return');\n        }\n\n        return false;\n      }\n\n      if (promFilter && isNewPromiseExpression(node.argument)) {\n      // Let caller decide how to filter, but this is, at the least,\n      //   a return of sorts and truthy\n        return promFilter(node.argument);\n      }\n\n      return true;\n    }\n\n    case 'SwitchStatement': {\n      return node.cases.some(\n        (someCase) => {\n          return someCase.consequent.some((nde) => {\n            return hasReturnValue(nde, throwOnNullReturn, promFilter);\n          });\n        },\n      );\n    }\n\n    case 'TryStatement': {\n      return hasReturnValue(node.block, throwOnNullReturn, promFilter) ||\n      hasReturnValue(node.handler && node.handler.body, throwOnNullReturn, promFilter) ||\n      hasReturnValue(node.finalizer, throwOnNullReturn, promFilter);\n    }\n\n    case 'TSDeclareFunction':\n\n    case 'TSFunctionType':\n\n    case 'TSMethodSignature': {\n      const type = node?.returnType?.typeAnnotation?.type;\n      return type && !undefinedKeywords.has(type);\n    }\n\n    default: {\n      return false;\n    }\n  }\n};\n\n/**\n * Checks if a node has a return statement. Void return does not count.\n * @param {ESTreeOrTypeScriptNode|null|undefined} node\n * @param {PromiseFilter} promFilter\n * @returns {undefined|boolean|ESTreeOrTypeScriptNode}\n */\n// eslint-disable-next-line complexity\nconst allBrancheshaveReturnValues = (node, promFilter) => {\n  if (!node) {\n    return false;\n  }\n\n  switch (node.type) {\n    // case 'MethodDefinition':\n    //   return allBrancheshaveReturnValues(node.value, promFilter);\n    case 'ArrowFunctionExpression':\n    case 'FunctionDeclaration':\n    case 'FunctionExpression': {\n      return 'expression' in node && node.expression && (!isNewPromiseExpression(node.body) || !isVoidPromise(node.body)) ||\n      allBrancheshaveReturnValues(node.body, promFilter) ||\n      /** @type {import('@typescript-eslint/types').TSESTree.BlockStatement} */\n      (node.body).body.some((nde) => {\n        return nde.type === 'ReturnStatement';\n      });\n    }\n\n    case 'BlockStatement': {\n      const lastBodyNode = node.body.slice(-1)[0];\n      return allBrancheshaveReturnValues(lastBodyNode, promFilter);\n    }\n\n    case 'DoWhileStatement':\n    case 'WhileStatement':\n      if (\n      /**\n       * @type {import('@typescript-eslint/types').TSESTree.Literal}\n       */\n        (node.test).value === true\n      ) {\n      // If this is an infinite loop, we assume only one branch\n      //   is needed to provide a return\n        return hasReturnValue(node.body, false, promFilter);\n      }\n\n    // Fallthrough\n    case 'ForStatement':\n      if (node.test === null) {\n      // If this is an infinite loop, we assume only one branch\n      //   is needed to provide a return\n        return hasReturnValue(node.body, false, promFilter);\n      }\n\n    case 'ForInStatement':\n    case 'ForOfStatement':\n\n    case 'LabeledStatement':\n\n    case 'WithStatement': {\n      return allBrancheshaveReturnValues(node.body, promFilter);\n    }\n\n    case 'IfStatement': {\n      return allBrancheshaveReturnValues(node.consequent, promFilter) &&\n      allBrancheshaveReturnValues(node.alternate, promFilter);\n    }\n\n    case 'ReturnStatement': {\n    // void return does not count.\n      if (node.argument === null) {\n        return false;\n      }\n\n      if (promFilter && isNewPromiseExpression(node.argument)) {\n      // Let caller decide how to filter, but this is, at the least,\n      //   a return of sorts and truthy\n        return promFilter(node.argument);\n      }\n\n      return true;\n    }\n\n    case 'SwitchStatement': {\n      return /** @type {import('@typescript-eslint/types').TSESTree.SwitchStatement} */ (node).cases.every(\n        (someCase) => {\n          return !someCase.consequent.some((consNode) => {\n            return consNode.type === 'BreakStatement' ||\n            consNode.type === 'ReturnStatement' && consNode.argument === null;\n          });\n        },\n      );\n    }\n\n    case 'ThrowStatement': {\n      return true;\n    }\n\n    case 'TryStatement': {\n    // If `finally` returns, all return\n      return node.finalizer && allBrancheshaveReturnValues(node.finalizer, promFilter) ||\n      // Return in `try`/`catch` may still occur despite `finally`\n      allBrancheshaveReturnValues(node.block, promFilter) &&\n        (!node.handler ||\n          allBrancheshaveReturnValues(node.handler && node.handler.body, promFilter)) &&\n          (!node.finalizer || (() => {\n            try {\n              hasReturnValue(node.finalizer, true, promFilter);\n            } catch (error) {\n              if (/** @type {Error} */ (error).message === 'Null return') {\n                return false;\n              }\n              /* c8 ignore next 3 */\n              // eslint-disable-next-line @stylistic/padding-line-between-statements -- c8\n              throw error;\n            }\n\n            // As long as not an explicit empty return, then return true\n            return true;\n          })());\n    }\n\n    case 'TSDeclareFunction':\n\n    case 'TSFunctionType':\n\n    case 'TSMethodSignature': {\n      const type = node?.returnType?.typeAnnotation?.type;\n      return type && !undefinedKeywords.has(type);\n    }\n\n    default: {\n      return false;\n    }\n  }\n};\n\n/**\n * @callback PromiseFilter\n * @param {ESTreeOrTypeScriptNode|undefined} node\n * @returns {boolean}\n */\n\n/**\n * Avoids further checking child nodes if a nested function shadows the\n * resolver, but otherwise, if name is used (by call or passed in as an\n * argument to another function), will be considered as non-empty.\n *\n * This could check for redeclaration of the resolver, but as such is\n * unlikely, we avoid the performance cost of checking everywhere for\n * (re)declarations or assignments.\n * @param {import('@typescript-eslint/types').TSESTree.Node|null|undefined} node\n * @param {string} resolverName\n * @returns {boolean}\n */\n// eslint-disable-next-line complexity\nconst hasNonEmptyResolverCall = (node, resolverName) => {\n  if (!node) {\n    return false;\n  }\n\n  // Arrow function without block\n  switch (node.type) {\n    case 'ArrayExpression':\n    case 'ArrayPattern':\n      return node.elements.some((element) => {\n        return hasNonEmptyResolverCall(element, resolverName);\n      });\n    case 'ArrowFunctionExpression':\n    case 'FunctionDeclaration':\n    case 'FunctionExpression': {\n    // Shadowing\n      if (/** @type {import('@typescript-eslint/types').TSESTree.Identifier} */ (\n        node.params[0]\n      )?.name === resolverName) {\n        return false;\n      }\n\n      return hasNonEmptyResolverCall(node.body, resolverName);\n    }\n\n    case 'AssignmentExpression':\n    case 'BinaryExpression':\n    case 'LogicalExpression': {\n      return hasNonEmptyResolverCall(node.left, resolverName) ||\n      hasNonEmptyResolverCall(node.right, resolverName);\n    }\n\n    case 'AssignmentPattern':\n      return hasNonEmptyResolverCall(node.right, resolverName);\n    case 'AwaitExpression':\n\n    case 'SpreadElement':\n    case 'UnaryExpression':\n    case 'YieldExpression':\n      return hasNonEmptyResolverCall(node.argument, resolverName);\n    case 'BlockStatement':\n    case 'ClassBody':\n      return node.body.some((bodyNode) => {\n        return hasNonEmptyResolverCall(bodyNode, resolverName);\n      });\n      /* c8 ignore next 2 -- In Babel? */\n    case 'CallExpression':\n      // @ts-expect-error Babel?\n    case 'OptionalCallExpression':\n      return /** @type {import('@typescript-eslint/types').TSESTree.Identifier} */ (\n        node.callee\n      ).name === resolverName && (\n\n      // Implicit or explicit undefined\n        node.arguments.length > 1 || node.arguments[0] !== undefined\n      ) ||\n      node.arguments.some((nde) => {\n        // Being passed in to another function (which might invoke it)\n        return nde.type === 'Identifier' && nde.name === resolverName ||\n\n          // Handle nested items\n          hasNonEmptyResolverCall(nde, resolverName);\n      });\n\n    case 'ChainExpression':\n    case 'Decorator':\n\n    case 'ExpressionStatement':\n      return hasNonEmptyResolverCall(node.expression, resolverName);\n\n    case 'ClassDeclaration':\n\n    case 'ClassExpression':\n      return hasNonEmptyResolverCall(node.body, resolverName);\n      /* c8 ignore next 2 -- In Babel? */\n      // @ts-expect-error Babel?\n    case 'ClassMethod':\n\n    case 'MethodDefinition':\n      return node.decorators && node.decorators.some((decorator) => {\n        return hasNonEmptyResolverCall(decorator, resolverName);\n      }) ||\n      node.computed && hasNonEmptyResolverCall(node.key, resolverName) ||\n      hasNonEmptyResolverCall(node.value, resolverName);\n\n    /* c8 ignore next 2 -- In Babel? */\n      // @ts-expect-error Babel?\n    case 'ClassProperty':\n    /* c8 ignore next 2 -- In Babel? */\n    // @ts-expect-error Babel?\n    case 'ObjectProperty':\n    case 'Property':\n\n    case 'PropertyDefinition':\n      return node.computed && hasNonEmptyResolverCall(node.key, resolverName) ||\n      hasNonEmptyResolverCall(node.value, resolverName);\n    case 'ConditionalExpression':\n\n    case 'IfStatement': {\n      return hasNonEmptyResolverCall(node.test, resolverName) ||\n      hasNonEmptyResolverCall(node.consequent, resolverName) ||\n      hasNonEmptyResolverCall(node.alternate, resolverName);\n    }\n\n    case 'DoWhileStatement':\n    case 'ForInStatement':\n    case 'ForOfStatement':\n\n    case 'ForStatement':\n    case 'LabeledStatement':\n    case 'WhileStatement':\n    case 'WithStatement': {\n      return hasNonEmptyResolverCall(node.body, resolverName);\n    }\n\n    /* c8 ignore next 2 -- In Babel? */\n    // @ts-expect-error Babel?\n    case 'Import':\n\n    case 'ImportExpression':\n      return hasNonEmptyResolverCall(node.source, resolverName);\n      // ?.\n      /* c8 ignore next 2 -- In Babel? */\n    case 'MemberExpression':\n\n    // @ts-expect-error Babel?\n    case 'OptionalMemberExpression':\n      return hasNonEmptyResolverCall(node.object, resolverName) ||\n      hasNonEmptyResolverCall(node.property, resolverName);\n    case 'ObjectExpression':\n    case 'ObjectPattern':\n      return node.properties.some((property) => {\n        return hasNonEmptyResolverCall(property, resolverName);\n      });\n    /* c8 ignore next 2 -- In Babel? */\n      // @ts-expect-error Babel?\n    case 'ObjectMethod':\n    /* c8 ignore next 6 -- In Babel? */\n    // @ts-expect-error\n      return node.computed && hasNonEmptyResolverCall(node.key, resolverName) ||\n      // @ts-expect-error\n      node.arguments.some((nde) => {\n        return hasNonEmptyResolverCall(nde, resolverName);\n      });\n\n    case 'ReturnStatement': {\n      if (node.argument === null) {\n        return false;\n      }\n\n      return hasNonEmptyResolverCall(node.argument, resolverName);\n    }\n\n    // Comma\n    case 'SequenceExpression':\n\n    case 'TemplateLiteral':\n      return node.expressions.some((subExpression) => {\n        return hasNonEmptyResolverCall(subExpression, resolverName);\n      });\n\n    case 'SwitchStatement': {\n      return node.cases.some(\n        (someCase) => {\n          return someCase.consequent.some((nde) => {\n            return hasNonEmptyResolverCall(nde, resolverName);\n          });\n        },\n      );\n    }\n\n    case 'TaggedTemplateExpression':\n      return hasNonEmptyResolverCall(node.quasi, resolverName);\n\n    case 'TryStatement': {\n      return hasNonEmptyResolverCall(node.block, resolverName) ||\n      hasNonEmptyResolverCall(node.handler && node.handler.body, resolverName) ||\n      hasNonEmptyResolverCall(node.finalizer, resolverName);\n    }\n\n    case 'VariableDeclaration': {\n      return node.declarations.some((nde) => {\n        return hasNonEmptyResolverCall(nde, resolverName);\n      });\n    }\n\n    case 'VariableDeclarator': {\n      return hasNonEmptyResolverCall(node.id, resolverName) ||\n      hasNonEmptyResolverCall(node.init, resolverName);\n    }\n\n    /*\n  // Shouldn't need to parse literals/literal components, etc.\n\n  case 'Identifier':\n  case 'TemplateElement':\n  case 'Super':\n  // Exports not relevant in this context\n  */\n    default:\n      return false;\n  }\n};\n\n/**\n * Checks if a Promise executor has no resolve value or an empty value.\n * An `undefined` resolve does not count.\n * @param {ESTreeOrTypeScriptNode} node\n * @param {boolean} anyPromiseAsReturn\n * @param {boolean} [allBranches]\n * @returns {boolean}\n */\nconst hasValueOrExecutorHasNonEmptyResolveValue = (node, anyPromiseAsReturn, allBranches) => {\n  const hasReturnMethod = allBranches ?\n    /**\n     * @param {ESTreeOrTypeScriptNode} nde\n     * @param {PromiseFilter} promiseFilter\n     * @returns {boolean}\n     */\n    (nde, promiseFilter) => {\n      let hasReturn;\n      try {\n        hasReturn = hasReturnValue(nde, true, promiseFilter);\n      } catch (error) {\n        // c8 ignore else\n        if (/** @type {Error} */ (error).message === 'Null return') {\n          return false;\n        }\n        /* c8 ignore next 3 */\n        // eslint-disable-next-line @stylistic/padding-line-between-statements -- c8\n        throw error;\n      }\n\n      // `hasReturn` check needed since `throw` treated as valid return by\n      //   `allBrancheshaveReturnValues`\n      return Boolean(hasReturn && allBrancheshaveReturnValues(nde, promiseFilter));\n    } :\n    /**\n     * @param {ESTreeOrTypeScriptNode} nde\n     * @param {PromiseFilter} promiseFilter\n     * @returns {boolean}\n     */\n    (nde, promiseFilter) => {\n      return Boolean(hasReturnValue(nde, false, promiseFilter));\n    };\n\n  return hasReturnMethod(node, (prom) => {\n    if (anyPromiseAsReturn) {\n      return true;\n    }\n\n    if (isVoidPromise(prom)) {\n      return false;\n    }\n\n    const {\n      body,\n      params,\n    } =\n    /**\n     * @type {import('@typescript-eslint/types').TSESTree.FunctionExpression|\n     * import('@typescript-eslint/types').TSESTree.ArrowFunctionExpression}\n     */ (\n      /** @type {import('@typescript-eslint/types').TSESTree.NewExpression} */ (\n          prom\n        ).arguments[0]\n      ) || {};\n\n    if (!params?.length) {\n      return false;\n    }\n\n    const {\n      name: resolverName,\n    } = /** @type {import('@typescript-eslint/types').TSESTree.Identifier} */ (\n      params[0]\n    );\n\n    return hasNonEmptyResolverCall(body, resolverName);\n  });\n};\n\nexport {\n  hasReturnValue,\n  hasValueOrExecutorHasNonEmptyResolveValue,\n};\n"],"mappings":"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","ignoreList":[]}