import { extractMemberExpressionPath } from './member-expression.js';
export function findParentNodeAndPathForIdentifier(sourceCode, node) {
    if (node.parent.type === 'MemberExpression') {
        return findParentNodeAndPathForIdentifier(sourceCode, node.parent);
    }
    if (node.parent.type === 'CallExpression' && node.parent.parent.type === 'MemberExpression') {
        return findParentNodeAndPathForIdentifier(sourceCode, node.parent.parent);
    }
    // eslint-disable-next-line @typescript-eslint/no-unsafe-type-assertion -- we know the type of the parent
    return { node: node.parent, path: extractMemberExpressionPath(sourceCode, node) };
}
export function initialReferenceToResolvedReference(reference, sourceCode) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-type-assertion -- due to the bad typing of eslint core, the type is missing the parent property but it has this property
    const { node, path } = findParentNodeAndPathForIdentifier(sourceCode, reference.identifier);
    return { node, path, resolvedPath: path };
}
//# sourceMappingURL=resolved-reference.js.map