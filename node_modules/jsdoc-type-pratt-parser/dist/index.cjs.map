{"version":3,"sources":["../src/index.ts","../src/errors.ts","../src/lexer/Token.ts","../src/assertTypes.ts","../src/Parser.ts","../src/parslets/isQuestionMarkUnknownType.ts","../src/parslets/NullableParslets.ts","../src/parslets/Parslet.ts","../src/parslets/OptionalParslet.ts","../src/parslets/NumberParslet.ts","../src/parslets/ParenthesisParslet.ts","../src/parslets/SpecialTypesParslet.ts","../src/parslets/NotNullableParslet.ts","../src/parslets/ParameterListParslet.ts","../src/parslets/GenericParslet.ts","../src/parslets/UnionParslets.ts","../src/grammars/baseGrammar.ts","../src/parslets/NamePathParslet.ts","../src/parslets/NameParslet.ts","../src/parslets/StringValueParslet.ts","../src/parslets/SpecialNamePathParslet.ts","../src/grammars/pathGrammar.ts","../src/parslets/FunctionParslet.ts","../src/parslets/VariadicParslet.ts","../src/parslets/SymbolParslet.ts","../src/parslets/ArrayBracketsParslet.ts","../src/parslets/ObjectParslet.ts","../src/parslets/ObjectFieldParslet.ts","../src/parslets/KeyValueParslet.ts","../src/grammars/jsdocGrammar.ts","../src/parslets/TypeOfParslet.ts","../src/grammars/closureGrammar.ts","../src/parslets/assertsParslet.ts","../src/parslets/FunctionPropertyParslet.ts","../src/parslets/TupleParslet.ts","../src/parslets/KeyOfParslet.ts","../src/parslets/ImportParslet.ts","../src/parslets/ReadonlyPropertyParslet.ts","../src/parslets/ArrowFunctionParslet.ts","../src/parslets/GenericArrowFunctionParslet.ts","../src/parslets/IntersectionParslet.ts","../src/parslets/predicateParslet.ts","../src/lexer/Lexer.ts","../src/parslets/ObjectSquaredPropertyParslet.ts","../src/parslets/ReadonlyArrayParslet.ts","../src/parslets/ConditionalParslet.ts","../src/lexer/LexerRules.ts","../src/parslets/TemplateLiteralParslet.ts","../src/grammars/typescriptGrammar.ts","../src/parse.ts","../src/transforms/transform.ts","../src/transforms/stringify.ts","../src/transforms/catharsisTransform.ts","../src/transforms/jtpTransform.ts","../src/transforms/identityTransformRules.ts","../src/visitorKeys.ts","../src/traverse.ts"],"sourcesContent":["/**\n * @package\n * This package provides a parser for jsdoc types.\n */\n\nexport * from './parse.js'\nexport type * from './result/RootResult.js'\nexport type * from './result/NonRootResult.js'\nexport { transform, type TransformRule, type TransformFunction, type TransformRules } from './transforms/transform.js'\nexport { catharsisTransform } from './transforms/catharsisTransform.js'\nexport { jtpTransform } from './transforms/jtpTransform.js'\nexport { stringify, stringifyRules } from './transforms/stringify.js'\nexport { identityTransformRules } from './transforms/identityTransformRules.js'\nexport * from './traverse.js'\nexport * from './visitorKeys.js'\n","import type { Token } from './lexer/Token.js'\nimport type { IntermediateResult } from './result/IntermediateResult.js'\n\nfunction tokenToString (token: Token): string {\n  if (token.text !== undefined && token.text !== '') {\n    return `'${token.type}' with value '${token.text}'`\n  } else {\n    return `'${token.type}'`\n  }\n}\n\nexport class NoParsletFoundError extends Error {\n  private readonly token: Token\n\n  constructor (token: Token) {\n    super(`No parslet found for token: ${tokenToString(token)}`)\n\n    this.token = token\n\n    Object.setPrototypeOf(this, NoParsletFoundError.prototype)\n  }\n\n  getToken (): Token {\n    return this.token\n  }\n}\n\nexport class EarlyEndOfParseError extends Error {\n  private readonly token: Token\n\n  constructor (token: Token) {\n    super(`The parsing ended early. The next token was: ${tokenToString(token)}`)\n\n    this.token = token\n\n    Object.setPrototypeOf(this, EarlyEndOfParseError.prototype)\n  }\n\n  getToken (): Token {\n    return this.token\n  }\n}\n\nexport class UnexpectedTypeError extends Error {\n  constructor (result: IntermediateResult, message?: string) {\n    let error = `Unexpected type: '${result.type}'.`\n    if (message !== undefined) {\n      error += ` Message: ${message}`\n    }\n    super(error)\n\n    Object.setPrototypeOf(this, UnexpectedTypeError.prototype)\n  }\n}\n\n// export class UnexpectedTokenError extends Error {\n//   private expected: Token\n//   private found: Token\n//\n//   constructor (expected: Token, found: Token) {\n//     super(`The parsing ended early. The next token was: ${tokenToString(token)}`)\n//\n//     this.token = token\n//\n//     Object.setPrototypeOf(this, EarlyEndOfParseError.prototype)\n//   }\n//\n//   getToken() {\n//     return this.token\n//   }\n// }\n","export type TokenType =\n  '('\n  | ')'\n  | '['\n  | ']'\n  | '{'\n  | '}'\n  | '|'\n  | '&'\n  | '<'\n  | '>'\n  | ';'\n  | ','\n  | '*'\n  | '?'\n  | '!'\n  | '='\n  | ':'\n  | '.'\n  | '@'\n  | '#'\n  | '~'\n  | '/'\n  | '=>'\n  | '...'\n  | 'null'\n  | 'undefined'\n  | 'function'\n  | 'this'\n  | 'new'\n  | 'module'\n  | 'event'\n  | 'extends'\n  | 'external'\n  | 'typeof'\n  | 'keyof'\n  | 'readonly'\n  | 'import'\n  | 'infer'\n  | 'is'\n  | 'in'\n  | 'asserts'\n  | 'Identifier'\n  | 'StringValue'\n  | 'TemplateLiteral'\n  | 'Number'\n  | 'EOF'\n\nexport interface Token {\n  type: TokenType\n  text: string\n  startOfLine: boolean\n}\n\nexport const baseNameTokens: TokenType[] = [\n  'module', 'keyof', 'event', 'external',\n  'readonly', 'is',\n  'typeof', 'in',\n  'null', 'undefined', 'function', 'asserts', 'infer',\n  'extends', 'import'\n]\n\nexport const reservedWordsAsRootTSTypes = [\n  'false',\n  'null',\n  'true',\n  'void'\n]\n\n// May not be needed\nexport const reservedWordsAsTSTypes = [\n  ...reservedWordsAsRootTSTypes,\n  'extends',\n  'import',\n  'in',\n  'new',\n  'this',\n  'typeof'\n]\n\nexport const reservedWords = {\n  always: [\n    'break',\n    'case',\n    'catch',\n    'class',\n    'const',\n    'continue',\n    'debugger',\n    'default',\n    'delete',\n    'do',\n    'else',\n    'export',\n    'extends',\n    'false',\n    'finally',\n    'for',\n    'function',\n    'if',\n    'import',\n    'in',\n    'instanceof',\n    'new',\n    'null',\n    'return',\n    'super',\n    'switch',\n    'this',\n    'throw',\n    'true',\n    'try',\n    'typeof',\n    'var',\n    'void',\n    'while',\n    'with'\n  ],\n  strictMode: [\n    'let',\n    'static',\n    'yield'\n  ],\n  moduleOrAsyncFunctionBodies: [\n    'await'\n  ]\n}\n\nexport const futureReservedWords = {\n  always: ['enum'],\n  strictMode: [\n    'implements',\n    'interface',\n    'package',\n    'private',\n    'protected',\n    'public'\n  ]\n}\n\nexport const strictModeNonIdentifiers = [\n  'arguments',\n  'eval'\n];\n","import type { IndexSignatureResult, KeyValueResult, MappedTypeResult } from './result/NonRootResult.js'\nimport { UnexpectedTypeError } from './errors.js'\nimport type { NameResult, NumberResult, RootResult, VariadicResult, TupleResult, GenericResult } from './result/RootResult.js'\nimport type { IntermediateResult } from './result/IntermediateResult.js'\nimport {\n  reservedWords, futureReservedWords, strictModeNonIdentifiers,\n  reservedWordsAsRootTSTypes\n} from './lexer/Token.js'\nimport type { Parser } from './Parser.js'\n\nexport function assertResultIsNotReservedWord <T extends RootResult|IntermediateResult> (\n  parser: Parser, result: T\n): T {\n  let text: string;\n  if (result.type === 'JsdocTypeName') {\n    text = result.value\n  } else if (result.type === 'JsdocTypeParenthesis') {\n    let res: IntermediateResult = result\n    while (res.type === 'JsdocTypeParenthesis') {\n      res = res.element\n    }\n\n    if (res.type === 'JsdocTypeName') {\n      text = res.value\n    } else {\n      return result\n    }\n  } else {\n    return result\n  }\n\n\n  if (reservedWords.always.includes(text) && !reservedWordsAsRootTSTypes.includes(text) &&\n    (text !== 'this' || parser.classContext !== true)) {\n    throw new Error(`Unexpected reserved keyword \"${text}\"`)\n  }\n  if (futureReservedWords.always.includes(text)) {\n    throw new Error(`Unexpected future reserved keyword \"${text}\"`)\n  }\n\n  if ((parser.module !== undefined && parser.module) ||\n    (parser.strictMode !== undefined && parser.strictMode)\n  ) {\n    if (reservedWords.strictMode.includes(text)) {\n      throw new Error(`Unexpected reserved keyword \"${text}\" for strict mode`)\n    }\n    if (futureReservedWords.strictMode.includes(text)) {\n      throw new Error(`Unexpected future reserved keyword \"${text}\" for strict mode`)\n    }\n    if (strictModeNonIdentifiers.includes(text)) {\n      throw new Error(`The item \"${text}\" is not an identifier in strict mode`);\n    }\n  }\n  if ((parser.module !== undefined && parser.module) ||\n    (parser.asyncFunctionBody !== undefined && parser.asyncFunctionBody)\n  ) {\n    if (reservedWords.moduleOrAsyncFunctionBodies.includes(text)) {\n      throw new Error(`Unexpected reserved keyword \"${text}\" for modules or async function bodies`)\n    }\n  }\n\n  return result\n}\n\n/**\n * Throws an error if the provided result is not a {@link RootResult}\n */\nexport function assertRootResult (result?: IntermediateResult): RootResult {\n  if (result === undefined) {\n    throw new Error('Unexpected undefined')\n  }\n  if (\n    result.type === 'JsdocTypeKeyValue' || result.type === 'JsdocTypeParameterList' ||\n    result.type === 'JsdocTypeProperty' || result.type === 'JsdocTypeReadonlyProperty' ||\n    result.type === 'JsdocTypeObjectField' || result.type === 'JsdocTypeJsdocObjectField' ||\n    result.type === 'JsdocTypeIndexSignature' || result.type === 'JsdocTypeMappedType' ||\n    result.type === 'JsdocTypeTypeParameter' || result.type === 'JsdocTypeCallSignature' ||\n    result.type === 'JsdocTypeConstructorSignature' || result.type === 'JsdocTypeMethodSignature' ||\n    result.type === 'JsdocTypeIndexedAccessIndex' || result.type === 'JsdocTypeComputedProperty' ||\n    result.type === 'JsdocTypeComputedMethod'\n  ) {\n    throw new UnexpectedTypeError(result)\n  }\n  return result\n}\n\nexport function assertPlainKeyValueOrRootResult (result: IntermediateResult): KeyValueResult | RootResult {\n  if (result.type === 'JsdocTypeKeyValue') {\n    return assertPlainKeyValueResult(result)\n  }\n  return assertRootResult(result)\n}\n\nexport function assertPlainKeyValueOrNameResult (result: IntermediateResult): KeyValueResult | NameResult {\n  if (result.type === 'JsdocTypeName') {\n    return result\n  }\n  return assertPlainKeyValueResult(result)\n}\n\nexport function assertPlainKeyValueResult (result: IntermediateResult): KeyValueResult {\n  if (result.type !== 'JsdocTypeKeyValue') {\n    throw new UnexpectedTypeError(result)\n  }\n  return result\n}\n\nexport function assertNumberOrVariadicNameResult (result: IntermediateResult): NumberResult | NameResult | VariadicResult<NameResult> {\n  if (result.type === 'JsdocTypeVariadic') {\n    if (result.element?.type === 'JsdocTypeName') {\n      return result as VariadicResult<NameResult>\n    }\n    throw new UnexpectedTypeError(result)\n  }\n  if (result.type !== 'JsdocTypeNumber' && result.type !== 'JsdocTypeName') {\n    throw new UnexpectedTypeError(result)\n  }\n  return result\n}\n\nexport function assertArrayOrTupleResult (result: IntermediateResult): TupleResult | GenericResult {\n  if (result.type === 'JsdocTypeTuple') {\n    return result\n  }\n\n  if (result.type === 'JsdocTypeGeneric' && result.meta.brackets === 'square') {\n    return result\n  }\n\n  throw new UnexpectedTypeError(result)\n}\n\nexport function isSquaredProperty (result: IntermediateResult): result is IndexSignatureResult | MappedTypeResult {\n  return result.type === 'JsdocTypeIndexSignature' || result.type === 'JsdocTypeMappedType'\n}\n","import { EarlyEndOfParseError, NoParsletFoundError } from './errors.js'\nimport type { Lexer } from './lexer/Lexer.js'\nimport type { Grammar } from './grammars/Grammar.js'\nimport { assertRootResult } from './assertTypes.js'\nimport { Precedence } from './Precedence.js'\nimport type { RootResult } from './result/RootResult.js'\nimport type { IntermediateResult } from './result/IntermediateResult.js'\nimport type { TokenType } from './lexer/Token.js'\n\nexport class Parser {\n  public readonly grammar: Grammar\n  private _lexer: Lexer\n  public readonly baseParser?: Parser\n  public readonly externalParsers?: Record<string, ((\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any -- Actual API\n    text: string, options?: any\n  ) => unknown)|undefined>\n  public readonly module?: boolean\n  public readonly strictMode?: boolean\n  public readonly asyncFunctionBody?: boolean\n  public readonly classContext?: boolean\n\n  constructor (grammar: Grammar, lexer: Lexer, baseParser?: Parser, {\n    module,\n    strictMode,\n    asyncFunctionBody,\n    classContext,\n    externalParsers\n  }: {\n    module?: boolean,\n    strictMode?: boolean,\n    asyncFunctionBody?: boolean,\n    classContext?: boolean,\n    externalParsers?: Record<string, ((\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any -- Actual API\n      text: string, options?: any\n    ) => unknown)|undefined>\n  } = {}) {\n    this.grammar = grammar\n    this._lexer = lexer\n    this.baseParser = baseParser\n    this.externalParsers = externalParsers\n    this.module = module\n    this.strictMode = strictMode\n    this.asyncFunctionBody = asyncFunctionBody\n    this.classContext = classContext\n  }\n\n  get lexer (): Lexer {\n    return this._lexer\n  }\n\n  /**\n   * Parses a given string and throws an error if the parse ended before the end of the string.\n   */\n  parse (): RootResult {\n    const result = this.parseType(Precedence.ALL)\n    if (this.lexer.current.type !== 'EOF') {\n      throw new EarlyEndOfParseError(this.lexer.current)\n    }\n    return result\n  }\n\n  /**\n   * Parses with the current lexer and asserts that the result is a {@link RootResult}.\n   */\n  public parseType (precedence: Precedence): RootResult {\n    return assertRootResult(this.parseIntermediateType(precedence))\n  }\n\n  /**\n   * The main parsing function. First it tries to parse the current state in the prefix step, and then it continues\n   * to parse the state in the infix step.\n   */\n  public parseIntermediateType (precedence: Precedence): IntermediateResult {\n    const result = this.tryParslets(null, precedence)\n\n    if (result === null) {\n      throw new NoParsletFoundError(this.lexer.current)\n    }\n\n    return this.parseInfixIntermediateType(result, precedence)\n  }\n\n  /**\n   * In the infix parsing step the parser continues to parse the current state with all parslets until none returns\n   * a result.\n   */\n  public parseInfixIntermediateType (left: IntermediateResult, precedence: Precedence): IntermediateResult {\n    let result = this.tryParslets(left, precedence)\n\n    while (result !== null) {\n      left = result\n      result = this.tryParslets(left, precedence)\n    }\n\n    return left\n  }\n\n  /**\n   * Tries to parse the current state with all parslets in the grammar and returns the first non null result.\n   */\n  private tryParslets (left: IntermediateResult | null, precedence: Precedence): IntermediateResult | null {\n    for (const parslet of this.grammar) {\n      const result = parslet(this, precedence, left)\n      if (result !== null) {\n        return result\n      }\n    }\n    return null\n  }\n\n  /**\n   * If the given type equals the current type of the {@link Lexer} advance the lexer. Return true if the lexer was\n   * advanced.\n   */\n  public consume (types: TokenType | TokenType[]): boolean {\n    if (!Array.isArray(types)) {\n      types = [types]\n    }\n\n    if (types.includes(this.lexer.current.type)) {\n      this._lexer = this.lexer.advance()\n      return true\n    } else {\n      return false\n    }\n  }\n\n  public acceptLexerState (parser: Parser): void {\n    this._lexer = parser.lexer\n  }\n}\n","import type { TokenType } from '../lexer/Token.js'\n\nexport function isQuestionMarkUnknownType (next: TokenType): boolean {\n  return next === '}' || next === 'EOF' || next === '|' || next === ',' || next === ')' || next === '>'\n}\n","import type { ParsletFunction } from './Parslet.js'\nimport { Precedence } from '../Precedence.js'\nimport { isQuestionMarkUnknownType } from './isQuestionMarkUnknownType.js'\nimport { assertRootResult } from '../assertTypes.js'\n\nexport const nullableParslet: ParsletFunction = (parser, precedence, left) => {\n  const type = parser.lexer.current.type\n  const next = parser.lexer.next.type\n\n  const accept = ((left == null) && type === '?' && !isQuestionMarkUnknownType(next)) ||\n    ((left != null) && type === '?')\n\n  if (!accept) {\n    return null\n  }\n\n  parser.consume('?')\n\n  if (left == null) {\n    return {\n      type: 'JsdocTypeNullable',\n      element: parser.parseType(Precedence.NULLABLE),\n      meta: {\n        position: 'prefix'\n      }\n    }\n  } else {\n    return {\n      type: 'JsdocTypeNullable',\n      element: assertRootResult(left),\n      meta: {\n        position: 'suffix'\n      }\n    }\n  }\n}\n","import type { TokenType } from '../lexer/Token.js'\nimport type { Parser } from '../Parser.js'\nimport type { Precedence } from '../Precedence.js'\nimport type { IntermediateResult } from '../result/IntermediateResult.js'\n\n/**\n * Each ParsletFunction can be called during the prefix or infix parsing step. In the prefix parsing step the `left` value\n * will be null and in the infix parsing step it value contain the previous value.\n * If the current state of the lexer in the current step is not accepted then the function should return `null`.\n * In the infix parsing step the current precedence should be checked.\n * See {@link composeParslet} for a more convenient way to use this function.\n */\nexport type ParsletFunction = (parser: Parser, precedence: Precedence, left: IntermediateResult | null) => IntermediateResult | null\n\ninterface BaseComposeParsletOptions {\n  name: string\n  accept: (type: TokenType, next: TokenType) => boolean\n}\n\ntype ComposePrefixParsletOptions = BaseComposeParsletOptions & {\n  parsePrefix: (parser: Parser) => IntermediateResult\n}\n\ntype ComposeInfixParsletOptions = BaseComposeParsletOptions & {\n  precedence: Precedence\n  parseInfix: (parser: Parser, left: IntermediateResult) => IntermediateResult\n}\n\nexport type ComposeParsletOptions = ComposePrefixParsletOptions | ComposeInfixParsletOptions | (ComposePrefixParsletOptions & ComposeInfixParsletOptions)\n\nexport function composeParslet (options: ComposeParsletOptions): ParsletFunction {\n  const parslet: ParsletFunction = (parser, curPrecedence, left) => {\n    const type = parser.lexer.current.type\n    const next = parser.lexer.next.type\n\n    if (left === null) {\n      if ('parsePrefix' in options) {\n        if (options.accept(type, next)) {\n          return options.parsePrefix(parser)\n        }\n      }\n    } else {\n      if ('parseInfix' in options) {\n        if (options.precedence > curPrecedence && options.accept(type, next)) {\n          return options.parseInfix(parser, left)\n        }\n      }\n    }\n    return null\n  }\n\n  // for debugging\n  Object.defineProperty(parslet, 'name', {\n    value: options.name\n  })\n\n  return parslet\n}\n","import { composeParslet } from './Parslet.js'\nimport { Precedence } from '../Precedence.js'\nimport { assertRootResult } from '../assertTypes.js'\n\nexport const optionalParslet = composeParslet({\n  name: 'optionalParslet',\n  accept: type => type === '=',\n  precedence: Precedence.OPTIONAL,\n  parsePrefix: parser => {\n    parser.consume('=')\n    return {\n      type: 'JsdocTypeOptional',\n      element: parser.parseType(Precedence.OPTIONAL),\n      meta: {\n        position: 'prefix'\n      }\n    }\n  },\n  parseInfix: (parser, left) => {\n    parser.consume('=')\n    return {\n      type: 'JsdocTypeOptional',\n      element: assertRootResult(left),\n      meta: {\n        position: 'suffix'\n      }\n    }\n  }\n})\n","import { composeParslet } from './Parslet.js'\n\nexport const numberParslet = composeParslet({\n  name: 'numberParslet',\n  accept: type => type === 'Number',\n  parsePrefix: parser => {\n    const value = parseFloat(parser.lexer.current.text)\n    parser.consume('Number')\n    return {\n      type: 'JsdocTypeNumber',\n      value\n    }\n  }\n})\n","import { composeParslet } from './Parslet.js'\nimport { Precedence } from '../Precedence.js'\nimport { assertRootResult } from '../assertTypes.js'\n\nexport const parenthesisParslet = composeParslet({\n  name: 'parenthesisParslet',\n  accept: type => type === '(',\n  parsePrefix: parser => {\n    parser.consume('(')\n    if (parser.consume(')')) {\n      return {\n        type: 'JsdocTypeParameterList',\n        elements: []\n      }\n    }\n    const result = parser.parseIntermediateType(Precedence.ALL)\n    if (!parser.consume(')')) {\n      throw new Error('Unterminated parenthesis')\n    }\n    if (result.type === 'JsdocTypeParameterList') {\n      return result\n    } else if (result.type === 'JsdocTypeKeyValue') {\n      return {\n        type: 'JsdocTypeParameterList',\n        elements: [result]\n      }\n    }\n    return {\n      type: 'JsdocTypeParenthesis',\n      element: assertRootResult(result)\n    }\n  }\n})\n","import { composeParslet } from './Parslet.js'\nimport { isQuestionMarkUnknownType } from './isQuestionMarkUnknownType.js'\n\nexport const specialTypesParslet = composeParslet({\n  name: 'specialTypesParslet',\n  accept: (type, next) => (type === '?' && isQuestionMarkUnknownType(next)) ||\n    type === 'null' || type === 'undefined' || type === '*',\n  parsePrefix: parser => {\n    if (parser.consume('null')) {\n      return {\n        type: 'JsdocTypeNull'\n      }\n    }\n\n    if (parser.consume('undefined')) {\n      return {\n        type: 'JsdocTypeUndefined'\n      }\n    }\n\n    if (parser.consume('*')) {\n      return {\n        type: 'JsdocTypeAny'\n      }\n    }\n\n    if (parser.consume('?')) {\n      return {\n        type: 'JsdocTypeUnknown'\n      }\n    }\n\n    throw new Error('Unacceptable token: ' + parser.lexer.current.text)\n  }\n})\n","import { composeParslet } from './Parslet.js'\nimport { Precedence } from '../Precedence.js'\nimport { assertRootResult } from '../assertTypes.js'\n\nexport const notNullableParslet = composeParslet({\n  name: 'notNullableParslet',\n  accept: type => type === '!',\n  precedence: Precedence.NULLABLE,\n  parsePrefix: parser => {\n    parser.consume('!')\n    return {\n      type: 'JsdocTypeNotNullable',\n      element: parser.parseType(Precedence.NULLABLE),\n      meta: {\n        position: 'prefix'\n      }\n    }\n  },\n  parseInfix: (parser, left) => {\n    parser.consume('!')\n    return {\n      type: 'JsdocTypeNotNullable',\n      element: assertRootResult(left),\n      meta: {\n        position: 'suffix'\n      }\n    }\n  }\n})\n","import { composeParslet, type ParsletFunction } from './Parslet.js'\nimport { Precedence } from '../Precedence.js'\nimport { assertPlainKeyValueOrRootResult } from '../assertTypes.js'\nimport { NoParsletFoundError } from '../errors.js'\nimport type { KeyValueResult } from '../index.js'\nimport type { RootResult } from '../result/RootResult.js'\n\nexport function createParameterListParslet ({ allowTrailingComma }: {\n  allowTrailingComma: boolean\n}): ParsletFunction {\n  return composeParslet({\n    name: 'parameterListParslet',\n    accept: type => type === ',',\n    precedence: Precedence.PARAMETER_LIST,\n    parseInfix: (parser, left) => {\n      const elements: Array<RootResult | KeyValueResult> = [\n        assertPlainKeyValueOrRootResult(left)\n      ]\n      parser.consume(',')\n      do {\n        try {\n          const next = parser.parseIntermediateType(Precedence.PARAMETER_LIST)\n          elements.push(assertPlainKeyValueOrRootResult(next))\n        } catch (e) {\n          if (allowTrailingComma && e instanceof NoParsletFoundError) {\n            break\n          } else {\n            throw e\n          }\n        }\n      } while (parser.consume(','))\n\n      if (elements.length > 0 && elements.slice(0, -1).some(e => e.type === 'JsdocTypeVariadic')) {\n        throw new Error('Only the last parameter may be a rest parameter')\n      }\n\n      return {\n        type: 'JsdocTypeParameterList',\n        elements\n      }\n    }\n  })\n}\n","import { composeParslet } from './Parslet.js'\nimport { Precedence } from '../Precedence.js'\nimport { assertRootResult } from '../assertTypes.js'\nimport { UnexpectedTypeError } from '../errors.js'\n\nexport const genericParslet = composeParslet({\n  name: 'genericParslet',\n  accept: (type, next) => type === '<' || (type === '.' && next === '<'),\n  precedence: Precedence.GENERIC,\n  parseInfix: (parser, left) => {\n    const dot = parser.consume('.')\n    parser.consume('<')\n\n    const objects = []\n    let infer = false\n    if (parser.consume('infer')) {\n      infer = true\n      const left = parser.parseIntermediateType(Precedence.SYMBOL)\n\n      if (left.type !== 'JsdocTypeName') {\n        throw new UnexpectedTypeError(left, 'A typescript infer always has to have a name.')\n      }\n      objects.push(left)\n    } else {\n      do {\n        objects.push(parser.parseType(Precedence.PARAMETER_LIST))\n      } while (parser.consume(','))\n    }\n\n    if (!parser.consume('>')) {\n      throw new Error('Unterminated generic parameter list')\n    }\n\n    return {\n      type: 'JsdocTypeGeneric',\n      left: assertRootResult(left),\n      elements: objects,\n      ...(infer ? { infer: true } : {}),\n      meta: {\n        brackets: 'angle',\n        dot\n      }\n    }\n  }\n})\n","import { composeParslet } from './Parslet.js'\nimport { Precedence } from '../Precedence.js'\nimport { assertRootResult, assertResultIsNotReservedWord } from '../assertTypes.js'\n\nexport const unionParslet = composeParslet({\n  name: 'unionParslet',\n  accept: type => type === '|',\n  precedence: Precedence.UNION,\n  parseInfix: (parser, left) => {\n    parser.consume('|')\n\n    const elements = []\n    do {\n      elements.push(parser.parseType(Precedence.UNION))\n    } while (parser.consume('|'))\n\n    return {\n      type: 'JsdocTypeUnion',\n      elements: [\n        assertResultIsNotReservedWord(parser, assertRootResult(left)),\n        ...elements.map((element) => assertResultIsNotReservedWord(parser, element))\n      ]\n    }\n  }\n})\n","import type { Grammar } from './Grammar.js'\nimport { nullableParslet } from '../parslets/NullableParslets.js'\nimport { optionalParslet } from '../parslets/OptionalParslet.js'\nimport { numberParslet } from '../parslets/NumberParslet.js'\nimport { parenthesisParslet } from '../parslets/ParenthesisParslet.js'\nimport { specialTypesParslet } from '../parslets/SpecialTypesParslet.js'\nimport { notNullableParslet } from '../parslets/NotNullableParslet.js'\nimport { createParameterListParslet } from '../parslets/ParameterListParslet.js'\nimport { genericParslet } from '../parslets/GenericParslet.js'\nimport { unionParslet } from '../parslets/UnionParslets.js'\n\nexport const baseGrammar: Grammar = [\n  nullableParslet,\n  optionalParslet,\n  numberParslet,\n  parenthesisParslet,\n  specialTypesParslet,\n  notNullableParslet,\n  createParameterListParslet({\n    allowTrailingComma: true\n  }),\n  genericParslet,\n  unionParslet,\n  optionalParslet\n]\n","import type { ParsletFunction } from './Parslet.js'\nimport { Precedence } from '../Precedence.js'\nimport { assertRootResult } from '../assertTypes.js'\nimport { Parser } from '../Parser.js'\nimport type { NamePathResult, SpecialNamePath } from '../result/RootResult.js'\nimport { UnexpectedTypeError } from '../errors.js'\nimport type { PropertyResult, IndexedAccessIndexResult } from '../result/NonRootResult.js'\nimport type { Grammar } from '../grammars/Grammar.js'\n\nexport function createNamePathParslet ({ allowSquareBracketsOnAnyType, allowJsdocNamePaths, pathGrammar }: {\n  allowJsdocNamePaths: boolean\n  allowSquareBracketsOnAnyType: boolean\n  pathGrammar: Grammar | null\n}): ParsletFunction {\n  return function namePathParslet (parser, precedence, left) {\n    if ((left == null) || precedence >= Precedence.NAME_PATH) {\n      return null\n    }\n    const type = parser.lexer.current.type\n    const next = parser.lexer.next.type\n\n    const accept = (type === '.' && next !== '<') ||\n      (type === '[' && (allowSquareBracketsOnAnyType || left.type === 'JsdocTypeName')) ||\n      (allowJsdocNamePaths && (type === '~' || type === '#'))\n\n    if (!accept) {\n      return null\n    }\n\n    let pathType: NamePathResult['pathType']\n    let brackets = false\n\n    if (parser.consume('.')) {\n      pathType = 'property'\n    } else if (parser.consume('[')) {\n      pathType = 'property-brackets'\n      brackets = true\n    } else if (parser.consume('~')) {\n      pathType = 'inner'\n    } else {\n      parser.consume('#')\n      pathType = 'instance'\n    }\n\n    const pathParser = brackets && allowSquareBracketsOnAnyType\n      ? parser\n      : pathGrammar !== null\n        ? new Parser(pathGrammar, parser.lexer, parser)\n        : parser\n\n    const parsed = pathParser.parseType(Precedence.NAME_PATH)\n    parser.acceptLexerState(pathParser)\n    let right: PropertyResult | SpecialNamePath<'event'> | IndexedAccessIndexResult\n\n    switch (parsed.type) {\n      case 'JsdocTypeName':\n        right = {\n          type: 'JsdocTypeProperty',\n          value: parsed.value,\n          meta: {\n            quote: undefined\n          }\n        }\n        break\n      case 'JsdocTypeNumber':\n        right = {\n          type: 'JsdocTypeProperty',\n          value: parsed.value.toString(10),\n          meta: {\n            quote: undefined\n          }\n        }\n        break\n      case 'JsdocTypeStringValue':\n        right = {\n          type: 'JsdocTypeProperty',\n          value: parsed.value,\n          meta: {\n            quote: parsed.meta.quote\n          }\n        }\n        break\n      case 'JsdocTypeSpecialNamePath':\n        if (parsed.specialType === 'event') {\n          right = parsed as SpecialNamePath<'event'>\n        } else {\n          throw new UnexpectedTypeError(parsed, 'Type \\'JsdocTypeSpecialNamePath\\' is only allowed with specialType \\'event\\'')\n        }\n        break\n      default:\n        if (!brackets || !allowSquareBracketsOnAnyType) {\n          throw new UnexpectedTypeError(parsed, 'Expecting \\'JsdocTypeName\\', \\'JsdocTypeNumber\\', \\'JsdocStringValue\\' or \\'JsdocTypeSpecialNamePath\\'')\n        }\n\n        right = {\n          type: 'JsdocTypeIndexedAccessIndex',\n          right: parsed\n        }\n    }\n\n    if (brackets && !parser.consume(']')) {\n      const token = parser.lexer.current\n      throw new Error(`Unterminated square brackets. Next token is '${token.type}' ` +\n        `with text '${token.text}'`)\n    }\n\n    return {\n      type: 'JsdocTypeNamePath',\n      left: assertRootResult(left),\n      right,\n      pathType\n    }\n  }\n}\n","import type { TokenType } from '../lexer/Token.js'\nimport { composeParslet, type ParsletFunction } from './Parslet.js'\n\nexport function createNameParslet ({ allowedAdditionalTokens }: {\n  allowedAdditionalTokens: TokenType[]\n}): ParsletFunction {\n  return composeParslet({\n    name: 'nameParslet',\n    accept: type => type === 'Identifier' || type === 'this' || type === 'new' || allowedAdditionalTokens.includes(type),\n    parsePrefix: parser => {\n      const { type, text } = parser.lexer.current\n      parser.consume(type)\n\n      return {\n        type: 'JsdocTypeName',\n        value: text\n      }\n    }\n  })\n}\n","import { composeParslet } from './Parslet.js'\n\nexport const stringValueParslet = composeParslet({\n  name: 'stringValueParslet',\n  accept: type => type === 'StringValue',\n  parsePrefix: parser => {\n    const text = parser.lexer.current.text\n    parser.consume('StringValue')\n    return {\n      type: 'JsdocTypeStringValue',\n      value: text.slice(1, -1),\n      meta: {\n        quote: text.startsWith('\\'') ? 'single' : 'double'\n      }\n    }\n  }\n})\n","import { composeParslet, type ParsletFunction } from './Parslet.js'\nimport type { TokenType } from '../lexer/Token.js'\nimport { Precedence } from '../Precedence.js'\nimport { Parser } from '../Parser.js'\nimport type { SpecialNamePath, SpecialNamePathType } from '../result/RootResult.js'\nimport { assertRootResult } from '../assertTypes.js'\nimport type { Grammar } from '../grammars/Grammar.js'\n\nexport function createSpecialNamePathParslet ({ pathGrammar, allowedTypes }: {\n  allowedTypes: SpecialNamePathType[]\n  pathGrammar: Grammar\n}): ParsletFunction {\n  return composeParslet({\n    name: 'specialNamePathParslet',\n    accept: type => (allowedTypes as TokenType[]).includes(type),\n    parsePrefix: parser => {\n      const type = parser.lexer.current.type as SpecialNamePathType\n      parser.consume(type)\n\n      if (!parser.consume(':')) {\n        return {\n          type: 'JsdocTypeName',\n          value: type\n        }\n      }\n\n      let result: SpecialNamePath\n\n      let token = parser.lexer.current\n      if (parser.consume('StringValue')) {\n        result = {\n          type: 'JsdocTypeSpecialNamePath',\n          value: token.text.slice(1, -1),\n          specialType: type,\n          meta: {\n            quote: token.text.startsWith('\\'') ? 'single' : 'double'\n          }\n        }\n      } else {\n        let value = ''\n        const allowed: TokenType[] = ['Identifier', '@', '/']\n        while (allowed.some(type => parser.consume(type))) {\n          value += token.text\n          token = parser.lexer.current\n        }\n        result = {\n          type: 'JsdocTypeSpecialNamePath',\n          value,\n          specialType: type,\n          meta: {\n            quote: undefined\n          }\n        }\n      }\n\n      const moduleParser = new Parser(pathGrammar, parser.lexer, parser)\n      const moduleResult = moduleParser.parseInfixIntermediateType(result, Precedence.ALL)\n      parser.acceptLexerState(moduleParser)\n\n      return assertRootResult(moduleResult)\n    }\n  })\n}\n","import type { Grammar } from './Grammar.js'\nimport { createNamePathParslet } from '../parslets/NamePathParslet.js'\nimport { createNameParslet } from '../parslets/NameParslet.js'\nimport { stringValueParslet } from '../parslets/StringValueParslet.js'\nimport { numberParslet } from '../parslets/NumberParslet.js'\nimport { createSpecialNamePathParslet } from '../parslets/SpecialNamePathParslet.js'\nimport { baseNameTokens } from '../lexer/Token.js'\n\nconst basePathGrammar: Grammar = [\n  createNameParslet({\n    allowedAdditionalTokens: ['external', 'module']\n  }),\n  stringValueParslet,\n  numberParslet,\n  createNamePathParslet({\n    allowSquareBracketsOnAnyType: false,\n    allowJsdocNamePaths: true,\n    pathGrammar: null\n  })\n]\n\nexport const pathGrammar: Grammar = [\n  ...basePathGrammar,\n  createSpecialNamePathParslet({\n    allowedTypes: ['event'],\n    pathGrammar: basePathGrammar\n  }),\n  createNameParslet({\n    allowedAdditionalTokens: baseNameTokens\n  })\n]\n","import { composeParslet, type ParsletFunction } from './Parslet.js'\nimport { Precedence } from '../Precedence.js'\nimport type { FunctionResult, RootResult } from '../result/RootResult.js'\nimport type { IntermediateResult } from '../result/IntermediateResult.js'\nimport type { KeyValueResult, NonRootResult } from '../result/NonRootResult.js'\nimport { UnexpectedTypeError } from '../errors.js'\nimport { assertPlainKeyValueOrRootResult } from '../assertTypes.js'\n\nexport function getParameters (value: IntermediateResult): Array<RootResult | KeyValueResult> {\n  let parameters: NonRootResult[] = []\n  if (value.type === 'JsdocTypeParameterList') {\n    parameters = value.elements\n  } else if (value.type === 'JsdocTypeParenthesis') {\n    parameters = [value.element]\n  } else {\n    throw new UnexpectedTypeError(value)\n  }\n\n  return parameters.map(p => assertPlainKeyValueOrRootResult(p))\n}\n\nexport function getUnnamedParameters (value: IntermediateResult): RootResult[] {\n  const parameters = getParameters(value)\n  if (parameters.some(p => p.type === 'JsdocTypeKeyValue')) {\n    throw new Error('No parameter should be named')\n  }\n  return parameters as RootResult[]\n}\n\nexport function createFunctionParslet ({ allowNamedParameters, allowNoReturnType, allowWithoutParenthesis, allowNewAsFunctionKeyword }: {\n  allowNamedParameters?: string[]\n  allowWithoutParenthesis: boolean\n  allowNoReturnType: boolean\n  allowNewAsFunctionKeyword: boolean\n}): ParsletFunction {\n  return composeParslet({\n    name: 'functionParslet',\n    accept: (type, next) => type === 'function' || (allowNewAsFunctionKeyword && type === 'new' && next === '('),\n    parsePrefix: parser => {\n      const newKeyword = parser.consume('new')\n      parser.consume('function')\n\n      const hasParenthesis = parser.lexer.current.type === '('\n\n      if (!hasParenthesis) {\n        if (!allowWithoutParenthesis) {\n          throw new Error('function is missing parameter list')\n        }\n\n        return {\n          type: 'JsdocTypeName',\n          value: 'function'\n        }\n      }\n\n      let result: FunctionResult = {\n        type: 'JsdocTypeFunction',\n        parameters: [],\n        arrow: false,\n        constructor: newKeyword,\n        parenthesis: hasParenthesis\n      }\n\n      const value = parser.parseIntermediateType(Precedence.FUNCTION)\n\n      if (allowNamedParameters === undefined) {\n        result.parameters = getUnnamedParameters(value)\n      } else if (newKeyword && value.type === 'JsdocTypeFunction' && value.arrow) {\n        result = value\n        result.constructor = true\n        return result\n      } else {\n        result.parameters = getParameters(value)\n        for (const p of result.parameters) {\n          if (p.type === 'JsdocTypeKeyValue' && (!allowNamedParameters.includes(p.key))) {\n            throw new Error(`only allowed named parameters are ${allowNamedParameters.join(', ')} but got ${p.type}`)\n          }\n        }\n      }\n\n      if (parser.consume(':')) {\n        result.returnType = parser.parseType(Precedence.PREFIX)\n      } else {\n        if (!allowNoReturnType) {\n          throw new Error('function is missing return type')\n        }\n      }\n\n      return result\n    }\n  })\n}\n","import { composeParslet, type ParsletFunction } from './Parslet.js'\nimport { Precedence } from '../Precedence.js'\nimport { assertRootResult } from '../assertTypes.js'\nimport { NoParsletFoundError } from '../errors.js'\n\nexport function createVariadicParslet ({ allowPostfix, allowEnclosingBrackets }: {\n  allowPostfix: boolean\n  allowEnclosingBrackets: boolean\n}): ParsletFunction {\n  return composeParslet({\n    name: 'variadicParslet',\n    accept: type => type === '...',\n    precedence: Precedence.PREFIX,\n    parsePrefix: parser => {\n      parser.consume('...')\n\n      const brackets = allowEnclosingBrackets && parser.consume('[')\n\n      try {\n        const element = parser.parseType(Precedence.PREFIX)\n        if (brackets && !parser.consume(']')) {\n          throw new Error('Unterminated variadic type. Missing \\']\\'')\n        }\n\n        return {\n          type: 'JsdocTypeVariadic',\n          element: assertRootResult(element),\n          meta: {\n            position: 'prefix',\n            squareBrackets: brackets\n          }\n        }\n      } catch (e) {\n        if (e instanceof NoParsletFoundError) {\n          if (brackets) {\n            throw new Error('Empty square brackets for variadic are not allowed.', {\n              cause: e\n            })\n          }\n          return {\n            type: 'JsdocTypeVariadic',\n            meta: {\n              position: undefined,\n              squareBrackets: false\n            }\n          }\n        } else {\n          throw e\n        }\n      }\n    },\n    parseInfix: allowPostfix\n      ? (parser, left) => {\n          parser.consume('...')\n          return {\n            type: 'JsdocTypeVariadic',\n            element: assertRootResult(left),\n            meta: {\n              position: 'suffix',\n              squareBrackets: false\n            }\n          }\n        }\n      : undefined\n  })\n}\n","import { composeParslet } from './Parslet.js'\nimport { Precedence } from '../Precedence.js'\nimport { assertNumberOrVariadicNameResult } from '../assertTypes.js'\nimport type { SymbolResult } from '../result/RootResult.js'\n\nexport const symbolParslet = composeParslet({\n  name: 'symbolParslet',\n  accept: type => type === '(',\n  precedence: Precedence.SYMBOL,\n  parseInfix: (parser, left) => {\n    if (left.type !== 'JsdocTypeName') {\n      throw new Error('Symbol expects a name on the left side. (Reacting on \\'(\\')')\n    }\n    parser.consume('(')\n    const result: SymbolResult = {\n      type: 'JsdocTypeSymbol',\n      value: left.value\n    }\n    if (!parser.consume(')')) {\n      const next = parser.parseIntermediateType(Precedence.SYMBOL)\n      result.element = assertNumberOrVariadicNameResult(next)\n      if (!parser.consume(')')) {\n        throw new Error('Symbol does not end after value')\n      }\n    }\n\n    return result\n  }\n})\n","import { composeParslet } from './Parslet.js'\nimport { Precedence } from '../Precedence.js'\nimport { assertRootResult } from '../assertTypes.js'\n\nexport const arrayBracketsParslet = composeParslet({\n  name: 'arrayBracketsParslet',\n  precedence: Precedence.ARRAY_BRACKETS,\n  accept: (type, next) => type === '[' && next === ']',\n  parseInfix: (parser, left) => {\n    parser.consume('[')\n    parser.consume(']')\n    return {\n      type: 'JsdocTypeGeneric',\n      left: {\n        type: 'JsdocTypeName',\n        value: 'Array'\n      },\n      elements: [\n        assertRootResult(left)\n      ],\n      meta: {\n        brackets: 'square',\n        dot: false\n      }\n    }\n  }\n})\n","import { composeParslet, type ParsletFunction } from './Parslet.js'\nimport { Parser } from '../Parser.js'\nimport { Precedence } from '../Precedence.js'\nimport { UnexpectedTypeError } from '../errors.js'\nimport type { ObjectResult } from '../result/RootResult.js'\nimport type { Grammar } from '../grammars/Grammar.js'\nimport { getParameters } from './FunctionParslet.js'\n\nexport function createObjectParslet ({ signatureGrammar, objectFieldGrammar, allowKeyTypes }: {\n  signatureGrammar?: Grammar\n  objectFieldGrammar: Grammar\n  allowKeyTypes: boolean\n}): ParsletFunction {\n  return composeParslet({\n    name: 'objectParslet',\n    accept: type => type === '{',\n    parsePrefix: parser => {\n      parser.consume('{')\n      const result: ObjectResult = {\n        type: 'JsdocTypeObject',\n        meta: {\n          separator: 'comma'\n        },\n        elements: []\n      }\n\n      if (!parser.consume('}')) {\n        let separator: 'comma' | 'semicolon' | 'linebreak' | 'comma-and-linebreak' | 'semicolon-and-linebreak' | undefined\n\n        const fieldParser = new Parser(\n          objectFieldGrammar,\n          parser.lexer,\n          parser,\n          parser.externalParsers?.computedPropertyParser !== undefined\n            ? {\n              externalParsers: {\n                computedPropertyParser: parser.externalParsers.computedPropertyParser\n              }\n            }\n            : undefined\n        )\n\n        while (true) {\n          fieldParser.acceptLexerState(parser)\n          let field = fieldParser.parseIntermediateType(Precedence.OBJECT)\n          parser.acceptLexerState(fieldParser)\n\n          if (field === undefined && allowKeyTypes) {\n            field = parser.parseIntermediateType(Precedence.OBJECT)\n          }\n\n          let optional = false\n          if (field.type === 'JsdocTypeNullable') {\n            optional = true\n            field = field.element\n          }\n\n          if (field.type === 'JsdocTypeNumber' || field.type === 'JsdocTypeName' || field.type === 'JsdocTypeStringValue') {\n            let quote\n            if (field.type === 'JsdocTypeStringValue') {\n              quote = field.meta.quote\n            }\n\n            result.elements.push({\n              type: 'JsdocTypeObjectField',\n              key: field.value.toString(),\n              right: undefined,\n              optional,\n              readonly: false,\n              meta: {\n                quote\n              }\n            })\n          } else if (\n            signatureGrammar !== undefined &&\n            (field.type === 'JsdocTypeCallSignature' ||\n            field.type === 'JsdocTypeConstructorSignature' ||\n            field.type === 'JsdocTypeMethodSignature')\n          ) {\n\n            const signatureParser = new Parser(\n              [\n                ...signatureGrammar,\n                ...parser.grammar.flatMap((grammar) => {\n                  // We're supplying our own version\n                  if (grammar.name === 'keyValueParslet') {\n                    return []\n                  }\n                  return [grammar]\n                })\n              ],\n              parser.lexer,\n              parser\n            )\n\n            signatureParser.acceptLexerState(parser)\n            const params = signatureParser.parseIntermediateType(Precedence.OBJECT)\n            parser.acceptLexerState(signatureParser)\n\n            field.parameters = getParameters(params)\n\n            const returnType = parser.parseType(Precedence.OBJECT)\n            field.returnType = returnType\n\n            result.elements.push(field)\n          } else if (\n            field.type === 'JsdocTypeObjectField' ||\n            field.type === 'JsdocTypeJsdocObjectField'\n          ) {\n            result.elements.push(field)\n          } else if (\n            field.type === 'JsdocTypeReadonlyProperty' &&\n            field.element.type === 'JsdocTypeObjectField'\n          ) {\n            if (typeof field.element.key === 'object' &&\n              field.element.key.type === 'JsdocTypeComputedMethod') {\n              throw new Error('Computed method may not be readonly');\n            }\n            field.element.readonly = true\n            result.elements.push(field.element)\n          } else {\n            throw new UnexpectedTypeError(field)\n          }\n          if (parser.lexer.current.startOfLine) {\n            separator ??= 'linebreak';\n            // Handle single stray comma/semi-colon\n            parser.consume(',') || parser.consume(';')\n          } else if (parser.consume(',')) {\n            if (parser.lexer.current.startOfLine) {\n              separator = 'comma-and-linebreak'\n            } else {\n              separator = 'comma'\n            }\n          } else if (parser.consume(';')) {\n            if (parser.lexer.current.startOfLine) {\n              separator = 'semicolon-and-linebreak'\n            } else {\n              separator = 'semicolon'\n            }\n          } else {\n            break\n          }\n          const type = parser.lexer.current.type\n          if (type === '}') {\n            break\n          }\n        }\n\n        result.meta.separator = separator ?? 'comma' // TODO: use undefined here\n        if ((separator ?? '').endsWith('linebreak')) {\n          // TODO: Consume appropriate whitespace\n          result.meta.propertyIndent = '  '\n        }\n\n        if (!parser.consume('}')) {\n          throw new Error('Unterminated record type. Missing \\'}\\'')\n        }\n      }\n      return result\n    }\n  })\n}\n","import { composeParslet, type ParsletFunction } from './Parslet.js'\nimport { Precedence } from '../Precedence.js'\nimport { UnexpectedTypeError } from '../errors.js'\nimport { assertRootResult, isSquaredProperty } from '../assertTypes.js'\n\nexport function createObjectFieldParslet ({ allowSquaredProperties, allowKeyTypes, allowReadonly, allowOptional }: {\n  allowSquaredProperties: boolean\n  allowKeyTypes: boolean\n  allowOptional: boolean\n  allowReadonly: boolean\n}): ParsletFunction {\n  return composeParslet({\n    name: 'objectFieldParslet',\n    precedence: Precedence.KEY_VALUE,\n    accept: type => type === ':',\n    parseInfix: (parser, left) => {\n      let optional = false\n      let readonlyProperty = false\n\n      if (allowOptional && left.type === 'JsdocTypeNullable') {\n        optional = true\n        left = left.element\n      }\n\n      if (allowReadonly && left.type === 'JsdocTypeReadonlyProperty') {\n        readonlyProperty = true\n        left = left.element\n      }\n\n      /* c8 ignore next 2 -- Always has base parser? */\n      // object parslet uses a special grammar and for the value we want to switch back to the parent\n      const parentParser = parser.baseParser ?? parser\n      parentParser.acceptLexerState(parser)\n\n      if (\n        left.type === 'JsdocTypeNumber' || left.type === 'JsdocTypeName' || left.type === 'JsdocTypeStringValue' ||\n        isSquaredProperty(left)\n      ) {\n        /* c8 ignore next 3 -- Guard */\n        if (isSquaredProperty(left) && !allowSquaredProperties) {\n          throw new UnexpectedTypeError(left)\n        }\n\n        parentParser.consume(':')\n\n        let quote\n        if (left.type === 'JsdocTypeStringValue') {\n          quote = left.meta.quote\n        }\n\n        const right = parentParser.parseType(Precedence.KEY_VALUE)\n        parser.acceptLexerState(parentParser)\n\n        return {\n          type: 'JsdocTypeObjectField',\n          /* c8 ignore next -- Guard; not needed anymore? */\n          key: isSquaredProperty(left) ? left : left.value.toString(),\n          right,\n          optional,\n          readonly: readonlyProperty,\n          meta: {\n            quote\n          }\n        }\n      } else {\n        if (!allowKeyTypes) {\n          throw new UnexpectedTypeError(left)\n        }\n\n        parentParser.consume(':')\n\n        const right = parentParser.parseType(Precedence.KEY_VALUE)\n        parser.acceptLexerState(parentParser)\n\n        return {\n          type: 'JsdocTypeJsdocObjectField',\n          left: assertRootResult(left),\n          right\n        }\n      }\n    }\n  })\n}\n","import { composeParslet, type ParsletFunction } from './Parslet.js'\nimport { Precedence } from '../Precedence.js'\nimport { UnexpectedTypeError } from '../errors.js'\n\nexport function createKeyValueParslet ({ allowOptional, allowVariadic, acceptParameterList }: {\n  allowOptional: boolean\n  allowVariadic: boolean,\n  acceptParameterList?: boolean\n}): ParsletFunction {\n  return composeParslet({\n    name: 'keyValueParslet',\n    precedence: Precedence.KEY_VALUE,\n    accept: type => type === ':',\n    parseInfix: (parser, left) => {\n      let optional = false\n      let variadic = false\n\n      if (allowOptional && left.type === 'JsdocTypeNullable') {\n        optional = true\n        left = left.element\n      }\n\n      if (allowVariadic && left.type === 'JsdocTypeVariadic' && left.element !== undefined) {\n        variadic = true\n        left = left.element\n      }\n\n      if (left.type !== 'JsdocTypeName') {\n        if (acceptParameterList !== undefined && left.type === 'JsdocTypeParameterList') {\n          parser.consume(':')\n          return left\n        }\n        throw new UnexpectedTypeError(left)\n      }\n\n      parser.consume(':')\n\n      const right = parser.parseType(Precedence.KEY_VALUE)\n\n      return {\n        type: 'JsdocTypeKeyValue',\n        key: left.value,\n        right,\n        optional,\n        variadic\n      }\n    }\n  })\n}\n","import { baseGrammar } from './baseGrammar.js'\nimport type { Grammar } from './Grammar.js'\nimport { pathGrammar } from './pathGrammar.js'\nimport { createFunctionParslet } from '../parslets/FunctionParslet.js'\nimport { stringValueParslet } from '../parslets/StringValueParslet.js'\nimport { createSpecialNamePathParslet } from '../parslets/SpecialNamePathParslet.js'\nimport { createVariadicParslet } from '../parslets/VariadicParslet.js'\nimport { createNameParslet } from '../parslets/NameParslet.js'\nimport { symbolParslet } from '../parslets/SymbolParslet.js'\nimport { arrayBracketsParslet } from '../parslets/ArrayBracketsParslet.js'\nimport { createNamePathParslet } from '../parslets/NamePathParslet.js'\nimport { createObjectParslet } from '../parslets/ObjectParslet.js'\nimport { createObjectFieldParslet } from '../parslets/ObjectFieldParslet.js'\nimport { createKeyValueParslet } from '../parslets/KeyValueParslet.js'\nimport { genericParslet } from '../parslets/GenericParslet.js'\nimport { baseNameTokens } from '../lexer/Token.js'\n\nconst jsdocBaseGrammar = [\n  ...baseGrammar,\n  createFunctionParslet({\n    allowWithoutParenthesis: true,\n    allowNamedParameters: ['this', 'new'],\n    allowNoReturnType: true,\n    allowNewAsFunctionKeyword: false\n  }),\n  stringValueParslet,\n  createSpecialNamePathParslet({\n    allowedTypes: ['module', 'external', 'event'],\n    pathGrammar\n  }),\n  createVariadicParslet({\n    allowEnclosingBrackets: true,\n    allowPostfix: true\n  }),\n  createNameParslet({\n    allowedAdditionalTokens: ['keyof']\n  }),\n  symbolParslet,\n  arrayBracketsParslet,\n  createNamePathParslet({\n    allowSquareBracketsOnAnyType: false,\n    allowJsdocNamePaths: true,\n    pathGrammar\n  })\n]\n\nexport const jsdocGrammar: Grammar = [\n  ...jsdocBaseGrammar,\n  createObjectParslet({\n    // jsdoc syntax allows full types as keys, so we need to pull in the full grammar here\n    // we leave out the object type deliberately\n    objectFieldGrammar: [\n      createNameParslet({\n        allowedAdditionalTokens: ['typeof', 'module', 'in']\n      }),\n      createObjectFieldParslet({\n        allowSquaredProperties: false,\n        allowKeyTypes: true,\n        allowOptional: false,\n        allowReadonly: false\n      }),\n      ...jsdocBaseGrammar\n    ],\n    allowKeyTypes: true\n  }),\n  createKeyValueParslet({\n    allowOptional: true,\n    allowVariadic: true\n  })\n]\n\nexport const jsdocNameGrammar = [\n  genericParslet,\n  arrayBracketsParslet,\n  createNameParslet({\n    allowedAdditionalTokens: baseNameTokens\n  })\n]\n\nexport const jsdocNamePathGrammar = [\n  genericParslet,\n  arrayBracketsParslet,\n  createNameParslet({\n    allowedAdditionalTokens: baseNameTokens\n  }),\n  createNamePathParslet({\n    allowSquareBracketsOnAnyType: false,\n    allowJsdocNamePaths: true,\n    pathGrammar\n  })\n]\n\nexport const jsdocNamePathSpecialGrammar = [\n  createSpecialNamePathParslet({\n    allowedTypes: ['module', 'external', 'event'],\n    pathGrammar\n  }),\n  ...jsdocNamePathGrammar\n]\n","import { composeParslet } from './Parslet.js'\nimport { Precedence } from '../Precedence.js'\n\nexport const typeOfParslet = composeParslet({\n  name: 'typeOfParslet',\n  accept: type => type === 'typeof',\n  parsePrefix: parser => {\n    parser.consume('typeof')\n    return {\n      type: 'JsdocTypeTypeof',\n      element: parser.parseType(Precedence.KEY_OF_TYPE_OF)\n    }\n  }\n})\n","import { baseGrammar } from './baseGrammar.js'\nimport { pathGrammar } from './pathGrammar.js'\nimport { createNameParslet } from '../parslets/NameParslet.js'\nimport { nullableParslet } from '../parslets/NullableParslets.js'\nimport type { Grammar } from './Grammar.js'\nimport { optionalParslet } from '../parslets/OptionalParslet.js'\nimport { stringValueParslet } from '../parslets/StringValueParslet.js'\nimport { numberParslet } from '../parslets/NumberParslet.js'\nimport { createKeyValueParslet } from '../parslets/KeyValueParslet.js'\nimport { createObjectParslet } from '../parslets/ObjectParslet.js'\nimport { typeOfParslet } from '../parslets/TypeOfParslet.js'\nimport { createFunctionParslet } from '../parslets/FunctionParslet.js'\nimport { createVariadicParslet } from '../parslets/VariadicParslet.js'\nimport { createSpecialNamePathParslet } from '../parslets/SpecialNamePathParslet.js'\nimport { createNamePathParslet } from '../parslets/NamePathParslet.js'\nimport { symbolParslet } from '../parslets/SymbolParslet.js'\nimport { createObjectFieldParslet } from '../parslets/ObjectFieldParslet.js'\nimport { genericParslet } from '../parslets/GenericParslet.js'\nimport { arrayBracketsParslet } from '../parslets/ArrayBracketsParslet.js'\nimport { baseNameTokens } from '../lexer/Token.js'\n\nconst objectFieldGrammar: Grammar = [\n  createNameParslet({\n    allowedAdditionalTokens: [\n      'typeof', 'module', 'keyof', 'event', 'external', 'in'\n    ]\n  }),\n  nullableParslet,\n  optionalParslet,\n  stringValueParslet,\n  numberParslet,\n  createObjectFieldParslet({\n    allowSquaredProperties: false,\n    allowKeyTypes: false,\n    allowOptional: false,\n    allowReadonly: false\n  })\n]\n\nexport const closureGrammar = [\n  ...baseGrammar,\n  createObjectParslet({\n    allowKeyTypes: false,\n    objectFieldGrammar\n  }),\n  createNameParslet({\n    allowedAdditionalTokens: ['event', 'external', 'in']\n  }),\n  typeOfParslet,\n  createFunctionParslet({\n    allowWithoutParenthesis: false,\n    allowNamedParameters: ['this', 'new'],\n    allowNoReturnType: true,\n    allowNewAsFunctionKeyword: false\n  }),\n  createVariadicParslet({\n    allowEnclosingBrackets: false,\n    allowPostfix: false\n  }),\n  // additional name parslet is needed for some special cases\n  createNameParslet({\n    allowedAdditionalTokens: ['keyof']\n  }),\n  createSpecialNamePathParslet({\n    allowedTypes: ['module'],\n    pathGrammar\n  }),\n  createNamePathParslet({\n    allowSquareBracketsOnAnyType: false,\n    allowJsdocNamePaths: true,\n    pathGrammar\n  }),\n  createKeyValueParslet({\n    allowOptional: false,\n    allowVariadic: false\n  }),\n  symbolParslet\n]\n\nexport const closureNameGrammar = [\n  genericParslet,\n  arrayBracketsParslet,\n  createNameParslet({\n    allowedAdditionalTokens: baseNameTokens\n  })\n]\n\nexport const closureNamePathGrammar = [\n  genericParslet,\n  arrayBracketsParslet,\n  createNameParslet({\n    allowedAdditionalTokens: baseNameTokens\n  }),\n  createNamePathParslet({\n    allowSquareBracketsOnAnyType: false,\n    allowJsdocNamePaths: true,\n    pathGrammar\n  })\n]\n\nexport const closureNamePathSpecialGrammar = [\n  createSpecialNamePathParslet({\n    allowedTypes: ['module'],\n    pathGrammar\n  }),\n  ...closureNamePathGrammar\n]\n","import { composeParslet } from './Parslet.js'\nimport { Precedence } from '../Precedence.js'\nimport { UnexpectedTypeError } from '../errors.js'\nimport { assertRootResult } from '../assertTypes.js'\n\nexport const assertsParslet = composeParslet({\n  name: 'assertsParslet',\n  accept: type => type === 'asserts',\n  parsePrefix: (parser) => {\n    parser.consume('asserts')\n\n    const left = parser.parseIntermediateType(Precedence.SYMBOL)\n\n    if (left.type !== 'JsdocTypeName') {\n      throw new UnexpectedTypeError(left, 'A typescript asserts always has to have a name.')\n    }\n\n    if (!parser.consume('is')) {\n      return {\n        type: 'JsdocTypeAssertsPlain',\n        element: left\n      }\n    }\n\n    return {\n      type: 'JsdocTypeAsserts',\n      left,\n      right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))\n    }\n  }\n})\n","import { composeParslet } from './Parslet.js'\nimport type { TypeParameterResult, CallSignatureResult, ConstructorSignatureResult, MethodSignatureResult } from '../result/NonRootResult.js'\nimport type { NameResult } from '../result/RootResult.js'\nimport { Precedence } from '../Precedence.js'\nimport { UnexpectedTypeError } from '../errors.js'\n\n// (optional new or optionally quoted other optional name) +\n//    (...args) + \":\" + return value\nexport const functionPropertyParslet = composeParslet({\n  name: 'functionPropertyParslet',\n  accept: (type, next) =>\n    type === 'new' && (next ==='(' || next === '<') ||\n    type === 'Identifier' && (next === '(' || next === '<') ||\n    type === 'StringValue' && (next === '(' || next === '<') ||\n    type === '(' || type === '<',\n  parsePrefix: parser => {\n    let result: CallSignatureResult | ConstructorSignatureResult | MethodSignatureResult\n\n    // Just a placeholder\n    const returnType: NameResult = {\n      type: 'JsdocTypeName',\n      value: 'void'\n    }\n\n    const newKeyword = parser.consume('new')\n    if (newKeyword) {\n      result = {\n        type: 'JsdocTypeConstructorSignature',\n        parameters: [],\n        returnType\n      }\n    } else {\n      const text = parser.lexer.current.text\n      const identifier = parser.consume('Identifier')\n      if (identifier) {\n        result = {\n          type: 'JsdocTypeMethodSignature',\n          name: text,\n          meta: {\n            quote: undefined\n          },\n          parameters: [],\n          returnType\n        }\n      } else {\n        const text = parser.lexer.current.text\n        const stringValue = parser.consume('StringValue')\n        if (stringValue) {\n          result = {\n            type: 'JsdocTypeMethodSignature',\n            name: text.slice(1, -1),\n            meta: {\n              quote: text.startsWith('\"') ? 'double' : 'single'\n            },\n            parameters: [],\n            returnType\n          }\n        } else {\n          result = {\n            type: 'JsdocTypeCallSignature',\n            parameters: [],\n            returnType\n          }\n        }\n      }\n    }\n\n    const typeParameters: TypeParameterResult[] = []\n    if (parser.consume('<')) {\n      do {\n        let defaultValue = undefined\n        let name = parser.parseIntermediateType(Precedence.SYMBOL)\n        if (name.type === 'JsdocTypeOptional') {\n          name = name.element\n          defaultValue = parser.parseType(Precedence.SYMBOL)\n        }\n        if (name.type !== 'JsdocTypeName') {\n          throw new UnexpectedTypeError(name)\n        }\n        let constraint = undefined\n        if (parser.consume('extends')) {\n          constraint = parser.parseType(Precedence.SYMBOL)\n          // Got an equal sign\n          if (constraint.type === 'JsdocTypeOptional') {\n            constraint = constraint.element\n            defaultValue = parser.parseType(Precedence.SYMBOL)\n          }\n        }\n\n        const typeParameter: TypeParameterResult = {\n          type: 'JsdocTypeTypeParameter',\n          name\n        }\n\n        if (constraint !== undefined) {\n          typeParameter.constraint = constraint\n        }\n\n        if (defaultValue !== undefined) {\n          typeParameter.defaultValue = defaultValue\n        }\n\n        typeParameters.push(typeParameter)\n\n        if (parser.consume('>')) {\n          break\n        }\n      } while (parser.consume(','))\n\n      result.typeParameters = typeParameters\n    }\n\n    const hasParenthesis = parser.lexer.current.type === '('\n\n    /* c8 ignore next 3 -- Unreachable */\n    if (!hasParenthesis) {\n      throw new Error('function property is missing parameter list')\n    }\n\n    return result\n  }\n})\n","import { assertPlainKeyValueResult, assertRootResult } from '../assertTypes.js'\nimport { composeParslet, type ParsletFunction } from './Parslet.js'\nimport { Precedence } from '../Precedence.js'\nimport type { TupleResult } from '../result/RootResult.js'\nimport type { IntermediateResult } from '../result/IntermediateResult.js'\n\nexport function createTupleParslet ({ allowQuestionMark }: {\n  allowQuestionMark: boolean\n}): ParsletFunction {\n  return composeParslet({\n    name: 'tupleParslet',\n    accept: type => type === '[',\n    parsePrefix: parser => {\n      parser.consume('[')\n      const result: TupleResult = {\n        type: 'JsdocTypeTuple',\n        elements: []\n      }\n\n      if (parser.consume(']')) {\n        return result\n      }\n\n      const typeList = parser.parseIntermediateType(Precedence.ALL)\n      if (typeList.type === 'JsdocTypeParameterList') {\n        if (typeList.elements[0].type === 'JsdocTypeKeyValue') {\n          result.elements = typeList.elements.map(assertPlainKeyValueResult)\n        } else {\n          result.elements = typeList.elements.map(assertRootResult)\n        }\n      } else {\n        if (typeList.type === 'JsdocTypeKeyValue') {\n          result.elements = [assertPlainKeyValueResult(typeList)]\n        } else {\n          result.elements = [assertRootResult(typeList)]\n        }\n      }\n\n      if (!parser.consume(']')) {\n        throw new Error('Unterminated \\'[\\'')\n      }\n\n      if (!allowQuestionMark && result.elements.some((e: IntermediateResult) => e.type === 'JsdocTypeUnknown')) {\n        throw new Error('Question mark in tuple not allowed')\n      }\n\n      return result\n    }\n  })\n}\n","import { composeParslet } from './Parslet.js'\nimport { Precedence } from '../Precedence.js'\nimport { assertRootResult } from '../assertTypes.js'\n\nexport const keyOfParslet = composeParslet({\n  name: 'keyOfParslet',\n  accept: type => type === 'keyof',\n  parsePrefix: parser => {\n    parser.consume('keyof')\n    return {\n      type: 'JsdocTypeKeyof',\n      element: assertRootResult(parser.parseType(Precedence.KEY_OF_TYPE_OF))\n    }\n  }\n})\n","import { composeParslet } from './Parslet.js'\nimport { Precedence } from '../Precedence.js'\n\nexport const importParslet = composeParslet({\n  name: 'importParslet',\n  accept: type => type === 'import',\n  parsePrefix: parser => {\n    parser.consume('import')\n    if (!parser.consume('(')) {\n      throw new Error('Missing parenthesis after import keyword')\n    }\n    const path = parser.parseType(Precedence.PREFIX)\n    if (path.type !== 'JsdocTypeStringValue') {\n      throw new Error('Only string values are allowed as paths for imports')\n    }\n    if (!parser.consume(')')) {\n      throw new Error('Missing closing parenthesis after import keyword')\n    }\n    return {\n      type: 'JsdocTypeImport',\n      element: path\n    }\n  }\n})\n","import { composeParslet } from './Parslet.js'\nimport { Precedence } from '../Precedence.js'\n\nexport const readonlyPropertyParslet = composeParslet({\n  name: 'readonlyPropertyParslet',\n  accept: (type, next) => type === 'readonly' && next !== ':',\n  parsePrefix: parser => {\n    parser.consume('readonly')\n    return {\n      type: 'JsdocTypeReadonlyProperty',\n      element: parser.parseIntermediateType(Precedence.KEY_VALUE)\n    }\n  }\n})\n","import { composeParslet } from './Parslet.js'\nimport { Precedence } from '../Precedence.js'\nimport { assertPlainKeyValueOrNameResult } from '../assertTypes.js'\nimport { getParameters } from './FunctionParslet.js'\n\nexport const arrowFunctionParslet = composeParslet({\n  name: 'arrowFunctionParslet',\n  precedence: Precedence.ARROW,\n  accept: type => type === '=>',\n  parseInfix: (parser, left) => {\n    parser.consume('=>')\n    return {\n      type: 'JsdocTypeFunction',\n      parameters: getParameters(left).map(assertPlainKeyValueOrNameResult),\n      arrow: true,\n      constructor: false,\n      parenthesis: true,\n      returnType: parser.parseType(Precedence.OBJECT)\n    }\n  }\n})\n","import { composeParslet } from './Parslet.js'\nimport { Precedence } from '../Precedence.js'\nimport { UnexpectedTypeError } from '../errors.js'\nimport type { FunctionResult } from '../result/RootResult.js'\nimport type { TypeParameterResult } from '../result/NonRootResult.js'\n\nexport const genericArrowFunctionParslet = composeParslet({\n  name: 'genericArrowFunctionParslet',\n  accept: type => type === '<',\n  parsePrefix: (parser) => {\n    const typeParameters: TypeParameterResult[] = []\n    parser.consume('<')\n\n    do {\n      let defaultValue = undefined\n      let name = parser.parseIntermediateType(Precedence.SYMBOL)\n      if (name.type === 'JsdocTypeOptional') {\n        name = name.element\n        defaultValue = parser.parseType(Precedence.SYMBOL)\n      }\n      if (name.type !== 'JsdocTypeName') {\n        throw new UnexpectedTypeError(name)\n      }\n      let constraint = undefined\n      if (parser.consume('extends')) {\n        constraint = parser.parseType(Precedence.SYMBOL)\n        // Got an equal sign\n        if (constraint.type === 'JsdocTypeOptional') {\n          constraint = constraint.element\n          defaultValue = parser.parseType(Precedence.SYMBOL)\n        }\n      }\n\n      const typeParameter: TypeParameterResult = {\n        type: 'JsdocTypeTypeParameter',\n        name\n      }\n\n      if (constraint !== undefined) {\n        typeParameter.constraint = constraint\n      }\n\n      if (defaultValue !== undefined) {\n        typeParameter.defaultValue = defaultValue\n      }\n\n      typeParameters.push(typeParameter)\n\n      if (parser.consume('>')) {\n        break\n      }\n    } while (parser.consume(','))\n\n    const functionBase = parser.parseIntermediateType(Precedence.SYMBOL) as FunctionResult\n    functionBase.typeParameters = typeParameters\n\n    return functionBase\n  }\n})\n","import { composeParslet } from './Parslet.js'\nimport { Precedence } from '../Precedence.js'\nimport { assertRootResult, assertResultIsNotReservedWord } from '../assertTypes.js'\n\nexport const intersectionParslet = composeParslet({\n  name: 'intersectionParslet',\n  accept: type => type === '&',\n  precedence: Precedence.INTERSECTION,\n  parseInfix: (parser, left) => {\n    parser.consume('&')\n\n    const elements = []\n    do {\n      elements.push(parser.parseType(Precedence.INTERSECTION))\n    } while (parser.consume('&'))\n\n    return {\n      type: 'JsdocTypeIntersection',\n      elements: [\n        assertResultIsNotReservedWord(parser, assertRootResult(left)),\n        ...elements.map((element) => assertResultIsNotReservedWord(parser, element))\n      ]\n    }\n  }\n})\n","import { composeParslet } from './Parslet.js'\nimport { Precedence } from '../Precedence.js'\nimport { UnexpectedTypeError } from '../errors.js'\nimport { assertRootResult } from '../assertTypes.js'\n\nexport const predicateParslet = composeParslet({\n  name: 'predicateParslet',\n  precedence: Precedence.INFIX,\n  accept: type => type === 'is',\n  parseInfix: (parser, left) => {\n    if (left.type !== 'JsdocTypeName') {\n      throw new UnexpectedTypeError(left, 'A typescript predicate always has to have a name on the left side.')\n    }\n\n    parser.consume('is')\n\n    return {\n      type: 'JsdocTypePredicate',\n      left,\n      right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))\n    }\n  }\n})\n","import type { Token } from './Token.js'\nimport type { Rule } from './LexerRules.js'\n\nconst breakingWhitespaceRegex = /^\\s*\\n\\s*/\n\nexport class Lexer {\n  private readonly text: string = ''\n  public readonly lexerRules: Rule[]\n  public readonly current: Token\n  public readonly next: Token\n  public readonly previous: Token | undefined\n\n  public static create (lexerRules: Rule[], text: string): Lexer {\n    const current = this.read(lexerRules, text)\n    text = current.text\n    const next = this.read(lexerRules, text)\n    text = next.text\n    return new Lexer(lexerRules, text, undefined, current.token, next.token)\n  }\n\n  private constructor (lexerRules: Rule[], text: string, previous: Token | undefined, current: Token, next: Token) {\n    this.lexerRules = lexerRules\n    this.text = text\n    this.previous = previous\n    this.current = current\n    this.next = next\n  }\n\n  private static read (lexerRules: Rule[], text: string, startOfLine = false): { text: string, token: Token } {\n    startOfLine ||= breakingWhitespaceRegex.test(text)\n    text = text.trim()\n    for (const rule of lexerRules) {\n      const partial = rule(text)\n      if (partial !== null) {\n        const token = {\n          ...partial,\n          startOfLine\n        }\n        text = text.slice(token.text.length)\n        return { text, token }\n      }\n    }\n    throw new Error('Unexpected Token ' + text)\n  }\n\n  remaining (): string {\n    return this.next.text + this.text\n  }\n\n  advance (): Lexer {\n    const next = Lexer.read(this.lexerRules, this.text)\n    return new Lexer(\n      this.lexerRules, next.text, this.current, this.next, next.token\n    )\n  }\n}\n","import { composeParslet } from './Parslet.js'\nimport { Parser } from '../Parser.js'\nimport type { TypeParameterResult, ObjectFieldResult, ComputedPropertyResult, ComputedMethodResult } from '../result/NonRootResult.js'\nimport { Precedence } from '../Precedence.js'\nimport { createKeyValueParslet } from '../parslets/KeyValueParslet.js'\nimport type { RootResult } from '../result/RootResult.js'\nimport { getParameters } from './FunctionParslet.js'\nimport { Lexer } from '../lexer/Lexer.js'\nimport { UnexpectedTypeError } from '../errors.js'\n\nexport const objectSquaredPropertyParslet = composeParslet({\n  name: 'objectSquarePropertyParslet',\n  accept: type => type === '[',\n  parsePrefix: parser => {\n    if (parser.baseParser === undefined) {\n      throw new Error('Only allowed inside object grammar')\n    }\n    parser.consume('[')\n\n    let innerBracketType;\n\n    if (parser.externalParsers?.computedPropertyParser === undefined) {\n      try {\n        innerBracketType = parser.parseIntermediateType(Precedence.OBJECT)\n      } catch (err) {\n        throw new Error('Error parsing value inside square bracketed property.', {\n          cause: err\n        })\n      }\n    }\n\n    let result: ObjectFieldResult\n\n    if (\n      innerBracketType !== undefined &&\n      // Looks like an object field because of `key: value`, but is\n      //  shaping to be an index signature\n      innerBracketType.type === 'JsdocTypeObjectField' &&\n      typeof innerBracketType.key === 'string' &&\n      !innerBracketType.optional &&\n      !innerBracketType.readonly &&\n      innerBracketType.right !== undefined\n    ) {\n      const key = innerBracketType.key\n\n      if (!parser.consume(']')) {\n        throw new Error('Unterminated square brackets')\n      }\n\n      if (!parser.consume(':')) {\n        throw new Error('Incomplete index signature')\n      }\n\n      const parentParser = parser.baseParser\n      parentParser.acceptLexerState(parser)\n\n      innerBracketType.key = {\n        type: 'JsdocTypeIndexSignature',\n        key,\n        right: innerBracketType.right\n      }\n      innerBracketType.optional = false\n      innerBracketType.meta.quote = undefined\n\n      result = innerBracketType\n\n      const right = parentParser.parseType(Precedence.INDEX_BRACKETS)\n      result.right = right\n\n      parser.acceptLexerState(parentParser)\n    } else if (\n      innerBracketType !== undefined &&\n      // Looks like a name, but is shaping to be a mapped type clause\n      innerBracketType.type === 'JsdocTypeName' &&\n      parser.consume('in')\n    ) {\n      const parentParser = parser.baseParser\n      parentParser.acceptLexerState(parser)\n\n      const mappedTypeRight = parentParser.parseType(Precedence.ARRAY_BRACKETS)\n\n      if (!parentParser.consume(']')) {\n        throw new Error('Unterminated square brackets')\n      }\n\n      const optional = parentParser.consume('?')\n\n      if (!parentParser.consume(':')) {\n        throw new Error('Incomplete mapped type clause: missing colon')\n      }\n\n      const right = parentParser.parseType(Precedence.INDEX_BRACKETS)\n      result = {\n        type: 'JsdocTypeObjectField',\n        optional,\n        readonly: false,\n        meta: {\n          quote: undefined\n        },\n        key: {\n          type: 'JsdocTypeMappedType',\n          key: innerBracketType.value,\n          right: mappedTypeRight\n        },\n        right\n      }\n\n      parser.acceptLexerState(parentParser)\n    } else {\n      if (parser.externalParsers?.computedPropertyParser !== undefined) {\n        let remaining = parser.lexer.current.text + parser.lexer.remaining()\n        let checkingText = remaining\n        while (checkingText !== '') {\n          try {\n            innerBracketType = parser.externalParsers.computedPropertyParser(\n              checkingText\n            )\n            break\n          } catch (err) {}\n          checkingText = checkingText.slice(0, -1)\n        }\n        remaining = remaining.slice(checkingText.length);\n\n        const remainingTextParser = new Parser(\n          parser.grammar,\n          Lexer.create(parser.lexer.lexerRules, remaining),\n          parser.baseParser,\n          {\n            externalParsers: {\n              computedPropertyParser: parser.externalParsers.computedPropertyParser\n            }\n          }\n        )\n        parser.acceptLexerState(remainingTextParser)\n      }\n\n      if (!parser.consume(']')) {\n        throw new Error('Unterminated square brackets')\n      }\n\n      let optional = parser.consume('?')\n\n      const typeParameters: TypeParameterResult[] = []\n      if (parser.consume('<')) {\n        do {\n          let defaultValue = undefined\n          let name = parser.parseIntermediateType(Precedence.SYMBOL)\n          if (name.type === 'JsdocTypeOptional') {\n            name = name.element\n            defaultValue = parser.parseType(Precedence.SYMBOL)\n          }\n          if (name.type !== 'JsdocTypeName') {\n            throw new UnexpectedTypeError(name)\n          }\n          let constraint = undefined\n          if (parser.consume('extends')) {\n            constraint = parser.parseType(Precedence.SYMBOL)\n            // Got an equal sign\n            if (constraint.type === 'JsdocTypeOptional') {\n              constraint = constraint.element\n              defaultValue = parser.parseType(Precedence.SYMBOL)\n            }\n          }\n\n          const typeParameter: TypeParameterResult = {\n            type: 'JsdocTypeTypeParameter',\n            name\n          }\n\n          if (constraint !== undefined) {\n            typeParameter.constraint = constraint\n          }\n\n          if (defaultValue !== undefined) {\n            typeParameter.defaultValue = defaultValue\n          }\n\n          typeParameters.push(typeParameter)\n\n          if (parser.consume('>')) {\n            break\n          }\n        } while (parser.consume(','))\n      }\n\n      let type: \"JsdocTypeComputedMethod\"|\"JsdocTypeComputedProperty\";\n\n      let key: ComputedPropertyResult|ComputedMethodResult\n\n      const checkMiddle = (): void => {\n        // Safe if set above\n\n        // eslint-disable-next-line logical-assignment-operators -- Keep for comment\n        if (!optional) {\n          optional = parser.consume('?')\n          // How can we grab this?\n          // if (optional && type === 'JsdocTypeComputedMethod') {\n          //   throw new Error('Computed methods may not be optional')\n          // }\n        }\n      }\n\n      // Limit this to JsdocTypeName and JsdocTypeStringValue?\n      let right\n\n      const text = parser.lexer.current.type\n      if (text === '(') {\n        const signatureParser = new Parser(\n          [\n            createKeyValueParslet({\n              allowVariadic: true,\n              allowOptional: true,\n              acceptParameterList: true,\n            }),\n            ...parser.baseParser.grammar.flatMap((grammar) => {\n              // We're supplying our own version\n              if (grammar.name === 'keyValueParslet') {\n                return []\n              }\n              return [grammar]\n            })\n          ],\n          parser.lexer,\n          parser\n        )\n\n        signatureParser.acceptLexerState(parser)\n        const params = signatureParser.parseIntermediateType(Precedence.OBJECT)\n        parser.acceptLexerState(signatureParser)\n\n        const parameters = getParameters(params)\n\n        type = 'JsdocTypeComputedMethod'\n\n        checkMiddle()\n        parser.consume(':')\n        const nextValue = parser.parseType(Precedence.INDEX_BRACKETS)\n\n        key = {\n          type,\n          optional,\n          value: innerBracketType as RootResult,\n          parameters,\n          returnType: nextValue\n        }\n\n        if (typeParameters.length > 0) {\n          key.typeParameters = typeParameters\n        }\n      } else {\n        type = 'JsdocTypeComputedProperty'\n        checkMiddle()\n        if (!parser.consume(':')) {\n          throw new Error('Incomplete computed property: missing colon')\n        }\n\n        right = parser.parseType(Precedence.INDEX_BRACKETS)\n        key = {\n          type,\n          value: innerBracketType as RootResult,\n        }\n      }\n\n      result = {\n        type: 'JsdocTypeObjectField',\n        optional: type === 'JsdocTypeComputedMethod' ? false : optional,\n        readonly: false,\n        meta: {\n          quote: undefined\n        },\n        key,\n        right\n      }\n    }\n\n    return result\n  }\n})\n","import { composeParslet } from './Parslet.js'\nimport { Precedence } from '../Precedence.js'\nimport { assertArrayOrTupleResult } from '../assertTypes.js'\n\nexport const readonlyArrayParslet = composeParslet({\n  name: 'readonlyArrayParslet',\n  accept: type => type === 'readonly',\n  parsePrefix: parser => {\n    parser.consume('readonly')\n    return {\n      type: 'JsdocTypeReadonlyArray',\n      element: assertArrayOrTupleResult(parser.parseIntermediateType(Precedence.ALL))\n    }\n  }\n})\n","import { composeParslet } from './Parslet.js'\nimport { Precedence } from '../Precedence.js'\n// import { UnexpectedTypeError } from '../errors.js'\nimport { assertRootResult } from '../assertTypes.js'\nimport type { RootResult, NullableResult } from '../result/RootResult.js'\n\nexport const conditionalParslet = composeParslet({\n  name: 'conditionalParslet',\n  precedence: Precedence.INFIX,\n  accept: type => type === 'extends',\n  parseInfix: (parser, left) => {\n    parser.consume('extends')\n\n    const extendsType = (\n      parser.parseType(Precedence.KEY_OF_TYPE_OF\n      ) as NullableResult<RootResult>).element\n\n    // parser.consume('?')\n\n    const trueType = parser.parseType(Precedence.INFIX)\n\n    parser.consume(':')\n\n    return {\n      type: 'JsdocTypeConditional',\n      checksType: assertRootResult(left),\n      extendsType,\n      trueType,\n      falseType: parser.parseType(Precedence.INFIX)\n    }\n  }\n})\n","import type { Token, TokenType } from './Token.js'\n\ntype PartialToken = Omit<Token, 'startOfLine'>\n\nexport type Rule = (text: string) => PartialToken | null\n\nfunction makePunctuationRule (type: TokenType): Rule {\n  return text => {\n    if (text.startsWith(type)) {\n      return { type, text: type }\n    } else {\n      return null\n    }\n  }\n}\n\nfunction getQuoted (text: string): string | null {\n  let position = 0\n  let char = undefined\n  const mark = text[0]\n  let escaped = false\n\n  if (mark !== '\\'' && mark !== '\"') {\n    return null\n  }\n\n  while (position < text.length) {\n    position++\n    char = text[position]\n    if (!escaped && char === mark) {\n      position++\n      break\n    }\n    escaped = !escaped && char === '\\\\'\n  }\n\n  if (char !== mark) {\n    throw new Error('Unterminated String')\n  }\n\n  return text.slice(0, position)\n}\n\n/**\n * Gets a full template literal (enclosed in backticks)\n */\nfunction getTemplateLiteral (text: string): string | null {\n  let position = 0\n  let char = undefined\n  const mark = text[0]\n  let escaped = false\n\n  if (mark !== '`') {\n    return null\n  }\n\n  while (position < text.length) {\n    position++\n    char = text[position]\n    if (!escaped && char === mark) {\n      position++\n      break\n    }\n    escaped = !escaped && char === '\\\\'\n  }\n\n  if (char !== mark) {\n    throw new Error('Unterminated template literal')\n  }\n\n  return text.slice(0, position)\n}\n\n/**\n * Gets the next literal (non-interpolation) portion of a text\n */\nexport function getTemplateLiteralLiteral (text: string): string | null {\n  let position = 0\n  let char = undefined\n  const start = text[0]\n  let escaped = false\n\n  if (start === '`' || (start === '$' && text[1] === '{')) {\n    return null\n  }\n\n  while (position < text.length) {\n    position++\n    char = text[position]\n    if (!escaped && (char === '`' || (char === '$' && text[position + 1] === '{'))) {\n      break\n    }\n    escaped = !escaped && char === '\\\\'\n  }\n\n  return text.slice(0, position)\n}\n\nconst identifierStartRegex = /[$_\\p{ID_Start}]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}/u\nconst identifierContinueRegex = /[$\\p{ID_Continue}\\u200C\\u200D]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}/u\nconst identifierContinueRegexLoose = /[$\\-\\p{ID_Continue}\\u200C\\u200D]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}/u\n\nfunction makeGetIdentifier (\n  identifierContinueRegex: RegExp\n) {\n  return function (text: string): string | null {\n    let char = text[0]\n    if (!identifierStartRegex.test(char)) {\n      return null\n    }\n    let position = 1\n    do {\n      char = text[position]\n      if (!identifierContinueRegex.test(char)) {\n        break\n      }\n      position++\n    } while (position < text.length)\n    return text.slice(0, position)\n  }\n}\n\nconst numberRegex = /^(-?((\\d*\\.\\d+|\\d+)([Ee][+-]?\\d+)?))/\nconst looseNumberRegex = /^(NaN|-?((\\d*\\.\\d+|\\d+)([Ee][+-]?\\d+)?|Infinity))/\n\nfunction getGetNumber (numberRegex: RegExp) {\n  return function getNumber (text: string): string | null {\n    return numberRegex.exec(text)?.[0] ?? null\n  }\n}\n\nconst looseIdentifierRule: Rule = text => {\n  const value = makeGetIdentifier(identifierContinueRegexLoose)(text)\n  if (value == null) {\n    return null\n  }\n\n  return {\n    type: 'Identifier',\n    text: value\n  }\n}\n\nconst identifierRule: Rule = text => {\n  const value = makeGetIdentifier(identifierContinueRegex)(text)\n  if (value == null) {\n    return null\n  }\n\n  return {\n    type: 'Identifier',\n    text: value\n  }\n}\n\nfunction makeKeyWordRule (type: TokenType): Rule {\n  return text => {\n    if (!text.startsWith(type)) {\n      return null\n    }\n    const prepends = text[type.length]\n    if (prepends !== undefined && identifierContinueRegex.test(prepends)) {\n      return null\n    }\n    return {\n      type,\n      text: type\n    }\n  }\n}\n\nconst stringValueRule: Rule = text => {\n  const value = getQuoted(text)\n  if (value == null) {\n    return null\n  }\n  return {\n    type: 'StringValue',\n    text: value\n  }\n}\n\nconst templateLiteralRule: Rule = text => {\n  const value = getTemplateLiteral(text)\n  if (value == null) {\n    return null\n  }\n  return {\n    type: 'TemplateLiteral',\n    text: value\n  }\n}\n\nconst eofRule: Rule = text => {\n  if (text.length > 0) {\n    return null\n  }\n  return {\n    type: 'EOF',\n    text: ''\n  }\n}\n\nconst numberRule: Rule = text => {\n  const value = getGetNumber(numberRegex)(text)\n  if (value === null) {\n    return null\n  }\n  return {\n    type: 'Number',\n    text: value\n  }\n}\n\nconst looseNumberRule: Rule = text => {\n  const value = getGetNumber(looseNumberRegex)(text)\n  if (value === null) {\n    return null\n  }\n  return {\n    type: 'Number',\n    text: value\n  }\n}\n\n/**\n * Will be processed highest precedence first\n */\nexport const rules: Rule[] = [\n  eofRule,\n  makePunctuationRule('=>'),\n  makePunctuationRule('('),\n  makePunctuationRule(')'),\n  makePunctuationRule('{'),\n  makePunctuationRule('}'),\n  makePunctuationRule('['),\n  makePunctuationRule(']'),\n  makePunctuationRule('|'),\n  makePunctuationRule('&'),\n  makePunctuationRule('<'),\n  makePunctuationRule('>'),\n  makePunctuationRule(','),\n  makePunctuationRule(';'),\n  makePunctuationRule('*'),\n  makePunctuationRule('?'),\n  makePunctuationRule('!'),\n  makePunctuationRule('='),\n  makePunctuationRule(':'),\n  makePunctuationRule('...'),\n  makePunctuationRule('.'),\n  makePunctuationRule('#'),\n  makePunctuationRule('~'),\n  makePunctuationRule('/'),\n  makePunctuationRule('@'),\n  makeKeyWordRule('undefined'),\n  makeKeyWordRule('null'),\n  makeKeyWordRule('function'),\n  makeKeyWordRule('this'),\n  makeKeyWordRule('new'),\n  makeKeyWordRule('module'),\n  makeKeyWordRule('event'),\n  makeKeyWordRule('extends'),\n  makeKeyWordRule('external'),\n  makeKeyWordRule('infer'),\n  makeKeyWordRule('typeof'),\n  makeKeyWordRule('keyof'),\n  makeKeyWordRule('readonly'),\n  makeKeyWordRule('import'),\n  makeKeyWordRule('is'),\n  makeKeyWordRule('in'),\n  makeKeyWordRule('asserts'),\n  numberRule,\n  identifierRule,\n  stringValueRule,\n  templateLiteralRule\n]\n\nexport const looseRules: Rule[] = rules.toSpliced(\n  -4, 2, looseNumberRule, looseIdentifierRule\n)\n","import { composeParslet } from './Parslet.js'\nimport type { RootResult } from '../result/RootResult.js'\nimport { Precedence } from '../Precedence.js'\nimport { getTemplateLiteralLiteral } from '../lexer/LexerRules.js'\nimport { Parser } from '../Parser.js'\nimport { Lexer } from '../lexer/Lexer.js'\n\nexport const templateLiteralParslet = composeParslet({\n  name: 'templateLiteralParslet',\n  accept: type => type === 'TemplateLiteral',\n  parsePrefix: parser => {\n    const text = parser.lexer.current.text\n    parser.consume('TemplateLiteral')\n\n    const literals: string[] = []\n    const interpolations = [] as RootResult[]\n\n    let currentText = text.slice(1, -1)\n\n    const advanceLiteral = (): void => {\n      const literal = getTemplateLiteralLiteral(currentText) ?? ''\n\n      // We collect backslashes for total length, but need to replace\n      literals.push(literal.replace(/\\\\`/g, '`'))\n\n      currentText = currentText.slice(literal.length)\n    }\n\n    // The first can be the empty string (at least one literal\n    //   should be populated)\n    advanceLiteral()\n\n    while (true) {\n      if (currentText.startsWith('${')) {\n        currentText = currentText.slice(2)\n\n        let templateParser\n        let interpolationType\n\n        let snipped = currentText\n        let remnant = ''\n        while (true) {\n          // Some tokens (like hyphen) may not be recognized by the parser,\n          //   so we avoid processing them (may be part of a literal)\n          try {\n            templateParser = new Parser(\n              parser.grammar,\n              Lexer.create(parser.lexer.lexerRules, snipped)\n            )\n            interpolationType = templateParser.parseType(Precedence.ALL)\n            break\n          } catch (err) {\n            remnant = snipped.slice(-1) + remnant\n            snipped = snipped.slice(0, -1)\n          }\n        }\n\n        interpolations.push(interpolationType)\n\n        if (templateParser.lexer.current.text !== '}') {\n          throw new Error('unterminated interpolation')\n        }\n\n        currentText = templateParser.lexer.remaining() + remnant\n      } else { // currentText.startsWith('`')\n        break;\n      }\n\n      // May also be empty string if seeing `}${` or just a final `}`\n      advanceLiteral()\n    }\n\n    return {\n      type: 'JsdocTypeTemplateLiteral',\n      literals,\n      interpolations\n    }\n  }\n})\n","import { assertsParslet } from '../parslets/assertsParslet.js'\nimport { baseGrammar } from './baseGrammar.js'\nimport type { Grammar } from './Grammar.js'\nimport { pathGrammar } from './pathGrammar.js'\nimport { createNameParslet } from '../parslets/NameParslet.js'\nimport { nullableParslet } from '../parslets/NullableParslets.js'\nimport { optionalParslet } from '../parslets/OptionalParslet.js'\nimport { stringValueParslet } from '../parslets/StringValueParslet.js'\nimport { numberParslet } from '../parslets/NumberParslet.js'\nimport { createFunctionParslet } from '../parslets/FunctionParslet.js'\nimport { createObjectParslet } from '../parslets/ObjectParslet.js'\nimport { functionPropertyParslet } from '../parslets/FunctionPropertyParslet.js'\nimport { createTupleParslet } from '../parslets/TupleParslet.js'\nimport { createVariadicParslet } from '../parslets/VariadicParslet.js'\nimport { typeOfParslet } from '../parslets/TypeOfParslet.js'\nimport { keyOfParslet } from '../parslets/KeyOfParslet.js'\nimport { importParslet } from '../parslets/ImportParslet.js'\nimport { createSpecialNamePathParslet } from '../parslets/SpecialNamePathParslet.js'\nimport { readonlyPropertyParslet } from '../parslets/ReadonlyPropertyParslet.js'\nimport { arrayBracketsParslet } from '../parslets/ArrayBracketsParslet.js'\nimport { arrowFunctionParslet } from '../parslets/ArrowFunctionParslet.js'\nimport { genericArrowFunctionParslet } from '../parslets/GenericArrowFunctionParslet.js'\nimport { createNamePathParslet } from '../parslets/NamePathParslet.js'\nimport { intersectionParslet } from '../parslets/IntersectionParslet.js'\nimport { predicateParslet } from '../parslets/predicateParslet.js'\nimport { createObjectFieldParslet } from '../parslets/ObjectFieldParslet.js'\nimport { createKeyValueParslet } from '../parslets/KeyValueParslet.js'\nimport { objectSquaredPropertyParslet } from '../parslets/ObjectSquaredPropertyParslet.js'\nimport { readonlyArrayParslet } from '../parslets/ReadonlyArrayParslet.js'\nimport { conditionalParslet } from '../parslets/ConditionalParslet.js'\nimport { templateLiteralParslet } from '../parslets/TemplateLiteralParslet.js'\nimport { genericParslet } from '../parslets/GenericParslet.js'\nimport { baseNameTokens } from '../lexer/Token.js'\n\nconst objectFieldGrammar: Grammar = [\n  functionPropertyParslet,\n  readonlyPropertyParslet,\n  createNameParslet({\n    allowedAdditionalTokens: baseNameTokens\n  }),\n  nullableParslet,\n  optionalParslet,\n  stringValueParslet,\n  numberParslet,\n  createObjectFieldParslet({\n    allowSquaredProperties: true,\n    allowKeyTypes: false,\n    allowOptional: true,\n    allowReadonly: true\n  }),\n  objectSquaredPropertyParslet\n]\n\nexport const typescriptGrammar: Grammar = [\n  ...baseGrammar,\n  createObjectParslet({\n    allowKeyTypes: false,\n    objectFieldGrammar,\n    signatureGrammar: [\n      createKeyValueParslet({\n        allowVariadic: true,\n        allowOptional: true,\n        acceptParameterList: true,\n      })\n    ]\n  }),\n  readonlyArrayParslet,\n  typeOfParslet,\n  keyOfParslet,\n  importParslet,\n  stringValueParslet,\n  createFunctionParslet({\n    allowWithoutParenthesis: true,\n    allowNoReturnType: true,\n    allowNamedParameters: ['this', 'new', 'args'],\n    allowNewAsFunctionKeyword: true\n  }),\n  createTupleParslet({\n    allowQuestionMark: false\n  }),\n  createVariadicParslet({\n    allowEnclosingBrackets: false,\n    allowPostfix: false\n  }),\n  assertsParslet,\n  conditionalParslet,\n  createNameParslet({\n    allowedAdditionalTokens: ['event', 'external', 'in']\n  }),\n  createSpecialNamePathParslet({\n    allowedTypes: ['module'],\n    pathGrammar\n  }),\n  arrayBracketsParslet,\n  arrowFunctionParslet,\n  genericArrowFunctionParslet,\n  createNamePathParslet({\n    allowSquareBracketsOnAnyType: true,\n    allowJsdocNamePaths: false,\n    pathGrammar\n  }),\n  intersectionParslet,\n  predicateParslet,\n  templateLiteralParslet,\n  createKeyValueParslet({\n    allowVariadic: true,\n    allowOptional: true\n  })\n]\n\nexport const typescriptNameGrammar = [\n  genericParslet,\n  arrayBracketsParslet,\n  createNameParslet({\n    allowedAdditionalTokens: baseNameTokens\n  })\n]\n\nexport const typescriptNamePathGrammar = [\n  genericParslet,\n  arrayBracketsParslet,\n  createNameParslet({\n    allowedAdditionalTokens: baseNameTokens\n  }),\n  createNamePathParslet({\n    allowSquareBracketsOnAnyType: true,\n    // Here we actually want JSDoc name paths (even though TS\n    //   in JSDoc namepath positions interpret them differently\n    //   than JSDoc)\n    allowJsdocNamePaths: true,\n    pathGrammar\n  })\n]\n\nexport const typescriptNamePathSpecialGrammar = [\n  createSpecialNamePathParslet({\n    allowedTypes: ['module'],\n    pathGrammar\n  }),\n  ...typescriptNamePathGrammar\n]\n","import { Parser } from './Parser.js'\nimport {\n  jsdocGrammar, jsdocNamePathGrammar,\n  jsdocNamePathSpecialGrammar, jsdocNameGrammar\n} from './grammars/jsdocGrammar.js'\nimport {\n  closureGrammar, closureNamePathGrammar,\n  closureNamePathSpecialGrammar, closureNameGrammar\n} from './grammars/closureGrammar.js'\nimport {\n  typescriptGrammar, typescriptNamePathGrammar,\n  typescriptNamePathSpecialGrammar, typescriptNameGrammar\n} from './grammars/typescriptGrammar.js'\nimport { assertResultIsNotReservedWord } from './assertTypes.js'\nimport type { RootResult } from './result/RootResult.js'\nimport { Lexer } from './lexer/Lexer.js'\nimport { rules, looseRules } from './lexer/LexerRules.js'\n\nexport type ParseMode = 'closure' | 'jsdoc' | 'typescript'\n\n/**\n * This function parses the given expression in the given mode and produces a {@link RootResult}.\n * @param expression\n * @param mode\n */\nexport function parse (\n  expression: string, mode: ParseMode,\n  {\n    module = true,\n    strictMode = true,\n    asyncFunctionBody = true,\n    classContext = false,\n    computedPropertyParser\n  }: {\n    module?: boolean,\n    strictMode?: boolean,\n    asyncFunctionBody?: boolean,\n    classContext?: boolean,\n    computedPropertyParser?: (\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any -- Actual API\n      text: string, options?: any\n    ) => unknown\n  } = {}\n): RootResult {\n  let parser: Parser\n  switch (mode) {\n    case 'closure':\n      parser = new Parser(closureGrammar, Lexer.create(looseRules, expression), undefined, {\n        module,\n        strictMode,\n        asyncFunctionBody,\n        classContext\n      })\n      break\n    case 'jsdoc':\n      parser = new Parser(jsdocGrammar, Lexer.create(looseRules, expression), undefined, {\n        module,\n        strictMode,\n        asyncFunctionBody,\n        classContext\n      })\n      break\n    case 'typescript':\n      parser = new Parser(\n        typescriptGrammar,\n        Lexer.create(rules, expression),\n        undefined,\n        {\n          module,\n          strictMode,\n          asyncFunctionBody,\n          classContext,\n          externalParsers: {\n            computedPropertyParser\n          }\n        }\n      )\n      break\n  }\n\n  const result = parser.parse()\n\n  return assertResultIsNotReservedWord(parser, result)\n}\n\n/**\n * This function tries to parse the given expression in multiple modes and returns the first successful\n * {@link RootResult}. By default it tries `'typescript'`, `'closure'` and `'jsdoc'` in this order. If\n * no mode was successful it throws the error that was produced by the last parsing attempt.\n * @param expression\n * @param modes\n */\nexport function tryParse (\n  expression: string,\n  modes: ParseMode[] = ['typescript', 'closure', 'jsdoc'],\n  {\n    module = true,\n    strictMode = true,\n    asyncFunctionBody = true,\n    classContext = false,\n  }: {\n    module?: boolean,\n    strictMode?: boolean,\n    asyncFunctionBody?: boolean,\n    classContext?: boolean,\n  } = {}\n): RootResult {\n  let error\n  for (const mode of modes) {\n    try {\n      return parse(expression, mode, {\n        module,\n        strictMode,\n        asyncFunctionBody,\n        classContext\n      })\n    } catch (e) {\n      error = e\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/only-throw-error -- Ok\n  throw error\n}\n\n\n/**\n * This function parses the given expression in the given mode and produces a name path.\n * @param expression\n * @param mode\n */\nexport function parseNamePath (\n  expression: string, mode: ParseMode, {\n    includeSpecial = false\n  }: {\n    includeSpecial?: boolean\n  } = {}\n): RootResult {\n  switch (mode) {\n    case 'closure':\n      return (new Parser(\n        includeSpecial ? closureNamePathSpecialGrammar : closureNamePathGrammar,\n        Lexer.create(looseRules, expression)\n      )).parse()\n    case 'jsdoc':\n      return (new Parser(\n        includeSpecial ? jsdocNamePathSpecialGrammar : jsdocNamePathGrammar,\n        Lexer.create(looseRules, expression)\n      )).parse()\n    case 'typescript': {\n      return (new Parser(\n        includeSpecial ? typescriptNamePathSpecialGrammar : typescriptNamePathGrammar,\n        Lexer.create(rules, expression)\n      )).parse()\n    }\n  }\n}\n\n/**\n * This function parses the given expression in the given mode and produces a name.\n * @param expression\n * @param mode\n */\nexport function parseName (\n  expression: string, mode: ParseMode\n): RootResult {\n  switch (mode) {\n    case 'closure':\n      return (new Parser(closureNameGrammar, Lexer.create(looseRules, expression))).parse()\n    case 'jsdoc':\n      return (new Parser(jsdocNameGrammar, Lexer.create(looseRules, expression))).parse()\n    case 'typescript':\n      return (new Parser(\n        typescriptNameGrammar,\n        Lexer.create(rules, expression)\n      )).parse()\n  }\n}\n","import type { KeyValueResult, NonRootResult } from '../result/NonRootResult.js'\nimport type { FunctionResult, RootResult } from '../result/RootResult.js'\n\nexport type TransformFunction<TransformResult> = (parseResult: NonRootResult) => TransformResult\n\nexport type TransformRule<TransformResult, InputType extends NonRootResult> = (parseResult: InputType, transform: TransformFunction<TransformResult>) => TransformResult\n\nexport type TransformRules<TransformResult> = {\n  [P in NonRootResult as P['type']]: TransformRule<TransformResult, P>\n}\n\nexport function transform<TransformResult> (rules: TransformRules<TransformResult>, parseResult: NonRootResult): TransformResult {\n  const rule = rules[parseResult.type] as TransformRule<TransformResult, NonRootResult>\n  if (rule === undefined) {\n    throw new Error(`In this set of transform rules exists no rule for type ${parseResult.type}.`)\n  }\n\n  return rule(parseResult, aParseResult => transform(rules, aParseResult))\n}\n\nexport function notAvailableTransform<TransformResult> (parseResult: NonRootResult): TransformResult {\n  throw new Error('This transform is not available. Are you trying the correct parsing mode?')\n}\n\ninterface SpecialFunctionParams {\n  params: Array<RootResult | KeyValueResult>\n  this?: RootResult\n  new?: RootResult\n}\n\nexport function extractSpecialParams (source: FunctionResult): SpecialFunctionParams {\n  const result: SpecialFunctionParams = {\n    params: []\n  }\n\n  for (const param of source.parameters) {\n    if (param.type === 'JsdocTypeKeyValue') {\n      if (param.key === 'this') {\n        result.this = param.right\n      } else if (param.key === 'new') {\n        result.new = param.right\n      } else {\n        result.params.push(param)\n      }\n    } else {\n      result.params.push(param)\n    }\n  }\n\n  return result\n}\n","import { transform, type TransformRules } from './transform.js'\nimport type { NonRootResult } from '../result/NonRootResult.js'\nimport type { RootResult } from '../result/RootResult.js'\nimport type { Node } from 'estree'\n\nfunction applyPosition (position: 'prefix' | 'suffix', target: string, value: string): string {\n  return position === 'prefix' ? value + target : target + value\n}\n\nexport function quote (value: string, quote: 'single' | 'double' | undefined): string {\n  switch (quote) {\n    case 'double':\n      return `\"${value}\"`\n    case 'single':\n      return `'${value}'`\n    case undefined:\n      return value\n  }\n}\n\nexport function stringifyRules ({\n  computedPropertyStringifier\n}: {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any -- Ok\n  computedPropertyStringifier?: (node: Node, options?: any) => string\n} = {}): TransformRules<string> {\n  return {\n    JsdocTypeParenthesis: (result, transform) => `(${result.element !== undefined ? transform(result.element) : ''})`,\n\n    JsdocTypeKeyof: (result, transform) => `keyof ${transform(result.element)}`,\n\n    JsdocTypeFunction: (result, transform) => {\n      if (!result.arrow) {\n        let stringified = result.constructor ? 'new' : 'function'\n        if (!result.parenthesis) {\n          return stringified\n        }\n        stringified += `(${result.parameters.map(transform).join(',' + (result.meta?.parameterSpacing ?? ' '))})`\n        if (result.returnType !== undefined) {\n          stringified += `${result.meta?.preReturnMarkerSpacing ?? ''}:${result.meta?.postReturnMarkerSpacing ?? ' '}${transform(result.returnType)}`\n        }\n        return stringified\n      } else {\n        if (result.returnType === undefined) {\n          throw new Error('Arrow function needs a return type.')\n        }\n        let stringified = `${\n          result.typeParameters !== undefined\n            ? `<${result.typeParameters.map(transform).join(',' + (result.meta?.typeParameterSpacing ?? ' '))}>${\n          result.meta?.postGenericSpacing ?? ''\n        }`\n            : ''\n        }(${result.parameters.map(transform).join(',' + (result.meta?.parameterSpacing ?? ' '))})${\n          result.meta?.preReturnMarkerSpacing ?? ' '\n        }=>${result.meta?.postReturnMarkerSpacing ?? ' '}${transform(result.returnType)}`\n        if (result.constructor) {\n          stringified = 'new ' + stringified\n        }\n        return stringified\n      }\n    },\n\n    JsdocTypeName: result => result.value,\n\n    JsdocTypeTuple: (result, transform) => `[${(result.elements as NonRootResult[]).map(transform).join(',' + (result.meta?.elementSpacing ?? ' '))}]`,\n\n    JsdocTypeVariadic: (result, transform) => result.meta.position === undefined\n      ? '...'\n      : applyPosition(result.meta.position, transform(result.element as NonRootResult), '...'),\n\n    JsdocTypeNamePath: (result, transform) => {\n      const left = transform(result.left)\n      const right = transform(result.right)\n      switch (result.pathType) {\n        case 'inner':\n          return `${left}~${right}`\n        case 'instance':\n          return `${left}#${right}`\n        case 'property':\n          return `${left}.${right}`\n        case 'property-brackets':\n          return `${left}[${right}]`\n      }\n    },\n\n    JsdocTypeStringValue: result => quote(result.value, result.meta.quote),\n\n    JsdocTypeAny: () => '*',\n\n    JsdocTypeGeneric: (result, transform) => {\n      if (result.meta.brackets === 'square') {\n        const element = result.elements[0]\n        const transformed = transform(element)\n        if (element.type === 'JsdocTypeUnion' || element.type === 'JsdocTypeIntersection') {\n          return `(${transformed})[]`\n        } else {\n          return `${transformed}[]`\n        }\n      } else {\n        return `${transform(result.left)}${result.meta.dot ? '.' : ''}<${result.infer === true ? 'infer ' : ''}${result.elements.map(transform).join(',' + (result.meta.elementSpacing ?? ' '))}>`\n      }\n    },\n\n    JsdocTypeImport: (result, transform) => `import(${transform(result.element)})`,\n\n    JsdocTypeObjectField: (result, transform) => {\n      let text = ''\n      if (result.readonly) {\n        text += 'readonly '\n      }\n\n      let optionalBeforeParentheses = false\n\n      if (typeof result.key === 'string') {\n        text += quote(result.key, result.meta.quote)\n      } else {\n        if (result.key.type === 'JsdocTypeComputedMethod') {\n          optionalBeforeParentheses = true;\n        }\n        text += transform(result.key)\n      }\n\n      text += result.meta.postKeySpacing ?? ''\n\n      if (!optionalBeforeParentheses && result.optional) {\n        text += '?'\n        text += result.meta.postOptionalSpacing ?? ''\n      }\n\n      if (result.right === undefined) {\n        return text\n      } else {\n        return text + `:${result.meta.postColonSpacing ?? ' '}${transform(result.right)}`\n      }\n    },\n\n    JsdocTypeJsdocObjectField: (result, transform) => `${transform(result.left)}: ${transform(result.right)}`,\n\n    JsdocTypeKeyValue: (result, transform) => {\n      let text = result.key\n      if (result.optional) {\n        text += (result.meta?.postKeySpacing ?? '') + '?' + (result.meta?.postOptionalSpacing ?? '')\n      } else if (result.variadic) {\n        text = '...' + (result.meta?.postVariadicSpacing ?? '') + text\n      } else if (result.right !== undefined) {\n        text += (result.meta?.postKeySpacing ?? '')\n      }\n\n      if (result.right === undefined) {\n        return text\n      } else {\n        return text + `:${(result.meta?.postColonSpacing ?? ' ')}${transform(result.right)}`\n      }\n    },\n\n    JsdocTypeSpecialNamePath: result => `${result.specialType}:${quote(result.value, result.meta.quote)}`,\n\n    JsdocTypeNotNullable: (result, transform) => applyPosition(result.meta.position, transform(result.element), '!'),\n\n    JsdocTypeNull: () => 'null',\n\n    JsdocTypeNullable: (result, transform) => applyPosition(result.meta.position, transform(result.element), '?'),\n\n    JsdocTypeNumber: result => result.value.toString(),\n\n    JsdocTypeObject: (result, transform) => {\n      /* c8 ignore next -- Guard */\n      const lbType = (result.meta.separator ?? '').endsWith('linebreak')\n      const lbEnding = result.meta.separator === 'comma-and-linebreak'\n        ? ',\\n'\n        : result.meta.separator === 'semicolon-and-linebreak'\n          ? ';\\n'\n          : result.meta.separator === 'linebreak' ? '\\n' : ''\n\n      const separatorForSingleObjectField = result.meta.separatorForSingleObjectField ?? false\n      const trailingPunctuation = result.meta.trailingPunctuation ?? false\n\n      return `{${\n      /* c8 ignore next -- Guard */\n      (lbType && (separatorForSingleObjectField || result.elements.length > 1) ? '\\n' + (result.meta.propertyIndent ?? '') : '') +\n      result.elements.map(transform).join(\n        (result.meta.separator === 'comma' ? ', ' : lbType\n          ? lbEnding +\n            /* c8 ignore next -- Guard */\n            (result.meta.propertyIndent ?? '')\n          : '; ')\n      ) +\n      (separatorForSingleObjectField && result.elements.length === 1\n        ? (result.meta.separator === 'comma' ? ',' : lbType ? lbEnding : ';')\n        : trailingPunctuation && result.meta.separator !== undefined\n          ? result.meta.separator.startsWith('comma')\n            ? ','\n            : result.meta.separator.startsWith('semicolon')\n             ? ';'\n             : ''\n          : '') +\n      (lbType && result.elements.length > 1 ? '\\n' : '')\n    }}`\n    },\n\n    JsdocTypeOptional: (result, transform) => applyPosition(result.meta.position, transform(result.element), '='),\n\n    JsdocTypeSymbol: (result, transform) => `${result.value}(${result.element !== undefined ? transform(result.element) : ''})`,\n\n    JsdocTypeTypeof: (result, transform) => `typeof ${transform(result.element)}`,\n\n    JsdocTypeUndefined: () => 'undefined',\n\n    JsdocTypeUnion: (result, transform) => result.elements.map(transform).join(\n      result.meta?.spacing === undefined\n        ? ' | '\n        : `${result.meta.spacing}|${result.meta.spacing}`\n    ),\n\n    JsdocTypeUnknown: () => '?',\n\n    JsdocTypeIntersection: (result, transform) => result.elements.map(transform).join(' & '),\n\n    JsdocTypeProperty: result => quote(result.value, result.meta.quote),\n\n    JsdocTypePredicate: (result, transform) => `${transform(result.left)} is ${transform(result.right)}`,\n\n    JsdocTypeIndexSignature: (result, transform) => `[${result.key}: ${transform(result.right)}]`,\n\n    JsdocTypeMappedType: (result, transform) => `[${result.key} in ${transform(result.right)}]`,\n\n    JsdocTypeAsserts: (result, transform) => `asserts ${transform(result.left)} is ${transform(result.right)}`,\n\n    JsdocTypeReadonlyArray: (result, transform) => `readonly ${transform(result.element)}`,\n\n    JsdocTypeAssertsPlain: (result, transform) => `asserts ${transform(result.element)}`,\n\n    JsdocTypeConditional: (result, transform) => `${transform(result.checksType)} extends ${transform(result.extendsType)} ? ${transform(result.trueType)} : ${transform(result.falseType)}`,\n\n    JsdocTypeTypeParameter: (result, transform) => `${\n      transform(result.name)}${\n        result.constraint !== undefined ? ` extends ${transform(result.constraint)}` : ''\n      }${\n        result.defaultValue !== undefined ? `${\n           result.meta?.defaultValueSpacing ?? ' '\n        }=${\n           result.meta?.defaultValueSpacing ?? ' '\n        }${transform(result.defaultValue)}` : ''\n      }`,\n\n    JsdocTypeCallSignature: (result, transform) => `${\n      result.typeParameters !== undefined\n        ? `<${result.typeParameters.map(transform).join(',' + (result.meta?.typeParameterSpacing ?? ' '))}>${\n          result.meta?.postGenericSpacing ?? ''\n        }`\n        : ''\n    }(${\n      result.parameters.map(transform).join(',' + (result.meta?.parameterSpacing ?? ' '))\n    })${result.meta?.preReturnMarkerSpacing ?? ''}:${result.meta?.postReturnMarkerSpacing ?? ' '}${\n      transform(result.returnType)\n    }`,\n\n    JsdocTypeConstructorSignature: (result, transform) => `new${result.meta?.postNewSpacing ?? ' '}${\n      result.typeParameters !== undefined\n        ? `<${result.typeParameters.map(transform).join(',' + (result.meta?.typeParameterSpacing ?? ' '))}>${\n          result.meta?.postGenericSpacing ?? ''\n        }`\n        : ''\n    }(${\n      result.parameters.map(transform).join(',' + (result.meta?.parameterSpacing ?? ' '))\n    })${result.meta?.preReturnMarkerSpacing ?? ''}:${result.meta?.postReturnMarkerSpacing ?? ' '}${\n      transform(result.returnType)\n    }`,\n\n    JsdocTypeMethodSignature: (result, transform) => {\n      const quote = result.meta.quote === 'double'\n        ? '\"'\n        : result.meta.quote === 'single'\n          ? \"'\"\n          : '';\n\n      return `${quote}${result.name}${quote}${\n        result.meta.postMethodNameSpacing ?? ''\n      }${\n        result.typeParameters !== undefined\n          ? `<${result.typeParameters.map(transform).join(',' + (result.meta.typeParameterSpacing ?? ' '))}>${\n          result.meta.postGenericSpacing ?? ''\n        }`\n          : ''\n      }(${\n        result.parameters.map(transform).join(',' + (result.meta.parameterSpacing ?? ' '))\n      })${result.meta.preReturnMarkerSpacing ?? ''}:${result.meta.postReturnMarkerSpacing ?? ' '}${\n        transform(result.returnType)\n      }`\n    },\n\n    JsdocTypeIndexedAccessIndex: (result, transform) => (transform(result.right)),\n\n    JsdocTypeTemplateLiteral: (result, transform) => (`\\`${\n      // starts with a literal (even empty string) then alternating\n      //    interpolations and literals and also ending in literal\n      //    (even empty string)\n      result.literals.slice(0, -1).map(\n        (literal, idx) =>\n          literal.replace(/`/gu, '\\\\`') + '${' + transform(result.interpolations[idx]) + '}'\n      ).join('') + result.literals.slice(-1)[0].replace(/`/gu, '\\\\`')\n    }\\``),\n\n    JsdocTypeComputedProperty: (result, transform) => {\n      if (result.value.type.startsWith('JsdocType')) {\n        return `[${\n          transform(result.value as RootResult)\n        }]`\n      } else {\n        if (computedPropertyStringifier === undefined) {\n          throw new Error('Must have a computed property stringifier')\n        }\n        return `[${\n          computedPropertyStringifier(result.value as Node).replace(/;$/u, '')\n        }]`\n      }\n    },\n\n    JsdocTypeComputedMethod: (result, transform) => {\n      if (result.value.type.startsWith('JsdocType')) {\n        return `[${transform(result.value as RootResult)}]${\n          result.optional ? '?' : ''\n        }${\n          result.typeParameters !== undefined\n            ? `<${result.typeParameters.map(transform).join(',' + (result.meta?.typeParameterSpacing ?? ' '))}>${\n              result.meta?.postGenericSpacing ?? ''\n            }`\n            : ''\n        }(${\n          result.parameters.map(transform).join(',' + (result.meta?.parameterSpacing ?? ' '))\n        })${result.meta?.preReturnMarkerSpacing ?? ''}:${result.meta?.postReturnMarkerSpacing ?? ' '}${transform(result.returnType)}`\n      } else {\n        if (computedPropertyStringifier === undefined) {\n          throw new Error('Must have a computed property stringifier')\n        }\n        return `[${\n          computedPropertyStringifier(result.value as Node).replace(/;$/u, '')\n        }](${\n          result.parameters.map(transform).join(',' + (result.meta?.parameterSpacing ?? ' '))\n        })${result.meta?.preReturnMarkerSpacing ?? ''}:${result.meta?.postReturnMarkerSpacing ?? ' '}${transform(result.returnType)}`\n      }\n    }\n  }\n}\n\nconst storedStringifyRules = stringifyRules()\n\nexport function stringify (\n  result: RootResult,\n  stringificationRules: TransformRules<string>|\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any -- Ok\n    ((node: Node, options?: any) => string) = storedStringifyRules\n): string {\n  if (typeof stringificationRules === 'function') {\n    stringificationRules = stringifyRules({\n      computedPropertyStringifier: stringificationRules,\n    })\n  }\n  return transform(stringificationRules, result)\n}\n","import { extractSpecialParams, notAvailableTransform, transform, type TransformRules } from './transform.js'\nimport { assertRootResult } from '../assertTypes.js'\nimport type { RootResult } from '../result/RootResult.js'\nimport { quote } from './stringify.js'\n\nexport const reservedWords = [\n  'null',\n  'true',\n  'false',\n  'break',\n  'case',\n  'catch',\n  'class',\n  'const',\n  'continue',\n  'debugger',\n  'default',\n  'delete',\n  'do',\n  'else',\n  'export',\n  'extends',\n  'finally',\n  'for',\n  'function',\n  'if',\n  'import',\n  'in',\n  'instanceof',\n  'new',\n  'return',\n  'super',\n  'switch',\n  'this',\n  'throw',\n  'try',\n  'typeof',\n  'var',\n  'void',\n  'while',\n  'with',\n  'yield'\n]\n\ninterface ModifiableResult {\n  optional?: boolean\n  nullable?: boolean\n  repeatable?: boolean\n}\n\nexport type CatharsisParseResult =\n  CatharsisNameResult\n  | CatharsisUnionResult\n  | CatharsisGenericResult\n  | CatharsisNullResult\n  | CatharsisUndefinedResult\n  | CatharsisAllResult\n  | CatharsisUnknownResult\n  | CatharsisFunctionResult\n  | CatharsisRecordResult\n  | CatharsisFieldResult\n\nexport type CatharsisNameResult = ModifiableResult & {\n  type: 'NameExpression'\n  name: string\n  reservedWord?: boolean\n}\n\nexport type CatharsisUnionResult = ModifiableResult & {\n  type: 'TypeUnion'\n  elements: CatharsisParseResult[]\n}\n\nexport type CatharsisGenericResult = ModifiableResult & {\n  type: 'TypeApplication'\n  expression: CatharsisParseResult\n  applications: CatharsisParseResult[]\n}\n\nexport type CatharsisNullResult = ModifiableResult & {\n  type: 'NullLiteral'\n}\n\nexport type CatharsisUndefinedResult = ModifiableResult & {\n  type: 'UndefinedLiteral'\n}\n\nexport type CatharsisAllResult = ModifiableResult & {\n  type: 'AllLiteral'\n}\n\nexport type CatharsisUnknownResult = ModifiableResult & {\n  type: 'UnknownLiteral'\n}\n\nexport type CatharsisFunctionResult = ModifiableResult & {\n  type: 'FunctionType'\n  params: CatharsisParseResult[]\n  result?: CatharsisParseResult\n  this?: CatharsisParseResult\n  new?: CatharsisParseResult\n}\n\nexport type CatharsisFieldResult = ModifiableResult & {\n  type: 'FieldType'\n  key: CatharsisParseResult\n  value: CatharsisParseResult | undefined\n}\n\nexport type CatharsisRecordResult = ModifiableResult & {\n  type: 'RecordType'\n  fields: CatharsisFieldResult[]\n}\n\nfunction makeName (value: string): CatharsisNameResult {\n  const result: CatharsisNameResult = {\n    type: 'NameExpression',\n    name: value\n  }\n  if (reservedWords.includes(value)) {\n    result.reservedWord = true\n  }\n  return result\n}\n\nconst catharsisTransformRules: TransformRules<CatharsisParseResult> = {\n  JsdocTypeOptional: (result, transform) => {\n    const transformed = transform(result.element)\n    transformed.optional = true\n    return transformed\n  },\n\n  JsdocTypeNullable: (result, transform) => {\n    const transformed = transform(result.element)\n    transformed.nullable = true\n    return transformed\n  },\n\n  JsdocTypeNotNullable: (result, transform) => {\n    const transformed = transform(result.element)\n    transformed.nullable = false\n    return transformed\n  },\n\n  JsdocTypeVariadic: (result, transform) => {\n    if (result.element === undefined) {\n      throw new Error('dots without value are not allowed in catharsis mode')\n    }\n    const transformed = transform(result.element)\n    transformed.repeatable = true\n    return transformed\n  },\n\n  JsdocTypeAny: () => ({\n    type: 'AllLiteral'\n  }),\n\n  JsdocTypeNull: () => ({\n    type: 'NullLiteral'\n  }),\n\n  JsdocTypeStringValue: result => makeName(quote(result.value, result.meta.quote)),\n\n  JsdocTypeUndefined: () => ({\n    type: 'UndefinedLiteral'\n  }),\n\n  JsdocTypeUnknown: () => ({\n    type: 'UnknownLiteral'\n  }),\n\n  JsdocTypeFunction: (result, transform) => {\n    const params = extractSpecialParams(result)\n\n    const transformed: CatharsisFunctionResult = {\n      type: 'FunctionType',\n      params: params.params.map(transform)\n    }\n\n    if (params.this !== undefined) {\n      transformed.this = transform(params.this)\n    }\n\n    if (params.new !== undefined) {\n      transformed.new = transform(params.new)\n    }\n\n    if (result.returnType !== undefined) {\n      transformed.result = transform(result.returnType)\n    }\n\n    return transformed\n  },\n\n  JsdocTypeGeneric: (result, transform) => ({\n    type: 'TypeApplication',\n    applications: result.elements.map(o => transform(o)),\n    expression: transform(result.left)\n  }),\n\n  JsdocTypeSpecialNamePath: result => makeName(result.specialType + ':' + quote(result.value, result.meta.quote)),\n\n  JsdocTypeName: result => {\n    if (result.value !== 'function') {\n      return makeName(result.value)\n    } else {\n      return {\n        type: 'FunctionType',\n        params: []\n      }\n    }\n  },\n\n  JsdocTypeNumber: result => makeName(result.value.toString()),\n\n  JsdocTypeObject: (result, transform) => {\n    const transformed: CatharsisRecordResult = {\n      type: 'RecordType',\n      fields: []\n    }\n    for (const field of result.elements) {\n      if (field.type !== 'JsdocTypeObjectField' && field.type !== 'JsdocTypeJsdocObjectField') {\n        transformed.fields.push({\n          type: 'FieldType',\n          key: transform(field),\n          value: undefined\n        })\n      } else {\n        transformed.fields.push(transform(field) as unknown as CatharsisFieldResult)\n      }\n    }\n\n    return transformed\n  },\n\n  JsdocTypeObjectField: (result, transform) => {\n    if (typeof result.key !== 'string') {\n      throw new Error('Index signatures and mapped types are not supported')\n    }\n    return {\n      type: 'FieldType',\n      key: makeName(quote(result.key, result.meta.quote)),\n      value: result.right === undefined ? undefined : transform(result.right)\n    }\n  },\n\n  JsdocTypeJsdocObjectField: (result, transform) => ({\n    type: 'FieldType',\n    key: transform(result.left),\n    value: transform(result.right)\n  }),\n\n  JsdocTypeUnion: (result, transform) => ({\n    type: 'TypeUnion',\n    elements: result.elements.map(e => transform(e))\n  }),\n\n  JsdocTypeKeyValue: (result, transform) => ({\n    type: 'FieldType',\n    key: makeName(result.key),\n    value: result.right === undefined ? undefined : transform(result.right)\n  }),\n\n  JsdocTypeNamePath: (result, transform) => {\n    const leftResult = transform(result.left) as CatharsisNameResult\n    let rightValue\n\n    if (result.right.type === 'JsdocTypeIndexedAccessIndex') {\n      throw new TypeError('JsdocTypeIndexedAccessIndex is not supported in catharsis')\n    }\n\n    if (result.right.type === 'JsdocTypeSpecialNamePath') {\n      rightValue = (transform(result.right) as CatharsisNameResult).name\n    } else {\n      rightValue = quote(result.right.value, result.right.meta.quote)\n    }\n\n    const joiner = result.pathType === 'inner' ? '~' : result.pathType === 'instance' ? '#' : '.'\n\n    return makeName(`${leftResult.name}${joiner}${rightValue}`)\n  },\n\n  JsdocTypeSymbol: result => {\n    let value = ''\n\n    let element = result.element\n    let trailingDots = false\n\n    if (element?.type === 'JsdocTypeVariadic') {\n      if (element.meta.position === 'prefix') {\n        value = '...'\n      } else {\n        trailingDots = true\n      }\n      element = element.element\n    }\n\n    if (element?.type === 'JsdocTypeName') {\n      value += element.value\n    } else if (element?.type === 'JsdocTypeNumber') {\n      value += element.value.toString()\n    }\n\n    if (trailingDots) {\n      value += '...'\n    }\n\n    return makeName(`${result.value}(${value})`)\n  },\n\n  JsdocTypeParenthesis: (result, transform) => transform(assertRootResult(result.element)),\n\n  JsdocTypeMappedType: notAvailableTransform,\n  JsdocTypeIndexSignature: notAvailableTransform,\n  JsdocTypeImport: notAvailableTransform,\n  JsdocTypeKeyof: notAvailableTransform,\n  JsdocTypeTuple: notAvailableTransform,\n  JsdocTypeTypeof: notAvailableTransform,\n  JsdocTypeIntersection: notAvailableTransform,\n  JsdocTypeProperty: notAvailableTransform,\n  JsdocTypePredicate: notAvailableTransform,\n  JsdocTypeAsserts: notAvailableTransform,\n  JsdocTypeReadonlyArray: notAvailableTransform,\n  JsdocTypeAssertsPlain: notAvailableTransform,\n  JsdocTypeConditional: notAvailableTransform,\n  JsdocTypeTypeParameter: notAvailableTransform,\n  JsdocTypeCallSignature: notAvailableTransform,\n  JsdocTypeConstructorSignature: notAvailableTransform,\n  JsdocTypeMethodSignature: notAvailableTransform,\n  JsdocTypeIndexedAccessIndex: notAvailableTransform,\n  JsdocTypeTemplateLiteral: notAvailableTransform,\n  JsdocTypeComputedProperty: notAvailableTransform,\n  JsdocTypeComputedMethod: notAvailableTransform\n}\n\nexport function catharsisTransform (result: RootResult): CatharsisParseResult {\n  return transform(catharsisTransformRules, result)\n}\n","import { extractSpecialParams, notAvailableTransform, transform, type TransformRules } from './transform.js'\nimport type { QuoteStyle, RootResult } from '../result/RootResult.js'\nimport { assertRootResult } from '../assertTypes.js'\nimport type { NonRootResult } from '../result/NonRootResult.js'\n\nexport type JtpResult =\n  JtpNameResult\n  | JtpNullableResult\n  | JtpNotNullableResult\n  | JtpOptionalResult\n  | JtpVariadicResult\n  | JtpTypeOfResult\n  | JtpTupleResult\n  | JtpKeyOfResult\n  | JtpStringValueResult\n  | JtpImportResult\n  | JtpAnyResult\n  | JtpUnknownResult\n  | JtpFunctionResult\n  | JtpGenericResult\n  | JtpRecordEntryResult\n  | JtpRecordResult\n  | JtpMemberResult\n  | JtpUnionResult\n  | JtpParenthesisResult\n  | JtpNamedParameterResult\n  | JtpModuleResult\n  | JtpFilePath\n  | JtpIntersectionResult\n  | JtpNumberResult\n\ntype JtpQuoteStyle = 'single' | 'double' | 'none'\n\nexport interface JtpNullableResult {\n  type: 'NULLABLE'\n  value: JtpResult\n  meta: {\n    syntax: 'PREFIX_QUESTION_MARK' | 'SUFFIX_QUESTION_MARK'\n  }\n}\n\nexport interface JtpNotNullableResult {\n  type: 'NOT_NULLABLE'\n  value: JtpResult\n  meta: {\n    syntax: 'PREFIX_BANG' | 'SUFFIX_BANG'\n  }\n}\n\nexport interface JtpOptionalResult {\n  type: 'OPTIONAL'\n  value: JtpResult\n  meta: {\n    syntax: 'PREFIX_EQUAL_SIGN' | 'SUFFIX_EQUALS_SIGN' | 'SUFFIX_KEY_QUESTION_MARK'\n  }\n}\n\nexport interface JtpVariadicResult {\n  type: 'VARIADIC'\n  value?: JtpResult\n  meta: {\n    syntax: 'PREFIX_DOTS' | 'SUFFIX_DOTS' | 'ONLY_DOTS'\n  }\n}\n\nexport interface JtpNameResult {\n  type: 'NAME'\n  name: string\n}\n\nexport interface JtpTypeOfResult {\n  type: 'TYPE_QUERY'\n  name?: JtpResult\n}\n\nexport interface JtpKeyOfResult {\n  type: 'KEY_QUERY'\n  value?: JtpResult\n}\n\nexport interface JtpTupleResult {\n  type: 'TUPLE'\n  entries: JtpResult[]\n}\n\nexport interface JtpStringValueResult {\n  type: 'STRING_VALUE'\n  quoteStyle: JtpQuoteStyle\n  string: string\n}\n\nexport interface JtpImportResult {\n  type: 'IMPORT'\n  path: JtpStringValueResult\n}\n\nexport interface JtpAnyResult {\n  type: 'ANY'\n}\n\nexport interface JtpUnknownResult {\n  type: 'UNKNOWN'\n}\n\nexport interface JtpFunctionResult {\n  type: 'FUNCTION' | 'ARROW'\n  params: JtpResult[]\n  returns: JtpResult | null\n  new: JtpResult | null\n  this?: JtpResult | null\n}\n\nexport interface JtpGenericResult {\n  type: 'GENERIC'\n  subject: JtpResult\n  objects: JtpResult[]\n  meta: {\n    syntax: 'ANGLE_BRACKET' | 'ANGLE_BRACKET_WITH_DOT' | 'SQUARE_BRACKET'\n  }\n}\n\nexport interface JtpRecordEntryResult {\n  type: 'RECORD_ENTRY'\n  key: string\n  quoteStyle: JtpQuoteStyle\n  value: JtpResult | null\n  readonly: false\n}\n\nexport interface JtpRecordResult {\n  type: 'RECORD'\n  entries: JtpRecordEntryResult[]\n}\n\nexport interface JtpMemberResult {\n  type: 'MEMBER' | 'INNER_MEMBER' | 'INSTANCE_MEMBER'\n  owner: JtpResult\n  name: string\n  quoteStyle: JtpQuoteStyle\n  hasEventPrefix: boolean\n}\n\nexport interface JtpUnionResult {\n  type: 'UNION'\n  left: JtpResult\n  right: JtpResult\n}\n\nexport interface JtpIntersectionResult {\n  type: 'INTERSECTION'\n  left: JtpResult\n  right: JtpResult\n}\n\nexport interface JtpParenthesisResult {\n  type: 'PARENTHESIS'\n  value: JtpResult\n}\n\nexport interface JtpNamedParameterResult {\n  type: 'NAMED_PARAMETER'\n  name: string\n  typeName: JtpResult\n}\n\nexport interface JtpModuleResult {\n  type: 'MODULE'\n  value: JtpResult\n}\n\nexport interface JtpFilePath {\n  type: 'FILE_PATH'\n  quoteStyle: JtpQuoteStyle\n  path: string\n}\n\nexport interface JtpNumberResult {\n  type: 'NUMBER_VALUE'\n  number: string\n}\n\nfunction getQuoteStyle (quote: QuoteStyle | undefined): JtpQuoteStyle {\n  switch (quote) {\n    case undefined:\n      return 'none'\n    case 'single':\n      return 'single'\n    case 'double':\n      return 'double'\n  }\n}\n\nfunction getMemberType (type: 'property' | 'inner' | 'instance' | 'property-brackets'): JtpMemberResult['type'] {\n  switch (type) {\n    case 'inner':\n      return 'INNER_MEMBER'\n    case 'instance':\n      return 'INSTANCE_MEMBER'\n    case 'property':\n      return 'MEMBER'\n    case 'property-brackets':\n      return 'MEMBER'\n  }\n}\n\nfunction nestResults (type: 'UNION' | 'INTERSECTION', results: JtpResult[]): JtpResult {\n  if (results.length === 2) {\n    return {\n      type,\n      left: results[0],\n      right: results[1]\n    }\n  } else {\n    return {\n      type,\n      left: results[0],\n      right: nestResults(type, results.slice(1))\n    }\n  }\n}\n\nconst jtpRules: TransformRules<JtpResult> = {\n  JsdocTypeOptional: (result, transform) => ({\n    type: 'OPTIONAL',\n    value: transform(result.element),\n    meta: {\n      syntax: result.meta.position === 'prefix' ? 'PREFIX_EQUAL_SIGN' : 'SUFFIX_EQUALS_SIGN'\n    }\n  }),\n\n  JsdocTypeNullable: (result, transform) => ({\n    type: 'NULLABLE',\n    value: transform(result.element),\n    meta: {\n      syntax: result.meta.position === 'prefix' ? 'PREFIX_QUESTION_MARK' : 'SUFFIX_QUESTION_MARK'\n    }\n  }),\n\n  JsdocTypeNotNullable: (result, transform) => ({\n    type: 'NOT_NULLABLE',\n    value: transform(result.element),\n    meta: {\n      syntax: result.meta.position === 'prefix' ? 'PREFIX_BANG' : 'SUFFIX_BANG'\n    }\n  }),\n\n  JsdocTypeVariadic: (result, transform) => {\n    const transformed: JtpVariadicResult = {\n      type: 'VARIADIC',\n      meta: {\n        syntax: result.meta.position === 'prefix'\n          ? 'PREFIX_DOTS'\n          : result.meta.position === 'suffix' ? 'SUFFIX_DOTS' : 'ONLY_DOTS'\n      }\n    }\n    if (result.element !== undefined) {\n      transformed.value = transform(result.element)\n    }\n\n    return transformed\n  },\n\n  JsdocTypeName: result => ({\n    type: 'NAME',\n    name: result.value\n  }),\n\n  JsdocTypeTypeof: (result, transform) => ({\n    type: 'TYPE_QUERY',\n    name: transform(result.element)\n  }),\n\n  JsdocTypeTuple: (result, transform) => ({\n    type: 'TUPLE',\n    entries: (result.elements as NonRootResult[]).map(transform)\n  }),\n\n  JsdocTypeKeyof: (result, transform) => ({\n    type: 'KEY_QUERY',\n    value: transform(result.element)\n  }),\n\n  JsdocTypeImport: result => ({\n    type: 'IMPORT',\n    path: {\n      type: 'STRING_VALUE',\n      quoteStyle: getQuoteStyle(result.element.meta.quote),\n      string: result.element.value\n    }\n  }),\n\n  JsdocTypeUndefined: () => ({\n    type: 'NAME',\n    name: 'undefined'\n  }),\n\n  JsdocTypeAny: () => ({\n    type: 'ANY'\n  }),\n\n  JsdocTypeFunction: (result, transform) => {\n    const specialParams = extractSpecialParams(result)\n\n    const transformed: JtpFunctionResult = {\n      type: result.arrow ? 'ARROW' : 'FUNCTION',\n      params: specialParams.params.map(param => {\n        if (param.type === 'JsdocTypeKeyValue') {\n          if (param.right === undefined) {\n            throw new Error('Function parameter without \\':\\' is not expected to be \\'KEY_VALUE\\'')\n          }\n          return {\n            type: 'NAMED_PARAMETER',\n            name: param.key,\n            typeName: transform(param.right)\n          }\n        } else {\n          return transform(param)\n        }\n      }),\n      new: null,\n      returns: null\n    }\n\n    if (specialParams.this !== undefined) {\n      transformed.this = transform(specialParams.this)\n    } else if (!result.arrow) {\n      transformed.this = null\n    }\n\n    if (specialParams.new !== undefined) {\n      transformed.new = transform(specialParams.new)\n    }\n\n    if (result.returnType !== undefined) {\n      transformed.returns = transform(result.returnType)\n    }\n\n    return transformed\n  },\n\n  JsdocTypeGeneric: (result, transform) => {\n    const transformed: JtpGenericResult = {\n      type: 'GENERIC',\n      subject: transform(result.left),\n      objects: result.elements.map(transform),\n      meta: {\n        syntax: result.meta.brackets === 'square' ? 'SQUARE_BRACKET' : result.meta.dot ? 'ANGLE_BRACKET_WITH_DOT' : 'ANGLE_BRACKET'\n      }\n    }\n\n    if (result.meta.brackets === 'square' && result.elements[0].type === 'JsdocTypeFunction' && !result.elements[0].parenthesis) {\n      transformed.objects[0] = {\n        type: 'NAME',\n        name: 'function'\n      }\n    }\n\n    return transformed\n  },\n\n  JsdocTypeObjectField: (result, transform) => {\n    if (typeof result.key !== 'string') {\n      throw new Error('Index signatures and mapped types are not supported')\n    }\n\n    if (result.right === undefined) {\n      return {\n        type: 'RECORD_ENTRY',\n        key: result.key,\n        quoteStyle: getQuoteStyle(result.meta.quote),\n        value: null,\n        readonly: false\n      }\n    }\n\n    let right = transform(result.right)\n    if (result.optional) {\n      right = {\n        type: 'OPTIONAL',\n        value: right,\n        meta: {\n          syntax: 'SUFFIX_KEY_QUESTION_MARK'\n        }\n      }\n    }\n\n    return {\n      type: 'RECORD_ENTRY',\n      key: result.key,\n      quoteStyle: getQuoteStyle(result.meta.quote),\n      value: right,\n      readonly: false\n    }\n  },\n\n  JsdocTypeJsdocObjectField: () => {\n    throw new Error('Keys may not be typed in jsdoctypeparser.')\n  },\n\n  JsdocTypeKeyValue: (result, transform) => {\n    if (result.right === undefined) {\n      return {\n        type: 'RECORD_ENTRY',\n        key: result.key,\n        quoteStyle: 'none',\n        value: null,\n        readonly: false\n      }\n    }\n\n    let right = transform(result.right)\n    if (result.optional) {\n      right = {\n        type: 'OPTIONAL',\n        value: right,\n        meta: {\n          syntax: 'SUFFIX_KEY_QUESTION_MARK'\n        }\n      }\n    }\n\n    return {\n      type: 'RECORD_ENTRY',\n      key: result.key,\n      quoteStyle: 'none',\n      value: right,\n      readonly: false\n    }\n  },\n\n  JsdocTypeObject: (result, transform) => {\n    const entries: JtpRecordEntryResult[] = []\n    for (const field of result.elements) {\n      if (field.type === 'JsdocTypeObjectField' || field.type === 'JsdocTypeJsdocObjectField') {\n        entries.push(transform(field) as JtpRecordEntryResult)\n      }\n    }\n    return {\n      type: 'RECORD',\n      entries\n    }\n  },\n\n  JsdocTypeSpecialNamePath: result => {\n    if (result.specialType !== 'module') {\n      throw new Error(`jsdoctypeparser does not support type ${result.specialType} at this point.`)\n    }\n    return {\n      type: 'MODULE',\n      value: {\n        type: 'FILE_PATH',\n        quoteStyle: getQuoteStyle(result.meta.quote),\n        path: result.value\n      }\n    }\n  },\n\n  JsdocTypeNamePath: (result, transform) => {\n    let hasEventPrefix = false\n    let name\n    let quoteStyle\n\n    if (result.right.type === 'JsdocTypeIndexedAccessIndex') {\n      throw new TypeError('JsdocTypeIndexedAccessIndex not allowed in jtp')\n    }\n\n    if (result.right.type === 'JsdocTypeSpecialNamePath' && result.right.specialType === 'event') {\n      hasEventPrefix = true\n      name = result.right.value\n      quoteStyle = getQuoteStyle(result.right.meta.quote)\n    } else {\n      name = result.right.value\n      quoteStyle = getQuoteStyle(result.right.meta.quote)\n    }\n\n    const transformed: JtpMemberResult = {\n      type: getMemberType(result.pathType),\n      owner: transform(result.left),\n      name,\n      quoteStyle,\n      hasEventPrefix\n    }\n\n    if (transformed.owner.type === 'MODULE') {\n      const tModule = transformed.owner\n      transformed.owner = transformed.owner.value\n      tModule.value = transformed\n      return tModule\n    } else {\n      return transformed\n    }\n  },\n\n  JsdocTypeUnion: (result, transform) => nestResults('UNION', result.elements.map(transform)),\n\n  JsdocTypeParenthesis: (result, transform) => ({\n    type: 'PARENTHESIS',\n    value: transform(assertRootResult(result.element))\n  }),\n\n  JsdocTypeNull: () => ({\n    type: 'NAME',\n    name: 'null'\n  }),\n\n  JsdocTypeUnknown: () => ({\n    type: 'UNKNOWN'\n  }),\n\n  JsdocTypeStringValue: result => ({\n    type: 'STRING_VALUE',\n    quoteStyle: getQuoteStyle(result.meta.quote),\n    string: result.value\n  }),\n\n  JsdocTypeIntersection: (result, transform) => nestResults('INTERSECTION', result.elements.map(transform)),\n\n  JsdocTypeNumber: result => ({\n    type: 'NUMBER_VALUE',\n    number: result.value.toString()\n  }),\n\n  JsdocTypeSymbol: notAvailableTransform,\n\n  JsdocTypeProperty: notAvailableTransform,\n\n  JsdocTypePredicate: notAvailableTransform,\n\n  JsdocTypeMappedType: notAvailableTransform,\n\n  JsdocTypeIndexSignature: notAvailableTransform,\n\n  JsdocTypeAsserts: notAvailableTransform,\n\n  JsdocTypeReadonlyArray: notAvailableTransform,\n\n  JsdocTypeAssertsPlain: notAvailableTransform,\n\n  JsdocTypeConditional: notAvailableTransform,\n\n  JsdocTypeTypeParameter: notAvailableTransform,\n\n  JsdocTypeCallSignature: notAvailableTransform,\n\n  JsdocTypeConstructorSignature: notAvailableTransform,\n\n  JsdocTypeMethodSignature: notAvailableTransform,\n\n  JsdocTypeIndexedAccessIndex: notAvailableTransform,\n\n  JsdocTypeTemplateLiteral: notAvailableTransform,\n\n  JsdocTypeComputedProperty: notAvailableTransform,\n\n  JsdocTypeComputedMethod: notAvailableTransform\n}\n\nexport function jtpTransform (result: RootResult): JtpResult {\n  return transform(jtpRules, result)\n}\n","import type { Node } from 'estree'\nimport type { TransformRules } from './transform.js'\nimport type {\n  JsdocObjectFieldResult,\n  KeyValueResult,\n  NonRootResult,\n  ObjectFieldResult,\n  CallSignatureResult,\n  ConstructorSignatureResult,\n  MethodSignatureResult\n} from '../result/NonRootResult.js'\nimport type {\n  FunctionResult,\n  NameResult,\n  StringValueResult,\n  SymbolResult,\n  RootResult,\n  VariadicResult,\n  NumberResult\n} from '../result/RootResult.js'\n\nexport function identityTransformRules (): TransformRules<NonRootResult> {\n  return {\n    JsdocTypeIntersection: (result, transform) => ({\n      type: 'JsdocTypeIntersection',\n      elements: result.elements.map(transform) as RootResult[]\n    }),\n\n    JsdocTypeGeneric: (result, transform) => ({\n      type: 'JsdocTypeGeneric',\n      left: transform(result.left) as RootResult,\n      elements: result.elements.map(transform) as RootResult[],\n      meta: {\n        dot: result.meta.dot,\n        brackets: result.meta.brackets\n      }\n    }),\n\n    JsdocTypeNullable: result => result,\n\n    JsdocTypeUnion: (result, transform) => ({\n      type: 'JsdocTypeUnion',\n      elements: result.elements.map(transform) as RootResult[]\n    }),\n\n    JsdocTypeUnknown: result => result,\n\n    JsdocTypeUndefined: result => result,\n\n    JsdocTypeTypeof: (result, transform) => ({\n      type: 'JsdocTypeTypeof',\n      element: transform(result.element) as RootResult\n    }),\n\n    JsdocTypeSymbol: (result, transform) => {\n      const transformed: SymbolResult = {\n        type: 'JsdocTypeSymbol',\n        value: result.value\n      }\n      if (result.element !== undefined) {\n        transformed.element = transform(result.element) as NumberResult | NameResult | VariadicResult<NameResult>\n      }\n      return transformed\n    },\n\n    JsdocTypeOptional: (result, transform) => ({\n      type: 'JsdocTypeOptional',\n      element: transform(result.element) as RootResult,\n      meta: {\n        position: result.meta.position\n      }\n    }),\n\n    JsdocTypeObject: (result, transform) => ({\n      type: 'JsdocTypeObject',\n      meta: {\n        separator: 'comma'\n      },\n      elements: result.elements.map(transform) as Array<ObjectFieldResult | JsdocObjectFieldResult | CallSignatureResult | ConstructorSignatureResult | MethodSignatureResult>\n    }),\n\n    JsdocTypeNumber: result => result,\n\n    JsdocTypeNull: result => result,\n\n    JsdocTypeNotNullable: (result, transform) => ({\n      type: 'JsdocTypeNotNullable',\n      element: transform(result.element) as RootResult,\n      meta: {\n        position: result.meta.position\n      }\n    }),\n\n    JsdocTypeSpecialNamePath: result => result,\n\n    JsdocTypeObjectField: (result, transform) => ({\n      type: 'JsdocTypeObjectField',\n      key: result.key,\n      right: result.right === undefined ? undefined : transform(result.right) as RootResult,\n      optional: result.optional,\n      readonly: result.readonly,\n      meta: result.meta\n    }),\n\n    JsdocTypeJsdocObjectField: (result, transform) => ({\n      type: 'JsdocTypeJsdocObjectField',\n      left: transform(result.left) as RootResult,\n      right: transform(result.right) as RootResult\n    }),\n\n    JsdocTypeKeyValue: (result, transform) => ({\n      type: 'JsdocTypeKeyValue',\n      key: result.key,\n      right: result.right === undefined ? undefined : transform(result.right) as RootResult,\n      optional: result.optional,\n      variadic: result.variadic\n    }),\n\n    JsdocTypeImport: (result, transform) => ({\n      type: 'JsdocTypeImport',\n      element: transform(result.element) as StringValueResult\n    }),\n\n    JsdocTypeAny: result => result,\n\n    JsdocTypeStringValue: result => result,\n\n    JsdocTypeNamePath: result => result,\n\n    JsdocTypeVariadic: (result, transform) => {\n      const transformed: VariadicResult<RootResult> = {\n        type: 'JsdocTypeVariadic',\n        meta: {\n          position: result.meta.position,\n          squareBrackets: result.meta.squareBrackets\n        }\n      }\n\n      if (result.element !== undefined) {\n        transformed.element = transform(result.element) as RootResult\n      }\n\n      return transformed\n    },\n\n    JsdocTypeTuple: (result, transform) => ({\n      type: 'JsdocTypeTuple',\n      elements: (result.elements as NonRootResult[]).map(transform) as RootResult[] | KeyValueResult[]\n    }),\n\n    JsdocTypeName: result => result,\n\n    JsdocTypeFunction: (result, transform) => {\n      const transformed: FunctionResult = {\n        type: 'JsdocTypeFunction',\n        arrow: result.arrow,\n        parameters: result.parameters.map(transform) as RootResult[],\n        constructor: result.constructor,\n        parenthesis: result.parenthesis\n      }\n\n      if (result.returnType !== undefined) {\n        transformed.returnType = transform(result.returnType) as RootResult\n      }\n\n      return transformed\n    },\n\n    JsdocTypeKeyof: (result, transform) => ({\n      type: 'JsdocTypeKeyof',\n      element: transform(result.element) as RootResult\n    }),\n\n    JsdocTypeParenthesis: (result, transform) => ({\n      type: 'JsdocTypeParenthesis',\n      element: transform(result.element) as RootResult\n    }),\n\n    JsdocTypeProperty: result => result,\n\n    JsdocTypePredicate: (result, transform) => ({\n      type: 'JsdocTypePredicate',\n      left: transform(result.left) as NameResult,\n      right: transform(result.right) as RootResult\n    }),\n\n    JsdocTypeIndexSignature: (result, transform) => ({\n      type: 'JsdocTypeIndexSignature',\n      key: result.key,\n      right: transform(result.right) as RootResult\n    }),\n\n    JsdocTypeMappedType: (result, transform) => ({\n      type: 'JsdocTypeMappedType',\n      key: result.key,\n      right: transform(result.right) as RootResult\n    }),\n\n    JsdocTypeAsserts: (result, transform) => ({\n      type: 'JsdocTypeAsserts',\n      left: transform(result.left) as NameResult,\n      right: transform(result.right) as RootResult\n    }),\n\n    JsdocTypeReadonlyArray: (result, transform) => ({\n      type: 'JsdocTypeReadonlyArray',\n      element: transform(result.element) as RootResult\n    }),\n\n    JsdocTypeAssertsPlain: (result, transform) => ({\n      type: 'JsdocTypeAssertsPlain',\n      element: transform(result.element) as NameResult\n    }),\n\n    JsdocTypeConditional: (result, transform) => ({\n      type: 'JsdocTypeConditional',\n      checksType: transform(result.checksType) as RootResult,\n      extendsType: transform(result.extendsType) as RootResult,\n      trueType: transform(result.trueType) as RootResult,\n      falseType: transform(result.falseType) as RootResult\n    }),\n\n    JsdocTypeTypeParameter: (result, transform) => ({\n      type: 'JsdocTypeTypeParameter',\n      name: transform(result.name) as NameResult,\n      constraint: result.constraint !== undefined ? transform(result.constraint) as RootResult : undefined,\n      defaultValue: result.defaultValue !== undefined ? transform(result.defaultValue) as RootResult : undefined\n    }),\n\n    JsdocTypeCallSignature: (result, transform) => ({\n      type: 'JsdocTypeCallSignature',\n      parameters: result.parameters.map(transform) as RootResult[],\n      returnType: transform(result.returnType) as RootResult\n    }),\n\n    JsdocTypeConstructorSignature: (result, transform) => ({\n      type: 'JsdocTypeConstructorSignature',\n      parameters: result.parameters.map(transform) as RootResult[],\n      returnType: transform(result.returnType) as RootResult\n    }),\n\n    JsdocTypeMethodSignature: (result, transform) => ({\n      type: 'JsdocTypeMethodSignature',\n      name: result.name,\n      parameters: result.parameters.map(transform) as RootResult[],\n      returnType: transform(result.returnType) as RootResult,\n      meta: result.meta\n    }),\n\n    JsdocTypeIndexedAccessIndex: (result, transform) => ({\n      type: 'JsdocTypeIndexedAccessIndex',\n      right: transform(result.right) as RootResult\n    }),\n\n    JsdocTypeTemplateLiteral: (result, transform) => ({\n      type: 'JsdocTypeTemplateLiteral',\n      literals: result.literals,\n      interpolations: result.interpolations.map(transform) as RootResult[]\n    }),\n\n    JsdocTypeComputedProperty: (result, transform) => {\n      if (result.value.type.startsWith('JsdocType')) {\n        return {\n          type: 'JsdocTypeComputedProperty',\n          value: transform(result.value as RootResult) as RootResult\n        }\n      } else {\n        return {\n          type: 'JsdocTypeComputedProperty',\n          value: structuredClone(result.value) as Node\n        }\n      }\n    },\n\n    JsdocTypeComputedMethod: (result, transform) => {\n      if (result.value.type.startsWith('JsdocType')) {\n        return {\n          type: 'JsdocTypeComputedMethod',\n          value: transform(result.value as RootResult) as RootResult,\n          optional: result.optional,\n          parameters: result.parameters.map(transform) as RootResult[],\n          returnType: transform(result.returnType) as RootResult\n        }\n      } else {\n        return {\n          type: 'JsdocTypeComputedMethod',\n          value: structuredClone(result.value) as Node,\n          optional: result.optional,\n          parameters: result.parameters.map(transform) as RootResult[],\n          returnType: transform(result.returnType) as RootResult\n        }\n      }\n    }\n  }\n}\n","import type { NonRootResult } from './result/NonRootResult.js'\n\nexport type VisitorKeys = {\n  [P in NonRootResult as P['type']]: Array<keyof P>\n}\n\nexport const visitorKeys: VisitorKeys = {\n  JsdocTypeAny: [],\n  JsdocTypeFunction: ['typeParameters', 'parameters', 'returnType'],\n  JsdocTypeGeneric: ['left', 'elements'],\n  JsdocTypeImport: ['element'],\n  JsdocTypeIndexSignature: ['right'],\n  JsdocTypeIntersection: ['elements'],\n  JsdocTypeKeyof: ['element'],\n  JsdocTypeKeyValue: ['right'],\n  JsdocTypeMappedType: ['right'],\n  JsdocTypeName: [],\n  JsdocTypeNamePath: ['left', 'right'],\n  JsdocTypeNotNullable: ['element'],\n  JsdocTypeNull: [],\n  JsdocTypeNullable: ['element'],\n  JsdocTypeNumber: [],\n  JsdocTypeObject: ['elements'],\n  JsdocTypeObjectField: ['key', 'right'],\n  JsdocTypeJsdocObjectField: ['left', 'right'],\n  JsdocTypeOptional: ['element'],\n  JsdocTypeParenthesis: ['element'],\n  JsdocTypeSpecialNamePath: [],\n  JsdocTypeStringValue: [],\n  JsdocTypeSymbol: ['element'],\n  JsdocTypeTuple: ['elements'],\n  JsdocTypeTypeof: ['element'],\n  JsdocTypeUndefined: [],\n  JsdocTypeUnion: ['elements'],\n  JsdocTypeUnknown: [],\n  JsdocTypeVariadic: ['element'],\n  JsdocTypeProperty: [],\n  JsdocTypePredicate: ['left', 'right'],\n  JsdocTypeAsserts: ['left', 'right'],\n  JsdocTypeReadonlyArray: ['element'],\n  JsdocTypeAssertsPlain: ['element'],\n  JsdocTypeConditional: ['checksType', 'extendsType', 'trueType', 'falseType'],\n  JsdocTypeTypeParameter: ['name', 'constraint', 'defaultValue'],\n  JsdocTypeCallSignature: ['typeParameters', 'parameters', 'returnType'],\n  JsdocTypeConstructorSignature: ['typeParameters', 'parameters', 'returnType'],\n  JsdocTypeMethodSignature: ['typeParameters', 'parameters', 'returnType'],\n  JsdocTypeIndexedAccessIndex: ['right'],\n  JsdocTypeTemplateLiteral: ['interpolations'],\n  JsdocTypeComputedProperty: ['value'],\n  JsdocTypeComputedMethod: ['value', 'typeParameters', 'parameters', 'returnType']\n}\n","import type { NonRootResult } from './result/NonRootResult.js'\nimport type { RootResult } from './result/RootResult.js'\nimport { visitorKeys } from './visitorKeys.js'\n\n/**\n * A node visitor function.\n * @param node the visited node.\n * @param parentNode the parent node.\n * @param property the property on the parent node that contains the visited node. It can be the node itself or\n *  an array of nodes.\n */\nexport type NodeVisitor = (node: NonRootResult, parentNode?: NonRootResult, property?: string, index?: number) => void\n\nfunction _traverse<T extends NonRootResult, U extends NonRootResult> (node: T, parentNode?: U, property?: keyof U, index?: number, onEnter?: NodeVisitor, onLeave?: NodeVisitor): void {\n  onEnter?.(node, parentNode, property as string, index)\n\n  const keysToVisit = visitorKeys[node.type] as Array<keyof T>\n\n  for (const key of keysToVisit) {\n    const value = node[key]\n    if (value !== undefined) {\n      if (Array.isArray(value)) {\n        for (const [index, element] of value.entries()) {\n          _traverse(element as unknown as NonRootResult, node, key, index, onEnter, onLeave)\n        }\n      } else if (value !== null && typeof value === 'object' && 'type' in value) {\n        _traverse(value as unknown as NonRootResult, node, key, undefined, onEnter, onLeave)\n      }\n    }\n  }\n\n  onLeave?.(node, parentNode, property as string, index)\n}\n\n/**\n * A function to traverse an AST. It traverses it depth first.\n * @param node the node to start traversing at.\n * @param onEnter node visitor function that will be called on entering the node. This corresponds to preorder traversing.\n * @param onLeave node visitor function that will be called on leaving the node. This corresponds to postorder traversing.\n */\nexport function traverse (node: RootResult, onEnter?: NodeVisitor, onLeave?: NodeVisitor): void {\n  _traverse(node, undefined, undefined, undefined, onEnter, onLeave)\n}\n"],"mappings":"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","names":["module","left","pathGrammar","pathGrammar","type","objectFieldGrammar","quote","quote","text","identifierContinueRegex","numberRegex","objectFieldGrammar","module","rules","quote","transform","reservedWords","transform","quote","transform","transform","index"]}